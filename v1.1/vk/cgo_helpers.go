// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 28 Aug 2018 21:43:25 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vk

/*
#cgo CFLAGS: -I.
#include "vulkan/vulkan.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewApplicationInfoRef(ref unsafe.Pointer) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	obj := new(ApplicationInfo)
	obj.refb0af7378 = (*C.VkApplicationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	allocsb0af7378.Add(memb0af7378)

	var csType_allocs *cgoAllocMap
	refb0af7378.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0af7378.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0af7378.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0af7378.Borrow(cpNext_allocs)

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = unpackPCharString(x.PApplicationName)
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	var capplicationVersion_allocs *cgoAllocMap
	refb0af7378.applicationVersion, capplicationVersion_allocs = (C.uint32_t)(x.ApplicationVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capplicationVersion_allocs)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = unpackPCharString(x.PEngineName)
	allocsb0af7378.Borrow(cpEngineName_allocs)

	var cengineVersion_allocs *cgoAllocMap
	refb0af7378.engineVersion, cengineVersion_allocs = (C.uint32_t)(x.EngineVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(cengineVersion_allocs)

	var capiVersion_allocs *cgoAllocMap
	refb0af7378.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capiVersion_allocs)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	x.PApplicationName = packPCharString(x.refb0af7378.pApplicationName)
	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	x.PEngineName = packPCharString(x.refb0af7378.pEngineName)
	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSApplicationInfo transforms a sliced Go data structure into plain C format.
func unpackSApplicationInfo(x []ApplicationInfo) (unpacked *C.VkApplicationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkApplicationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocApplicationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkApplicationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkApplicationInfo)(h.Data)
	return
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSApplicationInfo reads sliced Go data structure out from plain C format.
func packSApplicationInfo(v []ApplicationInfo, ptr0 *C.VkApplicationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfApplicationInfoValue]C.VkApplicationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewApplicationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInstanceCreateInfoRef(ref unsafe.Pointer) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = (*C.VkInstanceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	allocs9b760798.Add(mem9b760798)

	var csType_allocs *cgoAllocMap
	ref9b760798.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b760798.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b760798.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b760798.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref9b760798.flags, cflags_allocs = (C.VkInstanceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs9b760798.Borrow(cflags_allocs)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = unpackSApplicationInfo(x.PApplicationInfo)
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	ref9b760798.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	ref9b760798.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	packSApplicationInfo(x.PApplicationInfo, x.ref9b760798.pApplicationInfo)
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// allocAllocationCallbacksMemory allocates memory for type C.VkAllocationCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCallbacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocationCallbacksValue = unsafe.Sizeof([1]C.VkAllocationCallbacks{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return x.ref9638e01
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AllocationCallbacks) Free() {
	if x != nil && x.allocs9638e01 != nil {
		x.allocs9638e01.(*cgoAllocMap).Free()
		x.ref9638e01 = nil
	}
}

// NewAllocationCallbacksRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAllocationCallbacksRef(ref unsafe.Pointer) *AllocationCallbacks {
	if ref == nil {
		return nil
	}
	obj := new(AllocationCallbacks)
	obj.ref9638e01 = (*C.VkAllocationCallbacks)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AllocationCallbacks) PassRef() (*C.VkAllocationCallbacks, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9638e01 != nil {
		return x.ref9638e01, nil
	}
	mem9638e01 := allocAllocationCallbacksMemory(1)
	ref9638e01 := (*C.VkAllocationCallbacks)(mem9638e01)
	allocs9638e01 := new(cgoAllocMap)
	allocs9638e01.Add(mem9638e01)

	var cpUserData_allocs *cgoAllocMap
	ref9638e01.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocs9638e01.Borrow(cpUserData_allocs)

	var cpfnAllocation_allocs *cgoAllocMap
	ref9638e01.pfnAllocation, cpfnAllocation_allocs = x.PfnAllocation.PassValue()
	allocs9638e01.Borrow(cpfnAllocation_allocs)

	var cpfnReallocation_allocs *cgoAllocMap
	ref9638e01.pfnReallocation, cpfnReallocation_allocs = x.PfnReallocation.PassValue()
	allocs9638e01.Borrow(cpfnReallocation_allocs)

	var cpfnFree_allocs *cgoAllocMap
	ref9638e01.pfnFree, cpfnFree_allocs = x.PfnFree.PassValue()
	allocs9638e01.Borrow(cpfnFree_allocs)

	var cpfnInternalAllocation_allocs *cgoAllocMap
	ref9638e01.pfnInternalAllocation, cpfnInternalAllocation_allocs = x.PfnInternalAllocation.PassValue()
	allocs9638e01.Borrow(cpfnInternalAllocation_allocs)

	var cpfnInternalFree_allocs *cgoAllocMap
	ref9638e01.pfnInternalFree, cpfnInternalFree_allocs = x.PfnInternalFree.PassValue()
	allocs9638e01.Borrow(cpfnInternalFree_allocs)

	x.ref9638e01 = ref9638e01
	x.allocs9638e01 = allocs9638e01
	return ref9638e01, allocs9638e01

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AllocationCallbacks) PassValue() (C.VkAllocationCallbacks, *cgoAllocMap) {
	if x.ref9638e01 != nil {
		return *x.ref9638e01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AllocationCallbacks) Deref() {
	if x.ref9638e01 == nil {
		return
	}
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.ref9638e01.pUserData))
	x.PfnAllocation = *NewRef(unsafe.Pointer(&x.ref9638e01.pfnAllocation))
	x.PfnReallocation = *NewRef(unsafe.Pointer(&x.ref9638e01.pfnReallocation))
	x.PfnFree = *NewRef(unsafe.Pointer(&x.ref9638e01.pfnFree))
	x.PfnInternalAllocation = *NewRef(unsafe.Pointer(&x.ref9638e01.pfnInternalAllocation))
	x.PfnInternalFree = *NewRef(unsafe.Pointer(&x.ref9638e01.pfnInternalFree))
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures) Ref() *C.VkPhysicalDeviceFeatures {
	if x == nil {
		return nil
	}
	return x.reff97e405d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures) Free() {
	if x != nil && x.allocsf97e405d != nil {
		x.allocsf97e405d.(*cgoAllocMap).Free()
		x.reff97e405d = nil
	}
}

// NewPhysicalDeviceFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures)
	obj.reff97e405d = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures) PassRef() (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff97e405d != nil {
		return x.reff97e405d, nil
	}
	memf97e405d := allocPhysicalDeviceFeaturesMemory(1)
	reff97e405d := (*C.VkPhysicalDeviceFeatures)(memf97e405d)
	allocsf97e405d := new(cgoAllocMap)
	allocsf97e405d.Add(memf97e405d)

	var crobustBufferAccess_allocs *cgoAllocMap
	reff97e405d.robustBufferAccess, crobustBufferAccess_allocs = (C.VkBool32)(x.RobustBufferAccess), cgoAllocsUnknown
	allocsf97e405d.Borrow(crobustBufferAccess_allocs)

	var cfullDrawIndexUint32_allocs *cgoAllocMap
	reff97e405d.fullDrawIndexUint32, cfullDrawIndexUint32_allocs = (C.VkBool32)(x.FullDrawIndexUint32), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfullDrawIndexUint32_allocs)

	var cimageCubeArray_allocs *cgoAllocMap
	reff97e405d.imageCubeArray, cimageCubeArray_allocs = (C.VkBool32)(x.ImageCubeArray), cgoAllocsUnknown
	allocsf97e405d.Borrow(cimageCubeArray_allocs)

	var cindependentBlend_allocs *cgoAllocMap
	reff97e405d.independentBlend, cindependentBlend_allocs = (C.VkBool32)(x.IndependentBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cindependentBlend_allocs)

	var cgeometryShader_allocs *cgoAllocMap
	reff97e405d.geometryShader, cgeometryShader_allocs = (C.VkBool32)(x.GeometryShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(cgeometryShader_allocs)

	var ctessellationShader_allocs *cgoAllocMap
	reff97e405d.tessellationShader, ctessellationShader_allocs = (C.VkBool32)(x.TessellationShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctessellationShader_allocs)

	var csampleRateShading_allocs *cgoAllocMap
	reff97e405d.sampleRateShading, csampleRateShading_allocs = (C.VkBool32)(x.SampleRateShading), cgoAllocsUnknown
	allocsf97e405d.Borrow(csampleRateShading_allocs)

	var cdualSrcBlend_allocs *cgoAllocMap
	reff97e405d.dualSrcBlend, cdualSrcBlend_allocs = (C.VkBool32)(x.DualSrcBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdualSrcBlend_allocs)

	var clogicOp_allocs *cgoAllocMap
	reff97e405d.logicOp, clogicOp_allocs = (C.VkBool32)(x.LogicOp), cgoAllocsUnknown
	allocsf97e405d.Borrow(clogicOp_allocs)

	var cmultiDrawIndirect_allocs *cgoAllocMap
	reff97e405d.multiDrawIndirect, cmultiDrawIndirect_allocs = (C.VkBool32)(x.MultiDrawIndirect), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiDrawIndirect_allocs)

	var cdrawIndirectFirstInstance_allocs *cgoAllocMap
	reff97e405d.drawIndirectFirstInstance, cdrawIndirectFirstInstance_allocs = (C.VkBool32)(x.DrawIndirectFirstInstance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdrawIndirectFirstInstance_allocs)

	var cdepthClamp_allocs *cgoAllocMap
	reff97e405d.depthClamp, cdepthClamp_allocs = (C.VkBool32)(x.DepthClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthClamp_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	reff97e405d.depthBiasClamp, cdepthBiasClamp_allocs = (C.VkBool32)(x.DepthBiasClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBiasClamp_allocs)

	var cfillModeNonSolid_allocs *cgoAllocMap
	reff97e405d.fillModeNonSolid, cfillModeNonSolid_allocs = (C.VkBool32)(x.FillModeNonSolid), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfillModeNonSolid_allocs)

	var cdepthBounds_allocs *cgoAllocMap
	reff97e405d.depthBounds, cdepthBounds_allocs = (C.VkBool32)(x.DepthBounds), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBounds_allocs)

	var cwideLines_allocs *cgoAllocMap
	reff97e405d.wideLines, cwideLines_allocs = (C.VkBool32)(x.WideLines), cgoAllocsUnknown
	allocsf97e405d.Borrow(cwideLines_allocs)

	var clargePoints_allocs *cgoAllocMap
	reff97e405d.largePoints, clargePoints_allocs = (C.VkBool32)(x.LargePoints), cgoAllocsUnknown
	allocsf97e405d.Borrow(clargePoints_allocs)

	var calphaToOne_allocs *cgoAllocMap
	reff97e405d.alphaToOne, calphaToOne_allocs = (C.VkBool32)(x.AlphaToOne), cgoAllocsUnknown
	allocsf97e405d.Borrow(calphaToOne_allocs)

	var cmultiViewport_allocs *cgoAllocMap
	reff97e405d.multiViewport, cmultiViewport_allocs = (C.VkBool32)(x.MultiViewport), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiViewport_allocs)

	var csamplerAnisotropy_allocs *cgoAllocMap
	reff97e405d.samplerAnisotropy, csamplerAnisotropy_allocs = (C.VkBool32)(x.SamplerAnisotropy), cgoAllocsUnknown
	allocsf97e405d.Borrow(csamplerAnisotropy_allocs)

	var ctextureCompressionETC2_allocs *cgoAllocMap
	reff97e405d.textureCompressionETC2, ctextureCompressionETC2_allocs = (C.VkBool32)(x.TextureCompressionETC2), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionETC2_allocs)

	var ctextureCompressionASTC_LDR_allocs *cgoAllocMap
	reff97e405d.textureCompressionASTC_LDR, ctextureCompressionASTC_LDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_LDR), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionASTC_LDR_allocs)

	var ctextureCompressionBC_allocs *cgoAllocMap
	reff97e405d.textureCompressionBC, ctextureCompressionBC_allocs = (C.VkBool32)(x.TextureCompressionBC), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionBC_allocs)

	var cocclusionQueryPrecise_allocs *cgoAllocMap
	reff97e405d.occlusionQueryPrecise, cocclusionQueryPrecise_allocs = (C.VkBool32)(x.OcclusionQueryPrecise), cgoAllocsUnknown
	allocsf97e405d.Borrow(cocclusionQueryPrecise_allocs)

	var cpipelineStatisticsQuery_allocs *cgoAllocMap
	reff97e405d.pipelineStatisticsQuery, cpipelineStatisticsQuery_allocs = (C.VkBool32)(x.PipelineStatisticsQuery), cgoAllocsUnknown
	allocsf97e405d.Borrow(cpipelineStatisticsQuery_allocs)

	var cvertexPipelineStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.vertexPipelineStoresAndAtomics, cvertexPipelineStoresAndAtomics_allocs = (C.VkBool32)(x.VertexPipelineStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvertexPipelineStoresAndAtomics_allocs)

	var cfragmentStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.fragmentStoresAndAtomics, cfragmentStoresAndAtomics_allocs = (C.VkBool32)(x.FragmentStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfragmentStoresAndAtomics_allocs)

	var cshaderTessellationAndGeometryPointSize_allocs *cgoAllocMap
	reff97e405d.shaderTessellationAndGeometryPointSize, cshaderTessellationAndGeometryPointSize_allocs = (C.VkBool32)(x.ShaderTessellationAndGeometryPointSize), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderTessellationAndGeometryPointSize_allocs)

	var cshaderImageGatherExtended_allocs *cgoAllocMap
	reff97e405d.shaderImageGatherExtended, cshaderImageGatherExtended_allocs = (C.VkBool32)(x.ShaderImageGatherExtended), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderImageGatherExtended_allocs)

	var cshaderStorageImageExtendedFormats_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageExtendedFormats, cshaderStorageImageExtendedFormats_allocs = (C.VkBool32)(x.ShaderStorageImageExtendedFormats), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageExtendedFormats_allocs)

	var cshaderStorageImageMultisample_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageMultisample, cshaderStorageImageMultisample_allocs = (C.VkBool32)(x.ShaderStorageImageMultisample), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageMultisample_allocs)

	var cshaderStorageImageReadWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageReadWithoutFormat, cshaderStorageImageReadWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageReadWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageReadWithoutFormat_allocs)

	var cshaderStorageImageWriteWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageWriteWithoutFormat, cshaderStorageImageWriteWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageWriteWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageWriteWithoutFormat_allocs)

	var cshaderUniformBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderUniformBufferArrayDynamicIndexing, cshaderUniformBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderUniformBufferArrayDynamicIndexing_allocs)

	var cshaderSampledImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderSampledImageArrayDynamicIndexing, cshaderSampledImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderSampledImageArrayDynamicIndexing_allocs)

	var cshaderStorageBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageBufferArrayDynamicIndexing, cshaderStorageBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageBufferArrayDynamicIndexing_allocs)

	var cshaderStorageImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageArrayDynamicIndexing, cshaderStorageImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageArrayDynamicIndexing_allocs)

	var cshaderClipDistance_allocs *cgoAllocMap
	reff97e405d.shaderClipDistance, cshaderClipDistance_allocs = (C.VkBool32)(x.ShaderClipDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderClipDistance_allocs)

	var cshaderCullDistance_allocs *cgoAllocMap
	reff97e405d.shaderCullDistance, cshaderCullDistance_allocs = (C.VkBool32)(x.ShaderCullDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderCullDistance_allocs)

	var cshaderFloat64_allocs *cgoAllocMap
	reff97e405d.shaderFloat64, cshaderFloat64_allocs = (C.VkBool32)(x.ShaderFloat64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderFloat64_allocs)

	var cshaderInt64_allocs *cgoAllocMap
	reff97e405d.shaderInt64, cshaderInt64_allocs = (C.VkBool32)(x.ShaderInt64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt64_allocs)

	var cshaderInt16_allocs *cgoAllocMap
	reff97e405d.shaderInt16, cshaderInt16_allocs = (C.VkBool32)(x.ShaderInt16), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt16_allocs)

	var cshaderResourceResidency_allocs *cgoAllocMap
	reff97e405d.shaderResourceResidency, cshaderResourceResidency_allocs = (C.VkBool32)(x.ShaderResourceResidency), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceResidency_allocs)

	var cshaderResourceMinLod_allocs *cgoAllocMap
	reff97e405d.shaderResourceMinLod, cshaderResourceMinLod_allocs = (C.VkBool32)(x.ShaderResourceMinLod), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceMinLod_allocs)

	var csparseBinding_allocs *cgoAllocMap
	reff97e405d.sparseBinding, csparseBinding_allocs = (C.VkBool32)(x.SparseBinding), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseBinding_allocs)

	var csparseResidencyBuffer_allocs *cgoAllocMap
	reff97e405d.sparseResidencyBuffer, csparseResidencyBuffer_allocs = (C.VkBool32)(x.SparseResidencyBuffer), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyBuffer_allocs)

	var csparseResidencyImage2D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage2D, csparseResidencyImage2D_allocs = (C.VkBool32)(x.SparseResidencyImage2D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage2D_allocs)

	var csparseResidencyImage3D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage3D, csparseResidencyImage3D_allocs = (C.VkBool32)(x.SparseResidencyImage3D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage3D_allocs)

	var csparseResidency2Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency2Samples, csparseResidency2Samples_allocs = (C.VkBool32)(x.SparseResidency2Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency2Samples_allocs)

	var csparseResidency4Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency4Samples, csparseResidency4Samples_allocs = (C.VkBool32)(x.SparseResidency4Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency4Samples_allocs)

	var csparseResidency8Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency8Samples, csparseResidency8Samples_allocs = (C.VkBool32)(x.SparseResidency8Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency8Samples_allocs)

	var csparseResidency16Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency16Samples, csparseResidency16Samples_allocs = (C.VkBool32)(x.SparseResidency16Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency16Samples_allocs)

	var csparseResidencyAliased_allocs *cgoAllocMap
	reff97e405d.sparseResidencyAliased, csparseResidencyAliased_allocs = (C.VkBool32)(x.SparseResidencyAliased), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyAliased_allocs)

	var cvariableMultisampleRate_allocs *cgoAllocMap
	reff97e405d.variableMultisampleRate, cvariableMultisampleRate_allocs = (C.VkBool32)(x.VariableMultisampleRate), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvariableMultisampleRate_allocs)

	var cinheritedQueries_allocs *cgoAllocMap
	reff97e405d.inheritedQueries, cinheritedQueries_allocs = (C.VkBool32)(x.InheritedQueries), cgoAllocsUnknown
	allocsf97e405d.Borrow(cinheritedQueries_allocs)

	x.reff97e405d = reff97e405d
	x.allocsf97e405d = allocsf97e405d
	return reff97e405d, allocsf97e405d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures) PassValue() (C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x.reff97e405d != nil {
		return *x.reff97e405d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures) Deref() {
	if x.reff97e405d == nil {
		return
	}
	x.RobustBufferAccess = (Bool32)(x.reff97e405d.robustBufferAccess)
	x.FullDrawIndexUint32 = (Bool32)(x.reff97e405d.fullDrawIndexUint32)
	x.ImageCubeArray = (Bool32)(x.reff97e405d.imageCubeArray)
	x.IndependentBlend = (Bool32)(x.reff97e405d.independentBlend)
	x.GeometryShader = (Bool32)(x.reff97e405d.geometryShader)
	x.TessellationShader = (Bool32)(x.reff97e405d.tessellationShader)
	x.SampleRateShading = (Bool32)(x.reff97e405d.sampleRateShading)
	x.DualSrcBlend = (Bool32)(x.reff97e405d.dualSrcBlend)
	x.LogicOp = (Bool32)(x.reff97e405d.logicOp)
	x.MultiDrawIndirect = (Bool32)(x.reff97e405d.multiDrawIndirect)
	x.DrawIndirectFirstInstance = (Bool32)(x.reff97e405d.drawIndirectFirstInstance)
	x.DepthClamp = (Bool32)(x.reff97e405d.depthClamp)
	x.DepthBiasClamp = (Bool32)(x.reff97e405d.depthBiasClamp)
	x.FillModeNonSolid = (Bool32)(x.reff97e405d.fillModeNonSolid)
	x.DepthBounds = (Bool32)(x.reff97e405d.depthBounds)
	x.WideLines = (Bool32)(x.reff97e405d.wideLines)
	x.LargePoints = (Bool32)(x.reff97e405d.largePoints)
	x.AlphaToOne = (Bool32)(x.reff97e405d.alphaToOne)
	x.MultiViewport = (Bool32)(x.reff97e405d.multiViewport)
	x.SamplerAnisotropy = (Bool32)(x.reff97e405d.samplerAnisotropy)
	x.TextureCompressionETC2 = (Bool32)(x.reff97e405d.textureCompressionETC2)
	x.TextureCompressionASTC_LDR = (Bool32)(x.reff97e405d.textureCompressionASTC_LDR)
	x.TextureCompressionBC = (Bool32)(x.reff97e405d.textureCompressionBC)
	x.OcclusionQueryPrecise = (Bool32)(x.reff97e405d.occlusionQueryPrecise)
	x.PipelineStatisticsQuery = (Bool32)(x.reff97e405d.pipelineStatisticsQuery)
	x.VertexPipelineStoresAndAtomics = (Bool32)(x.reff97e405d.vertexPipelineStoresAndAtomics)
	x.FragmentStoresAndAtomics = (Bool32)(x.reff97e405d.fragmentStoresAndAtomics)
	x.ShaderTessellationAndGeometryPointSize = (Bool32)(x.reff97e405d.shaderTessellationAndGeometryPointSize)
	x.ShaderImageGatherExtended = (Bool32)(x.reff97e405d.shaderImageGatherExtended)
	x.ShaderStorageImageExtendedFormats = (Bool32)(x.reff97e405d.shaderStorageImageExtendedFormats)
	x.ShaderStorageImageMultisample = (Bool32)(x.reff97e405d.shaderStorageImageMultisample)
	x.ShaderStorageImageReadWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageReadWithoutFormat)
	x.ShaderStorageImageWriteWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageWriteWithoutFormat)
	x.ShaderUniformBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderUniformBufferArrayDynamicIndexing)
	x.ShaderSampledImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderSampledImageArrayDynamicIndexing)
	x.ShaderStorageBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageBufferArrayDynamicIndexing)
	x.ShaderStorageImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageImageArrayDynamicIndexing)
	x.ShaderClipDistance = (Bool32)(x.reff97e405d.shaderClipDistance)
	x.ShaderCullDistance = (Bool32)(x.reff97e405d.shaderCullDistance)
	x.ShaderFloat64 = (Bool32)(x.reff97e405d.shaderFloat64)
	x.ShaderInt64 = (Bool32)(x.reff97e405d.shaderInt64)
	x.ShaderInt16 = (Bool32)(x.reff97e405d.shaderInt16)
	x.ShaderResourceResidency = (Bool32)(x.reff97e405d.shaderResourceResidency)
	x.ShaderResourceMinLod = (Bool32)(x.reff97e405d.shaderResourceMinLod)
	x.SparseBinding = (Bool32)(x.reff97e405d.sparseBinding)
	x.SparseResidencyBuffer = (Bool32)(x.reff97e405d.sparseResidencyBuffer)
	x.SparseResidencyImage2D = (Bool32)(x.reff97e405d.sparseResidencyImage2D)
	x.SparseResidencyImage3D = (Bool32)(x.reff97e405d.sparseResidencyImage3D)
	x.SparseResidency2Samples = (Bool32)(x.reff97e405d.sparseResidency2Samples)
	x.SparseResidency4Samples = (Bool32)(x.reff97e405d.sparseResidency4Samples)
	x.SparseResidency8Samples = (Bool32)(x.reff97e405d.sparseResidency8Samples)
	x.SparseResidency16Samples = (Bool32)(x.reff97e405d.sparseResidency16Samples)
	x.SparseResidencyAliased = (Bool32)(x.reff97e405d.sparseResidencyAliased)
	x.VariableMultisampleRate = (Bool32)(x.reff97e405d.variableMultisampleRate)
	x.InheritedQueries = (Bool32)(x.reff97e405d.inheritedQueries)
}

// allocFormatPropertiesMemory allocates memory for type C.VkFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatPropertiesValue = unsafe.Sizeof([1]C.VkFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties) Ref() *C.VkFormatProperties {
	if x == nil {
		return nil
	}
	return x.refc4b9937b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties) Free() {
	if x != nil && x.allocsc4b9937b != nil {
		x.allocsc4b9937b.(*cgoAllocMap).Free()
		x.refc4b9937b = nil
	}
}

// NewFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatPropertiesRef(ref unsafe.Pointer) *FormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties)
	obj.refc4b9937b = (*C.VkFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties) PassRef() (*C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4b9937b != nil {
		return x.refc4b9937b, nil
	}
	memc4b9937b := allocFormatPropertiesMemory(1)
	refc4b9937b := (*C.VkFormatProperties)(memc4b9937b)
	allocsc4b9937b := new(cgoAllocMap)
	allocsc4b9937b.Add(memc4b9937b)

	var clinearTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.linearTilingFeatures, clinearTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.LinearTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(clinearTilingFeatures_allocs)

	var coptimalTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.optimalTilingFeatures, coptimalTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.OptimalTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(coptimalTilingFeatures_allocs)

	var cbufferFeatures_allocs *cgoAllocMap
	refc4b9937b.bufferFeatures, cbufferFeatures_allocs = (C.VkFormatFeatureFlags)(x.BufferFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(cbufferFeatures_allocs)

	x.refc4b9937b = refc4b9937b
	x.allocsc4b9937b = allocsc4b9937b
	return refc4b9937b, allocsc4b9937b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties) PassValue() (C.VkFormatProperties, *cgoAllocMap) {
	if x.refc4b9937b != nil {
		return *x.refc4b9937b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties) Deref() {
	if x.refc4b9937b == nil {
		return
	}
	x.LinearTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.linearTilingFeatures)
	x.OptimalTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.optimalTilingFeatures)
	x.BufferFeatures = (FormatFeatureFlags)(x.refc4b9937b.bufferFeatures)
}

// allocExtent3DMemory allocates memory for type C.VkExtent3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent3DValue = unsafe.Sizeof([1]C.VkExtent3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent3D) Ref() *C.VkExtent3D {
	if x == nil {
		return nil
	}
	return x.reffbf6c42a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent3D) Free() {
	if x != nil && x.allocsfbf6c42a != nil {
		x.allocsfbf6c42a.(*cgoAllocMap).Free()
		x.reffbf6c42a = nil
	}
}

// NewExtent3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent3DRef(ref unsafe.Pointer) *Extent3D {
	if ref == nil {
		return nil
	}
	obj := new(Extent3D)
	obj.reffbf6c42a = (*C.VkExtent3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent3D) PassRef() (*C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbf6c42a != nil {
		return x.reffbf6c42a, nil
	}
	memfbf6c42a := allocExtent3DMemory(1)
	reffbf6c42a := (*C.VkExtent3D)(memfbf6c42a)
	allocsfbf6c42a := new(cgoAllocMap)
	allocsfbf6c42a.Add(memfbf6c42a)

	var cwidth_allocs *cgoAllocMap
	reffbf6c42a.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	reffbf6c42a.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	reffbf6c42a.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cdepth_allocs)

	x.reffbf6c42a = reffbf6c42a
	x.allocsfbf6c42a = allocsfbf6c42a
	return reffbf6c42a, allocsfbf6c42a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent3D) PassValue() (C.VkExtent3D, *cgoAllocMap) {
	if x.reffbf6c42a != nil {
		return *x.reffbf6c42a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent3D) Deref() {
	if x.reffbf6c42a == nil {
		return
	}
	x.Width = (uint32)(x.reffbf6c42a.width)
	x.Height = (uint32)(x.reffbf6c42a.height)
	x.Depth = (uint32)(x.reffbf6c42a.depth)
}

// allocImageFormatPropertiesMemory allocates memory for type C.VkImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties) Ref() *C.VkImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref4cfb2ea2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties) Free() {
	if x != nil && x.allocs4cfb2ea2 != nil {
		x.allocs4cfb2ea2.(*cgoAllocMap).Free()
		x.ref4cfb2ea2 = nil
	}
}

// NewImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatPropertiesRef(ref unsafe.Pointer) *ImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties)
	obj.ref4cfb2ea2 = (*C.VkImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties) PassRef() (*C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cfb2ea2 != nil {
		return x.ref4cfb2ea2, nil
	}
	mem4cfb2ea2 := allocImageFormatPropertiesMemory(1)
	ref4cfb2ea2 := (*C.VkImageFormatProperties)(mem4cfb2ea2)
	allocs4cfb2ea2 := new(cgoAllocMap)
	allocs4cfb2ea2.Add(mem4cfb2ea2)

	var cmaxExtent_allocs *cgoAllocMap
	ref4cfb2ea2.maxExtent, cmaxExtent_allocs = x.MaxExtent.PassValue()
	allocs4cfb2ea2.Borrow(cmaxExtent_allocs)

	var cmaxMipLevels_allocs *cgoAllocMap
	ref4cfb2ea2.maxMipLevels, cmaxMipLevels_allocs = (C.uint32_t)(x.MaxMipLevels), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxMipLevels_allocs)

	var cmaxArrayLayers_allocs *cgoAllocMap
	ref4cfb2ea2.maxArrayLayers, cmaxArrayLayers_allocs = (C.uint32_t)(x.MaxArrayLayers), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxArrayLayers_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref4cfb2ea2.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(csampleCounts_allocs)

	var cmaxResourceSize_allocs *cgoAllocMap
	ref4cfb2ea2.maxResourceSize, cmaxResourceSize_allocs = (C.VkDeviceSize)(x.MaxResourceSize), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxResourceSize_allocs)

	x.ref4cfb2ea2 = ref4cfb2ea2
	x.allocs4cfb2ea2 = allocs4cfb2ea2
	return ref4cfb2ea2, allocs4cfb2ea2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties) PassValue() (C.VkImageFormatProperties, *cgoAllocMap) {
	if x.ref4cfb2ea2 != nil {
		return *x.ref4cfb2ea2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties) Deref() {
	if x.ref4cfb2ea2 == nil {
		return
	}
	x.MaxExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref4cfb2ea2.maxExtent))
	x.MaxMipLevels = (uint32)(x.ref4cfb2ea2.maxMipLevels)
	x.MaxArrayLayers = (uint32)(x.ref4cfb2ea2.maxArrayLayers)
	x.SampleCounts = (SampleCountFlags)(x.ref4cfb2ea2.sampleCounts)
	x.MaxResourceSize = (DeviceSize)(x.ref4cfb2ea2.maxResourceSize)
}

// allocPhysicalDeviceLimitsMemory allocates memory for type C.VkPhysicalDeviceLimits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLimitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLimitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceLimitsValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLimits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceLimits) Ref() *C.VkPhysicalDeviceLimits {
	if x == nil {
		return nil
	}
	return x.ref7926795a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceLimits) Free() {
	if x != nil && x.allocs7926795a != nil {
		x.allocs7926795a.(*cgoAllocMap).Free()
		x.ref7926795a = nil
	}
}

// NewPhysicalDeviceLimitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceLimitsRef(ref unsafe.Pointer) *PhysicalDeviceLimits {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLimits)
	obj.ref7926795a = (*C.VkPhysicalDeviceLimits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceLimits) PassRef() (*C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7926795a != nil {
		return x.ref7926795a, nil
	}
	mem7926795a := allocPhysicalDeviceLimitsMemory(1)
	ref7926795a := (*C.VkPhysicalDeviceLimits)(mem7926795a)
	allocs7926795a := new(cgoAllocMap)
	allocs7926795a.Add(mem7926795a)

	var cmaxImageDimension1D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension1D, cmaxImageDimension1D_allocs = (C.uint32_t)(x.MaxImageDimension1D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension1D_allocs)

	var cmaxImageDimension2D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension2D, cmaxImageDimension2D_allocs = (C.uint32_t)(x.MaxImageDimension2D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension2D_allocs)

	var cmaxImageDimension3D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension3D, cmaxImageDimension3D_allocs = (C.uint32_t)(x.MaxImageDimension3D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension3D_allocs)

	var cmaxImageDimensionCube_allocs *cgoAllocMap
	ref7926795a.maxImageDimensionCube, cmaxImageDimensionCube_allocs = (C.uint32_t)(x.MaxImageDimensionCube), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimensionCube_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref7926795a.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageArrayLayers_allocs)

	var cmaxTexelBufferElements_allocs *cgoAllocMap
	ref7926795a.maxTexelBufferElements, cmaxTexelBufferElements_allocs = (C.uint32_t)(x.MaxTexelBufferElements), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelBufferElements_allocs)

	var cmaxUniformBufferRange_allocs *cgoAllocMap
	ref7926795a.maxUniformBufferRange, cmaxUniformBufferRange_allocs = (C.uint32_t)(x.MaxUniformBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxUniformBufferRange_allocs)

	var cmaxStorageBufferRange_allocs *cgoAllocMap
	ref7926795a.maxStorageBufferRange, cmaxStorageBufferRange_allocs = (C.uint32_t)(x.MaxStorageBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxStorageBufferRange_allocs)

	var cmaxPushConstantsSize_allocs *cgoAllocMap
	ref7926795a.maxPushConstantsSize, cmaxPushConstantsSize_allocs = (C.uint32_t)(x.MaxPushConstantsSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPushConstantsSize_allocs)

	var cmaxMemoryAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxMemoryAllocationCount, cmaxMemoryAllocationCount_allocs = (C.uint32_t)(x.MaxMemoryAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxMemoryAllocationCount_allocs)

	var cmaxSamplerAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxSamplerAllocationCount, cmaxSamplerAllocationCount_allocs = (C.uint32_t)(x.MaxSamplerAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAllocationCount_allocs)

	var cbufferImageGranularity_allocs *cgoAllocMap
	ref7926795a.bufferImageGranularity, cbufferImageGranularity_allocs = (C.VkDeviceSize)(x.BufferImageGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cbufferImageGranularity_allocs)

	var csparseAddressSpaceSize_allocs *cgoAllocMap
	ref7926795a.sparseAddressSpaceSize, csparseAddressSpaceSize_allocs = (C.VkDeviceSize)(x.SparseAddressSpaceSize), cgoAllocsUnknown
	allocs7926795a.Borrow(csparseAddressSpaceSize_allocs)

	var cmaxBoundDescriptorSets_allocs *cgoAllocMap
	ref7926795a.maxBoundDescriptorSets, cmaxBoundDescriptorSets_allocs = (C.uint32_t)(x.MaxBoundDescriptorSets), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxBoundDescriptorSets_allocs)

	var cmaxPerStageDescriptorSamplers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSamplers, cmaxPerStageDescriptorSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSamplers_allocs)

	var cmaxPerStageDescriptorUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorUniformBuffers, cmaxPerStageDescriptorUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorUniformBuffers_allocs)

	var cmaxPerStageDescriptorStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageBuffers, cmaxPerStageDescriptorStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageBuffers_allocs)

	var cmaxPerStageDescriptorSampledImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSampledImages, cmaxPerStageDescriptorSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSampledImages_allocs)

	var cmaxPerStageDescriptorStorageImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageImages, cmaxPerStageDescriptorStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageImages_allocs)

	var cmaxPerStageDescriptorInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorInputAttachments, cmaxPerStageDescriptorInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorInputAttachments_allocs)

	var cmaxPerStageResources_allocs *cgoAllocMap
	ref7926795a.maxPerStageResources, cmaxPerStageResources_allocs = (C.uint32_t)(x.MaxPerStageResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageResources_allocs)

	var cmaxDescriptorSetSamplers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSamplers, cmaxDescriptorSetSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSamplers_allocs)

	var cmaxDescriptorSetUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffers, cmaxDescriptorSetUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffers_allocs)

	var cmaxDescriptorSetUniformBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffersDynamic, cmaxDescriptorSetUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffers, cmaxDescriptorSetStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffers_allocs)

	var cmaxDescriptorSetStorageBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffersDynamic, cmaxDescriptorSetStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetSampledImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSampledImages, cmaxDescriptorSetSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSampledImages_allocs)

	var cmaxDescriptorSetStorageImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageImages, cmaxDescriptorSetStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageImages_allocs)

	var cmaxDescriptorSetInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetInputAttachments, cmaxDescriptorSetInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetInputAttachments_allocs)

	var cmaxVertexInputAttributes_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributes, cmaxVertexInputAttributes_allocs = (C.uint32_t)(x.MaxVertexInputAttributes), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributes_allocs)

	var cmaxVertexInputBindings_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindings, cmaxVertexInputBindings_allocs = (C.uint32_t)(x.MaxVertexInputBindings), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindings_allocs)

	var cmaxVertexInputAttributeOffset_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributeOffset, cmaxVertexInputAttributeOffset_allocs = (C.uint32_t)(x.MaxVertexInputAttributeOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributeOffset_allocs)

	var cmaxVertexInputBindingStride_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindingStride, cmaxVertexInputBindingStride_allocs = (C.uint32_t)(x.MaxVertexInputBindingStride), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindingStride_allocs)

	var cmaxVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxVertexOutputComponents, cmaxVertexOutputComponents_allocs = (C.uint32_t)(x.MaxVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexOutputComponents_allocs)

	var cmaxTessellationGenerationLevel_allocs *cgoAllocMap
	ref7926795a.maxTessellationGenerationLevel, cmaxTessellationGenerationLevel_allocs = (C.uint32_t)(x.MaxTessellationGenerationLevel), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationGenerationLevel_allocs)

	var cmaxTessellationPatchSize_allocs *cgoAllocMap
	ref7926795a.maxTessellationPatchSize, cmaxTessellationPatchSize_allocs = (C.uint32_t)(x.MaxTessellationPatchSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationPatchSize_allocs)

	var cmaxTessellationControlPerVertexInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexInputComponents, cmaxTessellationControlPerVertexInputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexInputComponents_allocs)

	var cmaxTessellationControlPerVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexOutputComponents, cmaxTessellationControlPerVertexOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexOutputComponents_allocs)

	var cmaxTessellationControlPerPatchOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerPatchOutputComponents, cmaxTessellationControlPerPatchOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerPatchOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerPatchOutputComponents_allocs)

	var cmaxTessellationControlTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlTotalOutputComponents, cmaxTessellationControlTotalOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlTotalOutputComponents_allocs)

	var cmaxTessellationEvaluationInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationInputComponents, cmaxTessellationEvaluationInputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationInputComponents_allocs)

	var cmaxTessellationEvaluationOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationOutputComponents, cmaxTessellationEvaluationOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationOutputComponents_allocs)

	var cmaxGeometryShaderInvocations_allocs *cgoAllocMap
	ref7926795a.maxGeometryShaderInvocations, cmaxGeometryShaderInvocations_allocs = (C.uint32_t)(x.MaxGeometryShaderInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryShaderInvocations_allocs)

	var cmaxGeometryInputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryInputComponents, cmaxGeometryInputComponents_allocs = (C.uint32_t)(x.MaxGeometryInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryInputComponents_allocs)

	var cmaxGeometryOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputComponents, cmaxGeometryOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputComponents_allocs)

	var cmaxGeometryOutputVertices_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputVertices, cmaxGeometryOutputVertices_allocs = (C.uint32_t)(x.MaxGeometryOutputVertices), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputVertices_allocs)

	var cmaxGeometryTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryTotalOutputComponents, cmaxGeometryTotalOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryTotalOutputComponents_allocs)

	var cmaxFragmentInputComponents_allocs *cgoAllocMap
	ref7926795a.maxFragmentInputComponents, cmaxFragmentInputComponents_allocs = (C.uint32_t)(x.MaxFragmentInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentInputComponents_allocs)

	var cmaxFragmentOutputAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentOutputAttachments, cmaxFragmentOutputAttachments_allocs = (C.uint32_t)(x.MaxFragmentOutputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentOutputAttachments_allocs)

	var cmaxFragmentDualSrcAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentDualSrcAttachments, cmaxFragmentDualSrcAttachments_allocs = (C.uint32_t)(x.MaxFragmentDualSrcAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentDualSrcAttachments_allocs)

	var cmaxFragmentCombinedOutputResources_allocs *cgoAllocMap
	ref7926795a.maxFragmentCombinedOutputResources, cmaxFragmentCombinedOutputResources_allocs = (C.uint32_t)(x.MaxFragmentCombinedOutputResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentCombinedOutputResources_allocs)

	var cmaxComputeSharedMemorySize_allocs *cgoAllocMap
	ref7926795a.maxComputeSharedMemorySize, cmaxComputeSharedMemorySize_allocs = (C.uint32_t)(x.MaxComputeSharedMemorySize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeSharedMemorySize_allocs)

	var cmaxComputeWorkGroupCount_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupCount, cmaxComputeWorkGroupCount_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupCount)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupCount_allocs)

	var cmaxComputeWorkGroupInvocations_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupInvocations, cmaxComputeWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxComputeWorkGroupInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupInvocations_allocs)

	var cmaxComputeWorkGroupSize_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupSize, cmaxComputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupSize)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupSize_allocs)

	var csubPixelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subPixelPrecisionBits, csubPixelPrecisionBits_allocs = (C.uint32_t)(x.SubPixelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelPrecisionBits_allocs)

	var csubTexelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subTexelPrecisionBits, csubTexelPrecisionBits_allocs = (C.uint32_t)(x.SubTexelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubTexelPrecisionBits_allocs)

	var cmipmapPrecisionBits_allocs *cgoAllocMap
	ref7926795a.mipmapPrecisionBits, cmipmapPrecisionBits_allocs = (C.uint32_t)(x.MipmapPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cmipmapPrecisionBits_allocs)

	var cmaxDrawIndexedIndexValue_allocs *cgoAllocMap
	ref7926795a.maxDrawIndexedIndexValue, cmaxDrawIndexedIndexValue_allocs = (C.uint32_t)(x.MaxDrawIndexedIndexValue), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndexedIndexValue_allocs)

	var cmaxDrawIndirectCount_allocs *cgoAllocMap
	ref7926795a.maxDrawIndirectCount, cmaxDrawIndirectCount_allocs = (C.uint32_t)(x.MaxDrawIndirectCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndirectCount_allocs)

	var cmaxSamplerLodBias_allocs *cgoAllocMap
	ref7926795a.maxSamplerLodBias, cmaxSamplerLodBias_allocs = (C.float)(x.MaxSamplerLodBias), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerLodBias_allocs)

	var cmaxSamplerAnisotropy_allocs *cgoAllocMap
	ref7926795a.maxSamplerAnisotropy, cmaxSamplerAnisotropy_allocs = (C.float)(x.MaxSamplerAnisotropy), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAnisotropy_allocs)

	var cmaxViewports_allocs *cgoAllocMap
	ref7926795a.maxViewports, cmaxViewports_allocs = (C.uint32_t)(x.MaxViewports), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewports_allocs)

	var cmaxViewportDimensions_allocs *cgoAllocMap
	ref7926795a.maxViewportDimensions, cmaxViewportDimensions_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.MaxViewportDimensions)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewportDimensions_allocs)

	var cviewportBoundsRange_allocs *cgoAllocMap
	ref7926795a.viewportBoundsRange, cviewportBoundsRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.ViewportBoundsRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportBoundsRange_allocs)

	var cviewportSubPixelBits_allocs *cgoAllocMap
	ref7926795a.viewportSubPixelBits, cviewportSubPixelBits_allocs = (C.uint32_t)(x.ViewportSubPixelBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportSubPixelBits_allocs)

	var cminMemoryMapAlignment_allocs *cgoAllocMap
	ref7926795a.minMemoryMapAlignment, cminMemoryMapAlignment_allocs = (C.size_t)(x.MinMemoryMapAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminMemoryMapAlignment_allocs)

	var cminTexelBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minTexelBufferOffsetAlignment, cminTexelBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinTexelBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelBufferOffsetAlignment_allocs)

	var cminUniformBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minUniformBufferOffsetAlignment, cminUniformBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinUniformBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminUniformBufferOffsetAlignment_allocs)

	var cminStorageBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minStorageBufferOffsetAlignment, cminStorageBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinStorageBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminStorageBufferOffsetAlignment_allocs)

	var cminTexelOffset_allocs *cgoAllocMap
	ref7926795a.minTexelOffset, cminTexelOffset_allocs = (C.int32_t)(x.MinTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelOffset_allocs)

	var cmaxTexelOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelOffset, cmaxTexelOffset_allocs = (C.uint32_t)(x.MaxTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelOffset_allocs)

	var cminTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.minTexelGatherOffset, cminTexelGatherOffset_allocs = (C.int32_t)(x.MinTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelGatherOffset_allocs)

	var cmaxTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelGatherOffset, cmaxTexelGatherOffset_allocs = (C.uint32_t)(x.MaxTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelGatherOffset_allocs)

	var cminInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.minInterpolationOffset, cminInterpolationOffset_allocs = (C.float)(x.MinInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminInterpolationOffset_allocs)

	var cmaxInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.maxInterpolationOffset, cmaxInterpolationOffset_allocs = (C.float)(x.MaxInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxInterpolationOffset_allocs)

	var csubPixelInterpolationOffsetBits_allocs *cgoAllocMap
	ref7926795a.subPixelInterpolationOffsetBits, csubPixelInterpolationOffsetBits_allocs = (C.uint32_t)(x.SubPixelInterpolationOffsetBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelInterpolationOffsetBits_allocs)

	var cmaxFramebufferWidth_allocs *cgoAllocMap
	ref7926795a.maxFramebufferWidth, cmaxFramebufferWidth_allocs = (C.uint32_t)(x.MaxFramebufferWidth), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferWidth_allocs)

	var cmaxFramebufferHeight_allocs *cgoAllocMap
	ref7926795a.maxFramebufferHeight, cmaxFramebufferHeight_allocs = (C.uint32_t)(x.MaxFramebufferHeight), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferHeight_allocs)

	var cmaxFramebufferLayers_allocs *cgoAllocMap
	ref7926795a.maxFramebufferLayers, cmaxFramebufferLayers_allocs = (C.uint32_t)(x.MaxFramebufferLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferLayers_allocs)

	var cframebufferColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferColorSampleCounts, cframebufferColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferColorSampleCounts_allocs)

	var cframebufferDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferDepthSampleCounts, cframebufferDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferDepthSampleCounts_allocs)

	var cframebufferStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferStencilSampleCounts, cframebufferStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferStencilSampleCounts_allocs)

	var cframebufferNoAttachmentsSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferNoAttachmentsSampleCounts, cframebufferNoAttachmentsSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferNoAttachmentsSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferNoAttachmentsSampleCounts_allocs)

	var cmaxColorAttachments_allocs *cgoAllocMap
	ref7926795a.maxColorAttachments, cmaxColorAttachments_allocs = (C.uint32_t)(x.MaxColorAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxColorAttachments_allocs)

	var csampledImageColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageColorSampleCounts, csampledImageColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageColorSampleCounts_allocs)

	var csampledImageIntegerSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageIntegerSampleCounts, csampledImageIntegerSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageIntegerSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageIntegerSampleCounts_allocs)

	var csampledImageDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageDepthSampleCounts, csampledImageDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageDepthSampleCounts_allocs)

	var csampledImageStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageStencilSampleCounts, csampledImageStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageStencilSampleCounts_allocs)

	var cstorageImageSampleCounts_allocs *cgoAllocMap
	ref7926795a.storageImageSampleCounts, cstorageImageSampleCounts_allocs = (C.VkSampleCountFlags)(x.StorageImageSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cstorageImageSampleCounts_allocs)

	var cmaxSampleMaskWords_allocs *cgoAllocMap
	ref7926795a.maxSampleMaskWords, cmaxSampleMaskWords_allocs = (C.uint32_t)(x.MaxSampleMaskWords), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSampleMaskWords_allocs)

	var ctimestampComputeAndGraphics_allocs *cgoAllocMap
	ref7926795a.timestampComputeAndGraphics, ctimestampComputeAndGraphics_allocs = (C.VkBool32)(x.TimestampComputeAndGraphics), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampComputeAndGraphics_allocs)

	var ctimestampPeriod_allocs *cgoAllocMap
	ref7926795a.timestampPeriod, ctimestampPeriod_allocs = (C.float)(x.TimestampPeriod), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampPeriod_allocs)

	var cmaxClipDistances_allocs *cgoAllocMap
	ref7926795a.maxClipDistances, cmaxClipDistances_allocs = (C.uint32_t)(x.MaxClipDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxClipDistances_allocs)

	var cmaxCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCullDistances, cmaxCullDistances_allocs = (C.uint32_t)(x.MaxCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCullDistances_allocs)

	var cmaxCombinedClipAndCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCombinedClipAndCullDistances, cmaxCombinedClipAndCullDistances_allocs = (C.uint32_t)(x.MaxCombinedClipAndCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCombinedClipAndCullDistances_allocs)

	var cdiscreteQueuePriorities_allocs *cgoAllocMap
	ref7926795a.discreteQueuePriorities, cdiscreteQueuePriorities_allocs = (C.uint32_t)(x.DiscreteQueuePriorities), cgoAllocsUnknown
	allocs7926795a.Borrow(cdiscreteQueuePriorities_allocs)

	var cpointSizeRange_allocs *cgoAllocMap
	ref7926795a.pointSizeRange, cpointSizeRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.PointSizeRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeRange_allocs)

	var clineWidthRange_allocs *cgoAllocMap
	ref7926795a.lineWidthRange, clineWidthRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.LineWidthRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthRange_allocs)

	var cpointSizeGranularity_allocs *cgoAllocMap
	ref7926795a.pointSizeGranularity, cpointSizeGranularity_allocs = (C.float)(x.PointSizeGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeGranularity_allocs)

	var clineWidthGranularity_allocs *cgoAllocMap
	ref7926795a.lineWidthGranularity, clineWidthGranularity_allocs = (C.float)(x.LineWidthGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthGranularity_allocs)

	var cstrictLines_allocs *cgoAllocMap
	ref7926795a.strictLines, cstrictLines_allocs = (C.VkBool32)(x.StrictLines), cgoAllocsUnknown
	allocs7926795a.Borrow(cstrictLines_allocs)

	var cstandardSampleLocations_allocs *cgoAllocMap
	ref7926795a.standardSampleLocations, cstandardSampleLocations_allocs = (C.VkBool32)(x.StandardSampleLocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cstandardSampleLocations_allocs)

	var coptimalBufferCopyOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyOffsetAlignment, coptimalBufferCopyOffsetAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyOffsetAlignment_allocs)

	var coptimalBufferCopyRowPitchAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyRowPitchAlignment, coptimalBufferCopyRowPitchAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyRowPitchAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyRowPitchAlignment_allocs)

	var cnonCoherentAtomSize_allocs *cgoAllocMap
	ref7926795a.nonCoherentAtomSize, cnonCoherentAtomSize_allocs = (C.VkDeviceSize)(x.NonCoherentAtomSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cnonCoherentAtomSize_allocs)

	x.ref7926795a = ref7926795a
	x.allocs7926795a = allocs7926795a
	return ref7926795a, allocs7926795a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceLimits) PassValue() (C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x.ref7926795a != nil {
		return *x.ref7926795a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceLimits) Deref() {
	if x.ref7926795a == nil {
		return
	}
	x.MaxImageDimension1D = (uint32)(x.ref7926795a.maxImageDimension1D)
	x.MaxImageDimension2D = (uint32)(x.ref7926795a.maxImageDimension2D)
	x.MaxImageDimension3D = (uint32)(x.ref7926795a.maxImageDimension3D)
	x.MaxImageDimensionCube = (uint32)(x.ref7926795a.maxImageDimensionCube)
	x.MaxImageArrayLayers = (uint32)(x.ref7926795a.maxImageArrayLayers)
	x.MaxTexelBufferElements = (uint32)(x.ref7926795a.maxTexelBufferElements)
	x.MaxUniformBufferRange = (uint32)(x.ref7926795a.maxUniformBufferRange)
	x.MaxStorageBufferRange = (uint32)(x.ref7926795a.maxStorageBufferRange)
	x.MaxPushConstantsSize = (uint32)(x.ref7926795a.maxPushConstantsSize)
	x.MaxMemoryAllocationCount = (uint32)(x.ref7926795a.maxMemoryAllocationCount)
	x.MaxSamplerAllocationCount = (uint32)(x.ref7926795a.maxSamplerAllocationCount)
	x.BufferImageGranularity = (DeviceSize)(x.ref7926795a.bufferImageGranularity)
	x.SparseAddressSpaceSize = (DeviceSize)(x.ref7926795a.sparseAddressSpaceSize)
	x.MaxBoundDescriptorSets = (uint32)(x.ref7926795a.maxBoundDescriptorSets)
	x.MaxPerStageDescriptorSamplers = (uint32)(x.ref7926795a.maxPerStageDescriptorSamplers)
	x.MaxPerStageDescriptorUniformBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorUniformBuffers)
	x.MaxPerStageDescriptorStorageBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageBuffers)
	x.MaxPerStageDescriptorSampledImages = (uint32)(x.ref7926795a.maxPerStageDescriptorSampledImages)
	x.MaxPerStageDescriptorStorageImages = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageImages)
	x.MaxPerStageDescriptorInputAttachments = (uint32)(x.ref7926795a.maxPerStageDescriptorInputAttachments)
	x.MaxPerStageResources = (uint32)(x.ref7926795a.maxPerStageResources)
	x.MaxDescriptorSetSamplers = (uint32)(x.ref7926795a.maxDescriptorSetSamplers)
	x.MaxDescriptorSetUniformBuffers = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffers)
	x.MaxDescriptorSetUniformBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffersDynamic)
	x.MaxDescriptorSetStorageBuffers = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffers)
	x.MaxDescriptorSetStorageBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffersDynamic)
	x.MaxDescriptorSetSampledImages = (uint32)(x.ref7926795a.maxDescriptorSetSampledImages)
	x.MaxDescriptorSetStorageImages = (uint32)(x.ref7926795a.maxDescriptorSetStorageImages)
	x.MaxDescriptorSetInputAttachments = (uint32)(x.ref7926795a.maxDescriptorSetInputAttachments)
	x.MaxVertexInputAttributes = (uint32)(x.ref7926795a.maxVertexInputAttributes)
	x.MaxVertexInputBindings = (uint32)(x.ref7926795a.maxVertexInputBindings)
	x.MaxVertexInputAttributeOffset = (uint32)(x.ref7926795a.maxVertexInputAttributeOffset)
	x.MaxVertexInputBindingStride = (uint32)(x.ref7926795a.maxVertexInputBindingStride)
	x.MaxVertexOutputComponents = (uint32)(x.ref7926795a.maxVertexOutputComponents)
	x.MaxTessellationGenerationLevel = (uint32)(x.ref7926795a.maxTessellationGenerationLevel)
	x.MaxTessellationPatchSize = (uint32)(x.ref7926795a.maxTessellationPatchSize)
	x.MaxTessellationControlPerVertexInputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexInputComponents)
	x.MaxTessellationControlPerVertexOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexOutputComponents)
	x.MaxTessellationControlPerPatchOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerPatchOutputComponents)
	x.MaxTessellationControlTotalOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlTotalOutputComponents)
	x.MaxTessellationEvaluationInputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationInputComponents)
	x.MaxTessellationEvaluationOutputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationOutputComponents)
	x.MaxGeometryShaderInvocations = (uint32)(x.ref7926795a.maxGeometryShaderInvocations)
	x.MaxGeometryInputComponents = (uint32)(x.ref7926795a.maxGeometryInputComponents)
	x.MaxGeometryOutputComponents = (uint32)(x.ref7926795a.maxGeometryOutputComponents)
	x.MaxGeometryOutputVertices = (uint32)(x.ref7926795a.maxGeometryOutputVertices)
	x.MaxGeometryTotalOutputComponents = (uint32)(x.ref7926795a.maxGeometryTotalOutputComponents)
	x.MaxFragmentInputComponents = (uint32)(x.ref7926795a.maxFragmentInputComponents)
	x.MaxFragmentOutputAttachments = (uint32)(x.ref7926795a.maxFragmentOutputAttachments)
	x.MaxFragmentDualSrcAttachments = (uint32)(x.ref7926795a.maxFragmentDualSrcAttachments)
	x.MaxFragmentCombinedOutputResources = (uint32)(x.ref7926795a.maxFragmentCombinedOutputResources)
	x.MaxComputeSharedMemorySize = (uint32)(x.ref7926795a.maxComputeSharedMemorySize)
	x.MaxComputeWorkGroupCount = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupCount))
	x.MaxComputeWorkGroupInvocations = (uint32)(x.ref7926795a.maxComputeWorkGroupInvocations)
	x.MaxComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupSize))
	x.SubPixelPrecisionBits = (uint32)(x.ref7926795a.subPixelPrecisionBits)
	x.SubTexelPrecisionBits = (uint32)(x.ref7926795a.subTexelPrecisionBits)
	x.MipmapPrecisionBits = (uint32)(x.ref7926795a.mipmapPrecisionBits)
	x.MaxDrawIndexedIndexValue = (uint32)(x.ref7926795a.maxDrawIndexedIndexValue)
	x.MaxDrawIndirectCount = (uint32)(x.ref7926795a.maxDrawIndirectCount)
	x.MaxSamplerLodBias = (float32)(x.ref7926795a.maxSamplerLodBias)
	x.MaxSamplerAnisotropy = (float32)(x.ref7926795a.maxSamplerAnisotropy)
	x.MaxViewports = (uint32)(x.ref7926795a.maxViewports)
	x.MaxViewportDimensions = *(*[2]uint32)(unsafe.Pointer(&x.ref7926795a.maxViewportDimensions))
	x.ViewportBoundsRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.viewportBoundsRange))
	x.ViewportSubPixelBits = (uint32)(x.ref7926795a.viewportSubPixelBits)
	x.MinMemoryMapAlignment = (uint)(x.ref7926795a.minMemoryMapAlignment)
	x.MinTexelBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minTexelBufferOffsetAlignment)
	x.MinUniformBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minUniformBufferOffsetAlignment)
	x.MinStorageBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minStorageBufferOffsetAlignment)
	x.MinTexelOffset = (int32)(x.ref7926795a.minTexelOffset)
	x.MaxTexelOffset = (uint32)(x.ref7926795a.maxTexelOffset)
	x.MinTexelGatherOffset = (int32)(x.ref7926795a.minTexelGatherOffset)
	x.MaxTexelGatherOffset = (uint32)(x.ref7926795a.maxTexelGatherOffset)
	x.MinInterpolationOffset = (float32)(x.ref7926795a.minInterpolationOffset)
	x.MaxInterpolationOffset = (float32)(x.ref7926795a.maxInterpolationOffset)
	x.SubPixelInterpolationOffsetBits = (uint32)(x.ref7926795a.subPixelInterpolationOffsetBits)
	x.MaxFramebufferWidth = (uint32)(x.ref7926795a.maxFramebufferWidth)
	x.MaxFramebufferHeight = (uint32)(x.ref7926795a.maxFramebufferHeight)
	x.MaxFramebufferLayers = (uint32)(x.ref7926795a.maxFramebufferLayers)
	x.FramebufferColorSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferColorSampleCounts)
	x.FramebufferDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferDepthSampleCounts)
	x.FramebufferStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferStencilSampleCounts)
	x.FramebufferNoAttachmentsSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferNoAttachmentsSampleCounts)
	x.MaxColorAttachments = (uint32)(x.ref7926795a.maxColorAttachments)
	x.SampledImageColorSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageColorSampleCounts)
	x.SampledImageIntegerSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageIntegerSampleCounts)
	x.SampledImageDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageDepthSampleCounts)
	x.SampledImageStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageStencilSampleCounts)
	x.StorageImageSampleCounts = (SampleCountFlags)(x.ref7926795a.storageImageSampleCounts)
	x.MaxSampleMaskWords = (uint32)(x.ref7926795a.maxSampleMaskWords)
	x.TimestampComputeAndGraphics = (Bool32)(x.ref7926795a.timestampComputeAndGraphics)
	x.TimestampPeriod = (float32)(x.ref7926795a.timestampPeriod)
	x.MaxClipDistances = (uint32)(x.ref7926795a.maxClipDistances)
	x.MaxCullDistances = (uint32)(x.ref7926795a.maxCullDistances)
	x.MaxCombinedClipAndCullDistances = (uint32)(x.ref7926795a.maxCombinedClipAndCullDistances)
	x.DiscreteQueuePriorities = (uint32)(x.ref7926795a.discreteQueuePriorities)
	x.PointSizeRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.pointSizeRange))
	x.LineWidthRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.lineWidthRange))
	x.PointSizeGranularity = (float32)(x.ref7926795a.pointSizeGranularity)
	x.LineWidthGranularity = (float32)(x.ref7926795a.lineWidthGranularity)
	x.StrictLines = (Bool32)(x.ref7926795a.strictLines)
	x.StandardSampleLocations = (Bool32)(x.ref7926795a.standardSampleLocations)
	x.OptimalBufferCopyOffsetAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyOffsetAlignment)
	x.OptimalBufferCopyRowPitchAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyRowPitchAlignment)
	x.NonCoherentAtomSize = (DeviceSize)(x.ref7926795a.nonCoherentAtomSize)
}

// allocPhysicalDeviceSparsePropertiesMemory allocates memory for type C.VkPhysicalDeviceSparseProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparsePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparsePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparsePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseProperties) Ref() *C.VkPhysicalDeviceSparseProperties {
	if x == nil {
		return nil
	}
	return x.ref6d7c11e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseProperties) Free() {
	if x != nil && x.allocs6d7c11e6 != nil {
		x.allocs6d7c11e6.(*cgoAllocMap).Free()
		x.ref6d7c11e6 = nil
	}
}

// NewPhysicalDeviceSparsePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparsePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSparseProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseProperties)
	obj.ref6d7c11e6 = (*C.VkPhysicalDeviceSparseProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseProperties) PassRef() (*C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d7c11e6 != nil {
		return x.ref6d7c11e6, nil
	}
	mem6d7c11e6 := allocPhysicalDeviceSparsePropertiesMemory(1)
	ref6d7c11e6 := (*C.VkPhysicalDeviceSparseProperties)(mem6d7c11e6)
	allocs6d7c11e6 := new(cgoAllocMap)
	allocs6d7c11e6.Add(mem6d7c11e6)

	var cresidencyStandard2DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DBlockShape, cresidencyStandard2DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DBlockShape_allocs)

	var cresidencyStandard2DMultisampleBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DMultisampleBlockShape, cresidencyStandard2DMultisampleBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DMultisampleBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DMultisampleBlockShape_allocs)

	var cresidencyStandard3DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard3DBlockShape, cresidencyStandard3DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard3DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard3DBlockShape_allocs)

	var cresidencyAlignedMipSize_allocs *cgoAllocMap
	ref6d7c11e6.residencyAlignedMipSize, cresidencyAlignedMipSize_allocs = (C.VkBool32)(x.ResidencyAlignedMipSize), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyAlignedMipSize_allocs)

	var cresidencyNonResidentStrict_allocs *cgoAllocMap
	ref6d7c11e6.residencyNonResidentStrict, cresidencyNonResidentStrict_allocs = (C.VkBool32)(x.ResidencyNonResidentStrict), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyNonResidentStrict_allocs)

	x.ref6d7c11e6 = ref6d7c11e6
	x.allocs6d7c11e6 = allocs6d7c11e6
	return ref6d7c11e6, allocs6d7c11e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseProperties) PassValue() (C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x.ref6d7c11e6 != nil {
		return *x.ref6d7c11e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseProperties) Deref() {
	if x.ref6d7c11e6 == nil {
		return
	}
	x.ResidencyStandard2DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DBlockShape)
	x.ResidencyStandard2DMultisampleBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DMultisampleBlockShape)
	x.ResidencyStandard3DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard3DBlockShape)
	x.ResidencyAlignedMipSize = (Bool32)(x.ref6d7c11e6.residencyAlignedMipSize)
	x.ResidencyNonResidentStrict = (Bool32)(x.ref6d7c11e6.residencyNonResidentStrict)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = (*C.VkPhysicalDeviceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	allocs1080ca9d.Add(mem1080ca9d)

	var capiVersion_allocs *cgoAllocMap
	ref1080ca9d.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(capiVersion_allocs)

	var cdriverVersion_allocs *cgoAllocMap
	ref1080ca9d.driverVersion, cdriverVersion_allocs = (C.uint32_t)(x.DriverVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdriverVersion_allocs)

	var cvendorID_allocs *cgoAllocMap
	ref1080ca9d.vendorID, cvendorID_allocs = (C.uint32_t)(x.VendorID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cvendorID_allocs)

	var cdeviceID_allocs *cgoAllocMap
	ref1080ca9d.deviceID, cdeviceID_allocs = (C.uint32_t)(x.DeviceID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceID_allocs)

	var cdeviceType_allocs *cgoAllocMap
	ref1080ca9d.deviceType, cdeviceType_allocs = (C.VkPhysicalDeviceType)(x.DeviceType), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceType_allocs)

	var cdeviceName_allocs *cgoAllocMap
	ref1080ca9d.deviceName, cdeviceName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceName_allocs)

	var cpipelineCacheUUID_allocs *cgoAllocMap
	ref1080ca9d.pipelineCacheUUID, cpipelineCacheUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cpipelineCacheUUID_allocs)

	var climits_allocs *cgoAllocMap
	ref1080ca9d.limits, climits_allocs = x.Limits.PassValue()
	allocs1080ca9d.Borrow(climits_allocs)

	var csparseProperties_allocs *cgoAllocMap
	ref1080ca9d.sparseProperties, csparseProperties_allocs = x.SparseProperties.PassValue()
	allocs1080ca9d.Borrow(csparseProperties_allocs)

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *NewPhysicalDeviceLimitsRef(unsafe.Pointer(&x.ref1080ca9d.limits))
	x.SparseProperties = *NewPhysicalDeviceSparsePropertiesRef(unsafe.Pointer(&x.ref1080ca9d.sparseProperties))
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties) Ref() *C.VkQueueFamilyProperties {
	if x == nil {
		return nil
	}
	return x.refd538c446
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties) Free() {
	if x != nil && x.allocsd538c446 != nil {
		x.allocsd538c446.(*cgoAllocMap).Free()
		x.refd538c446 = nil
	}
}

// NewQueueFamilyPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyPropertiesRef(ref unsafe.Pointer) *QueueFamilyProperties {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties)
	obj.refd538c446 = (*C.VkQueueFamilyProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties) PassRef() (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd538c446 != nil {
		return x.refd538c446, nil
	}
	memd538c446 := allocQueueFamilyPropertiesMemory(1)
	refd538c446 := (*C.VkQueueFamilyProperties)(memd538c446)
	allocsd538c446 := new(cgoAllocMap)
	allocsd538c446.Add(memd538c446)

	var cqueueFlags_allocs *cgoAllocMap
	refd538c446.queueFlags, cqueueFlags_allocs = (C.VkQueueFlags)(x.QueueFlags), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueFlags_allocs)

	var cqueueCount_allocs *cgoAllocMap
	refd538c446.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueCount_allocs)

	var ctimestampValidBits_allocs *cgoAllocMap
	refd538c446.timestampValidBits, ctimestampValidBits_allocs = (C.uint32_t)(x.TimestampValidBits), cgoAllocsUnknown
	allocsd538c446.Borrow(ctimestampValidBits_allocs)

	var cminImageTransferGranularity_allocs *cgoAllocMap
	refd538c446.minImageTransferGranularity, cminImageTransferGranularity_allocs = x.MinImageTransferGranularity.PassValue()
	allocsd538c446.Borrow(cminImageTransferGranularity_allocs)

	x.refd538c446 = refd538c446
	x.allocsd538c446 = allocsd538c446
	return refd538c446, allocsd538c446

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties) PassValue() (C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x.refd538c446 != nil {
		return *x.refd538c446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties) Deref() {
	if x.refd538c446 == nil {
		return
	}
	x.QueueFlags = (QueueFlags)(x.refd538c446.queueFlags)
	x.QueueCount = (uint32)(x.refd538c446.queueCount)
	x.TimestampValidBits = (uint32)(x.refd538c446.timestampValidBits)
	x.MinImageTransferGranularity = *NewExtent3DRef(unsafe.Pointer(&x.refd538c446.minImageTransferGranularity))
}

// allocMemoryTypeMemory allocates memory for type C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryTypeValue = unsafe.Sizeof([1]C.VkMemoryType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryType) Ref() *C.VkMemoryType {
	if x == nil {
		return nil
	}
	return x.ref2f46e01d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryType) Free() {
	if x != nil && x.allocs2f46e01d != nil {
		x.allocs2f46e01d.(*cgoAllocMap).Free()
		x.ref2f46e01d = nil
	}
}

// NewMemoryTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryTypeRef(ref unsafe.Pointer) *MemoryType {
	if ref == nil {
		return nil
	}
	obj := new(MemoryType)
	obj.ref2f46e01d = (*C.VkMemoryType)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryType) PassRef() (*C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f46e01d != nil {
		return x.ref2f46e01d, nil
	}
	mem2f46e01d := allocMemoryTypeMemory(1)
	ref2f46e01d := (*C.VkMemoryType)(mem2f46e01d)
	allocs2f46e01d := new(cgoAllocMap)
	allocs2f46e01d.Add(mem2f46e01d)

	var cpropertyFlags_allocs *cgoAllocMap
	ref2f46e01d.propertyFlags, cpropertyFlags_allocs = (C.VkMemoryPropertyFlags)(x.PropertyFlags), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cpropertyFlags_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref2f46e01d.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cheapIndex_allocs)

	x.ref2f46e01d = ref2f46e01d
	x.allocs2f46e01d = allocs2f46e01d
	return ref2f46e01d, allocs2f46e01d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryType) PassValue() (C.VkMemoryType, *cgoAllocMap) {
	if x.ref2f46e01d != nil {
		return *x.ref2f46e01d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryType) Deref() {
	if x.ref2f46e01d == nil {
		return
	}
	x.PropertyFlags = (MemoryPropertyFlags)(x.ref2f46e01d.propertyFlags)
	x.HeapIndex = (uint32)(x.ref2f46e01d.heapIndex)
}

// allocMemoryHeapMemory allocates memory for type C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHeapValue = unsafe.Sizeof([1]C.VkMemoryHeap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHeap) Ref() *C.VkMemoryHeap {
	if x == nil {
		return nil
	}
	return x.ref1eb195d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHeap) Free() {
	if x != nil && x.allocs1eb195d5 != nil {
		x.allocs1eb195d5.(*cgoAllocMap).Free()
		x.ref1eb195d5 = nil
	}
}

// NewMemoryHeapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHeapRef(ref unsafe.Pointer) *MemoryHeap {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHeap)
	obj.ref1eb195d5 = (*C.VkMemoryHeap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHeap) PassRef() (*C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb195d5 != nil {
		return x.ref1eb195d5, nil
	}
	mem1eb195d5 := allocMemoryHeapMemory(1)
	ref1eb195d5 := (*C.VkMemoryHeap)(mem1eb195d5)
	allocs1eb195d5 := new(cgoAllocMap)
	allocs1eb195d5.Add(mem1eb195d5)

	var csize_allocs *cgoAllocMap
	ref1eb195d5.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs1eb195d5.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	ref1eb195d5.flags, cflags_allocs = (C.VkMemoryHeapFlags)(x.Flags), cgoAllocsUnknown
	allocs1eb195d5.Borrow(cflags_allocs)

	x.ref1eb195d5 = ref1eb195d5
	x.allocs1eb195d5 = allocs1eb195d5
	return ref1eb195d5, allocs1eb195d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHeap) PassValue() (C.VkMemoryHeap, *cgoAllocMap) {
	if x.ref1eb195d5 != nil {
		return *x.ref1eb195d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHeap) Deref() {
	if x.ref1eb195d5 == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref1eb195d5.size)
	x.Flags = (MemoryHeapFlags)(x.ref1eb195d5.flags)
}

// allocPhysicalDeviceMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties{})

// allocA32MemoryTypeMemory allocates memory for type [32]C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32MemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32MemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32MemoryTypeValue = unsafe.Sizeof([1][32]C.VkMemoryType{})

// unpackA32MemoryType transforms a sliced Go data structure into plain C format.
func unpackA32MemoryType(x [32]MemoryType) (unpacked [32]C.VkMemoryType, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.VkMemoryType) {
		go allocs.Free()
	})

	mem0 := allocA32MemoryTypeMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VkMemoryType)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[32]C.VkMemoryType)(mem0)
	return
}

// allocA16MemoryHeapMemory allocates memory for type [16]C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16MemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16MemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16MemoryHeapValue = unsafe.Sizeof([1][16]C.VkMemoryHeap{})

// unpackA16MemoryHeap transforms a sliced Go data structure into plain C format.
func unpackA16MemoryHeap(x [16]MemoryHeap) (unpacked [16]C.VkMemoryHeap, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[16]C.VkMemoryHeap) {
		go allocs.Free()
	})

	mem0 := allocA16MemoryHeapMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VkMemoryHeap)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.VkMemoryHeap)(mem0)
	return
}

// packA32MemoryType reads sliced Go data structure out from plain C format.
func packA32MemoryType(v *[32]MemoryType, ptr0 *[32]C.VkMemoryType) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryTypeRef(unsafe.Pointer(&ptr1))
	}
}

// packA16MemoryHeap reads sliced Go data structure out from plain C format.
func packA16MemoryHeap(v *[16]MemoryHeap, ptr0 *[16]C.VkMemoryHeap) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryHeapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties) Ref() *C.VkPhysicalDeviceMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref3aabb5fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties) Free() {
	if x != nil && x.allocs3aabb5fd != nil {
		x.allocs3aabb5fd.(*cgoAllocMap).Free()
		x.ref3aabb5fd = nil
	}
}

// NewPhysicalDeviceMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties)
	obj.ref3aabb5fd = (*C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties) PassRef() (*C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3aabb5fd != nil {
		return x.ref3aabb5fd, nil
	}
	mem3aabb5fd := allocPhysicalDeviceMemoryPropertiesMemory(1)
	ref3aabb5fd := (*C.VkPhysicalDeviceMemoryProperties)(mem3aabb5fd)
	allocs3aabb5fd := new(cgoAllocMap)
	allocs3aabb5fd.Add(mem3aabb5fd)

	var cmemoryTypeCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypeCount, cmemoryTypeCount_allocs = (C.uint32_t)(x.MemoryTypeCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryTypeCount_allocs)

	var cmemoryTypes_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypes, cmemoryTypes_allocs = unpackA32MemoryType(x.MemoryTypes)
	allocs3aabb5fd.Borrow(cmemoryTypes_allocs)

	var cmemoryHeapCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeapCount, cmemoryHeapCount_allocs = (C.uint32_t)(x.MemoryHeapCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryHeapCount_allocs)

	var cmemoryHeaps_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeaps, cmemoryHeaps_allocs = unpackA16MemoryHeap(x.MemoryHeaps)
	allocs3aabb5fd.Borrow(cmemoryHeaps_allocs)

	x.ref3aabb5fd = ref3aabb5fd
	x.allocs3aabb5fd = allocs3aabb5fd
	return ref3aabb5fd, allocs3aabb5fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties) PassValue() (C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x.ref3aabb5fd != nil {
		return *x.ref3aabb5fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties) Deref() {
	if x.ref3aabb5fd == nil {
		return
	}
	x.MemoryTypeCount = (uint32)(x.ref3aabb5fd.memoryTypeCount)
	packA32MemoryType(&x.MemoryTypes, (*[32]C.VkMemoryType)(unsafe.Pointer(&x.ref3aabb5fd.memoryTypes)))
	x.MemoryHeapCount = (uint32)(x.ref3aabb5fd.memoryHeapCount)
	packA16MemoryHeap(&x.MemoryHeaps, (*[16]C.VkMemoryHeap)(unsafe.Pointer(&x.ref3aabb5fd.memoryHeaps)))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueCreateInfoRef(ref unsafe.Pointer) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	allocs6087b30d.Add(mem6087b30d)

	var csType_allocs *cgoAllocMap
	ref6087b30d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6087b30d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6087b30d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref6087b30d.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs6087b30d.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref6087b30d.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueFamilyIndex_allocs)

	var cqueueCount_allocs *cgoAllocMap
	ref6087b30d.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueCount_allocs)

	var cpQueuePriorities_allocs *cgoAllocMap
	ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)).Data)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpQueuePriorities_allocs)

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxfc4425b.Data = unsafe.Pointer(x.ref6087b30d.pQueuePriorities)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceQueueCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(h.Data)
	return
}

// unpackSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(h.Data)
	return
}

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPhysicalDeviceFeatures reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures(v []PhysicalDeviceFeatures, ptr0 *C.VkPhysicalDeviceFeatures) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeaturesValue]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = (*C.VkDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	allocsc0d8b997.Add(memc0d8b997)

	var csType_allocs *cgoAllocMap
	refc0d8b997.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0d8b997.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0d8b997.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc0d8b997.flags, cflags_allocs = (C.VkDeviceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cflags_allocs)

	var cqueueCreateInfoCount_allocs *cgoAllocMap
	refc0d8b997.queueCreateInfoCount, cqueueCreateInfoCount_allocs = (C.uint32_t)(x.QueueCreateInfoCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cqueueCreateInfoCount_allocs)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	refc0d8b997.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	refc0d8b997.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	var cpEnabledFeatures_allocs *cgoAllocMap
	refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = unpackSPhysicalDeviceFeatures(x.PEnabledFeatures)
	allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	packSPhysicalDeviceFeatures(x.PEnabledFeatures, x.refc0d8b997.pEnabledFeatures)
}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtensionPropertiesRef(ref unsafe.Pointer) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExtensionProperties)
	obj.ref2f001956 = (*C.VkExtensionProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	allocs2f001956.Add(mem2f001956)

	var cextensionName_allocs *cgoAllocMap
	ref2f001956.extensionName, cextensionName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName)), cgoAllocsUnknown
	allocs2f001956.Borrow(cextensionName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	ref2f001956.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocs2f001956.Borrow(cspecVersion_allocs)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerPropertiesRef(ref unsafe.Pointer) *LayerProperties {
	if ref == nil {
		return nil
	}
	obj := new(LayerProperties)
	obj.refd9407ce7 = (*C.VkLayerProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	allocsd9407ce7.Add(memd9407ce7)

	var clayerName_allocs *cgoAllocMap
	refd9407ce7.layerName, clayerName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.LayerName)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(clayerName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	refd9407ce7.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cspecVersion_allocs)

	var cimplementationVersion_allocs *cgoAllocMap
	refd9407ce7.implementationVersion, cimplementationVersion_allocs = (C.uint32_t)(x.ImplementationVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cimplementationVersion_allocs)

	var cdescription_allocs *cgoAllocMap
	refd9407ce7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cdescription_allocs)

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfoRef(ref unsafe.Pointer) *SubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo)
	obj.ref22884025 = (*C.VkSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	allocs22884025.Add(mem22884025)

	var csType_allocs *cgoAllocMap
	ref22884025.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22884025.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22884025.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22884025.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref22884025.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitSemaphores_allocs)

	var cpWaitDstStageMask_allocs *cgoAllocMap
	ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = (*C.VkPipelineStageFlags)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitDstStageMask_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	ref22884025.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocs22884025.Borrow(ccommandBufferCount_allocs)

	var cpCommandBuffers_allocs *cgoAllocMap
	ref22884025.pCommandBuffers, cpCommandBuffers_allocs = (*C.VkCommandBuffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpCommandBuffers_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	ref22884025.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpSignalSemaphores_allocs)

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf95e7c8.Data = unsafe.Pointer(x.ref22884025.pWaitSemaphores)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxff2234b.Data = unsafe.Pointer(x.ref22884025.pWaitDstStageMask)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxff73280.Data = unsafe.Pointer(x.ref22884025.pCommandBuffers)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxfa9955c.Data = unsafe.Pointer(x.ref22884025.pSignalSemaphores)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocMemoryAllocateInfoMemory allocates memory for type C.VkMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateInfo) Ref() *C.VkMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref31032b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateInfo) Free() {
	if x != nil && x.allocs31032b != nil {
		x.allocs31032b.(*cgoAllocMap).Free()
		x.ref31032b = nil
	}
}

// NewMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateInfoRef(ref unsafe.Pointer) *MemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateInfo)
	obj.ref31032b = (*C.VkMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateInfo) PassRef() (*C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref31032b != nil {
		return x.ref31032b, nil
	}
	mem31032b := allocMemoryAllocateInfoMemory(1)
	ref31032b := (*C.VkMemoryAllocateInfo)(mem31032b)
	allocs31032b := new(cgoAllocMap)
	allocs31032b.Add(mem31032b)

	var csType_allocs *cgoAllocMap
	ref31032b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs31032b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref31032b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs31032b.Borrow(cpNext_allocs)

	var callocationSize_allocs *cgoAllocMap
	ref31032b.allocationSize, callocationSize_allocs = (C.VkDeviceSize)(x.AllocationSize), cgoAllocsUnknown
	allocs31032b.Borrow(callocationSize_allocs)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref31032b.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.MemoryTypeIndex), cgoAllocsUnknown
	allocs31032b.Borrow(cmemoryTypeIndex_allocs)

	x.ref31032b = ref31032b
	x.allocs31032b = allocs31032b
	return ref31032b, allocs31032b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateInfo) PassValue() (C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x.ref31032b != nil {
		return *x.ref31032b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateInfo) Deref() {
	if x.ref31032b == nil {
		return
	}
	x.SType = (StructureType)(x.ref31032b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref31032b.pNext))
	x.AllocationSize = (DeviceSize)(x.ref31032b.allocationSize)
	x.MemoryTypeIndex = (uint32)(x.ref31032b.memoryTypeIndex)
}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMappedMemoryRangeRef(ref unsafe.Pointer) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = (*C.VkMappedMemoryRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	allocs42a37320.Add(mem42a37320)

	var csType_allocs *cgoAllocMap
	ref42a37320.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs42a37320.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref42a37320.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs42a37320.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref42a37320.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs42a37320.Borrow(cmemory_allocs)

	var coffset_allocs *cgoAllocMap
	ref42a37320.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs42a37320.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref42a37320.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs42a37320.Borrow(csize_allocs)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocMemoryRequirementsMemory allocates memory for type C.VkMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirementsValue = unsafe.Sizeof([1]C.VkMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements) Ref() *C.VkMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref5259fc6b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements) Free() {
	if x != nil && x.allocs5259fc6b != nil {
		x.allocs5259fc6b.(*cgoAllocMap).Free()
		x.ref5259fc6b = nil
	}
}

// NewMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirementsRef(ref unsafe.Pointer) *MemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements)
	obj.ref5259fc6b = (*C.VkMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements) PassRef() (*C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5259fc6b != nil {
		return x.ref5259fc6b, nil
	}
	mem5259fc6b := allocMemoryRequirementsMemory(1)
	ref5259fc6b := (*C.VkMemoryRequirements)(mem5259fc6b)
	allocs5259fc6b := new(cgoAllocMap)
	allocs5259fc6b.Add(mem5259fc6b)

	var csize_allocs *cgoAllocMap
	ref5259fc6b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5259fc6b.Borrow(csize_allocs)

	var calignment_allocs *cgoAllocMap
	ref5259fc6b.alignment, calignment_allocs = (C.VkDeviceSize)(x.Alignment), cgoAllocsUnknown
	allocs5259fc6b.Borrow(calignment_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref5259fc6b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs5259fc6b.Borrow(cmemoryTypeBits_allocs)

	x.ref5259fc6b = ref5259fc6b
	x.allocs5259fc6b = allocs5259fc6b
	return ref5259fc6b, allocs5259fc6b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements) PassValue() (C.VkMemoryRequirements, *cgoAllocMap) {
	if x.ref5259fc6b != nil {
		return *x.ref5259fc6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements) Deref() {
	if x.ref5259fc6b == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref5259fc6b.size)
	x.Alignment = (DeviceSize)(x.ref5259fc6b.alignment)
	x.MemoryTypeBits = (uint32)(x.ref5259fc6b.memoryTypeBits)
}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties) Ref() *C.VkSparseImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref2c12cf44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties) Free() {
	if x != nil && x.allocs2c12cf44 != nil {
		x.allocs2c12cf44.(*cgoAllocMap).Free()
		x.ref2c12cf44 = nil
	}
}

// NewSparseImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatPropertiesRef(ref unsafe.Pointer) *SparseImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties)
	obj.ref2c12cf44 = (*C.VkSparseImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties) PassRef() (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c12cf44 != nil {
		return x.ref2c12cf44, nil
	}
	mem2c12cf44 := allocSparseImageFormatPropertiesMemory(1)
	ref2c12cf44 := (*C.VkSparseImageFormatProperties)(mem2c12cf44)
	allocs2c12cf44 := new(cgoAllocMap)
	allocs2c12cf44.Add(mem2c12cf44)

	var caspectMask_allocs *cgoAllocMap
	ref2c12cf44.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs2c12cf44.Borrow(caspectMask_allocs)

	var cimageGranularity_allocs *cgoAllocMap
	ref2c12cf44.imageGranularity, cimageGranularity_allocs = x.ImageGranularity.PassValue()
	allocs2c12cf44.Borrow(cimageGranularity_allocs)

	var cflags_allocs *cgoAllocMap
	ref2c12cf44.flags, cflags_allocs = (C.VkSparseImageFormatFlags)(x.Flags), cgoAllocsUnknown
	allocs2c12cf44.Borrow(cflags_allocs)

	x.ref2c12cf44 = ref2c12cf44
	x.allocs2c12cf44 = allocs2c12cf44
	return ref2c12cf44, allocs2c12cf44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties) PassValue() (C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x.ref2c12cf44 != nil {
		return *x.ref2c12cf44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties) Deref() {
	if x.ref2c12cf44 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref2c12cf44.aspectMask)
	x.ImageGranularity = *NewExtent3DRef(unsafe.Pointer(&x.ref2c12cf44.imageGranularity))
	x.Flags = (SparseImageFormatFlags)(x.ref2c12cf44.flags)
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements) Ref() *C.VkSparseImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref685a2323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements) Free() {
	if x != nil && x.allocs685a2323 != nil {
		x.allocs685a2323.(*cgoAllocMap).Free()
		x.ref685a2323 = nil
	}
}

// NewSparseImageMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirementsRef(ref unsafe.Pointer) *SparseImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements)
	obj.ref685a2323 = (*C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements) PassRef() (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685a2323 != nil {
		return x.ref685a2323, nil
	}
	mem685a2323 := allocSparseImageMemoryRequirementsMemory(1)
	ref685a2323 := (*C.VkSparseImageMemoryRequirements)(mem685a2323)
	allocs685a2323 := new(cgoAllocMap)
	allocs685a2323.Add(mem685a2323)

	var cformatProperties_allocs *cgoAllocMap
	ref685a2323.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocs685a2323.Borrow(cformatProperties_allocs)

	var cimageMipTailFirstLod_allocs *cgoAllocMap
	ref685a2323.imageMipTailFirstLod, cimageMipTailFirstLod_allocs = (C.uint32_t)(x.ImageMipTailFirstLod), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailFirstLod_allocs)

	var cimageMipTailSize_allocs *cgoAllocMap
	ref685a2323.imageMipTailSize, cimageMipTailSize_allocs = (C.VkDeviceSize)(x.ImageMipTailSize), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailSize_allocs)

	var cimageMipTailOffset_allocs *cgoAllocMap
	ref685a2323.imageMipTailOffset, cimageMipTailOffset_allocs = (C.VkDeviceSize)(x.ImageMipTailOffset), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailOffset_allocs)

	var cimageMipTailStride_allocs *cgoAllocMap
	ref685a2323.imageMipTailStride, cimageMipTailStride_allocs = (C.VkDeviceSize)(x.ImageMipTailStride), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailStride_allocs)

	x.ref685a2323 = ref685a2323
	x.allocs685a2323 = allocs685a2323
	return ref685a2323, allocs685a2323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements) PassValue() (C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x.ref685a2323 != nil {
		return *x.ref685a2323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements) Deref() {
	if x.ref685a2323 == nil {
		return
	}
	x.FormatProperties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref685a2323.formatProperties))
	x.ImageMipTailFirstLod = (uint32)(x.ref685a2323.imageMipTailFirstLod)
	x.ImageMipTailSize = (DeviceSize)(x.ref685a2323.imageMipTailSize)
	x.ImageMipTailOffset = (DeviceSize)(x.ref685a2323.imageMipTailOffset)
	x.ImageMipTailStride = (DeviceSize)(x.ref685a2323.imageMipTailStride)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseMemoryBindRef(ref unsafe.Pointer) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = (*C.VkSparseMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	allocs5bf418e8.Add(mem5bf418e8)

	var cresourceOffset_allocs *cgoAllocMap
	ref5bf418e8.resourceOffset, cresourceOffset_allocs = (C.VkDeviceSize)(x.ResourceOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cresourceOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref5bf418e8.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5bf418e8.Borrow(csize_allocs)

	var cmemory_allocs *cgoAllocMap
	ref5bf418e8.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref5bf418e8.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref5bf418e8.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cflags_allocs)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(h.Data)
	return
}

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseBufferMemoryBindInfoRef(ref unsafe.Pointer) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	allocsebcaf40c.Add(memebcaf40c)

	var cbuffer_allocs *cgoAllocMap
	refebcaf40c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbuffer_allocs)

	var cbindCount_allocs *cgoAllocMap
	refebcaf40c.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageOpaqueMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	allocsfb1b3d56.Add(memfb1b3d56)

	var cimage_allocs *cgoAllocMap
	reffb1b3d56.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	reffb1b3d56.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocImageSubresourceMemory allocates memory for type C.VkImageSubresource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceValue = unsafe.Sizeof([1]C.VkImageSubresource{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresource) Ref() *C.VkImageSubresource {
	if x == nil {
		return nil
	}
	return x.reffeaa0d8a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresource) Free() {
	if x != nil && x.allocsfeaa0d8a != nil {
		x.allocsfeaa0d8a.(*cgoAllocMap).Free()
		x.reffeaa0d8a = nil
	}
}

// NewImageSubresourceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRef(ref unsafe.Pointer) *ImageSubresource {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresource)
	obj.reffeaa0d8a = (*C.VkImageSubresource)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresource) PassRef() (*C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeaa0d8a != nil {
		return x.reffeaa0d8a, nil
	}
	memfeaa0d8a := allocImageSubresourceMemory(1)
	reffeaa0d8a := (*C.VkImageSubresource)(memfeaa0d8a)
	allocsfeaa0d8a := new(cgoAllocMap)
	allocsfeaa0d8a.Add(memfeaa0d8a)

	var caspectMask_allocs *cgoAllocMap
	reffeaa0d8a.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	reffeaa0d8a.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(cmipLevel_allocs)

	var carrayLayer_allocs *cgoAllocMap
	reffeaa0d8a.arrayLayer, carrayLayer_allocs = (C.uint32_t)(x.ArrayLayer), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(carrayLayer_allocs)

	x.reffeaa0d8a = reffeaa0d8a
	x.allocsfeaa0d8a = allocsfeaa0d8a
	return reffeaa0d8a, allocsfeaa0d8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresource) PassValue() (C.VkImageSubresource, *cgoAllocMap) {
	if x.reffeaa0d8a != nil {
		return *x.reffeaa0d8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresource) Deref() {
	if x.reffeaa0d8a == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.reffeaa0d8a.aspectMask)
	x.MipLevel = (uint32)(x.reffeaa0d8a.mipLevel)
	x.ArrayLayer = (uint32)(x.reffeaa0d8a.arrayLayer)
}

// allocOffset3DMemory allocates memory for type C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset3DValue = unsafe.Sizeof([1]C.VkOffset3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset3D) Ref() *C.VkOffset3D {
	if x == nil {
		return nil
	}
	return x.ref2b6879c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset3D) Free() {
	if x != nil && x.allocs2b6879c2 != nil {
		x.allocs2b6879c2.(*cgoAllocMap).Free()
		x.ref2b6879c2 = nil
	}
}

// NewOffset3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset3DRef(ref unsafe.Pointer) *Offset3D {
	if ref == nil {
		return nil
	}
	obj := new(Offset3D)
	obj.ref2b6879c2 = (*C.VkOffset3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset3D) PassRef() (*C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b6879c2 != nil {
		return x.ref2b6879c2, nil
	}
	mem2b6879c2 := allocOffset3DMemory(1)
	ref2b6879c2 := (*C.VkOffset3D)(mem2b6879c2)
	allocs2b6879c2 := new(cgoAllocMap)
	allocs2b6879c2.Add(mem2b6879c2)

	var cx_allocs *cgoAllocMap
	ref2b6879c2.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2b6879c2.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref2b6879c2.z, cz_allocs = (C.int32_t)(x.Z), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cz_allocs)

	x.ref2b6879c2 = ref2b6879c2
	x.allocs2b6879c2 = allocs2b6879c2
	return ref2b6879c2, allocs2b6879c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset3D) PassValue() (C.VkOffset3D, *cgoAllocMap) {
	if x.ref2b6879c2 != nil {
		return *x.ref2b6879c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset3D) Deref() {
	if x.ref2b6879c2 == nil {
		return
	}
	x.X = (int32)(x.ref2b6879c2.x)
	x.Y = (int32)(x.ref2b6879c2.y)
	x.Z = (int32)(x.ref2b6879c2.z)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindRef(ref unsafe.Pointer) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	allocs41b516d7.Add(mem41b516d7)

	var csubresource_allocs *cgoAllocMap
	ref41b516d7.subresource, csubresource_allocs = x.Subresource.PassValue()
	allocs41b516d7.Borrow(csubresource_allocs)

	var coffset_allocs *cgoAllocMap
	ref41b516d7.offset, coffset_allocs = x.Offset.PassValue()
	allocs41b516d7.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref41b516d7.extent, cextent_allocs = x.Extent.PassValue()
	allocs41b516d7.Borrow(cextent_allocs)

	var cmemory_allocs *cgoAllocMap
	ref41b516d7.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref41b516d7.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref41b516d7.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs41b516d7.Borrow(cflags_allocs)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *NewImageSubresourceRef(unsafe.Pointer(&x.ref41b516d7.subresource))
	x.Offset = *NewOffset3DRef(unsafe.Pointer(&x.ref41b516d7.offset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref41b516d7.extent))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(h.Data)
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	allocs50faeb70.Add(mem50faeb70)

	var cimage_allocs *cgoAllocMap
	ref50faeb70.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs50faeb70.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	ref50faeb70.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocs50faeb70.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseBufferMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageOpaqueMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(h.Data)
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindSparseInfoRef(ref unsafe.Pointer) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = (*C.VkBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	allocsb0cbe910.Add(memb0cbe910)

	var csType_allocs *cgoAllocMap
	refb0cbe910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0cbe910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)

	var cbufferBindCount_allocs *cgoAllocMap
	refb0cbe910.bufferBindCount, cbufferBindCount_allocs = (C.uint32_t)(x.BufferBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cbufferBindCount_allocs)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	var cimageOpaqueBindCount_allocs *cgoAllocMap
	refb0cbe910.imageOpaqueBindCount, cimageOpaqueBindCount_allocs = (C.uint32_t)(x.ImageOpaqueBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageOpaqueBindCount_allocs)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	var cimageBindCount_allocs *cgoAllocMap
	refb0cbe910.imageBindCount, cimageBindCount_allocs = (C.uint32_t)(x.ImageBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageBindCount_allocs)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa3f05c.Data = unsafe.Pointer(x.refb0cbe910.pWaitSemaphores)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf0d18b7.Data = unsafe.Pointer(x.refb0cbe910.pSignalSemaphores)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

}

// allocFenceCreateInfoMemory allocates memory for type C.VkFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceCreateInfoValue = unsafe.Sizeof([1]C.VkFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceCreateInfo) Ref() *C.VkFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb8ff4840
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceCreateInfo) Free() {
	if x != nil && x.allocsb8ff4840 != nil {
		x.allocsb8ff4840.(*cgoAllocMap).Free()
		x.refb8ff4840 = nil
	}
}

// NewFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceCreateInfoRef(ref unsafe.Pointer) *FenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceCreateInfo)
	obj.refb8ff4840 = (*C.VkFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceCreateInfo) PassRef() (*C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8ff4840 != nil {
		return x.refb8ff4840, nil
	}
	memb8ff4840 := allocFenceCreateInfoMemory(1)
	refb8ff4840 := (*C.VkFenceCreateInfo)(memb8ff4840)
	allocsb8ff4840 := new(cgoAllocMap)
	allocsb8ff4840.Add(memb8ff4840)

	var csType_allocs *cgoAllocMap
	refb8ff4840.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8ff4840.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8ff4840.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb8ff4840.flags, cflags_allocs = (C.VkFenceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cflags_allocs)

	x.refb8ff4840 = refb8ff4840
	x.allocsb8ff4840 = allocsb8ff4840
	return refb8ff4840, allocsb8ff4840

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceCreateInfo) PassValue() (C.VkFenceCreateInfo, *cgoAllocMap) {
	if x.refb8ff4840 != nil {
		return *x.refb8ff4840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceCreateInfo) Deref() {
	if x.refb8ff4840 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8ff4840.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8ff4840.pNext))
	x.Flags = (FenceCreateFlags)(x.refb8ff4840.flags)
}

// allocSemaphoreCreateInfoMemory allocates memory for type C.VkSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreCreateInfo) Ref() *C.VkSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff130cd2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreCreateInfo) Free() {
	if x != nil && x.allocsf130cd2b != nil {
		x.allocsf130cd2b.(*cgoAllocMap).Free()
		x.reff130cd2b = nil
	}
}

// NewSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreCreateInfoRef(ref unsafe.Pointer) *SemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreCreateInfo)
	obj.reff130cd2b = (*C.VkSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreCreateInfo) PassRef() (*C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff130cd2b != nil {
		return x.reff130cd2b, nil
	}
	memf130cd2b := allocSemaphoreCreateInfoMemory(1)
	reff130cd2b := (*C.VkSemaphoreCreateInfo)(memf130cd2b)
	allocsf130cd2b := new(cgoAllocMap)
	allocsf130cd2b.Add(memf130cd2b)

	var csType_allocs *cgoAllocMap
	reff130cd2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf130cd2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff130cd2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff130cd2b.flags, cflags_allocs = (C.VkSemaphoreCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cflags_allocs)

	x.reff130cd2b = reff130cd2b
	x.allocsf130cd2b = allocsf130cd2b
	return reff130cd2b, allocsf130cd2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreCreateInfo) PassValue() (C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x.reff130cd2b != nil {
		return *x.reff130cd2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreCreateInfo) Deref() {
	if x.reff130cd2b == nil {
		return
	}
	x.SType = (StructureType)(x.reff130cd2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff130cd2b.pNext))
	x.Flags = (SemaphoreCreateFlags)(x.reff130cd2b.flags)
}

// allocEventCreateInfoMemory allocates memory for type C.VkEventCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCreateInfoValue = unsafe.Sizeof([1]C.VkEventCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventCreateInfo) Ref() *C.VkEventCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa54f9ec8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventCreateInfo) Free() {
	if x != nil && x.allocsa54f9ec8 != nil {
		x.allocsa54f9ec8.(*cgoAllocMap).Free()
		x.refa54f9ec8 = nil
	}
}

// NewEventCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventCreateInfoRef(ref unsafe.Pointer) *EventCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(EventCreateInfo)
	obj.refa54f9ec8 = (*C.VkEventCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventCreateInfo) PassRef() (*C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54f9ec8 != nil {
		return x.refa54f9ec8, nil
	}
	mema54f9ec8 := allocEventCreateInfoMemory(1)
	refa54f9ec8 := (*C.VkEventCreateInfo)(mema54f9ec8)
	allocsa54f9ec8 := new(cgoAllocMap)
	allocsa54f9ec8.Add(mema54f9ec8)

	var csType_allocs *cgoAllocMap
	refa54f9ec8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa54f9ec8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa54f9ec8.flags, cflags_allocs = (C.VkEventCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cflags_allocs)

	x.refa54f9ec8 = refa54f9ec8
	x.allocsa54f9ec8 = allocsa54f9ec8
	return refa54f9ec8, allocsa54f9ec8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventCreateInfo) PassValue() (C.VkEventCreateInfo, *cgoAllocMap) {
	if x.refa54f9ec8 != nil {
		return *x.refa54f9ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventCreateInfo) Deref() {
	if x.refa54f9ec8 == nil {
		return
	}
	x.SType = (StructureType)(x.refa54f9ec8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa54f9ec8.pNext))
	x.Flags = (EventCreateFlags)(x.refa54f9ec8.flags)
}

// allocQueryPoolCreateInfoMemory allocates memory for type C.VkQueryPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueryPoolCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolCreateInfo) Ref() *C.VkQueryPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref85dfcd4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolCreateInfo) Free() {
	if x != nil && x.allocs85dfcd4a != nil {
		x.allocs85dfcd4a.(*cgoAllocMap).Free()
		x.ref85dfcd4a = nil
	}
}

// NewQueryPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolCreateInfoRef(ref unsafe.Pointer) *QueryPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolCreateInfo)
	obj.ref85dfcd4a = (*C.VkQueryPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolCreateInfo) PassRef() (*C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85dfcd4a != nil {
		return x.ref85dfcd4a, nil
	}
	mem85dfcd4a := allocQueryPoolCreateInfoMemory(1)
	ref85dfcd4a := (*C.VkQueryPoolCreateInfo)(mem85dfcd4a)
	allocs85dfcd4a := new(cgoAllocMap)
	allocs85dfcd4a.Add(mem85dfcd4a)

	var csType_allocs *cgoAllocMap
	ref85dfcd4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85dfcd4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref85dfcd4a.flags, cflags_allocs = (C.VkQueryPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cflags_allocs)

	var cqueryType_allocs *cgoAllocMap
	ref85dfcd4a.queryType, cqueryType_allocs = (C.VkQueryType)(x.QueryType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryType_allocs)

	var cqueryCount_allocs *cgoAllocMap
	ref85dfcd4a.queryCount, cqueryCount_allocs = (C.uint32_t)(x.QueryCount), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryCount_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref85dfcd4a.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpipelineStatistics_allocs)

	x.ref85dfcd4a = ref85dfcd4a
	x.allocs85dfcd4a = allocs85dfcd4a
	return ref85dfcd4a, allocs85dfcd4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolCreateInfo) PassValue() (C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x.ref85dfcd4a != nil {
		return *x.ref85dfcd4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolCreateInfo) Deref() {
	if x.ref85dfcd4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref85dfcd4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85dfcd4a.pNext))
	x.Flags = (QueryPoolCreateFlags)(x.ref85dfcd4a.flags)
	x.QueryType = (QueryType)(x.ref85dfcd4a.queryType)
	x.QueryCount = (uint32)(x.ref85dfcd4a.queryCount)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref85dfcd4a.pipelineStatistics)
}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCreateInfoRef(ref unsafe.Pointer) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = (*C.VkBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	allocsfe19d2cd.Add(memfe19d2cd)

	var csType_allocs *cgoAllocMap
	reffe19d2cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe19d2cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffe19d2cd.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cflags_allocs)

	var csize_allocs *cgoAllocMap
	reffe19d2cd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csize_allocs)

	var cusage_allocs *cgoAllocMap
	reffe19d2cd.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffe19d2cd.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffe19d2cd.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf2fab0d.Data = unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferViewCreateInfoRef(ref unsafe.Pointer) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = (*C.VkBufferViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	allocs49b97027.Add(mem49b97027)

	var csType_allocs *cgoAllocMap
	ref49b97027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49b97027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49b97027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49b97027.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref49b97027.flags, cflags_allocs = (C.VkBufferViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs49b97027.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref49b97027.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs49b97027.Borrow(cbuffer_allocs)

	var cformat_allocs *cgoAllocMap
	ref49b97027.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs49b97027.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	ref49b97027.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs49b97027.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	ref49b97027._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocs49b97027.Borrow(c_range_allocs)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x._range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCreateInfoRef(ref unsafe.Pointer) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = (*C.VkImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	allocsfb587ba1.Add(memfb587ba1)

	var csType_allocs *cgoAllocMap
	reffb587ba1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffb587ba1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffb587ba1.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cflags_allocs)

	var cimageType_allocs *cgoAllocMap
	reffb587ba1.imageType, cimageType_allocs = (C.VkImageType)(x.ImageType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cimageType_allocs)

	var cformat_allocs *cgoAllocMap
	reffb587ba1.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cformat_allocs)

	var cextent_allocs *cgoAllocMap
	reffb587ba1.extent, cextent_allocs = x.Extent.PassValue()
	allocsfb587ba1.Borrow(cextent_allocs)

	var cmipLevels_allocs *cgoAllocMap
	reffb587ba1.mipLevels, cmipLevels_allocs = (C.uint32_t)(x.MipLevels), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cmipLevels_allocs)

	var carrayLayers_allocs *cgoAllocMap
	reffb587ba1.arrayLayers, carrayLayers_allocs = (C.uint32_t)(x.ArrayLayers), cgoAllocsUnknown
	allocsfb587ba1.Borrow(carrayLayers_allocs)

	var csamples_allocs *cgoAllocMap
	reffb587ba1.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csamples_allocs)

	var ctiling_allocs *cgoAllocMap
	reffb587ba1.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocsfb587ba1.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	reffb587ba1.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffb587ba1.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffb587ba1.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	reffb587ba1.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cinitialLayout_allocs)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.reffb587ba1.extent))
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf69fe70.Data = unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubresourceLayout) Ref() *C.VkSubresourceLayout {
	if x == nil {
		return nil
	}
	return x.ref182612ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubresourceLayout) Free() {
	if x != nil && x.allocs182612ad != nil {
		x.allocs182612ad.(*cgoAllocMap).Free()
		x.ref182612ad = nil
	}
}

// NewSubresourceLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubresourceLayoutRef(ref unsafe.Pointer) *SubresourceLayout {
	if ref == nil {
		return nil
	}
	obj := new(SubresourceLayout)
	obj.ref182612ad = (*C.VkSubresourceLayout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubresourceLayout) PassRef() (*C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182612ad != nil {
		return x.ref182612ad, nil
	}
	mem182612ad := allocSubresourceLayoutMemory(1)
	ref182612ad := (*C.VkSubresourceLayout)(mem182612ad)
	allocs182612ad := new(cgoAllocMap)
	allocs182612ad.Add(mem182612ad)

	var coffset_allocs *cgoAllocMap
	ref182612ad.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs182612ad.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref182612ad.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs182612ad.Borrow(csize_allocs)

	var crowPitch_allocs *cgoAllocMap
	ref182612ad.rowPitch, crowPitch_allocs = (C.VkDeviceSize)(x.RowPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(crowPitch_allocs)

	var carrayPitch_allocs *cgoAllocMap
	ref182612ad.arrayPitch, carrayPitch_allocs = (C.VkDeviceSize)(x.ArrayPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(carrayPitch_allocs)

	var cdepthPitch_allocs *cgoAllocMap
	ref182612ad.depthPitch, cdepthPitch_allocs = (C.VkDeviceSize)(x.DepthPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(cdepthPitch_allocs)

	x.ref182612ad = ref182612ad
	x.allocs182612ad = allocs182612ad
	return ref182612ad, allocs182612ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubresourceLayout) PassValue() (C.VkSubresourceLayout, *cgoAllocMap) {
	if x.ref182612ad != nil {
		return *x.ref182612ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubresourceLayout) Deref() {
	if x.ref182612ad == nil {
		return
	}
	x.Offset = (DeviceSize)(x.ref182612ad.offset)
	x.Size = (DeviceSize)(x.ref182612ad.size)
	x.RowPitch = (DeviceSize)(x.ref182612ad.rowPitch)
	x.ArrayPitch = (DeviceSize)(x.ref182612ad.arrayPitch)
	x.DepthPitch = (DeviceSize)(x.ref182612ad.depthPitch)
}

// allocComponentMappingMemory allocates memory for type C.VkComponentMapping in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComponentMappingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComponentMappingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComponentMappingValue = unsafe.Sizeof([1]C.VkComponentMapping{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComponentMapping) Ref() *C.VkComponentMapping {
	if x == nil {
		return nil
	}
	return x.ref63d3d563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComponentMapping) Free() {
	if x != nil && x.allocs63d3d563 != nil {
		x.allocs63d3d563.(*cgoAllocMap).Free()
		x.ref63d3d563 = nil
	}
}

// NewComponentMappingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComponentMappingRef(ref unsafe.Pointer) *ComponentMapping {
	if ref == nil {
		return nil
	}
	obj := new(ComponentMapping)
	obj.ref63d3d563 = (*C.VkComponentMapping)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComponentMapping) PassRef() (*C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref63d3d563 != nil {
		return x.ref63d3d563, nil
	}
	mem63d3d563 := allocComponentMappingMemory(1)
	ref63d3d563 := (*C.VkComponentMapping)(mem63d3d563)
	allocs63d3d563 := new(cgoAllocMap)
	allocs63d3d563.Add(mem63d3d563)

	var cr_allocs *cgoAllocMap
	ref63d3d563.r, cr_allocs = (C.VkComponentSwizzle)(x.R), cgoAllocsUnknown
	allocs63d3d563.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref63d3d563.g, cg_allocs = (C.VkComponentSwizzle)(x.G), cgoAllocsUnknown
	allocs63d3d563.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref63d3d563.b, cb_allocs = (C.VkComponentSwizzle)(x.B), cgoAllocsUnknown
	allocs63d3d563.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref63d3d563.a, ca_allocs = (C.VkComponentSwizzle)(x.A), cgoAllocsUnknown
	allocs63d3d563.Borrow(ca_allocs)

	x.ref63d3d563 = ref63d3d563
	x.allocs63d3d563 = allocs63d3d563
	return ref63d3d563, allocs63d3d563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComponentMapping) PassValue() (C.VkComponentMapping, *cgoAllocMap) {
	if x.ref63d3d563 != nil {
		return *x.ref63d3d563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComponentMapping) Deref() {
	if x.ref63d3d563 == nil {
		return
	}
	x.R = (ComponentSwizzle)(x.ref63d3d563.r)
	x.G = (ComponentSwizzle)(x.ref63d3d563.g)
	x.B = (ComponentSwizzle)(x.ref63d3d563.b)
	x.A = (ComponentSwizzle)(x.ref63d3d563.a)
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceRange) Ref() *C.VkImageSubresourceRange {
	if x == nil {
		return nil
	}
	return x.ref5aa1126
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceRange) Free() {
	if x != nil && x.allocs5aa1126 != nil {
		x.allocs5aa1126.(*cgoAllocMap).Free()
		x.ref5aa1126 = nil
	}
}

// NewImageSubresourceRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRangeRef(ref unsafe.Pointer) *ImageSubresourceRange {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceRange)
	obj.ref5aa1126 = (*C.VkImageSubresourceRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceRange) PassRef() (*C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5aa1126 != nil {
		return x.ref5aa1126, nil
	}
	mem5aa1126 := allocImageSubresourceRangeMemory(1)
	ref5aa1126 := (*C.VkImageSubresourceRange)(mem5aa1126)
	allocs5aa1126 := new(cgoAllocMap)
	allocs5aa1126.Add(mem5aa1126)

	var caspectMask_allocs *cgoAllocMap
	ref5aa1126.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs5aa1126.Borrow(caspectMask_allocs)

	var cbaseMipLevel_allocs *cgoAllocMap
	ref5aa1126.baseMipLevel, cbaseMipLevel_allocs = (C.uint32_t)(x.BaseMipLevel), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseMipLevel_allocs)

	var clevelCount_allocs *cgoAllocMap
	ref5aa1126.levelCount, clevelCount_allocs = (C.uint32_t)(x.LevelCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clevelCount_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref5aa1126.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref5aa1126.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clayerCount_allocs)

	x.ref5aa1126 = ref5aa1126
	x.allocs5aa1126 = allocs5aa1126
	return ref5aa1126, allocs5aa1126

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceRange) PassValue() (C.VkImageSubresourceRange, *cgoAllocMap) {
	if x.ref5aa1126 != nil {
		return *x.ref5aa1126, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceRange) Deref() {
	if x.ref5aa1126 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref5aa1126.aspectMask)
	x.BaseMipLevel = (uint32)(x.ref5aa1126.baseMipLevel)
	x.LevelCount = (uint32)(x.ref5aa1126.levelCount)
	x.BaseArrayLayer = (uint32)(x.ref5aa1126.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref5aa1126.layerCount)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewCreateInfoRef(ref unsafe.Pointer) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = (*C.VkImageViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	allocs77e8d4b8.Add(mem77e8d4b8)

	var csType_allocs *cgoAllocMap
	ref77e8d4b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77e8d4b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77e8d4b8.flags, cflags_allocs = (C.VkImageViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cflags_allocs)

	var cimage_allocs *cgoAllocMap
	ref77e8d4b8.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cimage_allocs)

	var cviewType_allocs *cgoAllocMap
	ref77e8d4b8.viewType, cviewType_allocs = (C.VkImageViewType)(x.ViewType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cviewType_allocs)

	var cformat_allocs *cgoAllocMap
	ref77e8d4b8.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cformat_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref77e8d4b8.components, ccomponents_allocs = x.Components.PassValue()
	allocs77e8d4b8.Borrow(ccomponents_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref77e8d4b8.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs77e8d4b8.Borrow(csubresourceRange_allocs)

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref77e8d4b8.components))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.ref77e8d4b8.subresourceRange))
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleCreateInfoRef(ref unsafe.Pointer) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = (*C.VkShaderModuleCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	allocsc663d23e.Add(memc663d23e)

	var csType_allocs *cgoAllocMap
	refc663d23e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc663d23e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc663d23e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc663d23e.flags, cflags_allocs = (C.VkShaderModuleCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc663d23e.Borrow(cflags_allocs)

	var ccodeSize_allocs *cgoAllocMap
	refc663d23e.codeSize, ccodeSize_allocs = (C.size_t)(x.CodeSize), cgoAllocsUnknown
	allocsc663d23e.Borrow(ccodeSize_allocs)

	var cpCode_allocs *cgoAllocMap
	refc663d23e.pCode, cpCode_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCode)).Data)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpCode_allocs)

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint)(x.refc663d23e.codeSize)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxf65bf54.Data = unsafe.Pointer(x.refc663d23e.pCode)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

}

// allocPipelineCacheCreateInfoMemory allocates memory for type C.VkPipelineCacheCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCacheCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCacheCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCacheCreateInfo) Ref() *C.VkPipelineCacheCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff11e7dd1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCacheCreateInfo) Free() {
	if x != nil && x.allocsf11e7dd1 != nil {
		x.allocsf11e7dd1.(*cgoAllocMap).Free()
		x.reff11e7dd1 = nil
	}
}

// NewPipelineCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCacheCreateInfoRef(ref unsafe.Pointer) *PipelineCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCacheCreateInfo)
	obj.reff11e7dd1 = (*C.VkPipelineCacheCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCacheCreateInfo) PassRef() (*C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff11e7dd1 != nil {
		return x.reff11e7dd1, nil
	}
	memf11e7dd1 := allocPipelineCacheCreateInfoMemory(1)
	reff11e7dd1 := (*C.VkPipelineCacheCreateInfo)(memf11e7dd1)
	allocsf11e7dd1 := new(cgoAllocMap)
	allocsf11e7dd1.Add(memf11e7dd1)

	var csType_allocs *cgoAllocMap
	reff11e7dd1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff11e7dd1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff11e7dd1.flags, cflags_allocs = (C.VkPipelineCacheCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	reff11e7dd1.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	reff11e7dd1.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpInitialData_allocs)

	x.reff11e7dd1 = reff11e7dd1
	x.allocsf11e7dd1 = allocsf11e7dd1
	return reff11e7dd1, allocsf11e7dd1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCacheCreateInfo) PassValue() (C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x.reff11e7dd1 != nil {
		return *x.reff11e7dd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCacheCreateInfo) Deref() {
	if x.reff11e7dd1 == nil {
		return
	}
	x.SType = (StructureType)(x.reff11e7dd1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pNext))
	x.Flags = (PipelineCacheCreateFlags)(x.reff11e7dd1.flags)
	x.InitialDataSize = (uint)(x.reff11e7dd1.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pInitialData))
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationMapEntry) Ref() *C.VkSpecializationMapEntry {
	if x == nil {
		return nil
	}
	return x.ref2fd815d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationMapEntry) Free() {
	if x != nil && x.allocs2fd815d1 != nil {
		x.allocs2fd815d1.(*cgoAllocMap).Free()
		x.ref2fd815d1 = nil
	}
}

// NewSpecializationMapEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationMapEntryRef(ref unsafe.Pointer) *SpecializationMapEntry {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationMapEntry)
	obj.ref2fd815d1 = (*C.VkSpecializationMapEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationMapEntry) PassRef() (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fd815d1 != nil {
		return x.ref2fd815d1, nil
	}
	mem2fd815d1 := allocSpecializationMapEntryMemory(1)
	ref2fd815d1 := (*C.VkSpecializationMapEntry)(mem2fd815d1)
	allocs2fd815d1 := new(cgoAllocMap)
	allocs2fd815d1.Add(mem2fd815d1)

	var cconstantID_allocs *cgoAllocMap
	ref2fd815d1.constantID, cconstantID_allocs = (C.uint32_t)(x.ConstantID), cgoAllocsUnknown
	allocs2fd815d1.Borrow(cconstantID_allocs)

	var coffset_allocs *cgoAllocMap
	ref2fd815d1.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs2fd815d1.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref2fd815d1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs2fd815d1.Borrow(csize_allocs)

	x.ref2fd815d1 = ref2fd815d1
	x.allocs2fd815d1 = allocs2fd815d1
	return ref2fd815d1, allocs2fd815d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationMapEntry) PassValue() (C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x.ref2fd815d1 != nil {
		return *x.ref2fd815d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationMapEntry) Deref() {
	if x.ref2fd815d1 == nil {
		return
	}
	x.ConstantID = (uint32)(x.ref2fd815d1.constantID)
	x.Offset = (uint32)(x.ref2fd815d1.offset)
	x.Size = (uint)(x.ref2fd815d1.size)
}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// unpackSSpecializationMapEntry transforms a sliced Go data structure into plain C format.
func unpackSSpecializationMapEntry(x []SpecializationMapEntry) (unpacked *C.VkSpecializationMapEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationMapEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationMapEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationMapEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationMapEntry)(h.Data)
	return
}

// packSSpecializationMapEntry reads sliced Go data structure out from plain C format.
func packSSpecializationMapEntry(v []SpecializationMapEntry, ptr0 *C.VkSpecializationMapEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationMapEntryValue]C.VkSpecializationMapEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationMapEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationInfoRef(ref unsafe.Pointer) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = (*C.VkSpecializationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	allocs6bc395a3.Add(mem6bc395a3)

	var cmapEntryCount_allocs *cgoAllocMap
	ref6bc395a3.mapEntryCount, cmapEntryCount_allocs = (C.uint32_t)(x.MapEntryCount), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cmapEntryCount_allocs)

	var cpMapEntries_allocs *cgoAllocMap
	ref6bc395a3.pMapEntries, cpMapEntries_allocs = unpackSSpecializationMapEntry(x.PMapEntries)
	allocs6bc395a3.Borrow(cpMapEntries_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref6bc395a3.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref6bc395a3.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cpData_allocs)

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	packSSpecializationMapEntry(x.PMapEntries, x.ref6bc395a3.pMapEntries)
	x.DataSize = (uint)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(h.Data)
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineShaderStageCreateInfoRef(ref unsafe.Pointer) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	allocs50ba8b60.Add(mem50ba8b60)

	var csType_allocs *cgoAllocMap
	ref50ba8b60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs50ba8b60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref50ba8b60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref50ba8b60.flags, cflags_allocs = (C.VkPipelineShaderStageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref50ba8b60.stage, cstage_allocs = (C.VkShaderStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cstage_allocs)

	var cmodule_allocs *cgoAllocMap
	ref50ba8b60.module, cmodule_allocs = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cmodule_allocs)

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = unpackPCharString(x.PName)
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	x.PName = packPCharString(x.ref50ba8b60.pName)
	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDescription) Ref() *C.VkVertexInputBindingDescription {
	if x == nil {
		return nil
	}
	return x.ref5c9d8c23
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDescription) Free() {
	if x != nil && x.allocs5c9d8c23 != nil {
		x.allocs5c9d8c23.(*cgoAllocMap).Free()
		x.ref5c9d8c23 = nil
	}
}

// NewVertexInputBindingDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDescriptionRef(ref unsafe.Pointer) *VertexInputBindingDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDescription)
	obj.ref5c9d8c23 = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDescription) PassRef() (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c9d8c23 != nil {
		return x.ref5c9d8c23, nil
	}
	mem5c9d8c23 := allocVertexInputBindingDescriptionMemory(1)
	ref5c9d8c23 := (*C.VkVertexInputBindingDescription)(mem5c9d8c23)
	allocs5c9d8c23 := new(cgoAllocMap)
	allocs5c9d8c23.Add(mem5c9d8c23)

	var cbinding_allocs *cgoAllocMap
	ref5c9d8c23.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	ref5c9d8c23.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	ref5c9d8c23.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cinputRate_allocs)

	x.ref5c9d8c23 = ref5c9d8c23
	x.allocs5c9d8c23 = allocs5c9d8c23
	return ref5c9d8c23, allocs5c9d8c23

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDescription) PassValue() (C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x.ref5c9d8c23 != nil {
		return *x.ref5c9d8c23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDescription) Deref() {
	if x.ref5c9d8c23 == nil {
		return
	}
	x.Binding = (uint32)(x.ref5c9d8c23.binding)
	x.Stride = (uint32)(x.ref5c9d8c23.stride)
	x.InputRate = (VertexInputRate)(x.ref5c9d8c23.inputRate)
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputAttributeDescription) Ref() *C.VkVertexInputAttributeDescription {
	if x == nil {
		return nil
	}
	return x.refdc4635ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputAttributeDescription) Free() {
	if x != nil && x.allocsdc4635ff != nil {
		x.allocsdc4635ff.(*cgoAllocMap).Free()
		x.refdc4635ff = nil
	}
}

// NewVertexInputAttributeDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputAttributeDescriptionRef(ref unsafe.Pointer) *VertexInputAttributeDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputAttributeDescription)
	obj.refdc4635ff = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputAttributeDescription) PassRef() (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc4635ff != nil {
		return x.refdc4635ff, nil
	}
	memdc4635ff := allocVertexInputAttributeDescriptionMemory(1)
	refdc4635ff := (*C.VkVertexInputAttributeDescription)(memdc4635ff)
	allocsdc4635ff := new(cgoAllocMap)
	allocsdc4635ff.Add(memdc4635ff)

	var clocation_allocs *cgoAllocMap
	refdc4635ff.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsdc4635ff.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refdc4635ff.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refdc4635ff.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refdc4635ff.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsdc4635ff.Borrow(coffset_allocs)

	x.refdc4635ff = refdc4635ff
	x.allocsdc4635ff = allocsdc4635ff
	return refdc4635ff, allocsdc4635ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputAttributeDescription) PassValue() (C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x.refdc4635ff != nil {
		return *x.refdc4635ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputAttributeDescription) Deref() {
	if x.refdc4635ff == nil {
		return
	}
	x.Location = (uint32)(x.refdc4635ff.location)
	x.Binding = (uint32)(x.refdc4635ff.binding)
	x.Format = (Format)(x.refdc4635ff.format)
	x.Offset = (uint32)(x.refdc4635ff.offset)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// unpackSVertexInputBindingDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDescription(x []VertexInputBindingDescription) (unpacked *C.VkVertexInputBindingDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDescription)(h.Data)
	return
}

// unpackSVertexInputAttributeDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputAttributeDescription(x []VertexInputAttributeDescription) (unpacked *C.VkVertexInputAttributeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputAttributeDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputAttributeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputAttributeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputAttributeDescription)(h.Data)
	return
}

// packSVertexInputBindingDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDescription(v []VertexInputBindingDescription, ptr0 *C.VkVertexInputBindingDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDescriptionValue]C.VkVertexInputBindingDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSVertexInputAttributeDescription reads sliced Go data structure out from plain C format.
func packSVertexInputAttributeDescription(v []VertexInputAttributeDescription, ptr0 *C.VkVertexInputAttributeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputAttributeDescriptionValue]C.VkVertexInputAttributeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputAttributeDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	allocs5fe4aa50.Add(mem5fe4aa50)

	var csType_allocs *cgoAllocMap
	ref5fe4aa50.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fe4aa50.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5fe4aa50.flags, cflags_allocs = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cflags_allocs)

	var cvertexBindingDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexBindingDescriptionCount, cvertexBindingDescriptionCount_allocs = (C.uint32_t)(x.VertexBindingDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexBindingDescriptionCount_allocs)

	var cpVertexBindingDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = unpackSVertexInputBindingDescription(x.PVertexBindingDescriptions)
	allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)

	var cvertexAttributeDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexAttributeDescriptionCount, cvertexAttributeDescriptionCount_allocs = (C.uint32_t)(x.VertexAttributeDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexAttributeDescriptionCount_allocs)

	var cpVertexAttributeDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = unpackSVertexInputAttributeDescription(x.PVertexAttributeDescriptions)
	allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	packSVertexInputBindingDescription(x.PVertexBindingDescriptions, x.ref5fe4aa50.pVertexBindingDescriptions)
	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	packSVertexInputAttributeDescription(x.PVertexAttributeDescriptions, x.ref5fe4aa50.pVertexAttributeDescriptions)
}

// allocPipelineInputAssemblyStateCreateInfoMemory allocates memory for type C.VkPipelineInputAssemblyStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInputAssemblyStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInputAssemblyStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineInputAssemblyStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineInputAssemblyStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineInputAssemblyStateCreateInfo) Ref() *C.VkPipelineInputAssemblyStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref22e1691d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	if x != nil && x.allocs22e1691d != nil {
		x.allocs22e1691d.(*cgoAllocMap).Free()
		x.ref22e1691d = nil
	}
}

// NewPipelineInputAssemblyStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineInputAssemblyStateCreateInfoRef(ref unsafe.Pointer) *PipelineInputAssemblyStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInputAssemblyStateCreateInfo)
	obj.ref22e1691d = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) PassRef() (*C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22e1691d != nil {
		return x.ref22e1691d, nil
	}
	mem22e1691d := allocPipelineInputAssemblyStateCreateInfoMemory(1)
	ref22e1691d := (*C.VkPipelineInputAssemblyStateCreateInfo)(mem22e1691d)
	allocs22e1691d := new(cgoAllocMap)
	allocs22e1691d.Add(mem22e1691d)

	var csType_allocs *cgoAllocMap
	ref22e1691d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22e1691d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22e1691d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22e1691d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref22e1691d.flags, cflags_allocs = (C.VkPipelineInputAssemblyStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs22e1691d.Borrow(cflags_allocs)

	var ctopology_allocs *cgoAllocMap
	ref22e1691d.topology, ctopology_allocs = (C.VkPrimitiveTopology)(x.Topology), cgoAllocsUnknown
	allocs22e1691d.Borrow(ctopology_allocs)

	var cprimitiveRestartEnable_allocs *cgoAllocMap
	ref22e1691d.primitiveRestartEnable, cprimitiveRestartEnable_allocs = (C.VkBool32)(x.PrimitiveRestartEnable), cgoAllocsUnknown
	allocs22e1691d.Borrow(cprimitiveRestartEnable_allocs)

	x.ref22e1691d = ref22e1691d
	x.allocs22e1691d = allocs22e1691d
	return ref22e1691d, allocs22e1691d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) PassValue() (C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x.ref22e1691d != nil {
		return *x.ref22e1691d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineInputAssemblyStateCreateInfo) Deref() {
	if x.ref22e1691d == nil {
		return
	}
	x.SType = (StructureType)(x.ref22e1691d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22e1691d.pNext))
	x.Flags = (PipelineInputAssemblyStateCreateFlags)(x.ref22e1691d.flags)
	x.Topology = (PrimitiveTopology)(x.ref22e1691d.topology)
	x.PrimitiveRestartEnable = (Bool32)(x.ref22e1691d.primitiveRestartEnable)
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationStateCreateInfo) Ref() *C.VkPipelineTessellationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4ef3997a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationStateCreateInfo) Free() {
	if x != nil && x.allocs4ef3997a != nil {
		x.allocs4ef3997a.(*cgoAllocMap).Free()
		x.ref4ef3997a = nil
	}
}

// NewPipelineTessellationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationStateCreateInfo)
	obj.ref4ef3997a = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationStateCreateInfo) PassRef() (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ef3997a != nil {
		return x.ref4ef3997a, nil
	}
	mem4ef3997a := allocPipelineTessellationStateCreateInfoMemory(1)
	ref4ef3997a := (*C.VkPipelineTessellationStateCreateInfo)(mem4ef3997a)
	allocs4ef3997a := new(cgoAllocMap)
	allocs4ef3997a.Add(mem4ef3997a)

	var csType_allocs *cgoAllocMap
	ref4ef3997a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4ef3997a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4ef3997a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4ef3997a.flags, cflags_allocs = (C.VkPipelineTessellationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cflags_allocs)

	var cpatchControlPoints_allocs *cgoAllocMap
	ref4ef3997a.patchControlPoints, cpatchControlPoints_allocs = (C.uint32_t)(x.PatchControlPoints), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpatchControlPoints_allocs)

	x.ref4ef3997a = ref4ef3997a
	x.allocs4ef3997a = allocs4ef3997a
	return ref4ef3997a, allocs4ef3997a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationStateCreateInfo) PassValue() (C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x.ref4ef3997a != nil {
		return *x.ref4ef3997a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationStateCreateInfo) Deref() {
	if x.ref4ef3997a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4ef3997a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4ef3997a.pNext))
	x.Flags = (PipelineTessellationStateCreateFlags)(x.ref4ef3997a.flags)
	x.PatchControlPoints = (uint32)(x.ref4ef3997a.patchControlPoints)
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Viewport) Ref() *C.VkViewport {
	if x == nil {
		return nil
	}
	return x.ref75cf5291
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Viewport) Free() {
	if x != nil && x.allocs75cf5291 != nil {
		x.allocs75cf5291.(*cgoAllocMap).Free()
		x.ref75cf5291 = nil
	}
}

// NewViewportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportRef(ref unsafe.Pointer) *Viewport {
	if ref == nil {
		return nil
	}
	obj := new(Viewport)
	obj.ref75cf5291 = (*C.VkViewport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Viewport) PassRef() (*C.VkViewport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75cf5291 != nil {
		return x.ref75cf5291, nil
	}
	mem75cf5291 := allocViewportMemory(1)
	ref75cf5291 := (*C.VkViewport)(mem75cf5291)
	allocs75cf5291 := new(cgoAllocMap)
	allocs75cf5291.Add(mem75cf5291)

	var cx_allocs *cgoAllocMap
	ref75cf5291.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs75cf5291.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref75cf5291.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs75cf5291.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref75cf5291.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs75cf5291.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref75cf5291.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs75cf5291.Borrow(cheight_allocs)

	var cminDepth_allocs *cgoAllocMap
	ref75cf5291.minDepth, cminDepth_allocs = (C.float)(x.MinDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cminDepth_allocs)

	var cmaxDepth_allocs *cgoAllocMap
	ref75cf5291.maxDepth, cmaxDepth_allocs = (C.float)(x.MaxDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cmaxDepth_allocs)

	x.ref75cf5291 = ref75cf5291
	x.allocs75cf5291 = allocs75cf5291
	return ref75cf5291, allocs75cf5291

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Viewport) PassValue() (C.VkViewport, *cgoAllocMap) {
	if x.ref75cf5291 != nil {
		return *x.ref75cf5291, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Viewport) Deref() {
	if x.ref75cf5291 == nil {
		return
	}
	x.X = (float32)(x.ref75cf5291.x)
	x.Y = (float32)(x.ref75cf5291.y)
	x.Width = (float32)(x.ref75cf5291.width)
	x.Height = (float32)(x.ref75cf5291.height)
	x.MinDepth = (float32)(x.ref75cf5291.minDepth)
	x.MaxDepth = (float32)(x.ref75cf5291.maxDepth)
}

// allocOffset2DMemory allocates memory for type C.VkOffset2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset2DValue = unsafe.Sizeof([1]C.VkOffset2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset2D) Ref() *C.VkOffset2D {
	if x == nil {
		return nil
	}
	return x.ref32734883
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset2D) Free() {
	if x != nil && x.allocs32734883 != nil {
		x.allocs32734883.(*cgoAllocMap).Free()
		x.ref32734883 = nil
	}
}

// NewOffset2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset2DRef(ref unsafe.Pointer) *Offset2D {
	if ref == nil {
		return nil
	}
	obj := new(Offset2D)
	obj.ref32734883 = (*C.VkOffset2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset2D) PassRef() (*C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32734883 != nil {
		return x.ref32734883, nil
	}
	mem32734883 := allocOffset2DMemory(1)
	ref32734883 := (*C.VkOffset2D)(mem32734883)
	allocs32734883 := new(cgoAllocMap)
	allocs32734883.Add(mem32734883)

	var cx_allocs *cgoAllocMap
	ref32734883.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs32734883.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref32734883.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs32734883.Borrow(cy_allocs)

	x.ref32734883 = ref32734883
	x.allocs32734883 = allocs32734883
	return ref32734883, allocs32734883

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset2D) PassValue() (C.VkOffset2D, *cgoAllocMap) {
	if x.ref32734883 != nil {
		return *x.ref32734883, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset2D) Deref() {
	if x.ref32734883 == nil {
		return
	}
	x.X = (int32)(x.ref32734883.x)
	x.Y = (int32)(x.ref32734883.y)
}

// allocExtent2DMemory allocates memory for type C.VkExtent2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent2DValue = unsafe.Sizeof([1]C.VkExtent2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent2D) Ref() *C.VkExtent2D {
	if x == nil {
		return nil
	}
	return x.refe2edf56b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent2D) Free() {
	if x != nil && x.allocse2edf56b != nil {
		x.allocse2edf56b.(*cgoAllocMap).Free()
		x.refe2edf56b = nil
	}
}

// NewExtent2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent2DRef(ref unsafe.Pointer) *Extent2D {
	if ref == nil {
		return nil
	}
	obj := new(Extent2D)
	obj.refe2edf56b = (*C.VkExtent2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent2D) PassRef() (*C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2edf56b != nil {
		return x.refe2edf56b, nil
	}
	meme2edf56b := allocExtent2DMemory(1)
	refe2edf56b := (*C.VkExtent2D)(meme2edf56b)
	allocse2edf56b := new(cgoAllocMap)
	allocse2edf56b.Add(meme2edf56b)

	var cwidth_allocs *cgoAllocMap
	refe2edf56b.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse2edf56b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2edf56b.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse2edf56b.Borrow(cheight_allocs)

	x.refe2edf56b = refe2edf56b
	x.allocse2edf56b = allocse2edf56b
	return refe2edf56b, allocse2edf56b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent2D) PassValue() (C.VkExtent2D, *cgoAllocMap) {
	if x.refe2edf56b != nil {
		return *x.refe2edf56b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent2D) Deref() {
	if x.refe2edf56b == nil {
		return
	}
	x.Width = (uint32)(x.refe2edf56b.width)
	x.Height = (uint32)(x.refe2edf56b.height)
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect2D) Ref() *C.VkRect2D {
	if x == nil {
		return nil
	}
	return x.ref89e4256f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect2D) Free() {
	if x != nil && x.allocs89e4256f != nil {
		x.allocs89e4256f.(*cgoAllocMap).Free()
		x.ref89e4256f = nil
	}
}

// NewRect2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRect2DRef(ref unsafe.Pointer) *Rect2D {
	if ref == nil {
		return nil
	}
	obj := new(Rect2D)
	obj.ref89e4256f = (*C.VkRect2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect2D) PassRef() (*C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e4256f != nil {
		return x.ref89e4256f, nil
	}
	mem89e4256f := allocRect2DMemory(1)
	ref89e4256f := (*C.VkRect2D)(mem89e4256f)
	allocs89e4256f := new(cgoAllocMap)
	allocs89e4256f.Add(mem89e4256f)

	var coffset_allocs *cgoAllocMap
	ref89e4256f.offset, coffset_allocs = x.Offset.PassValue()
	allocs89e4256f.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref89e4256f.extent, cextent_allocs = x.Extent.PassValue()
	allocs89e4256f.Borrow(cextent_allocs)

	x.ref89e4256f = ref89e4256f
	x.allocs89e4256f = allocs89e4256f
	return ref89e4256f, allocs89e4256f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect2D) PassValue() (C.VkRect2D, *cgoAllocMap) {
	if x.ref89e4256f != nil {
		return *x.ref89e4256f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect2D) Deref() {
	if x.ref89e4256f == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.ref89e4256f.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.ref89e4256f.extent))
}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// unpackSViewport transforms a sliced Go data structure into plain C format.
func unpackSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackSRect2D transforms a sliced Go data structure into plain C format.
func unpackSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// packSViewport reads sliced Go data structure out from plain C format.
func packSViewport(v []Viewport, ptr0 *C.VkViewport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportValue]C.VkViewport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportRef(unsafe.Pointer(&ptr1))
	}
}

// packSRect2D reads sliced Go data structure out from plain C format.
func packSRect2D(v []Rect2D, ptr0 *C.VkRect2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRect2DValue]C.VkRect2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRect2DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportStateCreateInfoRef(ref unsafe.Pointer) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	allocsc4705791.Add(memc4705791)

	var csType_allocs *cgoAllocMap
	refc4705791.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4705791.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4705791.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4705791.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc4705791.flags, cflags_allocs = (C.VkPipelineViewportStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc4705791.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	refc4705791.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cviewportCount_allocs)

	var cpViewports_allocs *cgoAllocMap
	refc4705791.pViewports, cpViewports_allocs = unpackSViewport(x.PViewports)
	allocsc4705791.Borrow(cpViewports_allocs)

	var cscissorCount_allocs *cgoAllocMap
	refc4705791.scissorCount, cscissorCount_allocs = (C.uint32_t)(x.ScissorCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cscissorCount_allocs)

	var cpScissors_allocs *cgoAllocMap
	refc4705791.pScissors, cpScissors_allocs = unpackSRect2D(x.PScissors)
	allocsc4705791.Borrow(cpScissors_allocs)

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	packSViewport(x.PViewports, x.refc4705791.pViewports)
	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	packSRect2D(x.PScissors, x.refc4705791.pScissors)
}

// allocPipelineRasterizationStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateCreateInfo) Ref() *C.VkPipelineRasterizationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref48cb9fad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	if x != nil && x.allocs48cb9fad != nil {
		x.allocs48cb9fad.(*cgoAllocMap).Free()
		x.ref48cb9fad = nil
	}
}

// NewPipelineRasterizationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateCreateInfo)
	obj.ref48cb9fad = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateCreateInfo) PassRef() (*C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48cb9fad != nil {
		return x.ref48cb9fad, nil
	}
	mem48cb9fad := allocPipelineRasterizationStateCreateInfoMemory(1)
	ref48cb9fad := (*C.VkPipelineRasterizationStateCreateInfo)(mem48cb9fad)
	allocs48cb9fad := new(cgoAllocMap)
	allocs48cb9fad.Add(mem48cb9fad)

	var csType_allocs *cgoAllocMap
	ref48cb9fad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48cb9fad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48cb9fad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48cb9fad.flags, cflags_allocs = (C.VkPipelineRasterizationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cflags_allocs)

	var cdepthClampEnable_allocs *cgoAllocMap
	ref48cb9fad.depthClampEnable, cdepthClampEnable_allocs = (C.VkBool32)(x.DepthClampEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthClampEnable_allocs)

	var crasterizerDiscardEnable_allocs *cgoAllocMap
	ref48cb9fad.rasterizerDiscardEnable, crasterizerDiscardEnable_allocs = (C.VkBool32)(x.RasterizerDiscardEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(crasterizerDiscardEnable_allocs)

	var cpolygonMode_allocs *cgoAllocMap
	ref48cb9fad.polygonMode, cpolygonMode_allocs = (C.VkPolygonMode)(x.PolygonMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpolygonMode_allocs)

	var ccullMode_allocs *cgoAllocMap
	ref48cb9fad.cullMode, ccullMode_allocs = (C.VkCullModeFlags)(x.CullMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(ccullMode_allocs)

	var cfrontFace_allocs *cgoAllocMap
	ref48cb9fad.frontFace, cfrontFace_allocs = (C.VkFrontFace)(x.FrontFace), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cfrontFace_allocs)

	var cdepthBiasEnable_allocs *cgoAllocMap
	ref48cb9fad.depthBiasEnable, cdepthBiasEnable_allocs = (C.VkBool32)(x.DepthBiasEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasEnable_allocs)

	var cdepthBiasConstantFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasConstantFactor, cdepthBiasConstantFactor_allocs = (C.float)(x.DepthBiasConstantFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasConstantFactor_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	ref48cb9fad.depthBiasClamp, cdepthBiasClamp_allocs = (C.float)(x.DepthBiasClamp), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasClamp_allocs)

	var cdepthBiasSlopeFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasSlopeFactor, cdepthBiasSlopeFactor_allocs = (C.float)(x.DepthBiasSlopeFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasSlopeFactor_allocs)

	var clineWidth_allocs *cgoAllocMap
	ref48cb9fad.lineWidth, clineWidth_allocs = (C.float)(x.LineWidth), cgoAllocsUnknown
	allocs48cb9fad.Borrow(clineWidth_allocs)

	x.ref48cb9fad = ref48cb9fad
	x.allocs48cb9fad = allocs48cb9fad
	return ref48cb9fad, allocs48cb9fad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateCreateInfo) PassValue() (C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x.ref48cb9fad != nil {
		return *x.ref48cb9fad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateCreateInfo) Deref() {
	if x.ref48cb9fad == nil {
		return
	}
	x.SType = (StructureType)(x.ref48cb9fad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48cb9fad.pNext))
	x.Flags = (PipelineRasterizationStateCreateFlags)(x.ref48cb9fad.flags)
	x.DepthClampEnable = (Bool32)(x.ref48cb9fad.depthClampEnable)
	x.RasterizerDiscardEnable = (Bool32)(x.ref48cb9fad.rasterizerDiscardEnable)
	x.PolygonMode = (PolygonMode)(x.ref48cb9fad.polygonMode)
	x.CullMode = (CullModeFlags)(x.ref48cb9fad.cullMode)
	x.FrontFace = (FrontFace)(x.ref48cb9fad.frontFace)
	x.DepthBiasEnable = (Bool32)(x.ref48cb9fad.depthBiasEnable)
	x.DepthBiasConstantFactor = (float32)(x.ref48cb9fad.depthBiasConstantFactor)
	x.DepthBiasClamp = (float32)(x.ref48cb9fad.depthBiasClamp)
	x.DepthBiasSlopeFactor = (float32)(x.ref48cb9fad.depthBiasSlopeFactor)
	x.LineWidth = (float32)(x.ref48cb9fad.lineWidth)
}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineMultisampleStateCreateInfoRef(ref unsafe.Pointer) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	allocsb6538bfb.Add(memb6538bfb)

	var csType_allocs *cgoAllocMap
	refb6538bfb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb6538bfb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb6538bfb.flags, cflags_allocs = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cflags_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	refb6538bfb.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocsb6538bfb.Borrow(crasterizationSamples_allocs)

	var csampleShadingEnable_allocs *cgoAllocMap
	refb6538bfb.sampleShadingEnable, csampleShadingEnable_allocs = (C.VkBool32)(x.SampleShadingEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csampleShadingEnable_allocs)

	var cminSampleShading_allocs *cgoAllocMap
	refb6538bfb.minSampleShading, cminSampleShading_allocs = (C.float)(x.MinSampleShading), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cminSampleShading_allocs)

	var cpSampleMask_allocs *cgoAllocMap
	refb6538bfb.pSampleMask, cpSampleMask_allocs = (*C.VkSampleMask)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)).Data)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpSampleMask_allocs)

	var calphaToCoverageEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToCoverageEnable, calphaToCoverageEnable_allocs = (C.VkBool32)(x.AlphaToCoverageEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToCoverageEnable_allocs)

	var calphaToOneEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToOneEnable, calphaToOneEnable_allocs = (C.VkBool32)(x.AlphaToOneEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToOneEnable_allocs)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf3b8dbd.Data = unsafe.Pointer(x.refb6538bfb.pSampleMask)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocStencilOpStateMemory allocates memory for type C.VkStencilOpState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStencilOpStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStencilOpStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStencilOpStateValue = unsafe.Sizeof([1]C.VkStencilOpState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StencilOpState) Ref() *C.VkStencilOpState {
	if x == nil {
		return nil
	}
	return x.ref28886871
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StencilOpState) Free() {
	if x != nil && x.allocs28886871 != nil {
		x.allocs28886871.(*cgoAllocMap).Free()
		x.ref28886871 = nil
	}
}

// NewStencilOpStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStencilOpStateRef(ref unsafe.Pointer) *StencilOpState {
	if ref == nil {
		return nil
	}
	obj := new(StencilOpState)
	obj.ref28886871 = (*C.VkStencilOpState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StencilOpState) PassRef() (*C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28886871 != nil {
		return x.ref28886871, nil
	}
	mem28886871 := allocStencilOpStateMemory(1)
	ref28886871 := (*C.VkStencilOpState)(mem28886871)
	allocs28886871 := new(cgoAllocMap)
	allocs28886871.Add(mem28886871)

	var cfailOp_allocs *cgoAllocMap
	ref28886871.failOp, cfailOp_allocs = (C.VkStencilOp)(x.FailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cfailOp_allocs)

	var cpassOp_allocs *cgoAllocMap
	ref28886871.passOp, cpassOp_allocs = (C.VkStencilOp)(x.PassOp), cgoAllocsUnknown
	allocs28886871.Borrow(cpassOp_allocs)

	var cdepthFailOp_allocs *cgoAllocMap
	ref28886871.depthFailOp, cdepthFailOp_allocs = (C.VkStencilOp)(x.DepthFailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cdepthFailOp_allocs)

	var ccompareOp_allocs *cgoAllocMap
	ref28886871.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareOp_allocs)

	var ccompareMask_allocs *cgoAllocMap
	ref28886871.compareMask, ccompareMask_allocs = (C.uint32_t)(x.CompareMask), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareMask_allocs)

	var cwriteMask_allocs *cgoAllocMap
	ref28886871.writeMask, cwriteMask_allocs = (C.uint32_t)(x.WriteMask), cgoAllocsUnknown
	allocs28886871.Borrow(cwriteMask_allocs)

	var creference_allocs *cgoAllocMap
	ref28886871.reference, creference_allocs = (C.uint32_t)(x.Reference), cgoAllocsUnknown
	allocs28886871.Borrow(creference_allocs)

	x.ref28886871 = ref28886871
	x.allocs28886871 = allocs28886871
	return ref28886871, allocs28886871

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StencilOpState) PassValue() (C.VkStencilOpState, *cgoAllocMap) {
	if x.ref28886871 != nil {
		return *x.ref28886871, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StencilOpState) Deref() {
	if x.ref28886871 == nil {
		return
	}
	x.FailOp = (StencilOp)(x.ref28886871.failOp)
	x.PassOp = (StencilOp)(x.ref28886871.passOp)
	x.DepthFailOp = (StencilOp)(x.ref28886871.depthFailOp)
	x.CompareOp = (CompareOp)(x.ref28886871.compareOp)
	x.CompareMask = (uint32)(x.ref28886871.compareMask)
	x.WriteMask = (uint32)(x.ref28886871.writeMask)
	x.Reference = (uint32)(x.ref28886871.reference)
}

// allocPipelineDepthStencilStateCreateInfoMemory allocates memory for type C.VkPipelineDepthStencilStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDepthStencilStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDepthStencilStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDepthStencilStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDepthStencilStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDepthStencilStateCreateInfo) Ref() *C.VkPipelineDepthStencilStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refeabfcf1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	if x != nil && x.allocseabfcf1 != nil {
		x.allocseabfcf1.(*cgoAllocMap).Free()
		x.refeabfcf1 = nil
	}
}

// NewPipelineDepthStencilStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDepthStencilStateCreateInfoRef(ref unsafe.Pointer) *PipelineDepthStencilStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDepthStencilStateCreateInfo)
	obj.refeabfcf1 = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDepthStencilStateCreateInfo) PassRef() (*C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeabfcf1 != nil {
		return x.refeabfcf1, nil
	}
	memeabfcf1 := allocPipelineDepthStencilStateCreateInfoMemory(1)
	refeabfcf1 := (*C.VkPipelineDepthStencilStateCreateInfo)(memeabfcf1)
	allocseabfcf1 := new(cgoAllocMap)
	allocseabfcf1.Add(memeabfcf1)

	var csType_allocs *cgoAllocMap
	refeabfcf1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseabfcf1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeabfcf1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseabfcf1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeabfcf1.flags, cflags_allocs = (C.VkPipelineDepthStencilStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocseabfcf1.Borrow(cflags_allocs)

	var cdepthTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthTestEnable, cdepthTestEnable_allocs = (C.VkBool32)(x.DepthTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthTestEnable_allocs)

	var cdepthWriteEnable_allocs *cgoAllocMap
	refeabfcf1.depthWriteEnable, cdepthWriteEnable_allocs = (C.VkBool32)(x.DepthWriteEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthWriteEnable_allocs)

	var cdepthCompareOp_allocs *cgoAllocMap
	refeabfcf1.depthCompareOp, cdepthCompareOp_allocs = (C.VkCompareOp)(x.DepthCompareOp), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthCompareOp_allocs)

	var cdepthBoundsTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthBoundsTestEnable, cdepthBoundsTestEnable_allocs = (C.VkBool32)(x.DepthBoundsTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthBoundsTestEnable_allocs)

	var cstencilTestEnable_allocs *cgoAllocMap
	refeabfcf1.stencilTestEnable, cstencilTestEnable_allocs = (C.VkBool32)(x.StencilTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cstencilTestEnable_allocs)

	var cfront_allocs *cgoAllocMap
	refeabfcf1.front, cfront_allocs = x.Front.PassValue()
	allocseabfcf1.Borrow(cfront_allocs)

	var cback_allocs *cgoAllocMap
	refeabfcf1.back, cback_allocs = x.Back.PassValue()
	allocseabfcf1.Borrow(cback_allocs)

	var cminDepthBounds_allocs *cgoAllocMap
	refeabfcf1.minDepthBounds, cminDepthBounds_allocs = (C.float)(x.MinDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cminDepthBounds_allocs)

	var cmaxDepthBounds_allocs *cgoAllocMap
	refeabfcf1.maxDepthBounds, cmaxDepthBounds_allocs = (C.float)(x.MaxDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cmaxDepthBounds_allocs)

	x.refeabfcf1 = refeabfcf1
	x.allocseabfcf1 = allocseabfcf1
	return refeabfcf1, allocseabfcf1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) PassValue() (C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x.refeabfcf1 != nil {
		return *x.refeabfcf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDepthStencilStateCreateInfo) Deref() {
	if x.refeabfcf1 == nil {
		return
	}
	x.SType = (StructureType)(x.refeabfcf1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeabfcf1.pNext))
	x.Flags = (PipelineDepthStencilStateCreateFlags)(x.refeabfcf1.flags)
	x.DepthTestEnable = (Bool32)(x.refeabfcf1.depthTestEnable)
	x.DepthWriteEnable = (Bool32)(x.refeabfcf1.depthWriteEnable)
	x.DepthCompareOp = (CompareOp)(x.refeabfcf1.depthCompareOp)
	x.DepthBoundsTestEnable = (Bool32)(x.refeabfcf1.depthBoundsTestEnable)
	x.StencilTestEnable = (Bool32)(x.refeabfcf1.stencilTestEnable)
	x.Front = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.front))
	x.Back = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.back))
	x.MinDepthBounds = (float32)(x.refeabfcf1.minDepthBounds)
	x.MaxDepthBounds = (float32)(x.refeabfcf1.maxDepthBounds)
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAttachmentState) Ref() *C.VkPipelineColorBlendAttachmentState {
	if x == nil {
		return nil
	}
	return x.ref9e889477
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAttachmentState) Free() {
	if x != nil && x.allocs9e889477 != nil {
		x.allocs9e889477.(*cgoAllocMap).Free()
		x.ref9e889477 = nil
	}
}

// NewPipelineColorBlendAttachmentStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAttachmentStateRef(ref unsafe.Pointer) *PipelineColorBlendAttachmentState {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAttachmentState)
	obj.ref9e889477 = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAttachmentState) PassRef() (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e889477 != nil {
		return x.ref9e889477, nil
	}
	mem9e889477 := allocPipelineColorBlendAttachmentStateMemory(1)
	ref9e889477 := (*C.VkPipelineColorBlendAttachmentState)(mem9e889477)
	allocs9e889477 := new(cgoAllocMap)
	allocs9e889477.Add(mem9e889477)

	var cblendEnable_allocs *cgoAllocMap
	ref9e889477.blendEnable, cblendEnable_allocs = (C.VkBool32)(x.BlendEnable), cgoAllocsUnknown
	allocs9e889477.Borrow(cblendEnable_allocs)

	var csrcColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcColorBlendFactor, csrcColorBlendFactor_allocs = (C.VkBlendFactor)(x.SrcColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcColorBlendFactor_allocs)

	var cdstColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstColorBlendFactor, cdstColorBlendFactor_allocs = (C.VkBlendFactor)(x.DstColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstColorBlendFactor_allocs)

	var ccolorBlendOp_allocs *cgoAllocMap
	ref9e889477.colorBlendOp, ccolorBlendOp_allocs = (C.VkBlendOp)(x.ColorBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorBlendOp_allocs)

	var csrcAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcAlphaBlendFactor, csrcAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.SrcAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcAlphaBlendFactor_allocs)

	var cdstAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstAlphaBlendFactor, cdstAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.DstAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstAlphaBlendFactor_allocs)

	var calphaBlendOp_allocs *cgoAllocMap
	ref9e889477.alphaBlendOp, calphaBlendOp_allocs = (C.VkBlendOp)(x.AlphaBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(calphaBlendOp_allocs)

	var ccolorWriteMask_allocs *cgoAllocMap
	ref9e889477.colorWriteMask, ccolorWriteMask_allocs = (C.VkColorComponentFlags)(x.ColorWriteMask), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorWriteMask_allocs)

	x.ref9e889477 = ref9e889477
	x.allocs9e889477 = allocs9e889477
	return ref9e889477, allocs9e889477

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAttachmentState) PassValue() (C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x.ref9e889477 != nil {
		return *x.ref9e889477, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAttachmentState) Deref() {
	if x.ref9e889477 == nil {
		return
	}
	x.BlendEnable = (Bool32)(x.ref9e889477.blendEnable)
	x.SrcColorBlendFactor = (BlendFactor)(x.ref9e889477.srcColorBlendFactor)
	x.DstColorBlendFactor = (BlendFactor)(x.ref9e889477.dstColorBlendFactor)
	x.ColorBlendOp = (BlendOp)(x.ref9e889477.colorBlendOp)
	x.SrcAlphaBlendFactor = (BlendFactor)(x.ref9e889477.srcAlphaBlendFactor)
	x.DstAlphaBlendFactor = (BlendFactor)(x.ref9e889477.dstAlphaBlendFactor)
	x.AlphaBlendOp = (BlendOp)(x.ref9e889477.alphaBlendOp)
	x.ColorWriteMask = (ColorComponentFlags)(x.ref9e889477.colorWriteMask)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// unpackSPipelineColorBlendAttachmentState transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendAttachmentState(x []PipelineColorBlendAttachmentState) (unpacked *C.VkPipelineColorBlendAttachmentState, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendAttachmentState) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendAttachmentStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendAttachmentState)(h.Data)
	return
}

// packSPipelineColorBlendAttachmentState reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendAttachmentState(v []PipelineColorBlendAttachmentState, ptr0 *C.VkPipelineColorBlendAttachmentState) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendAttachmentStateValue]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendAttachmentStateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	allocs2a9b490b.Add(mem2a9b490b)

	var csType_allocs *cgoAllocMap
	ref2a9b490b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a9b490b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a9b490b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a9b490b.flags, cflags_allocs = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cflags_allocs)

	var clogicOpEnable_allocs *cgoAllocMap
	ref2a9b490b.logicOpEnable, clogicOpEnable_allocs = (C.VkBool32)(x.LogicOpEnable), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOpEnable_allocs)

	var clogicOp_allocs *cgoAllocMap
	ref2a9b490b.logicOp, clogicOp_allocs = (C.VkLogicOp)(x.LogicOp), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOp_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref2a9b490b.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref2a9b490b.pAttachments, cpAttachments_allocs = unpackSPipelineColorBlendAttachmentState(x.PAttachments)
	allocs2a9b490b.Borrow(cpAttachments_allocs)

	var cblendConstants_allocs *cgoAllocMap
	ref2a9b490b.blendConstants, cblendConstants_allocs = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cblendConstants_allocs)

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	packSPipelineColorBlendAttachmentState(x.PAttachments, x.ref2a9b490b.pAttachments)
	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDynamicStateCreateInfoRef(ref unsafe.Pointer) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	allocs246d7bc8.Add(mem246d7bc8)

	var csType_allocs *cgoAllocMap
	ref246d7bc8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs246d7bc8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref246d7bc8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref246d7bc8.flags, cflags_allocs = (C.VkPipelineDynamicStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cflags_allocs)

	var cdynamicStateCount_allocs *cgoAllocMap
	ref246d7bc8.dynamicStateCount, cdynamicStateCount_allocs = (C.uint32_t)(x.DynamicStateCount), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cdynamicStateCount_allocs)

	var cpDynamicStates_allocs *cgoAllocMap
	ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = (*C.VkDynamicState)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)).Data)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpDynamicStates_allocs)

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf7a6dff.Data = unsafe.Pointer(x.ref246d7bc8.pDynamicStates)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineShaderStageCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(h.Data)
	return
}

// unpackSPipelineVertexInputStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineVertexInputStateCreateInfo(x []PipelineVertexInputStateCreateInfo) (unpacked *C.VkPipelineVertexInputStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineVertexInputStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineVertexInputStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineVertexInputStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineInputAssemblyStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineInputAssemblyStateCreateInfo(x []PipelineInputAssemblyStateCreateInfo) (unpacked *C.VkPipelineInputAssemblyStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineInputAssemblyStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineInputAssemblyStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineInputAssemblyStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineTessellationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineTessellationStateCreateInfo(x []PipelineTessellationStateCreateInfo) (unpacked *C.VkPipelineTessellationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineTessellationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineTessellationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineTessellationStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineViewportStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineViewportStateCreateInfo(x []PipelineViewportStateCreateInfo) (unpacked *C.VkPipelineViewportStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineViewportStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineViewportStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineViewportStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineRasterizationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineRasterizationStateCreateInfo(x []PipelineRasterizationStateCreateInfo) (unpacked *C.VkPipelineRasterizationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineRasterizationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineRasterizationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineRasterizationStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineMultisampleStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineMultisampleStateCreateInfo(x []PipelineMultisampleStateCreateInfo) (unpacked *C.VkPipelineMultisampleStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineMultisampleStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineMultisampleStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineMultisampleStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineDepthStencilStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDepthStencilStateCreateInfo(x []PipelineDepthStencilStateCreateInfo) (unpacked *C.VkPipelineDepthStencilStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDepthStencilStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDepthStencilStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDepthStencilStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineColorBlendStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendStateCreateInfo(x []PipelineColorBlendStateCreateInfo) (unpacked *C.VkPipelineColorBlendStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineDynamicStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDynamicStateCreateInfo(x []PipelineDynamicStateCreateInfo) (unpacked *C.VkPipelineDynamicStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDynamicStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDynamicStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDynamicStateCreateInfo)(h.Data)
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineVertexInputStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineVertexInputStateCreateInfo(v []PipelineVertexInputStateCreateInfo, ptr0 *C.VkPipelineVertexInputStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineVertexInputStateCreateInfoValue]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineInputAssemblyStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineInputAssemblyStateCreateInfo(v []PipelineInputAssemblyStateCreateInfo, ptr0 *C.VkPipelineInputAssemblyStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineInputAssemblyStateCreateInfoValue]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineInputAssemblyStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineTessellationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineTessellationStateCreateInfo(v []PipelineTessellationStateCreateInfo, ptr0 *C.VkPipelineTessellationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineTessellationStateCreateInfoValue]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineTessellationStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineViewportStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineViewportStateCreateInfo(v []PipelineViewportStateCreateInfo, ptr0 *C.VkPipelineViewportStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineViewportStateCreateInfoValue]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineViewportStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineRasterizationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineRasterizationStateCreateInfo(v []PipelineRasterizationStateCreateInfo, ptr0 *C.VkPipelineRasterizationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineRasterizationStateCreateInfoValue]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineRasterizationStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineMultisampleStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineMultisampleStateCreateInfo(v []PipelineMultisampleStateCreateInfo, ptr0 *C.VkPipelineMultisampleStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineMultisampleStateCreateInfoValue]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineMultisampleStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineDepthStencilStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDepthStencilStateCreateInfo(v []PipelineDepthStencilStateCreateInfo, ptr0 *C.VkPipelineDepthStencilStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDepthStencilStateCreateInfoValue]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDepthStencilStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineColorBlendStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendStateCreateInfo(v []PipelineColorBlendStateCreateInfo, ptr0 *C.VkPipelineColorBlendStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendStateCreateInfoValue]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineDynamicStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDynamicStateCreateInfo(v []PipelineDynamicStateCreateInfo, ptr0 *C.VkPipelineDynamicStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDynamicStateCreateInfoValue]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineCreateInfoRef(ref unsafe.Pointer) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	allocs178f88b6.Add(mem178f88b6)

	var csType_allocs *cgoAllocMap
	ref178f88b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs178f88b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref178f88b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref178f88b6.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs178f88b6.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref178f88b6.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs178f88b6.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = unpackSPipelineVertexInputStateCreateInfo(x.PVertexInputState)
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	var cpInputAssemblyState_allocs *cgoAllocMap
	ref178f88b6.pInputAssemblyState, cpInputAssemblyState_allocs = unpackSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState)
	allocs178f88b6.Borrow(cpInputAssemblyState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	ref178f88b6.pTessellationState, cpTessellationState_allocs = unpackSPipelineTessellationStateCreateInfo(x.PTessellationState)
	allocs178f88b6.Borrow(cpTessellationState_allocs)

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = unpackSPipelineViewportStateCreateInfo(x.PViewportState)
	allocs178f88b6.Borrow(cpViewportState_allocs)

	var cpRasterizationState_allocs *cgoAllocMap
	ref178f88b6.pRasterizationState, cpRasterizationState_allocs = unpackSPipelineRasterizationStateCreateInfo(x.PRasterizationState)
	allocs178f88b6.Borrow(cpRasterizationState_allocs)

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = unpackSPipelineMultisampleStateCreateInfo(x.PMultisampleState)
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	var cpDepthStencilState_allocs *cgoAllocMap
	ref178f88b6.pDepthStencilState, cpDepthStencilState_allocs = unpackSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState)
	allocs178f88b6.Borrow(cpDepthStencilState_allocs)

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = unpackSPipelineColorBlendStateCreateInfo(x.PColorBlendState)
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = unpackSPipelineDynamicStateCreateInfo(x.PDynamicState)
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref178f88b6.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs178f88b6.Borrow(clayout_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref178f88b6.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs178f88b6.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref178f88b6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs178f88b6.Borrow(csubpass_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref178f88b6.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref178f88b6.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineIndex_allocs)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	packSPipelineVertexInputStateCreateInfo(x.PVertexInputState, x.ref178f88b6.pVertexInputState)
	packSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState, x.ref178f88b6.pInputAssemblyState)
	packSPipelineTessellationStateCreateInfo(x.PTessellationState, x.ref178f88b6.pTessellationState)
	packSPipelineViewportStateCreateInfo(x.PViewportState, x.ref178f88b6.pViewportState)
	packSPipelineRasterizationStateCreateInfo(x.PRasterizationState, x.ref178f88b6.pRasterizationState)
	packSPipelineMultisampleStateCreateInfo(x.PMultisampleState, x.ref178f88b6.pMultisampleState)
	packSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState, x.ref178f88b6.pDepthStencilState)
	packSPipelineColorBlendStateCreateInfo(x.PColorBlendState, x.ref178f88b6.pColorBlendState)
	packSPipelineDynamicStateCreateInfo(x.PDynamicState, x.ref178f88b6.pDynamicState)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComputePipelineCreateInfoRef(ref unsafe.Pointer) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	allocs77823220.Add(mem77823220)

	var csType_allocs *cgoAllocMap
	ref77823220.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77823220.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77823220.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77823220.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77823220.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77823220.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	var clayout_allocs *cgoAllocMap
	ref77823220.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs77823220.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref77823220.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref77823220.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineIndex_allocs)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&x.ref77823220.stage))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PushConstantRange) Ref() *C.VkPushConstantRange {
	if x == nil {
		return nil
	}
	return x.ref6f025856
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PushConstantRange) Free() {
	if x != nil && x.allocs6f025856 != nil {
		x.allocs6f025856.(*cgoAllocMap).Free()
		x.ref6f025856 = nil
	}
}

// NewPushConstantRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPushConstantRangeRef(ref unsafe.Pointer) *PushConstantRange {
	if ref == nil {
		return nil
	}
	obj := new(PushConstantRange)
	obj.ref6f025856 = (*C.VkPushConstantRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PushConstantRange) PassRef() (*C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f025856 != nil {
		return x.ref6f025856, nil
	}
	mem6f025856 := allocPushConstantRangeMemory(1)
	ref6f025856 := (*C.VkPushConstantRange)(mem6f025856)
	allocs6f025856 := new(cgoAllocMap)
	allocs6f025856.Add(mem6f025856)

	var cstageFlags_allocs *cgoAllocMap
	ref6f025856.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs6f025856.Borrow(cstageFlags_allocs)

	var coffset_allocs *cgoAllocMap
	ref6f025856.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs6f025856.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref6f025856.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs6f025856.Borrow(csize_allocs)

	x.ref6f025856 = ref6f025856
	x.allocs6f025856 = allocs6f025856
	return ref6f025856, allocs6f025856

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PushConstantRange) PassValue() (C.VkPushConstantRange, *cgoAllocMap) {
	if x.ref6f025856 != nil {
		return *x.ref6f025856, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PushConstantRange) Deref() {
	if x.ref6f025856 == nil {
		return
	}
	x.StageFlags = (ShaderStageFlags)(x.ref6f025856.stageFlags)
	x.Offset = (uint32)(x.ref6f025856.offset)
	x.Size = (uint32)(x.ref6f025856.size)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// unpackSPushConstantRange transforms a sliced Go data structure into plain C format.
func unpackSPushConstantRange(x []PushConstantRange) (unpacked *C.VkPushConstantRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPushConstantRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPushConstantRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPushConstantRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPushConstantRange)(h.Data)
	return
}

// packSPushConstantRange reads sliced Go data structure out from plain C format.
func packSPushConstantRange(v []PushConstantRange, ptr0 *C.VkPushConstantRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPushConstantRangeValue]C.VkPushConstantRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPushConstantRangeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLayoutCreateInfoRef(ref unsafe.Pointer) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = (*C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	allocs64cc4eed.Add(mem64cc4eed)

	var csType_allocs *cgoAllocMap
	ref64cc4eed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64cc4eed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref64cc4eed.flags, cflags_allocs = (C.VkPipelineLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cflags_allocs)

	var csetLayoutCount_allocs *cgoAllocMap
	ref64cc4eed.setLayoutCount, csetLayoutCount_allocs = (C.uint32_t)(x.SetLayoutCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csetLayoutCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpSetLayouts_allocs)

	var cpushConstantRangeCount_allocs *cgoAllocMap
	ref64cc4eed.pushConstantRangeCount, cpushConstantRangeCount_allocs = (C.uint32_t)(x.PushConstantRangeCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpushConstantRangeCount_allocs)

	var cpPushConstantRanges_allocs *cgoAllocMap
	ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = unpackSPushConstantRange(x.PPushConstantRanges)
	allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe48d67.Data = unsafe.Pointer(x.ref64cc4eed.pSetLayouts)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	packSPushConstantRange(x.PPushConstantRanges, x.ref64cc4eed.pPushConstantRanges)
}

// allocSamplerCreateInfoMemory allocates memory for type C.VkSamplerCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCreateInfo) Ref() *C.VkSamplerCreateInfo {
	if x == nil {
		return nil
	}
	return x.refce034abf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCreateInfo) Free() {
	if x != nil && x.allocsce034abf != nil {
		x.allocsce034abf.(*cgoAllocMap).Free()
		x.refce034abf = nil
	}
}

// NewSamplerCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCreateInfoRef(ref unsafe.Pointer) *SamplerCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCreateInfo)
	obj.refce034abf = (*C.VkSamplerCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCreateInfo) PassRef() (*C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce034abf != nil {
		return x.refce034abf, nil
	}
	memce034abf := allocSamplerCreateInfoMemory(1)
	refce034abf := (*C.VkSamplerCreateInfo)(memce034abf)
	allocsce034abf := new(cgoAllocMap)
	allocsce034abf.Add(memce034abf)

	var csType_allocs *cgoAllocMap
	refce034abf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsce034abf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refce034abf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsce034abf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refce034abf.flags, cflags_allocs = (C.VkSamplerCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsce034abf.Borrow(cflags_allocs)

	var cmagFilter_allocs *cgoAllocMap
	refce034abf.magFilter, cmagFilter_allocs = (C.VkFilter)(x.MagFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cmagFilter_allocs)

	var cminFilter_allocs *cgoAllocMap
	refce034abf.minFilter, cminFilter_allocs = (C.VkFilter)(x.MinFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cminFilter_allocs)

	var cmipmapMode_allocs *cgoAllocMap
	refce034abf.mipmapMode, cmipmapMode_allocs = (C.VkSamplerMipmapMode)(x.MipmapMode), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipmapMode_allocs)

	var caddressModeU_allocs *cgoAllocMap
	refce034abf.addressModeU, caddressModeU_allocs = (C.VkSamplerAddressMode)(x.AddressModeU), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeU_allocs)

	var caddressModeV_allocs *cgoAllocMap
	refce034abf.addressModeV, caddressModeV_allocs = (C.VkSamplerAddressMode)(x.AddressModeV), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeV_allocs)

	var caddressModeW_allocs *cgoAllocMap
	refce034abf.addressModeW, caddressModeW_allocs = (C.VkSamplerAddressMode)(x.AddressModeW), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeW_allocs)

	var cmipLodBias_allocs *cgoAllocMap
	refce034abf.mipLodBias, cmipLodBias_allocs = (C.float)(x.MipLodBias), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipLodBias_allocs)

	var canisotropyEnable_allocs *cgoAllocMap
	refce034abf.anisotropyEnable, canisotropyEnable_allocs = (C.VkBool32)(x.AnisotropyEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(canisotropyEnable_allocs)

	var cmaxAnisotropy_allocs *cgoAllocMap
	refce034abf.maxAnisotropy, cmaxAnisotropy_allocs = (C.float)(x.MaxAnisotropy), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxAnisotropy_allocs)

	var ccompareEnable_allocs *cgoAllocMap
	refce034abf.compareEnable, ccompareEnable_allocs = (C.VkBool32)(x.CompareEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareEnable_allocs)

	var ccompareOp_allocs *cgoAllocMap
	refce034abf.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareOp_allocs)

	var cminLod_allocs *cgoAllocMap
	refce034abf.minLod, cminLod_allocs = (C.float)(x.MinLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cminLod_allocs)

	var cmaxLod_allocs *cgoAllocMap
	refce034abf.maxLod, cmaxLod_allocs = (C.float)(x.MaxLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxLod_allocs)

	var cborderColor_allocs *cgoAllocMap
	refce034abf.borderColor, cborderColor_allocs = (C.VkBorderColor)(x.BorderColor), cgoAllocsUnknown
	allocsce034abf.Borrow(cborderColor_allocs)

	var cunnormalizedCoordinates_allocs *cgoAllocMap
	refce034abf.unnormalizedCoordinates, cunnormalizedCoordinates_allocs = (C.VkBool32)(x.UnnormalizedCoordinates), cgoAllocsUnknown
	allocsce034abf.Borrow(cunnormalizedCoordinates_allocs)

	x.refce034abf = refce034abf
	x.allocsce034abf = allocsce034abf
	return refce034abf, allocsce034abf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCreateInfo) PassValue() (C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x.refce034abf != nil {
		return *x.refce034abf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCreateInfo) Deref() {
	if x.refce034abf == nil {
		return
	}
	x.SType = (StructureType)(x.refce034abf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refce034abf.pNext))
	x.Flags = (SamplerCreateFlags)(x.refce034abf.flags)
	x.MagFilter = (Filter)(x.refce034abf.magFilter)
	x.MinFilter = (Filter)(x.refce034abf.minFilter)
	x.MipmapMode = (SamplerMipmapMode)(x.refce034abf.mipmapMode)
	x.AddressModeU = (SamplerAddressMode)(x.refce034abf.addressModeU)
	x.AddressModeV = (SamplerAddressMode)(x.refce034abf.addressModeV)
	x.AddressModeW = (SamplerAddressMode)(x.refce034abf.addressModeW)
	x.MipLodBias = (float32)(x.refce034abf.mipLodBias)
	x.AnisotropyEnable = (Bool32)(x.refce034abf.anisotropyEnable)
	x.MaxAnisotropy = (float32)(x.refce034abf.maxAnisotropy)
	x.CompareEnable = (Bool32)(x.refce034abf.compareEnable)
	x.CompareOp = (CompareOp)(x.refce034abf.compareOp)
	x.MinLod = (float32)(x.refce034abf.minLod)
	x.MaxLod = (float32)(x.refce034abf.maxLod)
	x.BorderColor = (BorderColor)(x.refce034abf.borderColor)
	x.UnnormalizedCoordinates = (Bool32)(x.refce034abf.unnormalizedCoordinates)
}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingRef(ref unsafe.Pointer) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	allocs8b50b4ec.Add(mem8b50b4ec)

	var cbinding_allocs *cgoAllocMap
	ref8b50b4ec.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cbinding_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref8b50b4ec.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorType_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref8b50b4ec.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorCount_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8b50b4ec.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cstageFlags_allocs)

	var cpImmutableSamplers_allocs *cgoAllocMap
	ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = (*C.VkSampler)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)).Data)), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxf4171bf.Data = unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(h.Data)
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = (*C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	allocs5ee8e0ed.Add(mem5ee8e0ed)

	var csType_allocs *cgoAllocMap
	ref5ee8e0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ee8e0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5ee8e0ed.flags, cflags_allocs = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cflags_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref5ee8e0ed.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cbindingCount_allocs)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolSize) Ref() *C.VkDescriptorPoolSize {
	if x == nil {
		return nil
	}
	return x.refe15137da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolSize) Free() {
	if x != nil && x.allocse15137da != nil {
		x.allocse15137da.(*cgoAllocMap).Free()
		x.refe15137da = nil
	}
}

// NewDescriptorPoolSizeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolSizeRef(ref unsafe.Pointer) *DescriptorPoolSize {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolSize)
	obj.refe15137da = (*C.VkDescriptorPoolSize)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolSize) PassRef() (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe15137da != nil {
		return x.refe15137da, nil
	}
	meme15137da := allocDescriptorPoolSizeMemory(1)
	refe15137da := (*C.VkDescriptorPoolSize)(meme15137da)
	allocse15137da := new(cgoAllocMap)
	allocse15137da.Add(meme15137da)

	var c_type_allocs *cgoAllocMap
	refe15137da._type, c_type_allocs = (C.VkDescriptorType)(x._type), cgoAllocsUnknown
	allocse15137da.Borrow(c_type_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refe15137da.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocse15137da.Borrow(cdescriptorCount_allocs)

	x.refe15137da = refe15137da
	x.allocse15137da = allocse15137da
	return refe15137da, allocse15137da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolSize) PassValue() (C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x.refe15137da != nil {
		return *x.refe15137da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolSize) Deref() {
	if x.refe15137da == nil {
		return
	}
	x._type = (DescriptorType)(x.refe15137da._type)
	x.DescriptorCount = (uint32)(x.refe15137da.descriptorCount)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// unpackSDescriptorPoolSize transforms a sliced Go data structure into plain C format.
func unpackSDescriptorPoolSize(x []DescriptorPoolSize) (unpacked *C.VkDescriptorPoolSize, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorPoolSize) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolSize)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolSize)(h.Data)
	return
}

// packSDescriptorPoolSize reads sliced Go data structure out from plain C format.
func packSDescriptorPoolSize(v []DescriptorPoolSize, ptr0 *C.VkDescriptorPoolSize) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolSizeValue]C.VkDescriptorPoolSize)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolSizeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = (*C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	allocs19868463.Add(mem19868463)

	var csType_allocs *cgoAllocMap
	ref19868463.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs19868463.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref19868463.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs19868463.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref19868463.flags, cflags_allocs = (C.VkDescriptorPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs19868463.Borrow(cflags_allocs)

	var cmaxSets_allocs *cgoAllocMap
	ref19868463.maxSets, cmaxSets_allocs = (C.uint32_t)(x.MaxSets), cgoAllocsUnknown
	allocs19868463.Borrow(cmaxSets_allocs)

	var cpoolSizeCount_allocs *cgoAllocMap
	ref19868463.poolSizeCount, cpoolSizeCount_allocs = (C.uint32_t)(x.PoolSizeCount), cgoAllocsUnknown
	allocs19868463.Borrow(cpoolSizeCount_allocs)

	var cpPoolSizes_allocs *cgoAllocMap
	ref19868463.pPoolSizes, cpPoolSizes_allocs = unpackSDescriptorPoolSize(x.PPoolSizes)
	allocs19868463.Borrow(cpPoolSizes_allocs)

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	packSDescriptorPoolSize(x.PPoolSizes, x.ref19868463.pPoolSizes)
}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = (*C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	allocs2dd6cc22.Add(mem2dd6cc22)

	var csType_allocs *cgoAllocMap
	ref2dd6cc22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2dd6cc22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpNext_allocs)

	var cdescriptorPool_allocs *cgoAllocMap
	ref2dd6cc22.descriptorPool, cdescriptorPool_allocs = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorPool_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref2dd6cc22.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorSetCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpSetLayouts_allocs)

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxf058b18.Data = unsafe.Pointer(x.ref2dd6cc22.pSetLayouts)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorImageInfoRef(ref unsafe.Pointer) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = (*C.VkDescriptorImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	allocsaf073b07.Add(memaf073b07)

	var csampler_allocs *cgoAllocMap
	refaf073b07.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsaf073b07.Borrow(csampler_allocs)

	var cimageView_allocs *cgoAllocMap
	refaf073b07.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageView_allocs)

	var cimageLayout_allocs *cgoAllocMap
	refaf073b07.imageLayout, cimageLayout_allocs = (C.VkImageLayout)(x.ImageLayout), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageLayout_allocs)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBufferInfoRef(ref unsafe.Pointer) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	allocse64bec0e.Add(meme64bec0e)

	var cbuffer_allocs *cgoAllocMap
	refe64bec0e.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse64bec0e.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refe64bec0e.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocse64bec0e.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	refe64bec0e._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocse64bec0e.Borrow(c_range_allocs)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x._range = (DeviceSize)(x.refe64bec0e._range)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorImageInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(h.Data)
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorBufferInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(h.Data)
	return
}

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetRef(ref unsafe.Pointer) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = (*C.VkWriteDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	allocs3cec3f3f.Add(mem3cec3f3f)

	var csType_allocs *cgoAllocMap
	ref3cec3f3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cec3f3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpNext_allocs)

	var cdstSet_allocs *cgoAllocMap
	ref3cec3f3f.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	ref3cec3f3f.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	ref3cec3f3f.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref3cec3f3f.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref3cec3f3f.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorType_allocs)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	var cpTexelBufferView_allocs *cgoAllocMap
	ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = (*C.VkBufferView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)).Data)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxff6bc57.Data = unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView)
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyDescriptorSetRef(ref unsafe.Pointer) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = (*C.VkCopyDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	allocsfe237a3a.Add(memfe237a3a)

	var csType_allocs *cgoAllocMap
	reffe237a3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe237a3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cpNext_allocs)

	var csrcSet_allocs *cgoAllocMap
	reffe237a3a.srcSet, csrcSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcSet_allocs)

	var csrcBinding_allocs *cgoAllocMap
	reffe237a3a.srcBinding, csrcBinding_allocs = (C.uint32_t)(x.SrcBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcBinding_allocs)

	var csrcArrayElement_allocs *cgoAllocMap
	reffe237a3a.srcArrayElement, csrcArrayElement_allocs = (C.uint32_t)(x.SrcArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcArrayElement_allocs)

	var cdstSet_allocs *cgoAllocMap
	reffe237a3a.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	reffe237a3a.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	reffe237a3a.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	reffe237a3a.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdescriptorCount_allocs)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferCreateInfoRef(ref unsafe.Pointer) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = (*C.VkFramebufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	allocsa3ad85cc.Add(mema3ad85cc)

	var csType_allocs *cgoAllocMap
	refa3ad85cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3ad85cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa3ad85cc.flags, cflags_allocs = (C.VkFramebufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cflags_allocs)

	var crenderPass_allocs *cgoAllocMap
	refa3ad85cc.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(crenderPass_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa3ad85cc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	refa3ad85cc.pAttachments, cpAttachments_allocs = (*C.VkImageView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PAttachments)).Data)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpAttachments_allocs)

	var cwidth_allocs *cgoAllocMap
	refa3ad85cc.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3ad85cc.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cheight_allocs)

	var clayers_allocs *cgoAllocMap
	refa3ad85cc.layers, clayers_allocs = (C.uint32_t)(x.Layers), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(clayers_allocs)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf5fa529.Data = unsafe.Pointer(x.refa3ad85cc.pAttachments)
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription) Ref() *C.VkAttachmentDescription {
	if x == nil {
		return nil
	}
	return x.refa5d685fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription) Free() {
	if x != nil && x.allocsa5d685fc != nil {
		x.allocsa5d685fc.(*cgoAllocMap).Free()
		x.refa5d685fc = nil
	}
}

// NewAttachmentDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescriptionRef(ref unsafe.Pointer) *AttachmentDescription {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription)
	obj.refa5d685fc = (*C.VkAttachmentDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription) PassRef() (*C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5d685fc != nil {
		return x.refa5d685fc, nil
	}
	mema5d685fc := allocAttachmentDescriptionMemory(1)
	refa5d685fc := (*C.VkAttachmentDescription)(mema5d685fc)
	allocsa5d685fc := new(cgoAllocMap)
	allocsa5d685fc.Add(mema5d685fc)

	var cflags_allocs *cgoAllocMap
	refa5d685fc.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refa5d685fc.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refa5d685fc.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsa5d685fc.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refa5d685fc.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refa5d685fc.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refa5d685fc.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refa5d685fc.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refa5d685fc.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refa5d685fc.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cfinalLayout_allocs)

	x.refa5d685fc = refa5d685fc
	x.allocsa5d685fc = allocsa5d685fc
	return refa5d685fc, allocsa5d685fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription) PassValue() (C.VkAttachmentDescription, *cgoAllocMap) {
	if x.refa5d685fc != nil {
		return *x.refa5d685fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription) Deref() {
	if x.refa5d685fc == nil {
		return
	}
	x.Flags = (AttachmentDescriptionFlags)(x.refa5d685fc.flags)
	x.Format = (Format)(x.refa5d685fc.format)
	x.Samples = (SampleCountFlagBits)(x.refa5d685fc.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refa5d685fc.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refa5d685fc.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refa5d685fc.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refa5d685fc.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refa5d685fc.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refa5d685fc.finalLayout)
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference) Ref() *C.VkAttachmentReference {
	if x == nil {
		return nil
	}
	return x.refef4776de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference) Free() {
	if x != nil && x.allocsef4776de != nil {
		x.allocsef4776de.(*cgoAllocMap).Free()
		x.refef4776de = nil
	}
}

// NewAttachmentReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReferenceRef(ref unsafe.Pointer) *AttachmentReference {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference)
	obj.refef4776de = (*C.VkAttachmentReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference) PassRef() (*C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef4776de != nil {
		return x.refef4776de, nil
	}
	memef4776de := allocAttachmentReferenceMemory(1)
	refef4776de := (*C.VkAttachmentReference)(memef4776de)
	allocsef4776de := new(cgoAllocMap)
	allocsef4776de.Add(memef4776de)

	var cattachment_allocs *cgoAllocMap
	refef4776de.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsef4776de.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refef4776de.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsef4776de.Borrow(clayout_allocs)

	x.refef4776de = refef4776de
	x.allocsef4776de = allocsef4776de
	return refef4776de, allocsef4776de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference) PassValue() (C.VkAttachmentReference, *cgoAllocMap) {
	if x.refef4776de != nil {
		return *x.refef4776de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference) Deref() {
	if x.refef4776de == nil {
		return
	}
	x.Attachment = (uint32)(x.refef4776de.attachment)
	x.Layout = (ImageLayout)(x.refef4776de.layout)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// unpackSAttachmentReference transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference(x []AttachmentReference) (unpacked *C.VkAttachmentReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference)(h.Data)
	return
}

// packSAttachmentReference reads sliced Go data structure out from plain C format.
func packSAttachmentReference(v []AttachmentReference, ptr0 *C.VkAttachmentReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReferenceValue]C.VkAttachmentReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionRef(ref unsafe.Pointer) *SubpassDescription {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription)
	obj.refc7bfeda = (*C.VkSubpassDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	allocsc7bfeda.Add(memc7bfeda)

	var cflags_allocs *cgoAllocMap
	refc7bfeda.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc7bfeda.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpipelineBindPoint_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	refc7bfeda.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference(x.PInputAttachments)
	allocsc7bfeda.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	refc7bfeda.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference(x.PColorAttachments)
	allocsc7bfeda.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference(x.PResolveAttachments)
	allocsc7bfeda.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	refc7bfeda.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference(x.PDepthStencilAttachment)
	allocsc7bfeda.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	packSAttachmentReference(x.PInputAttachments, x.refc7bfeda.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	packSAttachmentReference(x.PColorAttachments, x.refc7bfeda.pColorAttachments)
	packSAttachmentReference(x.PResolveAttachments, x.refc7bfeda.pResolveAttachments)
	packSAttachmentReference(x.PDepthStencilAttachment, x.refc7bfeda.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf21690b.Data = unsafe.Pointer(x.refc7bfeda.pPreserveAttachments)
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency) Ref() *C.VkSubpassDependency {
	if x == nil {
		return nil
	}
	return x.refdb197adb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency) Free() {
	if x != nil && x.allocsdb197adb != nil {
		x.allocsdb197adb.(*cgoAllocMap).Free()
		x.refdb197adb = nil
	}
}

// NewSubpassDependencyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependencyRef(ref unsafe.Pointer) *SubpassDependency {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency)
	obj.refdb197adb = (*C.VkSubpassDependency)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency) PassRef() (*C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb197adb != nil {
		return x.refdb197adb, nil
	}
	memdb197adb := allocSubpassDependencyMemory(1)
	refdb197adb := (*C.VkSubpassDependency)(memdb197adb)
	allocsdb197adb := new(cgoAllocMap)
	allocsdb197adb.Add(memdb197adb)

	var csrcSubpass_allocs *cgoAllocMap
	refdb197adb.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refdb197adb.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refdb197adb.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refdb197adb.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refdb197adb.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refdb197adb.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refdb197adb.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdependencyFlags_allocs)

	x.refdb197adb = refdb197adb
	x.allocsdb197adb = allocsdb197adb
	return refdb197adb, allocsdb197adb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency) PassValue() (C.VkSubpassDependency, *cgoAllocMap) {
	if x.refdb197adb != nil {
		return *x.refdb197adb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency) Deref() {
	if x.refdb197adb == nil {
		return
	}
	x.SrcSubpass = (uint32)(x.refdb197adb.srcSubpass)
	x.DstSubpass = (uint32)(x.refdb197adb.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refdb197adb.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refdb197adb.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refdb197adb.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refdb197adb.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refdb197adb.dependencyFlags)
}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// unpackSAttachmentDescription transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription(x []AttachmentDescription) (unpacked *C.VkAttachmentDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription)(h.Data)
	return
}

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(h.Data)
	return
}

// unpackSSubpassDependency transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency(x []SubpassDependency) (unpacked *C.VkSubpassDependency, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependencyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency)(h.Data)
	return
}

// packSAttachmentDescription reads sliced Go data structure out from plain C format.
func packSAttachmentDescription(v []AttachmentDescription, ptr0 *C.VkAttachmentDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescriptionValue]C.VkAttachmentDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency reads sliced Go data structure out from plain C format.
func packSSubpassDependency(v []SubpassDependency, ptr0 *C.VkSubpassDependency) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependencyValue]C.VkSubpassDependency)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependencyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfoRef(ref unsafe.Pointer) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = (*C.VkRenderPassCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	allocs886d7d86.Add(mem886d7d86)

	var csType_allocs *cgoAllocMap
	ref886d7d86.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs886d7d86.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref886d7d86.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs886d7d86.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref886d7d86.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs886d7d86.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref886d7d86.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref886d7d86.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription(x.PAttachments)
	allocs886d7d86.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref886d7d86.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref886d7d86.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref886d7d86.pDependencies, cpDependencies_allocs = unpackSSubpassDependency(x.PDependencies)
	allocs886d7d86.Borrow(cpDependencies_allocs)

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	packSAttachmentDescription(x.PAttachments, x.ref886d7d86.pAttachments)
	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	packSSubpassDependency(x.PDependencies, x.ref886d7d86.pDependencies)
}

// allocCommandPoolCreateInfoMemory allocates memory for type C.VkCommandPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandPoolCreateInfoValue = unsafe.Sizeof([1]C.VkCommandPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPoolCreateInfo) Ref() *C.VkCommandPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref73550de0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPoolCreateInfo) Free() {
	if x != nil && x.allocs73550de0 != nil {
		x.allocs73550de0.(*cgoAllocMap).Free()
		x.ref73550de0 = nil
	}
}

// NewCommandPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPoolCreateInfoRef(ref unsafe.Pointer) *CommandPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandPoolCreateInfo)
	obj.ref73550de0 = (*C.VkCommandPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPoolCreateInfo) PassRef() (*C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73550de0 != nil {
		return x.ref73550de0, nil
	}
	mem73550de0 := allocCommandPoolCreateInfoMemory(1)
	ref73550de0 := (*C.VkCommandPoolCreateInfo)(mem73550de0)
	allocs73550de0 := new(cgoAllocMap)
	allocs73550de0.Add(mem73550de0)

	var csType_allocs *cgoAllocMap
	ref73550de0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73550de0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73550de0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73550de0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73550de0.flags, cflags_allocs = (C.VkCommandPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs73550de0.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref73550de0.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs73550de0.Borrow(cqueueFamilyIndex_allocs)

	x.ref73550de0 = ref73550de0
	x.allocs73550de0 = allocs73550de0
	return ref73550de0, allocs73550de0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPoolCreateInfo) PassValue() (C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x.ref73550de0 != nil {
		return *x.ref73550de0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPoolCreateInfo) Deref() {
	if x.ref73550de0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73550de0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73550de0.pNext))
	x.Flags = (CommandPoolCreateFlags)(x.ref73550de0.flags)
	x.QueueFamilyIndex = (uint32)(x.ref73550de0.queueFamilyIndex)
}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferAllocateInfoRef(ref unsafe.Pointer) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = (*C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	allocsd1a0a7c8.Add(memd1a0a7c8)

	var csType_allocs *cgoAllocMap
	refd1a0a7c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1a0a7c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(cpNext_allocs)

	var ccommandPool_allocs *cgoAllocMap
	refd1a0a7c8.commandPool, ccommandPool_allocs = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandPool_allocs)

	var clevel_allocs *cgoAllocMap
	refd1a0a7c8.level, clevel_allocs = (C.VkCommandBufferLevel)(x.Level), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(clevel_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refd1a0a7c8.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandBufferCount_allocs)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	allocs737f8019.Add(mem737f8019)

	var csType_allocs *cgoAllocMap
	ref737f8019.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs737f8019.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref737f8019.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs737f8019.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref737f8019.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs737f8019.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref737f8019.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs737f8019.Borrow(csubpass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref737f8019.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs737f8019.Borrow(cframebuffer_allocs)

	var cocclusionQueryEnable_allocs *cgoAllocMap
	ref737f8019.occlusionQueryEnable, cocclusionQueryEnable_allocs = (C.VkBool32)(x.OcclusionQueryEnable), cgoAllocsUnknown
	allocs737f8019.Borrow(cocclusionQueryEnable_allocs)

	var cqueryFlags_allocs *cgoAllocMap
	ref737f8019.queryFlags, cqueryFlags_allocs = (C.VkQueryControlFlags)(x.QueryFlags), cgoAllocsUnknown
	allocs737f8019.Borrow(cqueryFlags_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref737f8019.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs737f8019.Borrow(cpipelineStatistics_allocs)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferInheritanceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(h.Data)
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferBeginInfoRef(ref unsafe.Pointer) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = (*C.VkCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	allocs266762df.Add(mem266762df)

	var csType_allocs *cgoAllocMap
	ref266762df.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs266762df.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref266762df.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs266762df.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref266762df.flags, cflags_allocs = (C.VkCommandBufferUsageFlags)(x.Flags), cgoAllocsUnknown
	allocs266762df.Borrow(cflags_allocs)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCopy) Ref() *C.VkBufferCopy {
	if x == nil {
		return nil
	}
	return x.ref12184ffd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCopy) Free() {
	if x != nil && x.allocs12184ffd != nil {
		x.allocs12184ffd.(*cgoAllocMap).Free()
		x.ref12184ffd = nil
	}
}

// NewBufferCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCopyRef(ref unsafe.Pointer) *BufferCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferCopy)
	obj.ref12184ffd = (*C.VkBufferCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCopy) PassRef() (*C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12184ffd != nil {
		return x.ref12184ffd, nil
	}
	mem12184ffd := allocBufferCopyMemory(1)
	ref12184ffd := (*C.VkBufferCopy)(mem12184ffd)
	allocs12184ffd := new(cgoAllocMap)
	allocs12184ffd.Add(mem12184ffd)

	var csrcOffset_allocs *cgoAllocMap
	ref12184ffd.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref12184ffd.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref12184ffd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs12184ffd.Borrow(csize_allocs)

	x.ref12184ffd = ref12184ffd
	x.allocs12184ffd = allocs12184ffd
	return ref12184ffd, allocs12184ffd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCopy) PassValue() (C.VkBufferCopy, *cgoAllocMap) {
	if x.ref12184ffd != nil {
		return *x.ref12184ffd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCopy) Deref() {
	if x.ref12184ffd == nil {
		return
	}
	x.SrcOffset = (DeviceSize)(x.ref12184ffd.srcOffset)
	x.DstOffset = (DeviceSize)(x.ref12184ffd.dstOffset)
	x.Size = (DeviceSize)(x.ref12184ffd.size)
}

// allocImageSubresourceLayersMemory allocates memory for type C.VkImageSubresourceLayers in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceLayersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceLayersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceLayersValue = unsafe.Sizeof([1]C.VkImageSubresourceLayers{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceLayers) Ref() *C.VkImageSubresourceLayers {
	if x == nil {
		return nil
	}
	return x.ref3b13bcd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceLayers) Free() {
	if x != nil && x.allocs3b13bcd2 != nil {
		x.allocs3b13bcd2.(*cgoAllocMap).Free()
		x.ref3b13bcd2 = nil
	}
}

// NewImageSubresourceLayersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceLayersRef(ref unsafe.Pointer) *ImageSubresourceLayers {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceLayers)
	obj.ref3b13bcd2 = (*C.VkImageSubresourceLayers)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceLayers) PassRef() (*C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b13bcd2 != nil {
		return x.ref3b13bcd2, nil
	}
	mem3b13bcd2 := allocImageSubresourceLayersMemory(1)
	ref3b13bcd2 := (*C.VkImageSubresourceLayers)(mem3b13bcd2)
	allocs3b13bcd2 := new(cgoAllocMap)
	allocs3b13bcd2.Add(mem3b13bcd2)

	var caspectMask_allocs *cgoAllocMap
	ref3b13bcd2.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	ref3b13bcd2.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cmipLevel_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref3b13bcd2.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref3b13bcd2.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(clayerCount_allocs)

	x.ref3b13bcd2 = ref3b13bcd2
	x.allocs3b13bcd2 = allocs3b13bcd2
	return ref3b13bcd2, allocs3b13bcd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceLayers) PassValue() (C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x.ref3b13bcd2 != nil {
		return *x.ref3b13bcd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceLayers) Deref() {
	if x.ref3b13bcd2 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref3b13bcd2.aspectMask)
	x.MipLevel = (uint32)(x.ref3b13bcd2.mipLevel)
	x.BaseArrayLayer = (uint32)(x.ref3b13bcd2.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref3b13bcd2.layerCount)
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCopy) Ref() *C.VkImageCopy {
	if x == nil {
		return nil
	}
	return x.ref4e7a1214
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCopy) Free() {
	if x != nil && x.allocs4e7a1214 != nil {
		x.allocs4e7a1214.(*cgoAllocMap).Free()
		x.ref4e7a1214 = nil
	}
}

// NewImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCopyRef(ref unsafe.Pointer) *ImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(ImageCopy)
	obj.ref4e7a1214 = (*C.VkImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCopy) PassRef() (*C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e7a1214 != nil {
		return x.ref4e7a1214, nil
	}
	mem4e7a1214 := allocImageCopyMemory(1)
	ref4e7a1214 := (*C.VkImageCopy)(mem4e7a1214)
	allocs4e7a1214 := new(cgoAllocMap)
	allocs4e7a1214.Add(mem4e7a1214)

	var csrcSubresource_allocs *cgoAllocMap
	ref4e7a1214.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs4e7a1214.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref4e7a1214.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs4e7a1214.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref4e7a1214.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs4e7a1214.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref4e7a1214.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs4e7a1214.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref4e7a1214.extent, cextent_allocs = x.Extent.PassValue()
	allocs4e7a1214.Borrow(cextent_allocs)

	x.ref4e7a1214 = ref4e7a1214
	x.allocs4e7a1214 = allocs4e7a1214
	return ref4e7a1214, allocs4e7a1214

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCopy) PassValue() (C.VkImageCopy, *cgoAllocMap) {
	if x.ref4e7a1214 != nil {
		return *x.ref4e7a1214, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCopy) Deref() {
	if x.ref4e7a1214 == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref4e7a1214.extent))
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// allocA2Offset3DMemory allocates memory for type [2]C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Offset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Offset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Offset3DValue = unsafe.Sizeof([1][2]C.VkOffset3D{})

// unpackA2Offset3D transforms a sliced Go data structure into plain C format.
func unpackA2Offset3D(x [2]Offset3D) (unpacked [2]C.VkOffset3D, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.VkOffset3D) {
		go allocs.Free()
	})

	mem0 := allocA2Offset3DMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.VkOffset3D)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.VkOffset3D)(mem0)
	return
}

// packA2Offset3D reads sliced Go data structure out from plain C format.
func packA2Offset3D(v *[2]Offset3D, ptr0 *[2]C.VkOffset3D) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewOffset3DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageBlit) Ref() *C.VkImageBlit {
	if x == nil {
		return nil
	}
	return x.ref11311e8d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageBlit) Free() {
	if x != nil && x.allocs11311e8d != nil {
		x.allocs11311e8d.(*cgoAllocMap).Free()
		x.ref11311e8d = nil
	}
}

// NewImageBlitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageBlitRef(ref unsafe.Pointer) *ImageBlit {
	if ref == nil {
		return nil
	}
	obj := new(ImageBlit)
	obj.ref11311e8d = (*C.VkImageBlit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageBlit) PassRef() (*C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11311e8d != nil {
		return x.ref11311e8d, nil
	}
	mem11311e8d := allocImageBlitMemory(1)
	ref11311e8d := (*C.VkImageBlit)(mem11311e8d)
	allocs11311e8d := new(cgoAllocMap)
	allocs11311e8d.Add(mem11311e8d)

	var csrcSubresource_allocs *cgoAllocMap
	ref11311e8d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs11311e8d.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref11311e8d.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs11311e8d.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref11311e8d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs11311e8d.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref11311e8d.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs11311e8d.Borrow(cdstOffsets_allocs)

	x.ref11311e8d = ref11311e8d
	x.allocs11311e8d = allocs11311e8d
	return ref11311e8d, allocs11311e8d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageBlit) PassValue() (C.VkImageBlit, *cgoAllocMap) {
	if x.ref11311e8d != nil {
		return *x.ref11311e8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageBlit) Deref() {
	if x.ref11311e8d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.srcSubresource))
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.dstSubresource))
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.dstOffsets)))
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferImageCopy) Ref() *C.VkBufferImageCopy {
	if x == nil {
		return nil
	}
	return x.ref6d50e36e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferImageCopy) Free() {
	if x != nil && x.allocs6d50e36e != nil {
		x.allocs6d50e36e.(*cgoAllocMap).Free()
		x.ref6d50e36e = nil
	}
}

// NewBufferImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferImageCopyRef(ref unsafe.Pointer) *BufferImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferImageCopy)
	obj.ref6d50e36e = (*C.VkBufferImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferImageCopy) PassRef() (*C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d50e36e != nil {
		return x.ref6d50e36e, nil
	}
	mem6d50e36e := allocBufferImageCopyMemory(1)
	ref6d50e36e := (*C.VkBufferImageCopy)(mem6d50e36e)
	allocs6d50e36e := new(cgoAllocMap)
	allocs6d50e36e.Add(mem6d50e36e)

	var cbufferOffset_allocs *cgoAllocMap
	ref6d50e36e.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref6d50e36e.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref6d50e36e.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref6d50e36e.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs6d50e36e.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref6d50e36e.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs6d50e36e.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref6d50e36e.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs6d50e36e.Borrow(cimageExtent_allocs)

	x.ref6d50e36e = ref6d50e36e
	x.allocs6d50e36e = allocs6d50e36e
	return ref6d50e36e, allocs6d50e36e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferImageCopy) PassValue() (C.VkBufferImageCopy, *cgoAllocMap) {
	if x.ref6d50e36e != nil {
		return *x.ref6d50e36e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferImageCopy) Deref() {
	if x.ref6d50e36e == nil {
		return
	}
	x.BufferOffset = (DeviceSize)(x.ref6d50e36e.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref6d50e36e.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref6d50e36e.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref6d50e36e.imageSubresource))
	x.ImageOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref6d50e36e.imageOffset))
	x.ImageExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref6d50e36e.imageExtent))
}

// allocClearDepthStencilValueMemory allocates memory for type C.VkClearDepthStencilValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearDepthStencilValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearDepthStencilValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearDepthStencilValueValue = unsafe.Sizeof([1]C.VkClearDepthStencilValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearDepthStencilValue) Ref() *C.VkClearDepthStencilValue {
	if x == nil {
		return nil
	}
	return x.refa7d07c03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearDepthStencilValue) Free() {
	if x != nil && x.allocsa7d07c03 != nil {
		x.allocsa7d07c03.(*cgoAllocMap).Free()
		x.refa7d07c03 = nil
	}
}

// NewClearDepthStencilValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearDepthStencilValueRef(ref unsafe.Pointer) *ClearDepthStencilValue {
	if ref == nil {
		return nil
	}
	obj := new(ClearDepthStencilValue)
	obj.refa7d07c03 = (*C.VkClearDepthStencilValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearDepthStencilValue) PassRef() (*C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7d07c03 != nil {
		return x.refa7d07c03, nil
	}
	mema7d07c03 := allocClearDepthStencilValueMemory(1)
	refa7d07c03 := (*C.VkClearDepthStencilValue)(mema7d07c03)
	allocsa7d07c03 := new(cgoAllocMap)
	allocsa7d07c03.Add(mema7d07c03)

	var cdepth_allocs *cgoAllocMap
	refa7d07c03.depth, cdepth_allocs = (C.float)(x.Depth), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cdepth_allocs)

	var cstencil_allocs *cgoAllocMap
	refa7d07c03.stencil, cstencil_allocs = (C.uint32_t)(x.Stencil), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cstencil_allocs)

	x.refa7d07c03 = refa7d07c03
	x.allocsa7d07c03 = allocsa7d07c03
	return refa7d07c03, allocsa7d07c03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearDepthStencilValue) PassValue() (C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x.refa7d07c03 != nil {
		return *x.refa7d07c03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearDepthStencilValue) Deref() {
	if x.refa7d07c03 == nil {
		return
	}
	x.Depth = (float32)(x.refa7d07c03.depth)
	x.Stencil = (uint32)(x.refa7d07c03.stencil)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearAttachmentRef(ref unsafe.Pointer) *ClearAttachment {
	if ref == nil {
		return nil
	}
	obj := new(ClearAttachment)
	obj.refe9150303 = (*C.VkClearAttachment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	allocse9150303.Add(meme9150303)

	var caspectMask_allocs *cgoAllocMap
	refe9150303.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocse9150303.Borrow(caspectMask_allocs)

	var ccolorAttachment_allocs *cgoAllocMap
	refe9150303.colorAttachment, ccolorAttachment_allocs = (C.uint32_t)(x.ColorAttachment), cgoAllocsUnknown
	allocse9150303.Borrow(ccolorAttachment_allocs)

	var cclearValue_allocs *cgoAllocMap
	refe9150303.clearValue, cclearValue_allocs = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue)), cgoAllocsUnknown
	allocse9150303.Borrow(cclearValue_allocs)

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearRect) Ref() *C.VkClearRect {
	if x == nil {
		return nil
	}
	return x.ref1d449c8b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearRect) Free() {
	if x != nil && x.allocs1d449c8b != nil {
		x.allocs1d449c8b.(*cgoAllocMap).Free()
		x.ref1d449c8b = nil
	}
}

// NewClearRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearRectRef(ref unsafe.Pointer) *ClearRect {
	if ref == nil {
		return nil
	}
	obj := new(ClearRect)
	obj.ref1d449c8b = (*C.VkClearRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearRect) PassRef() (*C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d449c8b != nil {
		return x.ref1d449c8b, nil
	}
	mem1d449c8b := allocClearRectMemory(1)
	ref1d449c8b := (*C.VkClearRect)(mem1d449c8b)
	allocs1d449c8b := new(cgoAllocMap)
	allocs1d449c8b.Add(mem1d449c8b)

	var crect_allocs *cgoAllocMap
	ref1d449c8b.rect, crect_allocs = x.Rect.PassValue()
	allocs1d449c8b.Borrow(crect_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref1d449c8b.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs1d449c8b.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref1d449c8b.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs1d449c8b.Borrow(clayerCount_allocs)

	x.ref1d449c8b = ref1d449c8b
	x.allocs1d449c8b = allocs1d449c8b
	return ref1d449c8b, allocs1d449c8b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearRect) PassValue() (C.VkClearRect, *cgoAllocMap) {
	if x.ref1d449c8b != nil {
		return *x.ref1d449c8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearRect) Deref() {
	if x.ref1d449c8b == nil {
		return
	}
	x.Rect = *NewRect2DRef(unsafe.Pointer(&x.ref1d449c8b.rect))
	x.BaseArrayLayer = (uint32)(x.ref1d449c8b.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref1d449c8b.layerCount)
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageResolve) Ref() *C.VkImageResolve {
	if x == nil {
		return nil
	}
	return x.ref7bda856d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageResolve) Free() {
	if x != nil && x.allocs7bda856d != nil {
		x.allocs7bda856d.(*cgoAllocMap).Free()
		x.ref7bda856d = nil
	}
}

// NewImageResolveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageResolveRef(ref unsafe.Pointer) *ImageResolve {
	if ref == nil {
		return nil
	}
	obj := new(ImageResolve)
	obj.ref7bda856d = (*C.VkImageResolve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageResolve) PassRef() (*C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bda856d != nil {
		return x.ref7bda856d, nil
	}
	mem7bda856d := allocImageResolveMemory(1)
	ref7bda856d := (*C.VkImageResolve)(mem7bda856d)
	allocs7bda856d := new(cgoAllocMap)
	allocs7bda856d.Add(mem7bda856d)

	var csrcSubresource_allocs *cgoAllocMap
	ref7bda856d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs7bda856d.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref7bda856d.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs7bda856d.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref7bda856d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs7bda856d.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref7bda856d.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs7bda856d.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref7bda856d.extent, cextent_allocs = x.Extent.PassValue()
	allocs7bda856d.Borrow(cextent_allocs)

	x.ref7bda856d = ref7bda856d
	x.allocs7bda856d = allocs7bda856d
	return ref7bda856d, allocs7bda856d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageResolve) PassValue() (C.VkImageResolve, *cgoAllocMap) {
	if x.ref7bda856d != nil {
		return *x.ref7bda856d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageResolve) Deref() {
	if x.ref7bda856d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref7bda856d.extent))
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryBarrier) Ref() *C.VkMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.ref977c944e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryBarrier) Free() {
	if x != nil && x.allocs977c944e != nil {
		x.allocs977c944e.(*cgoAllocMap).Free()
		x.ref977c944e = nil
	}
}

// NewMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryBarrierRef(ref unsafe.Pointer) *MemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(MemoryBarrier)
	obj.ref977c944e = (*C.VkMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryBarrier) PassRef() (*C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref977c944e != nil {
		return x.ref977c944e, nil
	}
	mem977c944e := allocMemoryBarrierMemory(1)
	ref977c944e := (*C.VkMemoryBarrier)(mem977c944e)
	allocs977c944e := new(cgoAllocMap)
	allocs977c944e.Add(mem977c944e)

	var csType_allocs *cgoAllocMap
	ref977c944e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs977c944e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref977c944e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs977c944e.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref977c944e.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref977c944e.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(cdstAccessMask_allocs)

	x.ref977c944e = ref977c944e
	x.allocs977c944e = allocs977c944e
	return ref977c944e, allocs977c944e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryBarrier) PassValue() (C.VkMemoryBarrier, *cgoAllocMap) {
	if x.ref977c944e != nil {
		return *x.ref977c944e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryBarrier) Deref() {
	if x.ref977c944e == nil {
		return
	}
	x.SType = (StructureType)(x.ref977c944e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref977c944e.pNext))
	x.SrcAccessMask = (AccessFlags)(x.ref977c944e.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref977c944e.dstAccessMask)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrierRef(ref unsafe.Pointer) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	allocseaf4700b.Add(memeaf4700b)

	var csType_allocs *cgoAllocMap
	refeaf4700b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaf4700b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaf4700b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refeaf4700b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refeaf4700b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf4700b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refeaf4700b.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocseaf4700b.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	refeaf4700b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocseaf4700b.Borrow(csize_allocs)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrierRef(ref unsafe.Pointer) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = (*C.VkImageMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	allocsd52734ec.Add(memd52734ec)

	var csType_allocs *cgoAllocMap
	refd52734ec.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd52734ec.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd52734ec.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd52734ec.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd52734ec.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	refd52734ec.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	refd52734ec.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	refd52734ec.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	refd52734ec.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocsd52734ec.Borrow(csubresourceRange_allocs)

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.refd52734ec.subresourceRange))
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassBeginInfoRef(ref unsafe.Pointer) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = (*C.VkRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	allocs3c3752c8.Add(mem3c3752c8)

	var csType_allocs *cgoAllocMap
	ref3c3752c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c3752c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c3752c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref3c3752c8.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(crenderPass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref3c3752c8.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cframebuffer_allocs)

	var crenderArea_allocs *cgoAllocMap
	ref3c3752c8.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocs3c3752c8.Borrow(crenderArea_allocs)

	var cclearValueCount_allocs *cgoAllocMap
	ref3c3752c8.clearValueCount, cclearValueCount_allocs = (C.uint32_t)(x.ClearValueCount), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cclearValueCount_allocs)

	var cpClearValues_allocs *cgoAllocMap
	ref3c3752c8.pClearValues, cpClearValues_allocs = (*C.VkClearValue)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PClearValues)).Data)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpClearValues_allocs)

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *NewRect2DRef(unsafe.Pointer(&x.ref3c3752c8.renderArea))
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxf1231c9.Data = unsafe.Pointer(x.ref3c3752c8.pClearValues)
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

}

// allocDispatchIndirectCommandMemory allocates memory for type C.VkDispatchIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDispatchIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDispatchIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDispatchIndirectCommandValue = unsafe.Sizeof([1]C.VkDispatchIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DispatchIndirectCommand) Ref() *C.VkDispatchIndirectCommand {
	if x == nil {
		return nil
	}
	return x.refd298ba27
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DispatchIndirectCommand) Free() {
	if x != nil && x.allocsd298ba27 != nil {
		x.allocsd298ba27.(*cgoAllocMap).Free()
		x.refd298ba27 = nil
	}
}

// NewDispatchIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDispatchIndirectCommandRef(ref unsafe.Pointer) *DispatchIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DispatchIndirectCommand)
	obj.refd298ba27 = (*C.VkDispatchIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DispatchIndirectCommand) PassRef() (*C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd298ba27 != nil {
		return x.refd298ba27, nil
	}
	memd298ba27 := allocDispatchIndirectCommandMemory(1)
	refd298ba27 := (*C.VkDispatchIndirectCommand)(memd298ba27)
	allocsd298ba27 := new(cgoAllocMap)
	allocsd298ba27.Add(memd298ba27)

	var cx_allocs *cgoAllocMap
	refd298ba27.x, cx_allocs = (C.uint32_t)(x.X), cgoAllocsUnknown
	allocsd298ba27.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd298ba27.y, cy_allocs = (C.uint32_t)(x.Y), cgoAllocsUnknown
	allocsd298ba27.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refd298ba27.z, cz_allocs = (C.uint32_t)(x.Z), cgoAllocsUnknown
	allocsd298ba27.Borrow(cz_allocs)

	x.refd298ba27 = refd298ba27
	x.allocsd298ba27 = allocsd298ba27
	return refd298ba27, allocsd298ba27

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DispatchIndirectCommand) PassValue() (C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x.refd298ba27 != nil {
		return *x.refd298ba27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DispatchIndirectCommand) Deref() {
	if x.refd298ba27 == nil {
		return
	}
	x.X = (uint32)(x.refd298ba27.x)
	x.Y = (uint32)(x.refd298ba27.y)
	x.Z = (uint32)(x.refd298ba27.z)
}

// allocDrawIndexedIndirectCommandMemory allocates memory for type C.VkDrawIndexedIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndexedIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndexedIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndexedIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndexedIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndexedIndirectCommand) Ref() *C.VkDrawIndexedIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref4c78b5c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndexedIndirectCommand) Free() {
	if x != nil && x.allocs4c78b5c3 != nil {
		x.allocs4c78b5c3.(*cgoAllocMap).Free()
		x.ref4c78b5c3 = nil
	}
}

// NewDrawIndexedIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndexedIndirectCommandRef(ref unsafe.Pointer) *DrawIndexedIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndexedIndirectCommand)
	obj.ref4c78b5c3 = (*C.VkDrawIndexedIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndexedIndirectCommand) PassRef() (*C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c78b5c3 != nil {
		return x.ref4c78b5c3, nil
	}
	mem4c78b5c3 := allocDrawIndexedIndirectCommandMemory(1)
	ref4c78b5c3 := (*C.VkDrawIndexedIndirectCommand)(mem4c78b5c3)
	allocs4c78b5c3 := new(cgoAllocMap)
	allocs4c78b5c3.Add(mem4c78b5c3)

	var cindexCount_allocs *cgoAllocMap
	ref4c78b5c3.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cindexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref4c78b5c3.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cinstanceCount_allocs)

	var cfirstIndex_allocs *cgoAllocMap
	ref4c78b5c3.firstIndex, cfirstIndex_allocs = (C.uint32_t)(x.FirstIndex), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstIndex_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref4c78b5c3.vertexOffset, cvertexOffset_allocs = (C.int32_t)(x.VertexOffset), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cvertexOffset_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref4c78b5c3.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstInstance_allocs)

	x.ref4c78b5c3 = ref4c78b5c3
	x.allocs4c78b5c3 = allocs4c78b5c3
	return ref4c78b5c3, allocs4c78b5c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndexedIndirectCommand) PassValue() (C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x.ref4c78b5c3 != nil {
		return *x.ref4c78b5c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndexedIndirectCommand) Deref() {
	if x.ref4c78b5c3 == nil {
		return
	}
	x.IndexCount = (uint32)(x.ref4c78b5c3.indexCount)
	x.InstanceCount = (uint32)(x.ref4c78b5c3.instanceCount)
	x.FirstIndex = (uint32)(x.ref4c78b5c3.firstIndex)
	x.VertexOffset = (int32)(x.ref4c78b5c3.vertexOffset)
	x.FirstInstance = (uint32)(x.ref4c78b5c3.firstInstance)
}

// allocDrawIndirectCommandMemory allocates memory for type C.VkDrawIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndirectCommand) Ref() *C.VkDrawIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref2b5b67c4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndirectCommand) Free() {
	if x != nil && x.allocs2b5b67c4 != nil {
		x.allocs2b5b67c4.(*cgoAllocMap).Free()
		x.ref2b5b67c4 = nil
	}
}

// NewDrawIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndirectCommandRef(ref unsafe.Pointer) *DrawIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndirectCommand)
	obj.ref2b5b67c4 = (*C.VkDrawIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndirectCommand) PassRef() (*C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b5b67c4 != nil {
		return x.ref2b5b67c4, nil
	}
	mem2b5b67c4 := allocDrawIndirectCommandMemory(1)
	ref2b5b67c4 := (*C.VkDrawIndirectCommand)(mem2b5b67c4)
	allocs2b5b67c4 := new(cgoAllocMap)
	allocs2b5b67c4.Add(mem2b5b67c4)

	var cvertexCount_allocs *cgoAllocMap
	ref2b5b67c4.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cvertexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref2b5b67c4.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cinstanceCount_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref2b5b67c4.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstVertex_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref2b5b67c4.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstInstance_allocs)

	x.ref2b5b67c4 = ref2b5b67c4
	x.allocs2b5b67c4 = allocs2b5b67c4
	return ref2b5b67c4, allocs2b5b67c4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndirectCommand) PassValue() (C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x.ref2b5b67c4 != nil {
		return *x.ref2b5b67c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndirectCommand) Deref() {
	if x.ref2b5b67c4 == nil {
		return
	}
	x.VertexCount = (uint32)(x.ref2b5b67c4.vertexCount)
	x.InstanceCount = (uint32)(x.ref2b5b67c4.instanceCount)
	x.FirstVertex = (uint32)(x.ref2b5b67c4.firstVertex)
	x.FirstInstance = (uint32)(x.ref2b5b67c4.firstInstance)
}

// allocBaseOutStructureMemory allocates memory for type C.VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseOutStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBaseOutStructureValue = unsafe.Sizeof([1]C.VkBaseOutStructure{})

// allocStruct_VkBaseOutStructureMemory allocates memory for type C.struct_VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseOutStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_VkBaseOutStructureValue = unsafe.Sizeof([1]C.struct_VkBaseOutStructure{})

// unpackSBaseOutStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseOutStructure(x []BaseOutStructure) (unpacked *C.struct_VkBaseOutStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_VkBaseOutStructure) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseOutStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseOutStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseOutStructure)(h.Data)
	return
}

// packSBaseOutStructure reads sliced Go data structure out from plain C format.
func packSBaseOutStructure(v []BaseOutStructure, ptr0 *C.struct_VkBaseOutStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseOutStructureValue]C.struct_VkBaseOutStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseOutStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseOutStructure) Ref() *C.VkBaseOutStructure {
	if x == nil {
		return nil
	}
	return x.refd536fcd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseOutStructure) Free() {
	if x != nil && x.allocsd536fcd0 != nil {
		x.allocsd536fcd0.(*cgoAllocMap).Free()
		x.refd536fcd0 = nil
	}
}

// NewBaseOutStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseOutStructureRef(ref unsafe.Pointer) *BaseOutStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseOutStructure)
	obj.refd536fcd0 = (*C.VkBaseOutStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseOutStructure) PassRef() (*C.VkBaseOutStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd536fcd0 != nil {
		return x.refd536fcd0, nil
	}
	memd536fcd0 := allocBaseOutStructureMemory(1)
	refd536fcd0 := (*C.VkBaseOutStructure)(memd536fcd0)
	allocsd536fcd0 := new(cgoAllocMap)
	allocsd536fcd0.Add(memd536fcd0)

	var csType_allocs *cgoAllocMap
	refd536fcd0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd536fcd0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd536fcd0.pNext, cpNext_allocs = unpackSBaseOutStructure(x.PNext)
	allocsd536fcd0.Borrow(cpNext_allocs)

	x.refd536fcd0 = refd536fcd0
	x.allocsd536fcd0 = allocsd536fcd0
	return refd536fcd0, allocsd536fcd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseOutStructure) PassValue() (C.VkBaseOutStructure, *cgoAllocMap) {
	if x.refd536fcd0 != nil {
		return *x.refd536fcd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseOutStructure) Deref() {
	if x.refd536fcd0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd536fcd0.sType)
	packSBaseOutStructure(x.PNext, x.refd536fcd0.pNext)
}

// allocBaseInStructureMemory allocates memory for type C.VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseInStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBaseInStructureValue = unsafe.Sizeof([1]C.VkBaseInStructure{})

// allocStruct_VkBaseInStructureMemory allocates memory for type C.struct_VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseInStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_VkBaseInStructureValue = unsafe.Sizeof([1]C.struct_VkBaseInStructure{})

// unpackSBaseInStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseInStructure(x []BaseInStructure) (unpacked *C.struct_VkBaseInStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_VkBaseInStructure) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseInStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseInStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseInStructure)(h.Data)
	return
}

// packSBaseInStructure reads sliced Go data structure out from plain C format.
func packSBaseInStructure(v []BaseInStructure, ptr0 *C.struct_VkBaseInStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseInStructureValue]C.struct_VkBaseInStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseInStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseInStructure) Ref() *C.VkBaseInStructure {
	if x == nil {
		return nil
	}
	return x.refeae401a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseInStructure) Free() {
	if x != nil && x.allocseae401a9 != nil {
		x.allocseae401a9.(*cgoAllocMap).Free()
		x.refeae401a9 = nil
	}
}

// NewBaseInStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseInStructureRef(ref unsafe.Pointer) *BaseInStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseInStructure)
	obj.refeae401a9 = (*C.VkBaseInStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseInStructure) PassRef() (*C.VkBaseInStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeae401a9 != nil {
		return x.refeae401a9, nil
	}
	memeae401a9 := allocBaseInStructureMemory(1)
	refeae401a9 := (*C.VkBaseInStructure)(memeae401a9)
	allocseae401a9 := new(cgoAllocMap)
	allocseae401a9.Add(memeae401a9)

	var csType_allocs *cgoAllocMap
	refeae401a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseae401a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeae401a9.pNext, cpNext_allocs = unpackSBaseInStructure(x.PNext)
	allocseae401a9.Borrow(cpNext_allocs)

	x.refeae401a9 = refeae401a9
	x.allocseae401a9 = allocseae401a9
	return refeae401a9, allocseae401a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseInStructure) PassValue() (C.VkBaseInStructure, *cgoAllocMap) {
	if x.refeae401a9 != nil {
		return *x.refeae401a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseInStructure) Deref() {
	if x.refeae401a9 == nil {
		return
	}
	x.SType = (StructureType)(x.refeae401a9.sType)
	packSBaseInStructure(x.PNext, x.refeae401a9.pNext)
}

// allocPhysicalDeviceSubgroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceSubgroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSubgroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSubgroupPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSubgroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSubgroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSubgroupProperties) Ref() *C.VkPhysicalDeviceSubgroupProperties {
	if x == nil {
		return nil
	}
	return x.refb019c29f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	if x != nil && x.allocsb019c29f != nil {
		x.allocsb019c29f.(*cgoAllocMap).Free()
		x.refb019c29f = nil
	}
}

// NewPhysicalDeviceSubgroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSubgroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSubgroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSubgroupProperties)
	obj.refb019c29f = (*C.VkPhysicalDeviceSubgroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSubgroupProperties) PassRef() (*C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb019c29f != nil {
		return x.refb019c29f, nil
	}
	memb019c29f := allocPhysicalDeviceSubgroupPropertiesMemory(1)
	refb019c29f := (*C.VkPhysicalDeviceSubgroupProperties)(memb019c29f)
	allocsb019c29f := new(cgoAllocMap)
	allocsb019c29f.Add(memb019c29f)

	var csType_allocs *cgoAllocMap
	refb019c29f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb019c29f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb019c29f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb019c29f.Borrow(cpNext_allocs)

	var csubgroupSize_allocs *cgoAllocMap
	refb019c29f.subgroupSize, csubgroupSize_allocs = (C.uint32_t)(x.SubgroupSize), cgoAllocsUnknown
	allocsb019c29f.Borrow(csubgroupSize_allocs)

	var csupportedStages_allocs *cgoAllocMap
	refb019c29f.supportedStages, csupportedStages_allocs = (C.VkShaderStageFlags)(x.SupportedStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedStages_allocs)

	var csupportedOperations_allocs *cgoAllocMap
	refb019c29f.supportedOperations, csupportedOperations_allocs = (C.VkSubgroupFeatureFlags)(x.SupportedOperations), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedOperations_allocs)

	var cquadOperationsInAllStages_allocs *cgoAllocMap
	refb019c29f.quadOperationsInAllStages, cquadOperationsInAllStages_allocs = (C.VkBool32)(x.QuadOperationsInAllStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(cquadOperationsInAllStages_allocs)

	x.refb019c29f = refb019c29f
	x.allocsb019c29f = allocsb019c29f
	return refb019c29f, allocsb019c29f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSubgroupProperties) PassValue() (C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x.refb019c29f != nil {
		return *x.refb019c29f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSubgroupProperties) Deref() {
	if x.refb019c29f == nil {
		return
	}
	x.SType = (StructureType)(x.refb019c29f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb019c29f.pNext))
	x.SubgroupSize = (uint32)(x.refb019c29f.subgroupSize)
	x.SupportedStages = (ShaderStageFlags)(x.refb019c29f.supportedStages)
	x.SupportedOperations = (SubgroupFeatureFlags)(x.refb019c29f.supportedOperations)
	x.QuadOperationsInAllStages = (Bool32)(x.refb019c29f.quadOperationsInAllStages)
}

// allocBindBufferMemoryInfoMemory allocates memory for type C.VkBindBufferMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindBufferMemoryInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryInfo) Ref() *C.VkBindBufferMemoryInfo {
	if x == nil {
		return nil
	}
	return x.refd392322d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryInfo) Free() {
	if x != nil && x.allocsd392322d != nil {
		x.allocsd392322d.(*cgoAllocMap).Free()
		x.refd392322d = nil
	}
}

// NewBindBufferMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryInfoRef(ref unsafe.Pointer) *BindBufferMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryInfo)
	obj.refd392322d = (*C.VkBindBufferMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryInfo) PassRef() (*C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd392322d != nil {
		return x.refd392322d, nil
	}
	memd392322d := allocBindBufferMemoryInfoMemory(1)
	refd392322d := (*C.VkBindBufferMemoryInfo)(memd392322d)
	allocsd392322d := new(cgoAllocMap)
	allocsd392322d.Add(memd392322d)

	var csType_allocs *cgoAllocMap
	refd392322d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd392322d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd392322d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd392322d.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd392322d.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd392322d.Borrow(cbuffer_allocs)

	var cmemory_allocs *cgoAllocMap
	refd392322d.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	refd392322d.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemoryOffset_allocs)

	x.refd392322d = refd392322d
	x.allocsd392322d = allocsd392322d
	return refd392322d, allocsd392322d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryInfo) PassValue() (C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x.refd392322d != nil {
		return *x.refd392322d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryInfo) Deref() {
	if x.refd392322d == nil {
		return
	}
	x.SType = (StructureType)(x.refd392322d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd392322d.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refd392322d.buffer))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refd392322d.memory))
	x.MemoryOffset = (DeviceSize)(x.refd392322d.memoryOffset)
}

// allocBindImageMemoryInfoMemory allocates memory for type C.VkBindImageMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryInfo) Ref() *C.VkBindImageMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref767a2113
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryInfo) Free() {
	if x != nil && x.allocs767a2113 != nil {
		x.allocs767a2113.(*cgoAllocMap).Free()
		x.ref767a2113 = nil
	}
}

// NewBindImageMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryInfoRef(ref unsafe.Pointer) *BindImageMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryInfo)
	obj.ref767a2113 = (*C.VkBindImageMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryInfo) PassRef() (*C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref767a2113 != nil {
		return x.ref767a2113, nil
	}
	mem767a2113 := allocBindImageMemoryInfoMemory(1)
	ref767a2113 := (*C.VkBindImageMemoryInfo)(mem767a2113)
	allocs767a2113 := new(cgoAllocMap)
	allocs767a2113.Add(mem767a2113)

	var csType_allocs *cgoAllocMap
	ref767a2113.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs767a2113.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref767a2113.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs767a2113.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref767a2113.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs767a2113.Borrow(cimage_allocs)

	var cmemory_allocs *cgoAllocMap
	ref767a2113.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref767a2113.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemoryOffset_allocs)

	x.ref767a2113 = ref767a2113
	x.allocs767a2113 = allocs767a2113
	return ref767a2113, allocs767a2113

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryInfo) PassValue() (C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x.ref767a2113 != nil {
		return *x.ref767a2113, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryInfo) Deref() {
	if x.ref767a2113 == nil {
		return
	}
	x.SType = (StructureType)(x.ref767a2113.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref767a2113.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref767a2113.image))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref767a2113.memory))
	x.MemoryOffset = (DeviceSize)(x.ref767a2113.memoryOffset)
}

// allocPhysicalDevice16BitStorageFeaturesMemory allocates memory for type C.VkPhysicalDevice16BitStorageFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice16BitStorageFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice16BitStorageFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevice16BitStorageFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice16BitStorageFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice16BitStorageFeatures) Ref() *C.VkPhysicalDevice16BitStorageFeatures {
	if x == nil {
		return nil
	}
	return x.refa90fed14
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	if x != nil && x.allocsa90fed14 != nil {
		x.allocsa90fed14.(*cgoAllocMap).Free()
		x.refa90fed14 = nil
	}
}

// NewPhysicalDevice16BitStorageFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice16BitStorageFeaturesRef(ref unsafe.Pointer) *PhysicalDevice16BitStorageFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice16BitStorageFeatures)
	obj.refa90fed14 = (*C.VkPhysicalDevice16BitStorageFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice16BitStorageFeatures) PassRef() (*C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa90fed14 != nil {
		return x.refa90fed14, nil
	}
	mema90fed14 := allocPhysicalDevice16BitStorageFeaturesMemory(1)
	refa90fed14 := (*C.VkPhysicalDevice16BitStorageFeatures)(mema90fed14)
	allocsa90fed14 := new(cgoAllocMap)
	allocsa90fed14.Add(mema90fed14)

	var csType_allocs *cgoAllocMap
	refa90fed14.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa90fed14.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa90fed14.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa90fed14.Borrow(cpNext_allocs)

	var cstorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.storageBuffer16BitAccess, cstorageBuffer16BitAccess_allocs = (C.VkBool32)(x.StorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageBuffer16BitAccess_allocs)

	var cuniformAndStorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.uniformAndStorageBuffer16BitAccess, cuniformAndStorageBuffer16BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cuniformAndStorageBuffer16BitAccess_allocs)

	var cstoragePushConstant16_allocs *cgoAllocMap
	refa90fed14.storagePushConstant16, cstoragePushConstant16_allocs = (C.VkBool32)(x.StoragePushConstant16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstoragePushConstant16_allocs)

	var cstorageInputOutput16_allocs *cgoAllocMap
	refa90fed14.storageInputOutput16, cstorageInputOutput16_allocs = (C.VkBool32)(x.StorageInputOutput16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageInputOutput16_allocs)

	x.refa90fed14 = refa90fed14
	x.allocsa90fed14 = allocsa90fed14
	return refa90fed14, allocsa90fed14

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) PassValue() (C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x.refa90fed14 != nil {
		return *x.refa90fed14, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice16BitStorageFeatures) Deref() {
	if x.refa90fed14 == nil {
		return
	}
	x.SType = (StructureType)(x.refa90fed14.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa90fed14.pNext))
	x.StorageBuffer16BitAccess = (Bool32)(x.refa90fed14.storageBuffer16BitAccess)
	x.UniformAndStorageBuffer16BitAccess = (Bool32)(x.refa90fed14.uniformAndStorageBuffer16BitAccess)
	x.StoragePushConstant16 = (Bool32)(x.refa90fed14.storagePushConstant16)
	x.StorageInputOutput16 = (Bool32)(x.refa90fed14.storageInputOutput16)
}

// allocMemoryDedicatedRequirementsMemory allocates memory for type C.VkMemoryDedicatedRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryDedicatedRequirementsValue = unsafe.Sizeof([1]C.VkMemoryDedicatedRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedRequirements) Ref() *C.VkMemoryDedicatedRequirements {
	if x == nil {
		return nil
	}
	return x.refaa924122
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedRequirements) Free() {
	if x != nil && x.allocsaa924122 != nil {
		x.allocsaa924122.(*cgoAllocMap).Free()
		x.refaa924122 = nil
	}
}

// NewMemoryDedicatedRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedRequirementsRef(ref unsafe.Pointer) *MemoryDedicatedRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedRequirements)
	obj.refaa924122 = (*C.VkMemoryDedicatedRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedRequirements) PassRef() (*C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa924122 != nil {
		return x.refaa924122, nil
	}
	memaa924122 := allocMemoryDedicatedRequirementsMemory(1)
	refaa924122 := (*C.VkMemoryDedicatedRequirements)(memaa924122)
	allocsaa924122 := new(cgoAllocMap)
	allocsaa924122.Add(memaa924122)

	var csType_allocs *cgoAllocMap
	refaa924122.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaa924122.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaa924122.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaa924122.Borrow(cpNext_allocs)

	var cprefersDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.prefersDedicatedAllocation, cprefersDedicatedAllocation_allocs = (C.VkBool32)(x.PrefersDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(cprefersDedicatedAllocation_allocs)

	var crequiresDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.requiresDedicatedAllocation, crequiresDedicatedAllocation_allocs = (C.VkBool32)(x.RequiresDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(crequiresDedicatedAllocation_allocs)

	x.refaa924122 = refaa924122
	x.allocsaa924122 = allocsaa924122
	return refaa924122, allocsaa924122

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedRequirements) PassValue() (C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x.refaa924122 != nil {
		return *x.refaa924122, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedRequirements) Deref() {
	if x.refaa924122 == nil {
		return
	}
	x.SType = (StructureType)(x.refaa924122.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaa924122.pNext))
	x.PrefersDedicatedAllocation = (Bool32)(x.refaa924122.prefersDedicatedAllocation)
	x.RequiresDedicatedAllocation = (Bool32)(x.refaa924122.requiresDedicatedAllocation)
}

// allocMemoryDedicatedAllocateInfoMemory allocates memory for type C.VkMemoryDedicatedAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryDedicatedAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryDedicatedAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedAllocateInfo) Ref() *C.VkMemoryDedicatedAllocateInfo {
	if x == nil {
		return nil
	}
	return x.reff8fabe62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedAllocateInfo) Free() {
	if x != nil && x.allocsf8fabe62 != nil {
		x.allocsf8fabe62.(*cgoAllocMap).Free()
		x.reff8fabe62 = nil
	}
}

// NewMemoryDedicatedAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedAllocateInfoRef(ref unsafe.Pointer) *MemoryDedicatedAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedAllocateInfo)
	obj.reff8fabe62 = (*C.VkMemoryDedicatedAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedAllocateInfo) PassRef() (*C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fabe62 != nil {
		return x.reff8fabe62, nil
	}
	memf8fabe62 := allocMemoryDedicatedAllocateInfoMemory(1)
	reff8fabe62 := (*C.VkMemoryDedicatedAllocateInfo)(memf8fabe62)
	allocsf8fabe62 := new(cgoAllocMap)
	allocsf8fabe62.Add(memf8fabe62)

	var csType_allocs *cgoAllocMap
	reff8fabe62.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf8fabe62.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff8fabe62.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	reff8fabe62.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff8fabe62.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cbuffer_allocs)

	x.reff8fabe62 = reff8fabe62
	x.allocsf8fabe62 = allocsf8fabe62
	return reff8fabe62, allocsf8fabe62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedAllocateInfo) PassValue() (C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x.reff8fabe62 != nil {
		return *x.reff8fabe62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedAllocateInfo) Deref() {
	if x.reff8fabe62 == nil {
		return
	}
	x.SType = (StructureType)(x.reff8fabe62.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff8fabe62.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.reff8fabe62.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff8fabe62.buffer))
}

// allocMemoryAllocateFlagsInfoMemory allocates memory for type C.VkMemoryAllocateFlagsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateFlagsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateFlagsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateFlagsInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateFlagsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateFlagsInfo) Ref() *C.VkMemoryAllocateFlagsInfo {
	if x == nil {
		return nil
	}
	return x.ref7ca6664
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateFlagsInfo) Free() {
	if x != nil && x.allocs7ca6664 != nil {
		x.allocs7ca6664.(*cgoAllocMap).Free()
		x.ref7ca6664 = nil
	}
}

// NewMemoryAllocateFlagsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateFlagsInfoRef(ref unsafe.Pointer) *MemoryAllocateFlagsInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateFlagsInfo)
	obj.ref7ca6664 = (*C.VkMemoryAllocateFlagsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateFlagsInfo) PassRef() (*C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ca6664 != nil {
		return x.ref7ca6664, nil
	}
	mem7ca6664 := allocMemoryAllocateFlagsInfoMemory(1)
	ref7ca6664 := (*C.VkMemoryAllocateFlagsInfo)(mem7ca6664)
	allocs7ca6664 := new(cgoAllocMap)
	allocs7ca6664.Add(mem7ca6664)

	var csType_allocs *cgoAllocMap
	ref7ca6664.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ca6664.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ca6664.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ca6664.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7ca6664.flags, cflags_allocs = (C.VkMemoryAllocateFlags)(x.Flags), cgoAllocsUnknown
	allocs7ca6664.Borrow(cflags_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref7ca6664.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs7ca6664.Borrow(cdeviceMask_allocs)

	x.ref7ca6664 = ref7ca6664
	x.allocs7ca6664 = allocs7ca6664
	return ref7ca6664, allocs7ca6664

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateFlagsInfo) PassValue() (C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x.ref7ca6664 != nil {
		return *x.ref7ca6664, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateFlagsInfo) Deref() {
	if x.ref7ca6664 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ca6664.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ca6664.pNext))
	x.Flags = (MemoryAllocateFlags)(x.ref7ca6664.flags)
	x.DeviceMask = (uint32)(x.ref7ca6664.deviceMask)
}

// allocDeviceGroupRenderPassBeginInfoMemory allocates memory for type C.VkDeviceGroupRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupRenderPassBeginInfo) Ref() *C.VkDeviceGroupRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref139f3599
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	if x != nil && x.allocs139f3599 != nil {
		x.allocs139f3599.(*cgoAllocMap).Free()
		x.ref139f3599 = nil
	}
}

// NewDeviceGroupRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupRenderPassBeginInfoRef(ref unsafe.Pointer) *DeviceGroupRenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupRenderPassBeginInfo)
	obj.ref139f3599 = (*C.VkDeviceGroupRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupRenderPassBeginInfo) PassRef() (*C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref139f3599 != nil {
		return x.ref139f3599, nil
	}
	mem139f3599 := allocDeviceGroupRenderPassBeginInfoMemory(1)
	ref139f3599 := (*C.VkDeviceGroupRenderPassBeginInfo)(mem139f3599)
	allocs139f3599 := new(cgoAllocMap)
	allocs139f3599.Add(mem139f3599)

	var csType_allocs *cgoAllocMap
	ref139f3599.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs139f3599.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref139f3599.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs139f3599.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref139f3599.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceMask_allocs)

	var cdeviceRenderAreaCount_allocs *cgoAllocMap
	ref139f3599.deviceRenderAreaCount, cdeviceRenderAreaCount_allocs = (C.uint32_t)(x.DeviceRenderAreaCount), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceRenderAreaCount_allocs)

	var cpDeviceRenderAreas_allocs *cgoAllocMap
	ref139f3599.pDeviceRenderAreas, cpDeviceRenderAreas_allocs = unpackSRect2D(x.PDeviceRenderAreas)
	allocs139f3599.Borrow(cpDeviceRenderAreas_allocs)

	x.ref139f3599 = ref139f3599
	x.allocs139f3599 = allocs139f3599
	return ref139f3599, allocs139f3599

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) PassValue() (C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref139f3599 != nil {
		return *x.ref139f3599, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupRenderPassBeginInfo) Deref() {
	if x.ref139f3599 == nil {
		return
	}
	x.SType = (StructureType)(x.ref139f3599.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref139f3599.pNext))
	x.DeviceMask = (uint32)(x.ref139f3599.deviceMask)
	x.DeviceRenderAreaCount = (uint32)(x.ref139f3599.deviceRenderAreaCount)
	packSRect2D(x.PDeviceRenderAreas, x.ref139f3599.pDeviceRenderAreas)
}

// allocDeviceGroupCommandBufferBeginInfoMemory allocates memory for type C.VkDeviceGroupCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupCommandBufferBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupCommandBufferBeginInfo) Ref() *C.VkDeviceGroupCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.refb9a8f0cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	if x != nil && x.allocsb9a8f0cd != nil {
		x.allocsb9a8f0cd.(*cgoAllocMap).Free()
		x.refb9a8f0cd = nil
	}
}

// NewDeviceGroupCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupCommandBufferBeginInfoRef(ref unsafe.Pointer) *DeviceGroupCommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupCommandBufferBeginInfo)
	obj.refb9a8f0cd = (*C.VkDeviceGroupCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) PassRef() (*C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9a8f0cd != nil {
		return x.refb9a8f0cd, nil
	}
	memb9a8f0cd := allocDeviceGroupCommandBufferBeginInfoMemory(1)
	refb9a8f0cd := (*C.VkDeviceGroupCommandBufferBeginInfo)(memb9a8f0cd)
	allocsb9a8f0cd := new(cgoAllocMap)
	allocsb9a8f0cd.Add(memb9a8f0cd)

	var csType_allocs *cgoAllocMap
	refb9a8f0cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb9a8f0cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	refb9a8f0cd.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cdeviceMask_allocs)

	x.refb9a8f0cd = refb9a8f0cd
	x.allocsb9a8f0cd = allocsb9a8f0cd
	return refb9a8f0cd, allocsb9a8f0cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) PassValue() (C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x.refb9a8f0cd != nil {
		return *x.refb9a8f0cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupCommandBufferBeginInfo) Deref() {
	if x.refb9a8f0cd == nil {
		return
	}
	x.SType = (StructureType)(x.refb9a8f0cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb9a8f0cd.pNext))
	x.DeviceMask = (uint32)(x.refb9a8f0cd.deviceMask)
}

// allocDeviceGroupSubmitInfoMemory allocates memory for type C.VkDeviceGroupSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupSubmitInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSubmitInfo) Ref() *C.VkDeviceGroupSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refea4e7ce4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSubmitInfo) Free() {
	if x != nil && x.allocsea4e7ce4 != nil {
		x.allocsea4e7ce4.(*cgoAllocMap).Free()
		x.refea4e7ce4 = nil
	}
}

// NewDeviceGroupSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSubmitInfoRef(ref unsafe.Pointer) *DeviceGroupSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSubmitInfo)
	obj.refea4e7ce4 = (*C.VkDeviceGroupSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSubmitInfo) PassRef() (*C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea4e7ce4 != nil {
		return x.refea4e7ce4, nil
	}
	memea4e7ce4 := allocDeviceGroupSubmitInfoMemory(1)
	refea4e7ce4 := (*C.VkDeviceGroupSubmitInfo)(memea4e7ce4)
	allocsea4e7ce4 := new(cgoAllocMap)
	allocsea4e7ce4.Add(memea4e7ce4)

	var csType_allocs *cgoAllocMap
	refea4e7ce4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea4e7ce4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pWaitSemaphoreDeviceIndices, cpWaitSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpWaitSemaphoreDeviceIndices_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refea4e7ce4.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(ccommandBufferCount_allocs)

	var cpCommandBufferDeviceMasks_allocs *cgoAllocMap
	refea4e7ce4.pCommandBufferDeviceMasks, cpCommandBufferDeviceMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpCommandBufferDeviceMasks_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pSignalSemaphoreDeviceIndices, cpSignalSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpSignalSemaphoreDeviceIndices_allocs)

	x.refea4e7ce4 = refea4e7ce4
	x.allocsea4e7ce4 = allocsea4e7ce4
	return refea4e7ce4, allocsea4e7ce4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSubmitInfo) PassValue() (C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x.refea4e7ce4 != nil {
		return *x.refea4e7ce4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSubmitInfo) Deref() {
	if x.refea4e7ce4 == nil {
		return
	}
	x.SType = (StructureType)(x.refea4e7ce4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea4e7ce4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refea4e7ce4.waitSemaphoreCount)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices))
	hxf04b15b.Data = unsafe.Pointer(x.refea4e7ce4.pWaitSemaphoreDeviceIndices)
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ?

	x.CommandBufferCount = (uint32)(x.refea4e7ce4.commandBufferCount)
	hxf2f888b := (*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks))
	hxf2f888b.Data = unsafe.Pointer(x.refea4e7ce4.pCommandBufferDeviceMasks)
	hxf2f888b.Cap = 0x7fffffff
	// hxf2f888b.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.refea4e7ce4.signalSemaphoreCount)
	hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices))
	hxf5d1de2.Data = unsafe.Pointer(x.refea4e7ce4.pSignalSemaphoreDeviceIndices)
	hxf5d1de2.Cap = 0x7fffffff
	// hxf5d1de2.Len = ?

}

// allocDeviceGroupBindSparseInfoMemory allocates memory for type C.VkDeviceGroupBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupBindSparseInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupBindSparseInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupBindSparseInfo) Ref() *C.VkDeviceGroupBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.ref5b5446cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupBindSparseInfo) Free() {
	if x != nil && x.allocs5b5446cd != nil {
		x.allocs5b5446cd.(*cgoAllocMap).Free()
		x.ref5b5446cd = nil
	}
}

// NewDeviceGroupBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupBindSparseInfoRef(ref unsafe.Pointer) *DeviceGroupBindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupBindSparseInfo)
	obj.ref5b5446cd = (*C.VkDeviceGroupBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupBindSparseInfo) PassRef() (*C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b5446cd != nil {
		return x.ref5b5446cd, nil
	}
	mem5b5446cd := allocDeviceGroupBindSparseInfoMemory(1)
	ref5b5446cd := (*C.VkDeviceGroupBindSparseInfo)(mem5b5446cd)
	allocs5b5446cd := new(cgoAllocMap)
	allocs5b5446cd.Add(mem5b5446cd)

	var csType_allocs *cgoAllocMap
	ref5b5446cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5b5446cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5b5446cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cpNext_allocs)

	var cresourceDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.resourceDeviceIndex, cresourceDeviceIndex_allocs = (C.uint32_t)(x.ResourceDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cresourceDeviceIndex_allocs)

	var cmemoryDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.memoryDeviceIndex, cmemoryDeviceIndex_allocs = (C.uint32_t)(x.MemoryDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cmemoryDeviceIndex_allocs)

	x.ref5b5446cd = ref5b5446cd
	x.allocs5b5446cd = allocs5b5446cd
	return ref5b5446cd, allocs5b5446cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupBindSparseInfo) PassValue() (C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x.ref5b5446cd != nil {
		return *x.ref5b5446cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupBindSparseInfo) Deref() {
	if x.ref5b5446cd == nil {
		return
	}
	x.SType = (StructureType)(x.ref5b5446cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5b5446cd.pNext))
	x.ResourceDeviceIndex = (uint32)(x.ref5b5446cd.resourceDeviceIndex)
	x.MemoryDeviceIndex = (uint32)(x.ref5b5446cd.memoryDeviceIndex)
}

// allocBindBufferMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindBufferMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryDeviceGroupInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindBufferMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryDeviceGroupInfo) Ref() *C.VkBindBufferMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.reff136b64f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocsf136b64f != nil {
		x.allocsf136b64f.(*cgoAllocMap).Free()
		x.reff136b64f = nil
	}
}

// NewBindBufferMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindBufferMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryDeviceGroupInfo)
	obj.reff136b64f = (*C.VkBindBufferMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) PassRef() (*C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff136b64f != nil {
		return x.reff136b64f, nil
	}
	memf136b64f := allocBindBufferMemoryDeviceGroupInfoMemory(1)
	reff136b64f := (*C.VkBindBufferMemoryDeviceGroupInfo)(memf136b64f)
	allocsf136b64f := new(cgoAllocMap)
	allocsf136b64f.Add(memf136b64f)

	var csType_allocs *cgoAllocMap
	reff136b64f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf136b64f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff136b64f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	reff136b64f.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocsf136b64f.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	reff136b64f.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpDeviceIndices_allocs)

	x.reff136b64f = reff136b64f
	x.allocsf136b64f = allocsf136b64f
	return reff136b64f, allocsf136b64f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) PassValue() (C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.reff136b64f != nil {
		return *x.reff136b64f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryDeviceGroupInfo) Deref() {
	if x.reff136b64f == nil {
		return
	}
	x.SType = (StructureType)(x.reff136b64f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff136b64f.pNext))
	x.DeviceIndexCount = (uint32)(x.reff136b64f.deviceIndexCount)
	hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxfe53d34.Data = unsafe.Pointer(x.reff136b64f.pDeviceIndices)
	hxfe53d34.Cap = 0x7fffffff
	// hxfe53d34.Len = ?

}

// allocBindImageMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindImageMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryDeviceGroupInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryDeviceGroupInfo) Ref() *C.VkBindImageMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.ref24f026a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocs24f026a5 != nil {
		x.allocs24f026a5.(*cgoAllocMap).Free()
		x.ref24f026a5 = nil
	}
}

// NewBindImageMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindImageMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryDeviceGroupInfo)
	obj.ref24f026a5 = (*C.VkBindImageMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryDeviceGroupInfo) PassRef() (*C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f026a5 != nil {
		return x.ref24f026a5, nil
	}
	mem24f026a5 := allocBindImageMemoryDeviceGroupInfoMemory(1)
	ref24f026a5 := (*C.VkBindImageMemoryDeviceGroupInfo)(mem24f026a5)
	allocs24f026a5 := new(cgoAllocMap)
	allocs24f026a5.Add(mem24f026a5)

	var csType_allocs *cgoAllocMap
	ref24f026a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs24f026a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref24f026a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	ref24f026a5.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	ref24f026a5.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpDeviceIndices_allocs)

	var csplitInstanceBindRegionCount_allocs *cgoAllocMap
	ref24f026a5.splitInstanceBindRegionCount, csplitInstanceBindRegionCount_allocs = (C.uint32_t)(x.SplitInstanceBindRegionCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(csplitInstanceBindRegionCount_allocs)

	var cpSplitInstanceBindRegions_allocs *cgoAllocMap
	ref24f026a5.pSplitInstanceBindRegions, cpSplitInstanceBindRegions_allocs = unpackSRect2D(x.PSplitInstanceBindRegions)
	allocs24f026a5.Borrow(cpSplitInstanceBindRegions_allocs)

	x.ref24f026a5 = ref24f026a5
	x.allocs24f026a5 = allocs24f026a5
	return ref24f026a5, allocs24f026a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) PassValue() (C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.ref24f026a5 != nil {
		return *x.ref24f026a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryDeviceGroupInfo) Deref() {
	if x.ref24f026a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f026a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f026a5.pNext))
	x.DeviceIndexCount = (uint32)(x.ref24f026a5.deviceIndexCount)
	hxf547023 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf547023.Data = unsafe.Pointer(x.ref24f026a5.pDeviceIndices)
	hxf547023.Cap = 0x7fffffff
	// hxf547023.Len = ?

	x.SplitInstanceBindRegionCount = (uint32)(x.ref24f026a5.splitInstanceBindRegionCount)
	packSRect2D(x.PSplitInstanceBindRegions, x.ref24f026a5.pSplitInstanceBindRegions)
}

// allocPhysicalDeviceGroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceGroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceGroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceGroupPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceGroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceGroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceGroupProperties) Ref() *C.VkPhysicalDeviceGroupProperties {
	if x == nil {
		return nil
	}
	return x.ref2aa9a663
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceGroupProperties) Free() {
	if x != nil && x.allocs2aa9a663 != nil {
		x.allocs2aa9a663.(*cgoAllocMap).Free()
		x.ref2aa9a663 = nil
	}
}

// NewPhysicalDeviceGroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceGroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceGroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceGroupProperties)
	obj.ref2aa9a663 = (*C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceGroupProperties) PassRef() (*C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa9a663 != nil {
		return x.ref2aa9a663, nil
	}
	mem2aa9a663 := allocPhysicalDeviceGroupPropertiesMemory(1)
	ref2aa9a663 := (*C.VkPhysicalDeviceGroupProperties)(mem2aa9a663)
	allocs2aa9a663 := new(cgoAllocMap)
	allocs2aa9a663.Add(mem2aa9a663)

	var csType_allocs *cgoAllocMap
	ref2aa9a663.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2aa9a663.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	ref2aa9a663.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDeviceCount_allocs)

	var cphysicalDevices_allocs *cgoAllocMap
	ref2aa9a663.physicalDevices, cphysicalDevices_allocs = *(*[32]C.VkPhysicalDevice)(unsafe.Pointer(&x.PhysicalDevices)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDevices_allocs)

	var csubsetAllocation_allocs *cgoAllocMap
	ref2aa9a663.subsetAllocation, csubsetAllocation_allocs = (C.VkBool32)(x.SubsetAllocation), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csubsetAllocation_allocs)

	x.ref2aa9a663 = ref2aa9a663
	x.allocs2aa9a663 = allocs2aa9a663
	return ref2aa9a663, allocs2aa9a663

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceGroupProperties) PassValue() (C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x.ref2aa9a663 != nil {
		return *x.ref2aa9a663, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceGroupProperties) Deref() {
	if x.ref2aa9a663 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2aa9a663.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2aa9a663.pNext))
	x.PhysicalDeviceCount = (uint32)(x.ref2aa9a663.physicalDeviceCount)
	x.PhysicalDevices = *(*[32]PhysicalDevice)(unsafe.Pointer(&x.ref2aa9a663.physicalDevices))
	x.SubsetAllocation = (Bool32)(x.ref2aa9a663.subsetAllocation)
}

// allocDeviceGroupDeviceCreateInfoMemory allocates memory for type C.VkDeviceGroupDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupDeviceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupDeviceCreateInfo) Ref() *C.VkDeviceGroupDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb2275723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	if x != nil && x.allocsb2275723 != nil {
		x.allocsb2275723.(*cgoAllocMap).Free()
		x.refb2275723 = nil
	}
}

// NewDeviceGroupDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceGroupDeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupDeviceCreateInfo)
	obj.refb2275723 = (*C.VkDeviceGroupDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupDeviceCreateInfo) PassRef() (*C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2275723 != nil {
		return x.refb2275723, nil
	}
	memb2275723 := allocDeviceGroupDeviceCreateInfoMemory(1)
	refb2275723 := (*C.VkDeviceGroupDeviceCreateInfo)(memb2275723)
	allocsb2275723 := new(cgoAllocMap)
	allocsb2275723.Add(memb2275723)

	var csType_allocs *cgoAllocMap
	refb2275723.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2275723.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2275723.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	refb2275723.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocsb2275723.Borrow(cphysicalDeviceCount_allocs)

	var cpPhysicalDevices_allocs *cgoAllocMap
	refb2275723.pPhysicalDevices, cpPhysicalDevices_allocs = (*C.VkPhysicalDevice)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices)).Data)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpPhysicalDevices_allocs)

	x.refb2275723 = refb2275723
	x.allocsb2275723 = allocsb2275723
	return refb2275723, allocsb2275723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupDeviceCreateInfo) PassValue() (C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x.refb2275723 != nil {
		return *x.refb2275723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupDeviceCreateInfo) Deref() {
	if x.refb2275723 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2275723.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2275723.pNext))
	x.PhysicalDeviceCount = (uint32)(x.refb2275723.physicalDeviceCount)
	hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices))
	hxf5ebb88.Data = unsafe.Pointer(x.refb2275723.pPhysicalDevices)
	hxf5ebb88.Cap = 0x7fffffff
	// hxf5ebb88.Len = ?

}

// allocBufferMemoryRequirementsInfo2Memory allocates memory for type C.VkBufferMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkBufferMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryRequirementsInfo2) Ref() *C.VkBufferMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.reff54a2a42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocsf54a2a42 != nil {
		x.allocsf54a2a42.(*cgoAllocMap).Free()
		x.reff54a2a42 = nil
	}
}

// NewBufferMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *BufferMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryRequirementsInfo2)
	obj.reff54a2a42 = (*C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryRequirementsInfo2) PassRef() (*C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff54a2a42 != nil {
		return x.reff54a2a42, nil
	}
	memf54a2a42 := allocBufferMemoryRequirementsInfo2Memory(1)
	reff54a2a42 := (*C.VkBufferMemoryRequirementsInfo2)(memf54a2a42)
	allocsf54a2a42 := new(cgoAllocMap)
	allocsf54a2a42.Add(memf54a2a42)

	var csType_allocs *cgoAllocMap
	reff54a2a42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf54a2a42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff54a2a42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff54a2a42.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cbuffer_allocs)

	x.reff54a2a42 = reff54a2a42
	x.allocsf54a2a42 = allocsf54a2a42
	return reff54a2a42, allocsf54a2a42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryRequirementsInfo2) PassValue() (C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.reff54a2a42 != nil {
		return *x.reff54a2a42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryRequirementsInfo2) Deref() {
	if x.reff54a2a42 == nil {
		return
	}
	x.SType = (StructureType)(x.reff54a2a42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff54a2a42.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff54a2a42.buffer))
}

// allocImageMemoryRequirementsInfo2Memory allocates memory for type C.VkImageMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryRequirementsInfo2) Ref() *C.VkImageMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref75b3ca05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs75b3ca05 != nil {
		x.allocs75b3ca05.(*cgoAllocMap).Free()
		x.ref75b3ca05 = nil
	}
}

// NewImageMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryRequirementsInfo2)
	obj.ref75b3ca05 = (*C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryRequirementsInfo2) PassRef() (*C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75b3ca05 != nil {
		return x.ref75b3ca05, nil
	}
	mem75b3ca05 := allocImageMemoryRequirementsInfo2Memory(1)
	ref75b3ca05 := (*C.VkImageMemoryRequirementsInfo2)(mem75b3ca05)
	allocs75b3ca05 := new(cgoAllocMap)
	allocs75b3ca05.Add(mem75b3ca05)

	var csType_allocs *cgoAllocMap
	ref75b3ca05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75b3ca05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75b3ca05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref75b3ca05.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cimage_allocs)

	x.ref75b3ca05 = ref75b3ca05
	x.allocs75b3ca05 = allocs75b3ca05
	return ref75b3ca05, allocs75b3ca05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryRequirementsInfo2) PassValue() (C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref75b3ca05 != nil {
		return *x.ref75b3ca05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryRequirementsInfo2) Deref() {
	if x.ref75b3ca05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75b3ca05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75b3ca05.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref75b3ca05.image))
}

// allocImageSparseMemoryRequirementsInfo2Memory allocates memory for type C.VkImageSparseMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSparseMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSparseMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSparseMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageSparseMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSparseMemoryRequirementsInfo2) Ref() *C.VkImageSparseMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref878956f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs878956f7 != nil {
		x.allocs878956f7.(*cgoAllocMap).Free()
		x.ref878956f7 = nil
	}
}

// NewImageSparseMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSparseMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageSparseMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageSparseMemoryRequirementsInfo2)
	obj.ref878956f7 = (*C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) PassRef() (*C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878956f7 != nil {
		return x.ref878956f7, nil
	}
	mem878956f7 := allocImageSparseMemoryRequirementsInfo2Memory(1)
	ref878956f7 := (*C.VkImageSparseMemoryRequirementsInfo2)(mem878956f7)
	allocs878956f7 := new(cgoAllocMap)
	allocs878956f7.Add(mem878956f7)

	var csType_allocs *cgoAllocMap
	ref878956f7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878956f7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878956f7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878956f7.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref878956f7.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs878956f7.Borrow(cimage_allocs)

	x.ref878956f7 = ref878956f7
	x.allocs878956f7 = allocs878956f7
	return ref878956f7, allocs878956f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) PassValue() (C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref878956f7 != nil {
		return *x.ref878956f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSparseMemoryRequirementsInfo2) Deref() {
	if x.ref878956f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref878956f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878956f7.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref878956f7.image))
}

// allocMemoryRequirements2Memory allocates memory for type C.VkMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirements2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirements2Value = unsafe.Sizeof([1]C.VkMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements2) Ref() *C.VkMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refc0e75f21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements2) Free() {
	if x != nil && x.allocsc0e75f21 != nil {
		x.allocsc0e75f21.(*cgoAllocMap).Free()
		x.refc0e75f21 = nil
	}
}

// NewMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirements2Ref(ref unsafe.Pointer) *MemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements2)
	obj.refc0e75f21 = (*C.VkMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements2) PassRef() (*C.VkMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0e75f21 != nil {
		return x.refc0e75f21, nil
	}
	memc0e75f21 := allocMemoryRequirements2Memory(1)
	refc0e75f21 := (*C.VkMemoryRequirements2)(memc0e75f21)
	allocsc0e75f21 := new(cgoAllocMap)
	allocsc0e75f21.Add(memc0e75f21)

	var csType_allocs *cgoAllocMap
	refc0e75f21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0e75f21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0e75f21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0e75f21.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refc0e75f21.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsc0e75f21.Borrow(cmemoryRequirements_allocs)

	x.refc0e75f21 = refc0e75f21
	x.allocsc0e75f21 = allocsc0e75f21
	return refc0e75f21, allocsc0e75f21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements2) PassValue() (C.VkMemoryRequirements2, *cgoAllocMap) {
	if x.refc0e75f21 != nil {
		return *x.refc0e75f21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements2) Deref() {
	if x.refc0e75f21 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0e75f21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0e75f21.pNext))
	x.MemoryRequirements = *NewMemoryRequirementsRef(unsafe.Pointer(&x.refc0e75f21.memoryRequirements))
}

// allocSparseImageMemoryRequirements2Memory allocates memory for type C.VkSparseImageMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirements2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirements2Value = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements2) Ref() *C.VkSparseImageMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refb8da955c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements2) Free() {
	if x != nil && x.allocsb8da955c != nil {
		x.allocsb8da955c.(*cgoAllocMap).Free()
		x.refb8da955c = nil
	}
}

// NewSparseImageMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirements2Ref(ref unsafe.Pointer) *SparseImageMemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements2)
	obj.refb8da955c = (*C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements2) PassRef() (*C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8da955c != nil {
		return x.refb8da955c, nil
	}
	memb8da955c := allocSparseImageMemoryRequirements2Memory(1)
	refb8da955c := (*C.VkSparseImageMemoryRequirements2)(memb8da955c)
	allocsb8da955c := new(cgoAllocMap)
	allocsb8da955c.Add(memb8da955c)

	var csType_allocs *cgoAllocMap
	refb8da955c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8da955c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8da955c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8da955c.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refb8da955c.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsb8da955c.Borrow(cmemoryRequirements_allocs)

	x.refb8da955c = refb8da955c
	x.allocsb8da955c = allocsb8da955c
	return refb8da955c, allocsb8da955c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements2) PassValue() (C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x.refb8da955c != nil {
		return *x.refb8da955c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements2) Deref() {
	if x.refb8da955c == nil {
		return
	}
	x.SType = (StructureType)(x.refb8da955c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8da955c.pNext))
	x.MemoryRequirements = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&x.refb8da955c.memoryRequirements))
}

// allocPhysicalDeviceFeatures2Memory allocates memory for type C.VkPhysicalDeviceFeatures2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeatures2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeatures2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeatures2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures2) Ref() *C.VkPhysicalDeviceFeatures2 {
	if x == nil {
		return nil
	}
	return x.refff6ed04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures2) Free() {
	if x != nil && x.allocsff6ed04 != nil {
		x.allocsff6ed04.(*cgoAllocMap).Free()
		x.refff6ed04 = nil
	}
}

// NewPhysicalDeviceFeatures2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeatures2Ref(ref unsafe.Pointer) *PhysicalDeviceFeatures2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures2)
	obj.refff6ed04 = (*C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures2) PassRef() (*C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff6ed04 != nil {
		return x.refff6ed04, nil
	}
	memff6ed04 := allocPhysicalDeviceFeatures2Memory(1)
	refff6ed04 := (*C.VkPhysicalDeviceFeatures2)(memff6ed04)
	allocsff6ed04 := new(cgoAllocMap)
	allocsff6ed04.Add(memff6ed04)

	var csType_allocs *cgoAllocMap
	refff6ed04.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff6ed04.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff6ed04.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff6ed04.Borrow(cpNext_allocs)

	var cfeatures_allocs *cgoAllocMap
	refff6ed04.features, cfeatures_allocs = x.Features.PassValue()
	allocsff6ed04.Borrow(cfeatures_allocs)

	x.refff6ed04 = refff6ed04
	x.allocsff6ed04 = allocsff6ed04
	return refff6ed04, allocsff6ed04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures2) PassValue() (C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x.refff6ed04 != nil {
		return *x.refff6ed04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures2) Deref() {
	if x.refff6ed04 == nil {
		return
	}
	x.SType = (StructureType)(x.refff6ed04.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff6ed04.pNext))
	x.Features = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&x.refff6ed04.features))
}

// allocPhysicalDeviceProperties2Memory allocates memory for type C.VkPhysicalDeviceProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties2) Ref() *C.VkPhysicalDeviceProperties2 {
	if x == nil {
		return nil
	}
	return x.ref947bd13e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties2) Free() {
	if x != nil && x.allocs947bd13e != nil {
		x.allocs947bd13e.(*cgoAllocMap).Free()
		x.ref947bd13e = nil
	}
}

// NewPhysicalDeviceProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties2)
	obj.ref947bd13e = (*C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties2) PassRef() (*C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref947bd13e != nil {
		return x.ref947bd13e, nil
	}
	mem947bd13e := allocPhysicalDeviceProperties2Memory(1)
	ref947bd13e := (*C.VkPhysicalDeviceProperties2)(mem947bd13e)
	allocs947bd13e := new(cgoAllocMap)
	allocs947bd13e.Add(mem947bd13e)

	var csType_allocs *cgoAllocMap
	ref947bd13e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs947bd13e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref947bd13e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs947bd13e.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref947bd13e.properties, cproperties_allocs = x.Properties.PassValue()
	allocs947bd13e.Borrow(cproperties_allocs)

	x.ref947bd13e = ref947bd13e
	x.allocs947bd13e = allocs947bd13e
	return ref947bd13e, allocs947bd13e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties2) PassValue() (C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x.ref947bd13e != nil {
		return *x.ref947bd13e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties2) Deref() {
	if x.ref947bd13e == nil {
		return
	}
	x.SType = (StructureType)(x.ref947bd13e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref947bd13e.pNext))
	x.Properties = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&x.ref947bd13e.properties))
}

// allocFormatProperties2Memory allocates memory for type C.VkFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatProperties2Value = unsafe.Sizeof([1]C.VkFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties2) Ref() *C.VkFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.refddc6af2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties2) Free() {
	if x != nil && x.allocsddc6af2a != nil {
		x.allocsddc6af2a.(*cgoAllocMap).Free()
		x.refddc6af2a = nil
	}
}

// NewFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatProperties2Ref(ref unsafe.Pointer) *FormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties2)
	obj.refddc6af2a = (*C.VkFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties2) PassRef() (*C.VkFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refddc6af2a != nil {
		return x.refddc6af2a, nil
	}
	memddc6af2a := allocFormatProperties2Memory(1)
	refddc6af2a := (*C.VkFormatProperties2)(memddc6af2a)
	allocsddc6af2a := new(cgoAllocMap)
	allocsddc6af2a.Add(memddc6af2a)

	var csType_allocs *cgoAllocMap
	refddc6af2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsddc6af2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refddc6af2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsddc6af2a.Borrow(cpNext_allocs)

	var cformatProperties_allocs *cgoAllocMap
	refddc6af2a.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocsddc6af2a.Borrow(cformatProperties_allocs)

	x.refddc6af2a = refddc6af2a
	x.allocsddc6af2a = allocsddc6af2a
	return refddc6af2a, allocsddc6af2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties2) PassValue() (C.VkFormatProperties2, *cgoAllocMap) {
	if x.refddc6af2a != nil {
		return *x.refddc6af2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties2) Deref() {
	if x.refddc6af2a == nil {
		return
	}
	x.SType = (StructureType)(x.refddc6af2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refddc6af2a.pNext))
	x.FormatProperties = *NewFormatPropertiesRef(unsafe.Pointer(&x.refddc6af2a.formatProperties))
}

// allocImageFormatProperties2Memory allocates memory for type C.VkImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatProperties2Value = unsafe.Sizeof([1]C.VkImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties2) Ref() *C.VkImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref224187e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties2) Free() {
	if x != nil && x.allocs224187e7 != nil {
		x.allocs224187e7.(*cgoAllocMap).Free()
		x.ref224187e7 = nil
	}
}

// NewImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatProperties2Ref(ref unsafe.Pointer) *ImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties2)
	obj.ref224187e7 = (*C.VkImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties2) PassRef() (*C.VkImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref224187e7 != nil {
		return x.ref224187e7, nil
	}
	mem224187e7 := allocImageFormatProperties2Memory(1)
	ref224187e7 := (*C.VkImageFormatProperties2)(mem224187e7)
	allocs224187e7 := new(cgoAllocMap)
	allocs224187e7.Add(mem224187e7)

	var csType_allocs *cgoAllocMap
	ref224187e7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs224187e7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref224187e7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs224187e7.Borrow(cpNext_allocs)

	var cimageFormatProperties_allocs *cgoAllocMap
	ref224187e7.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocs224187e7.Borrow(cimageFormatProperties_allocs)

	x.ref224187e7 = ref224187e7
	x.allocs224187e7 = allocs224187e7
	return ref224187e7, allocs224187e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties2) PassValue() (C.VkImageFormatProperties2, *cgoAllocMap) {
	if x.ref224187e7 != nil {
		return *x.ref224187e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties2) Deref() {
	if x.ref224187e7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref224187e7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref224187e7.pNext))
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.ref224187e7.imageFormatProperties))
}

// allocPhysicalDeviceImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageFormatInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageFormatInfo2) Ref() *C.VkPhysicalDeviceImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref5934b445
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	if x != nil && x.allocs5934b445 != nil {
		x.allocs5934b445.(*cgoAllocMap).Free()
		x.ref5934b445 = nil
	}
}

// NewPhysicalDeviceImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageFormatInfo2)
	obj.ref5934b445 = (*C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5934b445 != nil {
		return x.ref5934b445, nil
	}
	mem5934b445 := allocPhysicalDeviceImageFormatInfo2Memory(1)
	ref5934b445 := (*C.VkPhysicalDeviceImageFormatInfo2)(mem5934b445)
	allocs5934b445 := new(cgoAllocMap)
	allocs5934b445.Add(mem5934b445)

	var csType_allocs *cgoAllocMap
	ref5934b445.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5934b445.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5934b445.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5934b445.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref5934b445.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs5934b445.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref5934b445._type, c_type_allocs = (C.VkImageType)(x._type), cgoAllocsUnknown
	allocs5934b445.Borrow(c_type_allocs)

	var ctiling_allocs *cgoAllocMap
	ref5934b445.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs5934b445.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	ref5934b445.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs5934b445.Borrow(cusage_allocs)

	var cflags_allocs *cgoAllocMap
	ref5934b445.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5934b445.Borrow(cflags_allocs)

	x.ref5934b445 = ref5934b445
	x.allocs5934b445 = allocs5934b445
	return ref5934b445, allocs5934b445

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) PassValue() (C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x.ref5934b445 != nil {
		return *x.ref5934b445, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageFormatInfo2) Deref() {
	if x.ref5934b445 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5934b445.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5934b445.pNext))
	x.Format = (Format)(x.ref5934b445.format)
	x._type = (ImageType)(x.ref5934b445._type)
	x.Tiling = (ImageTiling)(x.ref5934b445.tiling)
	x.Usage = (ImageUsageFlags)(x.ref5934b445.usage)
	x.Flags = (ImageCreateFlags)(x.ref5934b445.flags)
}

// allocQueueFamilyProperties2Memory allocates memory for type C.VkQueueFamilyProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyProperties2Value = unsafe.Sizeof([1]C.VkQueueFamilyProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties2) Ref() *C.VkQueueFamilyProperties2 {
	if x == nil {
		return nil
	}
	return x.ref85bf626c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties2) Free() {
	if x != nil && x.allocs85bf626c != nil {
		x.allocs85bf626c.(*cgoAllocMap).Free()
		x.ref85bf626c = nil
	}
}

// NewQueueFamilyProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyProperties2Ref(ref unsafe.Pointer) *QueueFamilyProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties2)
	obj.ref85bf626c = (*C.VkQueueFamilyProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties2) PassRef() (*C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85bf626c != nil {
		return x.ref85bf626c, nil
	}
	mem85bf626c := allocQueueFamilyProperties2Memory(1)
	ref85bf626c := (*C.VkQueueFamilyProperties2)(mem85bf626c)
	allocs85bf626c := new(cgoAllocMap)
	allocs85bf626c.Add(mem85bf626c)

	var csType_allocs *cgoAllocMap
	ref85bf626c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85bf626c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85bf626c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85bf626c.Borrow(cpNext_allocs)

	var cqueueFamilyProperties_allocs *cgoAllocMap
	ref85bf626c.queueFamilyProperties, cqueueFamilyProperties_allocs = x.QueueFamilyProperties.PassValue()
	allocs85bf626c.Borrow(cqueueFamilyProperties_allocs)

	x.ref85bf626c = ref85bf626c
	x.allocs85bf626c = allocs85bf626c
	return ref85bf626c, allocs85bf626c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties2) PassValue() (C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x.ref85bf626c != nil {
		return *x.ref85bf626c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties2) Deref() {
	if x.ref85bf626c == nil {
		return
	}
	x.SType = (StructureType)(x.ref85bf626c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85bf626c.pNext))
	x.QueueFamilyProperties = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&x.ref85bf626c.queueFamilyProperties))
}

// allocPhysicalDeviceMemoryProperties2Memory allocates memory for type C.VkPhysicalDeviceMemoryProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties2) Ref() *C.VkPhysicalDeviceMemoryProperties2 {
	if x == nil {
		return nil
	}
	return x.refd9e39b19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	if x != nil && x.allocsd9e39b19 != nil {
		x.allocsd9e39b19.(*cgoAllocMap).Free()
		x.refd9e39b19 = nil
	}
}

// NewPhysicalDeviceMemoryProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties2)
	obj.refd9e39b19 = (*C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties2) PassRef() (*C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9e39b19 != nil {
		return x.refd9e39b19, nil
	}
	memd9e39b19 := allocPhysicalDeviceMemoryProperties2Memory(1)
	refd9e39b19 := (*C.VkPhysicalDeviceMemoryProperties2)(memd9e39b19)
	allocsd9e39b19 := new(cgoAllocMap)
	allocsd9e39b19.Add(memd9e39b19)

	var csType_allocs *cgoAllocMap
	refd9e39b19.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9e39b19.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9e39b19.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9e39b19.Borrow(cpNext_allocs)

	var cmemoryProperties_allocs *cgoAllocMap
	refd9e39b19.memoryProperties, cmemoryProperties_allocs = x.MemoryProperties.PassValue()
	allocsd9e39b19.Borrow(cmemoryProperties_allocs)

	x.refd9e39b19 = refd9e39b19
	x.allocsd9e39b19 = allocsd9e39b19
	return refd9e39b19, allocsd9e39b19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties2) PassValue() (C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x.refd9e39b19 != nil {
		return *x.refd9e39b19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties2) Deref() {
	if x.refd9e39b19 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9e39b19.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9e39b19.pNext))
	x.MemoryProperties = *NewPhysicalDeviceMemoryPropertiesRef(unsafe.Pointer(&x.refd9e39b19.memoryProperties))
}

// allocSparseImageFormatProperties2Memory allocates memory for type C.VkSparseImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatProperties2Value = unsafe.Sizeof([1]C.VkSparseImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties2) Ref() *C.VkSparseImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref6b48294b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties2) Free() {
	if x != nil && x.allocs6b48294b != nil {
		x.allocs6b48294b.(*cgoAllocMap).Free()
		x.ref6b48294b = nil
	}
}

// NewSparseImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatProperties2Ref(ref unsafe.Pointer) *SparseImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties2)
	obj.ref6b48294b = (*C.VkSparseImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties2) PassRef() (*C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b48294b != nil {
		return x.ref6b48294b, nil
	}
	mem6b48294b := allocSparseImageFormatProperties2Memory(1)
	ref6b48294b := (*C.VkSparseImageFormatProperties2)(mem6b48294b)
	allocs6b48294b := new(cgoAllocMap)
	allocs6b48294b.Add(mem6b48294b)

	var csType_allocs *cgoAllocMap
	ref6b48294b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6b48294b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6b48294b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6b48294b.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref6b48294b.properties, cproperties_allocs = x.Properties.PassValue()
	allocs6b48294b.Borrow(cproperties_allocs)

	x.ref6b48294b = ref6b48294b
	x.allocs6b48294b = allocs6b48294b
	return ref6b48294b, allocs6b48294b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties2) PassValue() (C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x.ref6b48294b != nil {
		return *x.ref6b48294b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties2) Deref() {
	if x.ref6b48294b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6b48294b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6b48294b.pNext))
	x.Properties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref6b48294b.properties))
}

// allocPhysicalDeviceSparseImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceSparseImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparseImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparseImageFormatInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparseImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseImageFormatInfo2) Ref() *C.VkPhysicalDeviceSparseImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref566d5513
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	if x != nil && x.allocs566d5513 != nil {
		x.allocs566d5513.(*cgoAllocMap).Free()
		x.ref566d5513 = nil
	}
}

// NewPhysicalDeviceSparseImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparseImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSparseImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseImageFormatInfo2)
	obj.ref566d5513 = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref566d5513 != nil {
		return x.ref566d5513, nil
	}
	mem566d5513 := allocPhysicalDeviceSparseImageFormatInfo2Memory(1)
	ref566d5513 := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(mem566d5513)
	allocs566d5513 := new(cgoAllocMap)
	allocs566d5513.Add(mem566d5513)

	var csType_allocs *cgoAllocMap
	ref566d5513.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs566d5513.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref566d5513.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs566d5513.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref566d5513.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs566d5513.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref566d5513._type, c_type_allocs = (C.VkImageType)(x._type), cgoAllocsUnknown
	allocs566d5513.Borrow(c_type_allocs)

	var csamples_allocs *cgoAllocMap
	ref566d5513.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocs566d5513.Borrow(csamples_allocs)

	var cusage_allocs *cgoAllocMap
	ref566d5513.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs566d5513.Borrow(cusage_allocs)

	var ctiling_allocs *cgoAllocMap
	ref566d5513.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs566d5513.Borrow(ctiling_allocs)

	x.ref566d5513 = ref566d5513
	x.allocs566d5513 = allocs566d5513
	return ref566d5513, allocs566d5513

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) PassValue() (C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x.ref566d5513 != nil {
		return *x.ref566d5513, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseImageFormatInfo2) Deref() {
	if x.ref566d5513 == nil {
		return
	}
	x.SType = (StructureType)(x.ref566d5513.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref566d5513.pNext))
	x.Format = (Format)(x.ref566d5513.format)
	x._type = (ImageType)(x.ref566d5513._type)
	x.Samples = (SampleCountFlagBits)(x.ref566d5513.samples)
	x.Usage = (ImageUsageFlags)(x.ref566d5513.usage)
	x.Tiling = (ImageTiling)(x.ref566d5513.tiling)
}

// allocPhysicalDevicePointClippingPropertiesMemory allocates memory for type C.VkPhysicalDevicePointClippingProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePointClippingPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePointClippingPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePointClippingPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePointClippingProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePointClippingProperties) Ref() *C.VkPhysicalDevicePointClippingProperties {
	if x == nil {
		return nil
	}
	return x.ref5afbd22f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePointClippingProperties) Free() {
	if x != nil && x.allocs5afbd22f != nil {
		x.allocs5afbd22f.(*cgoAllocMap).Free()
		x.ref5afbd22f = nil
	}
}

// NewPhysicalDevicePointClippingPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePointClippingPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePointClippingProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePointClippingProperties)
	obj.ref5afbd22f = (*C.VkPhysicalDevicePointClippingProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePointClippingProperties) PassRef() (*C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5afbd22f != nil {
		return x.ref5afbd22f, nil
	}
	mem5afbd22f := allocPhysicalDevicePointClippingPropertiesMemory(1)
	ref5afbd22f := (*C.VkPhysicalDevicePointClippingProperties)(mem5afbd22f)
	allocs5afbd22f := new(cgoAllocMap)
	allocs5afbd22f.Add(mem5afbd22f)

	var csType_allocs *cgoAllocMap
	ref5afbd22f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5afbd22f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5afbd22f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpNext_allocs)

	var cpointClippingBehavior_allocs *cgoAllocMap
	ref5afbd22f.pointClippingBehavior, cpointClippingBehavior_allocs = (C.VkPointClippingBehavior)(x.PointClippingBehavior), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpointClippingBehavior_allocs)

	x.ref5afbd22f = ref5afbd22f
	x.allocs5afbd22f = allocs5afbd22f
	return ref5afbd22f, allocs5afbd22f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePointClippingProperties) PassValue() (C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x.ref5afbd22f != nil {
		return *x.ref5afbd22f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePointClippingProperties) Deref() {
	if x.ref5afbd22f == nil {
		return
	}
	x.SType = (StructureType)(x.ref5afbd22f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5afbd22f.pNext))
	x.PointClippingBehavior = (PointClippingBehavior)(x.ref5afbd22f.pointClippingBehavior)
}

// allocInputAttachmentAspectReferenceMemory allocates memory for type C.VkInputAttachmentAspectReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInputAttachmentAspectReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInputAttachmentAspectReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInputAttachmentAspectReferenceValue = unsafe.Sizeof([1]C.VkInputAttachmentAspectReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InputAttachmentAspectReference) Ref() *C.VkInputAttachmentAspectReference {
	if x == nil {
		return nil
	}
	return x.ref4f7194e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InputAttachmentAspectReference) Free() {
	if x != nil && x.allocs4f7194e6 != nil {
		x.allocs4f7194e6.(*cgoAllocMap).Free()
		x.ref4f7194e6 = nil
	}
}

// NewInputAttachmentAspectReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInputAttachmentAspectReferenceRef(ref unsafe.Pointer) *InputAttachmentAspectReference {
	if ref == nil {
		return nil
	}
	obj := new(InputAttachmentAspectReference)
	obj.ref4f7194e6 = (*C.VkInputAttachmentAspectReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InputAttachmentAspectReference) PassRef() (*C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f7194e6 != nil {
		return x.ref4f7194e6, nil
	}
	mem4f7194e6 := allocInputAttachmentAspectReferenceMemory(1)
	ref4f7194e6 := (*C.VkInputAttachmentAspectReference)(mem4f7194e6)
	allocs4f7194e6 := new(cgoAllocMap)
	allocs4f7194e6.Add(mem4f7194e6)

	var csubpass_allocs *cgoAllocMap
	ref4f7194e6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs4f7194e6.Borrow(csubpass_allocs)

	var cinputAttachmentIndex_allocs *cgoAllocMap
	ref4f7194e6.inputAttachmentIndex, cinputAttachmentIndex_allocs = (C.uint32_t)(x.InputAttachmentIndex), cgoAllocsUnknown
	allocs4f7194e6.Borrow(cinputAttachmentIndex_allocs)

	var caspectMask_allocs *cgoAllocMap
	ref4f7194e6.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs4f7194e6.Borrow(caspectMask_allocs)

	x.ref4f7194e6 = ref4f7194e6
	x.allocs4f7194e6 = allocs4f7194e6
	return ref4f7194e6, allocs4f7194e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InputAttachmentAspectReference) PassValue() (C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x.ref4f7194e6 != nil {
		return *x.ref4f7194e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InputAttachmentAspectReference) Deref() {
	if x.ref4f7194e6 == nil {
		return
	}
	x.Subpass = (uint32)(x.ref4f7194e6.subpass)
	x.InputAttachmentIndex = (uint32)(x.ref4f7194e6.inputAttachmentIndex)
	x.AspectMask = (ImageAspectFlags)(x.ref4f7194e6.aspectMask)
}

// allocRenderPassInputAttachmentAspectCreateInfoMemory allocates memory for type C.VkRenderPassInputAttachmentAspectCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassInputAttachmentAspectCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassInputAttachmentAspectCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassInputAttachmentAspectCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassInputAttachmentAspectCreateInfo{})

// unpackSInputAttachmentAspectReference transforms a sliced Go data structure into plain C format.
func unpackSInputAttachmentAspectReference(x []InputAttachmentAspectReference) (unpacked *C.VkInputAttachmentAspectReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkInputAttachmentAspectReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocInputAttachmentAspectReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkInputAttachmentAspectReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkInputAttachmentAspectReference)(h.Data)
	return
}

// packSInputAttachmentAspectReference reads sliced Go data structure out from plain C format.
func packSInputAttachmentAspectReference(v []InputAttachmentAspectReference, ptr0 *C.VkInputAttachmentAspectReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInputAttachmentAspectReferenceValue]C.VkInputAttachmentAspectReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInputAttachmentAspectReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassInputAttachmentAspectCreateInfo) Ref() *C.VkRenderPassInputAttachmentAspectCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref34eaa5c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	if x != nil && x.allocs34eaa5c7 != nil {
		x.allocs34eaa5c7.(*cgoAllocMap).Free()
		x.ref34eaa5c7 = nil
	}
}

// NewRenderPassInputAttachmentAspectCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassInputAttachmentAspectCreateInfoRef(ref unsafe.Pointer) *RenderPassInputAttachmentAspectCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassInputAttachmentAspectCreateInfo)
	obj.ref34eaa5c7 = (*C.VkRenderPassInputAttachmentAspectCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) PassRef() (*C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34eaa5c7 != nil {
		return x.ref34eaa5c7, nil
	}
	mem34eaa5c7 := allocRenderPassInputAttachmentAspectCreateInfoMemory(1)
	ref34eaa5c7 := (*C.VkRenderPassInputAttachmentAspectCreateInfo)(mem34eaa5c7)
	allocs34eaa5c7 := new(cgoAllocMap)
	allocs34eaa5c7.Add(mem34eaa5c7)

	var csType_allocs *cgoAllocMap
	ref34eaa5c7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref34eaa5c7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(cpNext_allocs)

	var caspectReferenceCount_allocs *cgoAllocMap
	ref34eaa5c7.aspectReferenceCount, caspectReferenceCount_allocs = (C.uint32_t)(x.AspectReferenceCount), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(caspectReferenceCount_allocs)

	var cpAspectReferences_allocs *cgoAllocMap
	ref34eaa5c7.pAspectReferences, cpAspectReferences_allocs = unpackSInputAttachmentAspectReference(x.PAspectReferences)
	allocs34eaa5c7.Borrow(cpAspectReferences_allocs)

	x.ref34eaa5c7 = ref34eaa5c7
	x.allocs34eaa5c7 = allocs34eaa5c7
	return ref34eaa5c7, allocs34eaa5c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) PassValue() (C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x.ref34eaa5c7 != nil {
		return *x.ref34eaa5c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassInputAttachmentAspectCreateInfo) Deref() {
	if x.ref34eaa5c7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34eaa5c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34eaa5c7.pNext))
	x.AspectReferenceCount = (uint32)(x.ref34eaa5c7.aspectReferenceCount)
	packSInputAttachmentAspectReference(x.PAspectReferences, x.ref34eaa5c7.pAspectReferences)
}

// allocImageViewUsageCreateInfoMemory allocates memory for type C.VkImageViewUsageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewUsageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewUsageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewUsageCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewUsageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewUsageCreateInfo) Ref() *C.VkImageViewUsageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref3791cec9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewUsageCreateInfo) Free() {
	if x != nil && x.allocs3791cec9 != nil {
		x.allocs3791cec9.(*cgoAllocMap).Free()
		x.ref3791cec9 = nil
	}
}

// NewImageViewUsageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewUsageCreateInfoRef(ref unsafe.Pointer) *ImageViewUsageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewUsageCreateInfo)
	obj.ref3791cec9 = (*C.VkImageViewUsageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewUsageCreateInfo) PassRef() (*C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3791cec9 != nil {
		return x.ref3791cec9, nil
	}
	mem3791cec9 := allocImageViewUsageCreateInfoMemory(1)
	ref3791cec9 := (*C.VkImageViewUsageCreateInfo)(mem3791cec9)
	allocs3791cec9 := new(cgoAllocMap)
	allocs3791cec9.Add(mem3791cec9)

	var csType_allocs *cgoAllocMap
	ref3791cec9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3791cec9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3791cec9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3791cec9.Borrow(cpNext_allocs)

	var cusage_allocs *cgoAllocMap
	ref3791cec9.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs3791cec9.Borrow(cusage_allocs)

	x.ref3791cec9 = ref3791cec9
	x.allocs3791cec9 = allocs3791cec9
	return ref3791cec9, allocs3791cec9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewUsageCreateInfo) PassValue() (C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x.ref3791cec9 != nil {
		return *x.ref3791cec9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewUsageCreateInfo) Deref() {
	if x.ref3791cec9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3791cec9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3791cec9.pNext))
	x.Usage = (ImageUsageFlags)(x.ref3791cec9.usage)
}

// allocPipelineTessellationDomainOriginStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationDomainOriginStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationDomainOriginStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationDomainOriginStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationDomainOriginStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationDomainOriginStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Ref() *C.VkPipelineTessellationDomainOriginStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref58ef29bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	if x != nil && x.allocs58ef29bf != nil {
		x.allocs58ef29bf.(*cgoAllocMap).Free()
		x.ref58ef29bf = nil
	}
}

// NewPipelineTessellationDomainOriginStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationDomainOriginStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationDomainOriginStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationDomainOriginStateCreateInfo)
	obj.ref58ef29bf = (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) PassRef() (*C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58ef29bf != nil {
		return x.ref58ef29bf, nil
	}
	mem58ef29bf := allocPipelineTessellationDomainOriginStateCreateInfoMemory(1)
	ref58ef29bf := (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(mem58ef29bf)
	allocs58ef29bf := new(cgoAllocMap)
	allocs58ef29bf.Add(mem58ef29bf)

	var csType_allocs *cgoAllocMap
	ref58ef29bf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58ef29bf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58ef29bf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cpNext_allocs)

	var cdomainOrigin_allocs *cgoAllocMap
	ref58ef29bf.domainOrigin, cdomainOrigin_allocs = (C.VkTessellationDomainOrigin)(x.DomainOrigin), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cdomainOrigin_allocs)

	x.ref58ef29bf = ref58ef29bf
	x.allocs58ef29bf = allocs58ef29bf
	return ref58ef29bf, allocs58ef29bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) PassValue() (C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x.ref58ef29bf != nil {
		return *x.ref58ef29bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Deref() {
	if x.ref58ef29bf == nil {
		return
	}
	x.SType = (StructureType)(x.ref58ef29bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58ef29bf.pNext))
	x.DomainOrigin = (TessellationDomainOrigin)(x.ref58ef29bf.domainOrigin)
}

// allocRenderPassMultiviewCreateInfoMemory allocates memory for type C.VkRenderPassMultiviewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassMultiviewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassMultiviewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassMultiviewCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassMultiviewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassMultiviewCreateInfo) Ref() *C.VkRenderPassMultiviewCreateInfo {
	if x == nil {
		return nil
	}
	return x.refee413e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassMultiviewCreateInfo) Free() {
	if x != nil && x.allocsee413e05 != nil {
		x.allocsee413e05.(*cgoAllocMap).Free()
		x.refee413e05 = nil
	}
}

// NewRenderPassMultiviewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassMultiviewCreateInfoRef(ref unsafe.Pointer) *RenderPassMultiviewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassMultiviewCreateInfo)
	obj.refee413e05 = (*C.VkRenderPassMultiviewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassMultiviewCreateInfo) PassRef() (*C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee413e05 != nil {
		return x.refee413e05, nil
	}
	memee413e05 := allocRenderPassMultiviewCreateInfoMemory(1)
	refee413e05 := (*C.VkRenderPassMultiviewCreateInfo)(memee413e05)
	allocsee413e05 := new(cgoAllocMap)
	allocsee413e05.Add(memee413e05)

	var csType_allocs *cgoAllocMap
	refee413e05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsee413e05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refee413e05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpNext_allocs)

	var csubpassCount_allocs *cgoAllocMap
	refee413e05.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocsee413e05.Borrow(csubpassCount_allocs)

	var cpViewMasks_allocs *cgoAllocMap
	refee413e05.pViewMasks, cpViewMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewMasks_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	refee413e05.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocsee413e05.Borrow(cdependencyCount_allocs)

	var cpViewOffsets_allocs *cgoAllocMap
	refee413e05.pViewOffsets, cpViewOffsets_allocs = (*C.int32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewOffsets)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewOffsets_allocs)

	var ccorrelationMaskCount_allocs *cgoAllocMap
	refee413e05.correlationMaskCount, ccorrelationMaskCount_allocs = (C.uint32_t)(x.CorrelationMaskCount), cgoAllocsUnknown
	allocsee413e05.Borrow(ccorrelationMaskCount_allocs)

	var cpCorrelationMasks_allocs *cgoAllocMap
	refee413e05.pCorrelationMasks, cpCorrelationMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpCorrelationMasks_allocs)

	x.refee413e05 = refee413e05
	x.allocsee413e05 = allocsee413e05
	return refee413e05, allocsee413e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassMultiviewCreateInfo) PassValue() (C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x.refee413e05 != nil {
		return *x.refee413e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassMultiviewCreateInfo) Deref() {
	if x.refee413e05 == nil {
		return
	}
	x.SType = (StructureType)(x.refee413e05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee413e05.pNext))
	x.SubpassCount = (uint32)(x.refee413e05.subpassCount)
	hxff20e84 := (*sliceHeader)(unsafe.Pointer(&x.PViewMasks))
	hxff20e84.Data = unsafe.Pointer(x.refee413e05.pViewMasks)
	hxff20e84.Cap = 0x7fffffff
	// hxff20e84.Len = ?

	x.DependencyCount = (uint32)(x.refee413e05.dependencyCount)
	hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&x.PViewOffsets))
	hxfa26a4d.Data = unsafe.Pointer(x.refee413e05.pViewOffsets)
	hxfa26a4d.Cap = 0x7fffffff
	// hxfa26a4d.Len = ?

	x.CorrelationMaskCount = (uint32)(x.refee413e05.correlationMaskCount)
	hxfe48098 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks))
	hxfe48098.Data = unsafe.Pointer(x.refee413e05.pCorrelationMasks)
	hxfe48098.Cap = 0x7fffffff
	// hxfe48098.Len = ?

}

// allocPhysicalDeviceMultiviewFeaturesMemory allocates memory for type C.VkPhysicalDeviceMultiviewFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewFeatures) Ref() *C.VkPhysicalDeviceMultiviewFeatures {
	if x == nil {
		return nil
	}
	return x.refd7a7434b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	if x != nil && x.allocsd7a7434b != nil {
		x.allocsd7a7434b.(*cgoAllocMap).Free()
		x.refd7a7434b = nil
	}
}

// NewPhysicalDeviceMultiviewFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewFeatures)
	obj.refd7a7434b = (*C.VkPhysicalDeviceMultiviewFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewFeatures) PassRef() (*C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7a7434b != nil {
		return x.refd7a7434b, nil
	}
	memd7a7434b := allocPhysicalDeviceMultiviewFeaturesMemory(1)
	refd7a7434b := (*C.VkPhysicalDeviceMultiviewFeatures)(memd7a7434b)
	allocsd7a7434b := new(cgoAllocMap)
	allocsd7a7434b.Add(memd7a7434b)

	var csType_allocs *cgoAllocMap
	refd7a7434b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7a7434b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7a7434b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cpNext_allocs)

	var cmultiview_allocs *cgoAllocMap
	refd7a7434b.multiview, cmultiview_allocs = (C.VkBool32)(x.Multiview), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiview_allocs)

	var cmultiviewGeometryShader_allocs *cgoAllocMap
	refd7a7434b.multiviewGeometryShader, cmultiviewGeometryShader_allocs = (C.VkBool32)(x.MultiviewGeometryShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewGeometryShader_allocs)

	var cmultiviewTessellationShader_allocs *cgoAllocMap
	refd7a7434b.multiviewTessellationShader, cmultiviewTessellationShader_allocs = (C.VkBool32)(x.MultiviewTessellationShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewTessellationShader_allocs)

	x.refd7a7434b = refd7a7434b
	x.allocsd7a7434b = allocsd7a7434b
	return refd7a7434b, allocsd7a7434b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) PassValue() (C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x.refd7a7434b != nil {
		return *x.refd7a7434b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewFeatures) Deref() {
	if x.refd7a7434b == nil {
		return
	}
	x.SType = (StructureType)(x.refd7a7434b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7a7434b.pNext))
	x.Multiview = (Bool32)(x.refd7a7434b.multiview)
	x.MultiviewGeometryShader = (Bool32)(x.refd7a7434b.multiviewGeometryShader)
	x.MultiviewTessellationShader = (Bool32)(x.refd7a7434b.multiviewTessellationShader)
}

// allocPhysicalDeviceMultiviewPropertiesMemory allocates memory for type C.VkPhysicalDeviceMultiviewProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewProperties) Ref() *C.VkPhysicalDeviceMultiviewProperties {
	if x == nil {
		return nil
	}
	return x.ref95110029
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	if x != nil && x.allocs95110029 != nil {
		x.allocs95110029.(*cgoAllocMap).Free()
		x.ref95110029 = nil
	}
}

// NewPhysicalDeviceMultiviewPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewProperties)
	obj.ref95110029 = (*C.VkPhysicalDeviceMultiviewProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewProperties) PassRef() (*C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95110029 != nil {
		return x.ref95110029, nil
	}
	mem95110029 := allocPhysicalDeviceMultiviewPropertiesMemory(1)
	ref95110029 := (*C.VkPhysicalDeviceMultiviewProperties)(mem95110029)
	allocs95110029 := new(cgoAllocMap)
	allocs95110029.Add(mem95110029)

	var csType_allocs *cgoAllocMap
	ref95110029.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95110029.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95110029.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95110029.Borrow(cpNext_allocs)

	var cmaxMultiviewViewCount_allocs *cgoAllocMap
	ref95110029.maxMultiviewViewCount, cmaxMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMultiviewViewCount), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewViewCount_allocs)

	var cmaxMultiviewInstanceIndex_allocs *cgoAllocMap
	ref95110029.maxMultiviewInstanceIndex, cmaxMultiviewInstanceIndex_allocs = (C.uint32_t)(x.MaxMultiviewInstanceIndex), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewInstanceIndex_allocs)

	x.ref95110029 = ref95110029
	x.allocs95110029 = allocs95110029
	return ref95110029, allocs95110029

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewProperties) PassValue() (C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x.ref95110029 != nil {
		return *x.ref95110029, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewProperties) Deref() {
	if x.ref95110029 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95110029.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95110029.pNext))
	x.MaxMultiviewViewCount = (uint32)(x.ref95110029.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.ref95110029.maxMultiviewInstanceIndex)
}

// allocPhysicalDeviceVariablePointerFeaturesMemory allocates memory for type C.VkPhysicalDeviceVariablePointerFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVariablePointerFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVariablePointerFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVariablePointerFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVariablePointerFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVariablePointerFeatures) Ref() *C.VkPhysicalDeviceVariablePointerFeatures {
	if x == nil {
		return nil
	}
	return x.refdedd8372
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) Free() {
	if x != nil && x.allocsdedd8372 != nil {
		x.allocsdedd8372.(*cgoAllocMap).Free()
		x.refdedd8372 = nil
	}
}

// NewPhysicalDeviceVariablePointerFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVariablePointerFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVariablePointerFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVariablePointerFeatures)
	obj.refdedd8372 = (*C.VkPhysicalDeviceVariablePointerFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) PassRef() (*C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdedd8372 != nil {
		return x.refdedd8372, nil
	}
	memdedd8372 := allocPhysicalDeviceVariablePointerFeaturesMemory(1)
	refdedd8372 := (*C.VkPhysicalDeviceVariablePointerFeatures)(memdedd8372)
	allocsdedd8372 := new(cgoAllocMap)
	allocsdedd8372.Add(memdedd8372)

	var csType_allocs *cgoAllocMap
	refdedd8372.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdedd8372.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdedd8372.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdedd8372.Borrow(cpNext_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refdedd8372.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refdedd8372.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointers_allocs)

	x.refdedd8372 = refdedd8372
	x.allocsdedd8372 = allocsdedd8372
	return refdedd8372, allocsdedd8372

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVariablePointerFeatures) PassValue() (C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x.refdedd8372 != nil {
		return *x.refdedd8372, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVariablePointerFeatures) Deref() {
	if x.refdedd8372 == nil {
		return
	}
	x.SType = (StructureType)(x.refdedd8372.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdedd8372.pNext))
	x.VariablePointersStorageBuffer = (Bool32)(x.refdedd8372.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refdedd8372.variablePointers)
}

// allocPhysicalDeviceProtectedMemoryFeaturesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryFeatures) Ref() *C.VkPhysicalDeviceProtectedMemoryFeatures {
	if x == nil {
		return nil
	}
	return x.refac441ed1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	if x != nil && x.allocsac441ed1 != nil {
		x.allocsac441ed1.(*cgoAllocMap).Free()
		x.refac441ed1 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryFeatures)
	obj.refac441ed1 = (*C.VkPhysicalDeviceProtectedMemoryFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) PassRef() (*C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac441ed1 != nil {
		return x.refac441ed1, nil
	}
	memac441ed1 := allocPhysicalDeviceProtectedMemoryFeaturesMemory(1)
	refac441ed1 := (*C.VkPhysicalDeviceProtectedMemoryFeatures)(memac441ed1)
	allocsac441ed1 := new(cgoAllocMap)
	allocsac441ed1.Add(memac441ed1)

	var csType_allocs *cgoAllocMap
	refac441ed1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsac441ed1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refac441ed1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsac441ed1.Borrow(cpNext_allocs)

	var cprotectedMemory_allocs *cgoAllocMap
	refac441ed1.protectedMemory, cprotectedMemory_allocs = (C.VkBool32)(x.ProtectedMemory), cgoAllocsUnknown
	allocsac441ed1.Borrow(cprotectedMemory_allocs)

	x.refac441ed1 = refac441ed1
	x.allocsac441ed1 = allocsac441ed1
	return refac441ed1, allocsac441ed1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) PassValue() (C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x.refac441ed1 != nil {
		return *x.refac441ed1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryFeatures) Deref() {
	if x.refac441ed1 == nil {
		return
	}
	x.SType = (StructureType)(x.refac441ed1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refac441ed1.pNext))
	x.ProtectedMemory = (Bool32)(x.refac441ed1.protectedMemory)
}

// allocPhysicalDeviceProtectedMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryProperties) Ref() *C.VkPhysicalDeviceProtectedMemoryProperties {
	if x == nil {
		return nil
	}
	return x.refb653413
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	if x != nil && x.allocsb653413 != nil {
		x.allocsb653413.(*cgoAllocMap).Free()
		x.refb653413 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryProperties)
	obj.refb653413 = (*C.VkPhysicalDeviceProtectedMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) PassRef() (*C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb653413 != nil {
		return x.refb653413, nil
	}
	memb653413 := allocPhysicalDeviceProtectedMemoryPropertiesMemory(1)
	refb653413 := (*C.VkPhysicalDeviceProtectedMemoryProperties)(memb653413)
	allocsb653413 := new(cgoAllocMap)
	allocsb653413.Add(memb653413)

	var csType_allocs *cgoAllocMap
	refb653413.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb653413.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb653413.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb653413.Borrow(cpNext_allocs)

	var cprotectedNoFault_allocs *cgoAllocMap
	refb653413.protectedNoFault, cprotectedNoFault_allocs = (C.VkBool32)(x.ProtectedNoFault), cgoAllocsUnknown
	allocsb653413.Borrow(cprotectedNoFault_allocs)

	x.refb653413 = refb653413
	x.allocsb653413 = allocsb653413
	return refb653413, allocsb653413

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) PassValue() (C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x.refb653413 != nil {
		return *x.refb653413, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryProperties) Deref() {
	if x.refb653413 == nil {
		return
	}
	x.SType = (StructureType)(x.refb653413.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb653413.pNext))
	x.ProtectedNoFault = (Bool32)(x.refb653413.protectedNoFault)
}

// allocDeviceQueueInfo2Memory allocates memory for type C.VkDeviceQueueInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueInfo2Value = unsafe.Sizeof([1]C.VkDeviceQueueInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueInfo2) Ref() *C.VkDeviceQueueInfo2 {
	if x == nil {
		return nil
	}
	return x.ref2f267e52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueInfo2) Free() {
	if x != nil && x.allocs2f267e52 != nil {
		x.allocs2f267e52.(*cgoAllocMap).Free()
		x.ref2f267e52 = nil
	}
}

// NewDeviceQueueInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueInfo2Ref(ref unsafe.Pointer) *DeviceQueueInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueInfo2)
	obj.ref2f267e52 = (*C.VkDeviceQueueInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueInfo2) PassRef() (*C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f267e52 != nil {
		return x.ref2f267e52, nil
	}
	mem2f267e52 := allocDeviceQueueInfo2Memory(1)
	ref2f267e52 := (*C.VkDeviceQueueInfo2)(mem2f267e52)
	allocs2f267e52 := new(cgoAllocMap)
	allocs2f267e52.Add(mem2f267e52)

	var csType_allocs *cgoAllocMap
	ref2f267e52.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2f267e52.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2f267e52.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2f267e52.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2f267e52.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2f267e52.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref2f267e52.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueFamilyIndex_allocs)

	var cqueueIndex_allocs *cgoAllocMap
	ref2f267e52.queueIndex, cqueueIndex_allocs = (C.uint32_t)(x.QueueIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueIndex_allocs)

	x.ref2f267e52 = ref2f267e52
	x.allocs2f267e52 = allocs2f267e52
	return ref2f267e52, allocs2f267e52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueInfo2) PassValue() (C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x.ref2f267e52 != nil {
		return *x.ref2f267e52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueInfo2) Deref() {
	if x.ref2f267e52 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2f267e52.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2f267e52.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref2f267e52.flags)
	x.QueueFamilyIndex = (uint32)(x.ref2f267e52.queueFamilyIndex)
	x.QueueIndex = (uint32)(x.ref2f267e52.queueIndex)
}

// allocProtectedSubmitInfoMemory allocates memory for type C.VkProtectedSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProtectedSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProtectedSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfProtectedSubmitInfoValue = unsafe.Sizeof([1]C.VkProtectedSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ProtectedSubmitInfo) Ref() *C.VkProtectedSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref6bd69669
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ProtectedSubmitInfo) Free() {
	if x != nil && x.allocs6bd69669 != nil {
		x.allocs6bd69669.(*cgoAllocMap).Free()
		x.ref6bd69669 = nil
	}
}

// NewProtectedSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewProtectedSubmitInfoRef(ref unsafe.Pointer) *ProtectedSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(ProtectedSubmitInfo)
	obj.ref6bd69669 = (*C.VkProtectedSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ProtectedSubmitInfo) PassRef() (*C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bd69669 != nil {
		return x.ref6bd69669, nil
	}
	mem6bd69669 := allocProtectedSubmitInfoMemory(1)
	ref6bd69669 := (*C.VkProtectedSubmitInfo)(mem6bd69669)
	allocs6bd69669 := new(cgoAllocMap)
	allocs6bd69669.Add(mem6bd69669)

	var csType_allocs *cgoAllocMap
	ref6bd69669.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bd69669.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bd69669.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bd69669.Borrow(cpNext_allocs)

	var cprotectedSubmit_allocs *cgoAllocMap
	ref6bd69669.protectedSubmit, cprotectedSubmit_allocs = (C.VkBool32)(x.ProtectedSubmit), cgoAllocsUnknown
	allocs6bd69669.Borrow(cprotectedSubmit_allocs)

	x.ref6bd69669 = ref6bd69669
	x.allocs6bd69669 = allocs6bd69669
	return ref6bd69669, allocs6bd69669

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ProtectedSubmitInfo) PassValue() (C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x.ref6bd69669 != nil {
		return *x.ref6bd69669, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ProtectedSubmitInfo) Deref() {
	if x.ref6bd69669 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bd69669.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bd69669.pNext))
	x.ProtectedSubmit = (Bool32)(x.ref6bd69669.protectedSubmit)
}

// allocSamplerYcbcrConversionCreateInfoMemory allocates memory for type C.VkSamplerYcbcrConversionCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionCreateInfo) Ref() *C.VkSamplerYcbcrConversionCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9875bff7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	if x != nil && x.allocs9875bff7 != nil {
		x.allocs9875bff7.(*cgoAllocMap).Free()
		x.ref9875bff7 = nil
	}
}

// NewSamplerYcbcrConversionCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionCreateInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionCreateInfo)
	obj.ref9875bff7 = (*C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionCreateInfo) PassRef() (*C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9875bff7 != nil {
		return x.ref9875bff7, nil
	}
	mem9875bff7 := allocSamplerYcbcrConversionCreateInfoMemory(1)
	ref9875bff7 := (*C.VkSamplerYcbcrConversionCreateInfo)(mem9875bff7)
	allocs9875bff7 := new(cgoAllocMap)
	allocs9875bff7.Add(mem9875bff7)

	var csType_allocs *cgoAllocMap
	ref9875bff7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9875bff7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9875bff7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9875bff7.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref9875bff7.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs9875bff7.Borrow(cformat_allocs)

	var cycbcrModel_allocs *cgoAllocMap
	ref9875bff7.ycbcrModel, cycbcrModel_allocs = (C.VkSamplerYcbcrModelConversion)(x.YcbcrModel), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrModel_allocs)

	var cycbcrRange_allocs *cgoAllocMap
	ref9875bff7.ycbcrRange, cycbcrRange_allocs = (C.VkSamplerYcbcrRange)(x.YcbcrRange), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrRange_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref9875bff7.components, ccomponents_allocs = x.Components.PassValue()
	allocs9875bff7.Borrow(ccomponents_allocs)

	var cxChromaOffset_allocs *cgoAllocMap
	ref9875bff7.xChromaOffset, cxChromaOffset_allocs = (C.VkChromaLocation)(x.XChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cxChromaOffset_allocs)

	var cyChromaOffset_allocs *cgoAllocMap
	ref9875bff7.yChromaOffset, cyChromaOffset_allocs = (C.VkChromaLocation)(x.YChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cyChromaOffset_allocs)

	var cchromaFilter_allocs *cgoAllocMap
	ref9875bff7.chromaFilter, cchromaFilter_allocs = (C.VkFilter)(x.ChromaFilter), cgoAllocsUnknown
	allocs9875bff7.Borrow(cchromaFilter_allocs)

	var cforceExplicitReconstruction_allocs *cgoAllocMap
	ref9875bff7.forceExplicitReconstruction, cforceExplicitReconstruction_allocs = (C.VkBool32)(x.ForceExplicitReconstruction), cgoAllocsUnknown
	allocs9875bff7.Borrow(cforceExplicitReconstruction_allocs)

	x.ref9875bff7 = ref9875bff7
	x.allocs9875bff7 = allocs9875bff7
	return ref9875bff7, allocs9875bff7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) PassValue() (C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x.ref9875bff7 != nil {
		return *x.ref9875bff7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionCreateInfo) Deref() {
	if x.ref9875bff7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9875bff7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9875bff7.pNext))
	x.Format = (Format)(x.ref9875bff7.format)
	x.YcbcrModel = (SamplerYcbcrModelConversion)(x.ref9875bff7.ycbcrModel)
	x.YcbcrRange = (SamplerYcbcrRange)(x.ref9875bff7.ycbcrRange)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref9875bff7.components))
	x.XChromaOffset = (ChromaLocation)(x.ref9875bff7.xChromaOffset)
	x.YChromaOffset = (ChromaLocation)(x.ref9875bff7.yChromaOffset)
	x.ChromaFilter = (Filter)(x.ref9875bff7.chromaFilter)
	x.ForceExplicitReconstruction = (Bool32)(x.ref9875bff7.forceExplicitReconstruction)
}

// allocSamplerYcbcrConversionInfoMemory allocates memory for type C.VkSamplerYcbcrConversionInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionInfo) Ref() *C.VkSamplerYcbcrConversionInfo {
	if x == nil {
		return nil
	}
	return x.ref11ff5547
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionInfo) Free() {
	if x != nil && x.allocs11ff5547 != nil {
		x.allocs11ff5547.(*cgoAllocMap).Free()
		x.ref11ff5547 = nil
	}
}

// NewSamplerYcbcrConversionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionInfo)
	obj.ref11ff5547 = (*C.VkSamplerYcbcrConversionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionInfo) PassRef() (*C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11ff5547 != nil {
		return x.ref11ff5547, nil
	}
	mem11ff5547 := allocSamplerYcbcrConversionInfoMemory(1)
	ref11ff5547 := (*C.VkSamplerYcbcrConversionInfo)(mem11ff5547)
	allocs11ff5547 := new(cgoAllocMap)
	allocs11ff5547.Add(mem11ff5547)

	var csType_allocs *cgoAllocMap
	ref11ff5547.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs11ff5547.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref11ff5547.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cpNext_allocs)

	var cconversion_allocs *cgoAllocMap
	ref11ff5547.conversion, cconversion_allocs = *(*C.VkSamplerYcbcrConversion)(unsafe.Pointer(&x.Conversion)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cconversion_allocs)

	x.ref11ff5547 = ref11ff5547
	x.allocs11ff5547 = allocs11ff5547
	return ref11ff5547, allocs11ff5547

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionInfo) PassValue() (C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x.ref11ff5547 != nil {
		return *x.ref11ff5547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionInfo) Deref() {
	if x.ref11ff5547 == nil {
		return
	}
	x.SType = (StructureType)(x.ref11ff5547.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref11ff5547.pNext))
	x.Conversion = *(*SamplerYcbcrConversion)(unsafe.Pointer(&x.ref11ff5547.conversion))
}

// allocBindImagePlaneMemoryInfoMemory allocates memory for type C.VkBindImagePlaneMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImagePlaneMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImagePlaneMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImagePlaneMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImagePlaneMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImagePlaneMemoryInfo) Ref() *C.VkBindImagePlaneMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref56b81476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImagePlaneMemoryInfo) Free() {
	if x != nil && x.allocs56b81476 != nil {
		x.allocs56b81476.(*cgoAllocMap).Free()
		x.ref56b81476 = nil
	}
}

// NewBindImagePlaneMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImagePlaneMemoryInfoRef(ref unsafe.Pointer) *BindImagePlaneMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImagePlaneMemoryInfo)
	obj.ref56b81476 = (*C.VkBindImagePlaneMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImagePlaneMemoryInfo) PassRef() (*C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56b81476 != nil {
		return x.ref56b81476, nil
	}
	mem56b81476 := allocBindImagePlaneMemoryInfoMemory(1)
	ref56b81476 := (*C.VkBindImagePlaneMemoryInfo)(mem56b81476)
	allocs56b81476 := new(cgoAllocMap)
	allocs56b81476.Add(mem56b81476)

	var csType_allocs *cgoAllocMap
	ref56b81476.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs56b81476.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref56b81476.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs56b81476.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	ref56b81476.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocs56b81476.Borrow(cplaneAspect_allocs)

	x.ref56b81476 = ref56b81476
	x.allocs56b81476 = allocs56b81476
	return ref56b81476, allocs56b81476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImagePlaneMemoryInfo) PassValue() (C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x.ref56b81476 != nil {
		return *x.ref56b81476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImagePlaneMemoryInfo) Deref() {
	if x.ref56b81476 == nil {
		return
	}
	x.SType = (StructureType)(x.ref56b81476.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref56b81476.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.ref56b81476.planeAspect)
}

// allocImagePlaneMemoryRequirementsInfoMemory allocates memory for type C.VkImagePlaneMemoryRequirementsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImagePlaneMemoryRequirementsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImagePlaneMemoryRequirementsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImagePlaneMemoryRequirementsInfoValue = unsafe.Sizeof([1]C.VkImagePlaneMemoryRequirementsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImagePlaneMemoryRequirementsInfo) Ref() *C.VkImagePlaneMemoryRequirementsInfo {
	if x == nil {
		return nil
	}
	return x.refefec131f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	if x != nil && x.allocsefec131f != nil {
		x.allocsefec131f.(*cgoAllocMap).Free()
		x.refefec131f = nil
	}
}

// NewImagePlaneMemoryRequirementsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImagePlaneMemoryRequirementsInfoRef(ref unsafe.Pointer) *ImagePlaneMemoryRequirementsInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImagePlaneMemoryRequirementsInfo)
	obj.refefec131f = (*C.VkImagePlaneMemoryRequirementsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) PassRef() (*C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefec131f != nil {
		return x.refefec131f, nil
	}
	memefec131f := allocImagePlaneMemoryRequirementsInfoMemory(1)
	refefec131f := (*C.VkImagePlaneMemoryRequirementsInfo)(memefec131f)
	allocsefec131f := new(cgoAllocMap)
	allocsefec131f.Add(memefec131f)

	var csType_allocs *cgoAllocMap
	refefec131f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsefec131f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refefec131f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsefec131f.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	refefec131f.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocsefec131f.Borrow(cplaneAspect_allocs)

	x.refefec131f = refefec131f
	x.allocsefec131f = allocsefec131f
	return refefec131f, allocsefec131f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) PassValue() (C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x.refefec131f != nil {
		return *x.refefec131f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImagePlaneMemoryRequirementsInfo) Deref() {
	if x.refefec131f == nil {
		return
	}
	x.SType = (StructureType)(x.refefec131f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refefec131f.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.refefec131f.planeAspect)
}

// allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory allocates memory for type C.VkPhysicalDeviceSamplerYcbcrConversionFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerYcbcrConversionFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Ref() *C.VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	if x == nil {
		return nil
	}
	return x.ref1d054d67
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	if x != nil && x.allocs1d054d67 != nil {
		x.allocs1d054d67.(*cgoAllocMap).Free()
		x.ref1d054d67 = nil
	}
}

// NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSamplerYcbcrConversionFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerYcbcrConversionFeatures)
	obj.ref1d054d67 = (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) PassRef() (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d054d67 != nil {
		return x.ref1d054d67, nil
	}
	mem1d054d67 := allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(1)
	ref1d054d67 := (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(mem1d054d67)
	allocs1d054d67 := new(cgoAllocMap)
	allocs1d054d67.Add(mem1d054d67)

	var csType_allocs *cgoAllocMap
	ref1d054d67.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d054d67.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d054d67.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d054d67.Borrow(cpNext_allocs)

	var csamplerYcbcrConversion_allocs *cgoAllocMap
	ref1d054d67.samplerYcbcrConversion, csamplerYcbcrConversion_allocs = (C.VkBool32)(x.SamplerYcbcrConversion), cgoAllocsUnknown
	allocs1d054d67.Borrow(csamplerYcbcrConversion_allocs)

	x.ref1d054d67 = ref1d054d67
	x.allocs1d054d67 = allocs1d054d67
	return ref1d054d67, allocs1d054d67

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PassValue() (C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x.ref1d054d67 != nil {
		return *x.ref1d054d67, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Deref() {
	if x.ref1d054d67 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d054d67.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d054d67.pNext))
	x.SamplerYcbcrConversion = (Bool32)(x.ref1d054d67.samplerYcbcrConversion)
}

// allocSamplerYcbcrConversionImageFormatPropertiesMemory allocates memory for type C.VkSamplerYcbcrConversionImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionImageFormatProperties) Ref() *C.VkSamplerYcbcrConversionImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref6bc79530
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	if x != nil && x.allocs6bc79530 != nil {
		x.allocs6bc79530.(*cgoAllocMap).Free()
		x.ref6bc79530 = nil
	}
}

// NewSamplerYcbcrConversionImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionImageFormatPropertiesRef(ref unsafe.Pointer) *SamplerYcbcrConversionImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionImageFormatProperties)
	obj.ref6bc79530 = (*C.VkSamplerYcbcrConversionImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) PassRef() (*C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc79530 != nil {
		return x.ref6bc79530, nil
	}
	mem6bc79530 := allocSamplerYcbcrConversionImageFormatPropertiesMemory(1)
	ref6bc79530 := (*C.VkSamplerYcbcrConversionImageFormatProperties)(mem6bc79530)
	allocs6bc79530 := new(cgoAllocMap)
	allocs6bc79530.Add(mem6bc79530)

	var csType_allocs *cgoAllocMap
	ref6bc79530.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bc79530.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bc79530.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bc79530.Borrow(cpNext_allocs)

	var ccombinedImageSamplerDescriptorCount_allocs *cgoAllocMap
	ref6bc79530.combinedImageSamplerDescriptorCount, ccombinedImageSamplerDescriptorCount_allocs = (C.uint32_t)(x.CombinedImageSamplerDescriptorCount), cgoAllocsUnknown
	allocs6bc79530.Borrow(ccombinedImageSamplerDescriptorCount_allocs)

	x.ref6bc79530 = ref6bc79530
	x.allocs6bc79530 = allocs6bc79530
	return ref6bc79530, allocs6bc79530

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) PassValue() (C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x.ref6bc79530 != nil {
		return *x.ref6bc79530, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionImageFormatProperties) Deref() {
	if x.ref6bc79530 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bc79530.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc79530.pNext))
	x.CombinedImageSamplerDescriptorCount = (uint32)(x.ref6bc79530.combinedImageSamplerDescriptorCount)
}

// allocDescriptorUpdateTemplateEntryMemory allocates memory for type C.VkDescriptorUpdateTemplateEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateEntryValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateEntry) Ref() *C.VkDescriptorUpdateTemplateEntry {
	if x == nil {
		return nil
	}
	return x.refabf78fb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateEntry) Free() {
	if x != nil && x.allocsabf78fb7 != nil {
		x.allocsabf78fb7.(*cgoAllocMap).Free()
		x.refabf78fb7 = nil
	}
}

// NewDescriptorUpdateTemplateEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateEntryRef(ref unsafe.Pointer) *DescriptorUpdateTemplateEntry {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateEntry)
	obj.refabf78fb7 = (*C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateEntry) PassRef() (*C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf78fb7 != nil {
		return x.refabf78fb7, nil
	}
	memabf78fb7 := allocDescriptorUpdateTemplateEntryMemory(1)
	refabf78fb7 := (*C.VkDescriptorUpdateTemplateEntry)(memabf78fb7)
	allocsabf78fb7 := new(cgoAllocMap)
	allocsabf78fb7.Add(memabf78fb7)

	var cdstBinding_allocs *cgoAllocMap
	refabf78fb7.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	refabf78fb7.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refabf78fb7.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	refabf78fb7.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorType_allocs)

	var coffset_allocs *cgoAllocMap
	refabf78fb7.offset, coffset_allocs = (C.size_t)(x.Offset), cgoAllocsUnknown
	allocsabf78fb7.Borrow(coffset_allocs)

	var cstride_allocs *cgoAllocMap
	refabf78fb7.stride, cstride_allocs = (C.size_t)(x.Stride), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cstride_allocs)

	x.refabf78fb7 = refabf78fb7
	x.allocsabf78fb7 = allocsabf78fb7
	return refabf78fb7, allocsabf78fb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateEntry) PassValue() (C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x.refabf78fb7 != nil {
		return *x.refabf78fb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateEntry) Deref() {
	if x.refabf78fb7 == nil {
		return
	}
	x.DstBinding = (uint32)(x.refabf78fb7.dstBinding)
	x.DstArrayElement = (uint32)(x.refabf78fb7.dstArrayElement)
	x.DescriptorCount = (uint32)(x.refabf78fb7.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.refabf78fb7.descriptorType)
	x.Offset = (uint)(x.refabf78fb7.offset)
	x.Stride = (uint)(x.refabf78fb7.stride)
}

// allocDescriptorUpdateTemplateCreateInfoMemory allocates memory for type C.VkDescriptorUpdateTemplateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateCreateInfo{})

// unpackSDescriptorUpdateTemplateEntry transforms a sliced Go data structure into plain C format.
func unpackSDescriptorUpdateTemplateEntry(x []DescriptorUpdateTemplateEntry) (unpacked *C.VkDescriptorUpdateTemplateEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorUpdateTemplateEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorUpdateTemplateEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorUpdateTemplateEntry)(h.Data)
	return
}

// packSDescriptorUpdateTemplateEntry reads sliced Go data structure out from plain C format.
func packSDescriptorUpdateTemplateEntry(v []DescriptorUpdateTemplateEntry, ptr0 *C.VkDescriptorUpdateTemplateEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorUpdateTemplateEntryValue]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorUpdateTemplateEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateCreateInfo) Ref() *C.VkDescriptorUpdateTemplateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2af95951
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	if x != nil && x.allocs2af95951 != nil {
		x.allocs2af95951.(*cgoAllocMap).Free()
		x.ref2af95951 = nil
	}
}

// NewDescriptorUpdateTemplateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateCreateInfoRef(ref unsafe.Pointer) *DescriptorUpdateTemplateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateCreateInfo)
	obj.ref2af95951 = (*C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) PassRef() (*C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2af95951 != nil {
		return x.ref2af95951, nil
	}
	mem2af95951 := allocDescriptorUpdateTemplateCreateInfoMemory(1)
	ref2af95951 := (*C.VkDescriptorUpdateTemplateCreateInfo)(mem2af95951)
	allocs2af95951 := new(cgoAllocMap)
	allocs2af95951.Add(mem2af95951)

	var csType_allocs *cgoAllocMap
	ref2af95951.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2af95951.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2af95951.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2af95951.flags, cflags_allocs = (C.VkDescriptorUpdateTemplateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2af95951.Borrow(cflags_allocs)

	var cdescriptorUpdateEntryCount_allocs *cgoAllocMap
	ref2af95951.descriptorUpdateEntryCount, cdescriptorUpdateEntryCount_allocs = (C.uint32_t)(x.DescriptorUpdateEntryCount), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorUpdateEntryCount_allocs)

	var cpDescriptorUpdateEntries_allocs *cgoAllocMap
	ref2af95951.pDescriptorUpdateEntries, cpDescriptorUpdateEntries_allocs = unpackSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries)
	allocs2af95951.Borrow(cpDescriptorUpdateEntries_allocs)

	var ctemplateType_allocs *cgoAllocMap
	ref2af95951.templateType, ctemplateType_allocs = (C.VkDescriptorUpdateTemplateType)(x.TemplateType), cgoAllocsUnknown
	allocs2af95951.Borrow(ctemplateType_allocs)

	var cdescriptorSetLayout_allocs *cgoAllocMap
	ref2af95951.descriptorSetLayout, cdescriptorSetLayout_allocs = *(*C.VkDescriptorSetLayout)(unsafe.Pointer(&x.DescriptorSetLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorSetLayout_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2af95951.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineBindPoint_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref2af95951.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineLayout_allocs)

	var cset_allocs *cgoAllocMap
	ref2af95951.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs2af95951.Borrow(cset_allocs)

	x.ref2af95951 = ref2af95951
	x.allocs2af95951 = allocs2af95951
	return ref2af95951, allocs2af95951

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) PassValue() (C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x.ref2af95951 != nil {
		return *x.ref2af95951, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateCreateInfo) Deref() {
	if x.ref2af95951 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2af95951.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2af95951.pNext))
	x.Flags = (DescriptorUpdateTemplateCreateFlags)(x.ref2af95951.flags)
	x.DescriptorUpdateEntryCount = (uint32)(x.ref2af95951.descriptorUpdateEntryCount)
	packSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries, x.ref2af95951.pDescriptorUpdateEntries)
	x.TemplateType = (DescriptorUpdateTemplateType)(x.ref2af95951.templateType)
	x.DescriptorSetLayout = *(*DescriptorSetLayout)(unsafe.Pointer(&x.ref2af95951.descriptorSetLayout))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2af95951.pipelineBindPoint)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref2af95951.pipelineLayout))
	x.Set = (uint32)(x.ref2af95951.set)
}

// allocExternalMemoryPropertiesMemory allocates memory for type C.VkExternalMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryPropertiesValue = unsafe.Sizeof([1]C.VkExternalMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryProperties) Ref() *C.VkExternalMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref4b738f01
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryProperties) Free() {
	if x != nil && x.allocs4b738f01 != nil {
		x.allocs4b738f01.(*cgoAllocMap).Free()
		x.ref4b738f01 = nil
	}
}

// NewExternalMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryPropertiesRef(ref unsafe.Pointer) *ExternalMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryProperties)
	obj.ref4b738f01 = (*C.VkExternalMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryProperties) PassRef() (*C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b738f01 != nil {
		return x.ref4b738f01, nil
	}
	mem4b738f01 := allocExternalMemoryPropertiesMemory(1)
	ref4b738f01 := (*C.VkExternalMemoryProperties)(mem4b738f01)
	allocs4b738f01 := new(cgoAllocMap)
	allocs4b738f01.Add(mem4b738f01)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	ref4b738f01.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlags)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref4b738f01.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref4b738f01.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(ccompatibleHandleTypes_allocs)

	x.ref4b738f01 = ref4b738f01
	x.allocs4b738f01 = allocs4b738f01
	return ref4b738f01, allocs4b738f01

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryProperties) PassValue() (C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x.ref4b738f01 != nil {
		return *x.ref4b738f01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryProperties) Deref() {
	if x.ref4b738f01 == nil {
		return
	}
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlags)(x.ref4b738f01.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.compatibleHandleTypes)
}

// allocPhysicalDeviceExternalImageFormatInfoMemory allocates memory for type C.VkPhysicalDeviceExternalImageFormatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalImageFormatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalImageFormatInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalImageFormatInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalImageFormatInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalImageFormatInfo) Ref() *C.VkPhysicalDeviceExternalImageFormatInfo {
	if x == nil {
		return nil
	}
	return x.refc839c724
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	if x != nil && x.allocsc839c724 != nil {
		x.allocsc839c724.(*cgoAllocMap).Free()
		x.refc839c724 = nil
	}
}

// NewPhysicalDeviceExternalImageFormatInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalImageFormatInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalImageFormatInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalImageFormatInfo)
	obj.refc839c724 = (*C.VkPhysicalDeviceExternalImageFormatInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) PassRef() (*C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc839c724 != nil {
		return x.refc839c724, nil
	}
	memc839c724 := allocPhysicalDeviceExternalImageFormatInfoMemory(1)
	refc839c724 := (*C.VkPhysicalDeviceExternalImageFormatInfo)(memc839c724)
	allocsc839c724 := new(cgoAllocMap)
	allocsc839c724.Add(memc839c724)

	var csType_allocs *cgoAllocMap
	refc839c724.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc839c724.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc839c724.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc839c724.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	refc839c724.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc839c724.Borrow(chandleType_allocs)

	x.refc839c724 = refc839c724
	x.allocsc839c724 = allocsc839c724
	return refc839c724, allocsc839c724

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) PassValue() (C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x.refc839c724 != nil {
		return *x.refc839c724, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalImageFormatInfo) Deref() {
	if x.refc839c724 == nil {
		return
	}
	x.SType = (StructureType)(x.refc839c724.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc839c724.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.refc839c724.handleType)
}

// allocExternalImageFormatPropertiesMemory allocates memory for type C.VkExternalImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkExternalImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatProperties) Ref() *C.VkExternalImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.refd404c4b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatProperties) Free() {
	if x != nil && x.allocsd404c4b5 != nil {
		x.allocsd404c4b5.(*cgoAllocMap).Free()
		x.refd404c4b5 = nil
	}
}

// NewExternalImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesRef(ref unsafe.Pointer) *ExternalImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatProperties)
	obj.refd404c4b5 = (*C.VkExternalImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatProperties) PassRef() (*C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd404c4b5 != nil {
		return x.refd404c4b5, nil
	}
	memd404c4b5 := allocExternalImageFormatPropertiesMemory(1)
	refd404c4b5 := (*C.VkExternalImageFormatProperties)(memd404c4b5)
	allocsd404c4b5 := new(cgoAllocMap)
	allocsd404c4b5.Add(memd404c4b5)

	var csType_allocs *cgoAllocMap
	refd404c4b5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd404c4b5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd404c4b5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd404c4b5.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	refd404c4b5.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocsd404c4b5.Borrow(cexternalMemoryProperties_allocs)

	x.refd404c4b5 = refd404c4b5
	x.allocsd404c4b5 = allocsd404c4b5
	return refd404c4b5, allocsd404c4b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatProperties) PassValue() (C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x.refd404c4b5 != nil {
		return *x.refd404c4b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatProperties) Deref() {
	if x.refd404c4b5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd404c4b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd404c4b5.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.refd404c4b5.externalMemoryProperties))
}

// allocPhysicalDeviceExternalBufferInfoMemory allocates memory for type C.VkPhysicalDeviceExternalBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalBufferInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalBufferInfo) Ref() *C.VkPhysicalDeviceExternalBufferInfo {
	if x == nil {
		return nil
	}
	return x.ref8d758947
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	if x != nil && x.allocs8d758947 != nil {
		x.allocs8d758947.(*cgoAllocMap).Free()
		x.ref8d758947 = nil
	}
}

// NewPhysicalDeviceExternalBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalBufferInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalBufferInfo)
	obj.ref8d758947 = (*C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalBufferInfo) PassRef() (*C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d758947 != nil {
		return x.ref8d758947, nil
	}
	mem8d758947 := allocPhysicalDeviceExternalBufferInfoMemory(1)
	ref8d758947 := (*C.VkPhysicalDeviceExternalBufferInfo)(mem8d758947)
	allocs8d758947 := new(cgoAllocMap)
	allocs8d758947.Add(mem8d758947)

	var csType_allocs *cgoAllocMap
	ref8d758947.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d758947.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d758947.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d758947.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref8d758947.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs8d758947.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	ref8d758947.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs8d758947.Borrow(cusage_allocs)

	var chandleType_allocs *cgoAllocMap
	ref8d758947.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs8d758947.Borrow(chandleType_allocs)

	x.ref8d758947 = ref8d758947
	x.allocs8d758947 = allocs8d758947
	return ref8d758947, allocs8d758947

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) PassValue() (C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x.ref8d758947 != nil {
		return *x.ref8d758947, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalBufferInfo) Deref() {
	if x.ref8d758947 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d758947.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d758947.pNext))
	x.Flags = (BufferCreateFlags)(x.ref8d758947.flags)
	x.Usage = (BufferUsageFlags)(x.ref8d758947.usage)
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref8d758947.handleType)
}

// allocExternalBufferPropertiesMemory allocates memory for type C.VkExternalBufferProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalBufferPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalBufferPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalBufferPropertiesValue = unsafe.Sizeof([1]C.VkExternalBufferProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalBufferProperties) Ref() *C.VkExternalBufferProperties {
	if x == nil {
		return nil
	}
	return x.ref12f7c546
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalBufferProperties) Free() {
	if x != nil && x.allocs12f7c546 != nil {
		x.allocs12f7c546.(*cgoAllocMap).Free()
		x.ref12f7c546 = nil
	}
}

// NewExternalBufferPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalBufferPropertiesRef(ref unsafe.Pointer) *ExternalBufferProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalBufferProperties)
	obj.ref12f7c546 = (*C.VkExternalBufferProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalBufferProperties) PassRef() (*C.VkExternalBufferProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12f7c546 != nil {
		return x.ref12f7c546, nil
	}
	mem12f7c546 := allocExternalBufferPropertiesMemory(1)
	ref12f7c546 := (*C.VkExternalBufferProperties)(mem12f7c546)
	allocs12f7c546 := new(cgoAllocMap)
	allocs12f7c546.Add(mem12f7c546)

	var csType_allocs *cgoAllocMap
	ref12f7c546.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12f7c546.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12f7c546.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12f7c546.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	ref12f7c546.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocs12f7c546.Borrow(cexternalMemoryProperties_allocs)

	x.ref12f7c546 = ref12f7c546
	x.allocs12f7c546 = allocs12f7c546
	return ref12f7c546, allocs12f7c546

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalBufferProperties) PassValue() (C.VkExternalBufferProperties, *cgoAllocMap) {
	if x.ref12f7c546 != nil {
		return *x.ref12f7c546, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalBufferProperties) Deref() {
	if x.ref12f7c546 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12f7c546.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12f7c546.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.ref12f7c546.externalMemoryProperties))
}

// allocPhysicalDeviceIDPropertiesMemory allocates memory for type C.VkPhysicalDeviceIDProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceIDPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceIDPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceIDPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceIDProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIDProperties) Ref() *C.VkPhysicalDeviceIDProperties {
	if x == nil {
		return nil
	}
	return x.refe990a9f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIDProperties) Free() {
	if x != nil && x.allocse990a9f3 != nil {
		x.allocse990a9f3.(*cgoAllocMap).Free()
		x.refe990a9f3 = nil
	}
}

// NewPhysicalDeviceIDPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIDPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceIDProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIDProperties)
	obj.refe990a9f3 = (*C.VkPhysicalDeviceIDProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIDProperties) PassRef() (*C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe990a9f3 != nil {
		return x.refe990a9f3, nil
	}
	meme990a9f3 := allocPhysicalDeviceIDPropertiesMemory(1)
	refe990a9f3 := (*C.VkPhysicalDeviceIDProperties)(meme990a9f3)
	allocse990a9f3 := new(cgoAllocMap)
	allocse990a9f3.Add(meme990a9f3)

	var csType_allocs *cgoAllocMap
	refe990a9f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse990a9f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe990a9f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cpNext_allocs)

	var cdeviceUUID_allocs *cgoAllocMap
	refe990a9f3.deviceUUID, cdeviceUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceUUID_allocs)

	var cdriverUUID_allocs *cgoAllocMap
	refe990a9f3.driverUUID, cdriverUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdriverUUID_allocs)

	var cdeviceLUID_allocs *cgoAllocMap
	refe990a9f3.deviceLUID, cdeviceLUID_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUID_allocs)

	var cdeviceNodeMask_allocs *cgoAllocMap
	refe990a9f3.deviceNodeMask, cdeviceNodeMask_allocs = (C.uint32_t)(x.DeviceNodeMask), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceNodeMask_allocs)

	var cdeviceLUIDValid_allocs *cgoAllocMap
	refe990a9f3.deviceLUIDValid, cdeviceLUIDValid_allocs = (C.VkBool32)(x.DeviceLUIDValid), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUIDValid_allocs)

	x.refe990a9f3 = refe990a9f3
	x.allocse990a9f3 = allocse990a9f3
	return refe990a9f3, allocse990a9f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIDProperties) PassValue() (C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x.refe990a9f3 != nil {
		return *x.refe990a9f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIDProperties) Deref() {
	if x.refe990a9f3 == nil {
		return
	}
	x.SType = (StructureType)(x.refe990a9f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe990a9f3.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refe990a9f3.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refe990a9f3.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refe990a9f3.deviceLUIDValid)
}

// allocExternalMemoryImageCreateInfoMemory allocates memory for type C.VkExternalMemoryImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfo) Ref() *C.VkExternalMemoryImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.refdaf1185e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfo) Free() {
	if x != nil && x.allocsdaf1185e != nil {
		x.allocsdaf1185e.(*cgoAllocMap).Free()
		x.refdaf1185e = nil
	}
}

// NewExternalMemoryImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfo)
	obj.refdaf1185e = (*C.VkExternalMemoryImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfo) PassRef() (*C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdaf1185e != nil {
		return x.refdaf1185e, nil
	}
	memdaf1185e := allocExternalMemoryImageCreateInfoMemory(1)
	refdaf1185e := (*C.VkExternalMemoryImageCreateInfo)(memdaf1185e)
	allocsdaf1185e := new(cgoAllocMap)
	allocsdaf1185e.Add(memdaf1185e)

	var csType_allocs *cgoAllocMap
	refdaf1185e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdaf1185e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdaf1185e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdaf1185e.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refdaf1185e.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsdaf1185e.Borrow(chandleTypes_allocs)

	x.refdaf1185e = refdaf1185e
	x.allocsdaf1185e = allocsdaf1185e
	return refdaf1185e, allocsdaf1185e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfo) PassValue() (C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x.refdaf1185e != nil {
		return *x.refdaf1185e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfo) Deref() {
	if x.refdaf1185e == nil {
		return
	}
	x.SType = (StructureType)(x.refdaf1185e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdaf1185e.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refdaf1185e.handleTypes)
}

// allocExternalMemoryBufferCreateInfoMemory allocates memory for type C.VkExternalMemoryBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryBufferCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryBufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryBufferCreateInfo) Ref() *C.VkExternalMemoryBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refd33a9423
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	if x != nil && x.allocsd33a9423 != nil {
		x.allocsd33a9423.(*cgoAllocMap).Free()
		x.refd33a9423 = nil
	}
}

// NewExternalMemoryBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryBufferCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryBufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryBufferCreateInfo)
	obj.refd33a9423 = (*C.VkExternalMemoryBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryBufferCreateInfo) PassRef() (*C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd33a9423 != nil {
		return x.refd33a9423, nil
	}
	memd33a9423 := allocExternalMemoryBufferCreateInfoMemory(1)
	refd33a9423 := (*C.VkExternalMemoryBufferCreateInfo)(memd33a9423)
	allocsd33a9423 := new(cgoAllocMap)
	allocsd33a9423.Add(memd33a9423)

	var csType_allocs *cgoAllocMap
	refd33a9423.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd33a9423.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd33a9423.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd33a9423.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refd33a9423.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsd33a9423.Borrow(chandleTypes_allocs)

	x.refd33a9423 = refd33a9423
	x.allocsd33a9423 = allocsd33a9423
	return refd33a9423, allocsd33a9423

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryBufferCreateInfo) PassValue() (C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x.refd33a9423 != nil {
		return *x.refd33a9423, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryBufferCreateInfo) Deref() {
	if x.refd33a9423 == nil {
		return
	}
	x.SType = (StructureType)(x.refd33a9423.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd33a9423.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refd33a9423.handleTypes)
}

// allocExportMemoryAllocateInfoMemory allocates memory for type C.VkExportMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfo) Ref() *C.VkExportMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refeb76ec64
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfo) Free() {
	if x != nil && x.allocseb76ec64 != nil {
		x.allocseb76ec64.(*cgoAllocMap).Free()
		x.refeb76ec64 = nil
	}
}

// NewExportMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoRef(ref unsafe.Pointer) *ExportMemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfo)
	obj.refeb76ec64 = (*C.VkExportMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfo) PassRef() (*C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb76ec64 != nil {
		return x.refeb76ec64, nil
	}
	memeb76ec64 := allocExportMemoryAllocateInfoMemory(1)
	refeb76ec64 := (*C.VkExportMemoryAllocateInfo)(memeb76ec64)
	allocseb76ec64 := new(cgoAllocMap)
	allocseb76ec64.Add(memeb76ec64)

	var csType_allocs *cgoAllocMap
	refeb76ec64.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseb76ec64.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeb76ec64.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseb76ec64.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refeb76ec64.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocseb76ec64.Borrow(chandleTypes_allocs)

	x.refeb76ec64 = refeb76ec64
	x.allocseb76ec64 = allocseb76ec64
	return refeb76ec64, allocseb76ec64

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfo) PassValue() (C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x.refeb76ec64 != nil {
		return *x.refeb76ec64, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfo) Deref() {
	if x.refeb76ec64 == nil {
		return
	}
	x.SType = (StructureType)(x.refeb76ec64.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeb76ec64.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refeb76ec64.handleTypes)
}

// allocPhysicalDeviceExternalFenceInfoMemory allocates memory for type C.VkPhysicalDeviceExternalFenceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalFenceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalFenceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalFenceInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalFenceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalFenceInfo) Ref() *C.VkPhysicalDeviceExternalFenceInfo {
	if x == nil {
		return nil
	}
	return x.ref9bb660cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	if x != nil && x.allocs9bb660cc != nil {
		x.allocs9bb660cc.(*cgoAllocMap).Free()
		x.ref9bb660cc = nil
	}
}

// NewPhysicalDeviceExternalFenceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalFenceInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalFenceInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalFenceInfo)
	obj.ref9bb660cc = (*C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalFenceInfo) PassRef() (*C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb660cc != nil {
		return x.ref9bb660cc, nil
	}
	mem9bb660cc := allocPhysicalDeviceExternalFenceInfoMemory(1)
	ref9bb660cc := (*C.VkPhysicalDeviceExternalFenceInfo)(mem9bb660cc)
	allocs9bb660cc := new(cgoAllocMap)
	allocs9bb660cc.Add(mem9bb660cc)

	var csType_allocs *cgoAllocMap
	ref9bb660cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9bb660cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9bb660cc.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref9bb660cc.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(chandleType_allocs)

	x.ref9bb660cc = ref9bb660cc
	x.allocs9bb660cc = allocs9bb660cc
	return ref9bb660cc, allocs9bb660cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) PassValue() (C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x.ref9bb660cc != nil {
		return *x.ref9bb660cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalFenceInfo) Deref() {
	if x.ref9bb660cc == nil {
		return
	}
	x.SType = (StructureType)(x.ref9bb660cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9bb660cc.pNext))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref9bb660cc.handleType)
}

// allocExternalFencePropertiesMemory allocates memory for type C.VkExternalFenceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalFencePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalFencePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalFencePropertiesValue = unsafe.Sizeof([1]C.VkExternalFenceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalFenceProperties) Ref() *C.VkExternalFenceProperties {
	if x == nil {
		return nil
	}
	return x.ref18806773
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalFenceProperties) Free() {
	if x != nil && x.allocs18806773 != nil {
		x.allocs18806773.(*cgoAllocMap).Free()
		x.ref18806773 = nil
	}
}

// NewExternalFencePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalFencePropertiesRef(ref unsafe.Pointer) *ExternalFenceProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalFenceProperties)
	obj.ref18806773 = (*C.VkExternalFenceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalFenceProperties) PassRef() (*C.VkExternalFenceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18806773 != nil {
		return x.ref18806773, nil
	}
	mem18806773 := allocExternalFencePropertiesMemory(1)
	ref18806773 := (*C.VkExternalFenceProperties)(mem18806773)
	allocs18806773 := new(cgoAllocMap)
	allocs18806773.Add(mem18806773)

	var csType_allocs *cgoAllocMap
	ref18806773.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18806773.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18806773.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18806773.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref18806773.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref18806773.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalFenceFeatures_allocs *cgoAllocMap
	ref18806773.externalFenceFeatures, cexternalFenceFeatures_allocs = (C.VkExternalFenceFeatureFlags)(x.ExternalFenceFeatures), cgoAllocsUnknown
	allocs18806773.Borrow(cexternalFenceFeatures_allocs)

	x.ref18806773 = ref18806773
	x.allocs18806773 = allocs18806773
	return ref18806773, allocs18806773

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalFenceProperties) PassValue() (C.VkExternalFenceProperties, *cgoAllocMap) {
	if x.ref18806773 != nil {
		return *x.ref18806773, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalFenceProperties) Deref() {
	if x.ref18806773 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18806773.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18806773.pNext))
	x.ExportFromImportedHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.compatibleHandleTypes)
	x.ExternalFenceFeatures = (ExternalFenceFeatureFlags)(x.ref18806773.externalFenceFeatures)
}

// allocExportFenceCreateInfoMemory allocates memory for type C.VkExportFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportFenceCreateInfoValue = unsafe.Sizeof([1]C.VkExportFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportFenceCreateInfo) Ref() *C.VkExportFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fef8c3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportFenceCreateInfo) Free() {
	if x != nil && x.allocs5fef8c3a != nil {
		x.allocs5fef8c3a.(*cgoAllocMap).Free()
		x.ref5fef8c3a = nil
	}
}

// NewExportFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportFenceCreateInfoRef(ref unsafe.Pointer) *ExportFenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportFenceCreateInfo)
	obj.ref5fef8c3a = (*C.VkExportFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportFenceCreateInfo) PassRef() (*C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fef8c3a != nil {
		return x.ref5fef8c3a, nil
	}
	mem5fef8c3a := allocExportFenceCreateInfoMemory(1)
	ref5fef8c3a := (*C.VkExportFenceCreateInfo)(mem5fef8c3a)
	allocs5fef8c3a := new(cgoAllocMap)
	allocs5fef8c3a.Add(mem5fef8c3a)

	var csType_allocs *cgoAllocMap
	ref5fef8c3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fef8c3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5fef8c3a.handleTypes, chandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(chandleTypes_allocs)

	x.ref5fef8c3a = ref5fef8c3a
	x.allocs5fef8c3a = allocs5fef8c3a
	return ref5fef8c3a, allocs5fef8c3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportFenceCreateInfo) PassValue() (C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x.ref5fef8c3a != nil {
		return *x.ref5fef8c3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportFenceCreateInfo) Deref() {
	if x.ref5fef8c3a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fef8c3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fef8c3a.pNext))
	x.HandleTypes = (ExternalFenceHandleTypeFlags)(x.ref5fef8c3a.handleTypes)
}

// allocExportSemaphoreCreateInfoMemory allocates memory for type C.VkExportSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkExportSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportSemaphoreCreateInfo) Ref() *C.VkExportSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref17b8d6c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportSemaphoreCreateInfo) Free() {
	if x != nil && x.allocs17b8d6c5 != nil {
		x.allocs17b8d6c5.(*cgoAllocMap).Free()
		x.ref17b8d6c5 = nil
	}
}

// NewExportSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportSemaphoreCreateInfoRef(ref unsafe.Pointer) *ExportSemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportSemaphoreCreateInfo)
	obj.ref17b8d6c5 = (*C.VkExportSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportSemaphoreCreateInfo) PassRef() (*C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17b8d6c5 != nil {
		return x.ref17b8d6c5, nil
	}
	mem17b8d6c5 := allocExportSemaphoreCreateInfoMemory(1)
	ref17b8d6c5 := (*C.VkExportSemaphoreCreateInfo)(mem17b8d6c5)
	allocs17b8d6c5 := new(cgoAllocMap)
	allocs17b8d6c5.Add(mem17b8d6c5)

	var csType_allocs *cgoAllocMap
	ref17b8d6c5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref17b8d6c5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref17b8d6c5.handleTypes, chandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(chandleTypes_allocs)

	x.ref17b8d6c5 = ref17b8d6c5
	x.allocs17b8d6c5 = allocs17b8d6c5
	return ref17b8d6c5, allocs17b8d6c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportSemaphoreCreateInfo) PassValue() (C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x.ref17b8d6c5 != nil {
		return *x.ref17b8d6c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportSemaphoreCreateInfo) Deref() {
	if x.ref17b8d6c5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref17b8d6c5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref17b8d6c5.pNext))
	x.HandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref17b8d6c5.handleTypes)
}

// allocPhysicalDeviceExternalSemaphoreInfoMemory allocates memory for type C.VkPhysicalDeviceExternalSemaphoreInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalSemaphoreInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalSemaphoreInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalSemaphoreInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalSemaphoreInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalSemaphoreInfo) Ref() *C.VkPhysicalDeviceExternalSemaphoreInfo {
	if x == nil {
		return nil
	}
	return x.ref5981d29e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	if x != nil && x.allocs5981d29e != nil {
		x.allocs5981d29e.(*cgoAllocMap).Free()
		x.ref5981d29e = nil
	}
}

// NewPhysicalDeviceExternalSemaphoreInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalSemaphoreInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalSemaphoreInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalSemaphoreInfo)
	obj.ref5981d29e = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) PassRef() (*C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5981d29e != nil {
		return x.ref5981d29e, nil
	}
	mem5981d29e := allocPhysicalDeviceExternalSemaphoreInfoMemory(1)
	ref5981d29e := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(mem5981d29e)
	allocs5981d29e := new(cgoAllocMap)
	allocs5981d29e.Add(mem5981d29e)

	var csType_allocs *cgoAllocMap
	ref5981d29e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5981d29e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5981d29e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5981d29e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref5981d29e.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs5981d29e.Borrow(chandleType_allocs)

	x.ref5981d29e = ref5981d29e
	x.allocs5981d29e = allocs5981d29e
	return ref5981d29e, allocs5981d29e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) PassValue() (C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x.ref5981d29e != nil {
		return *x.ref5981d29e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalSemaphoreInfo) Deref() {
	if x.ref5981d29e == nil {
		return
	}
	x.SType = (StructureType)(x.ref5981d29e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5981d29e.pNext))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.ref5981d29e.handleType)
}

// allocExternalSemaphorePropertiesMemory allocates memory for type C.VkExternalSemaphoreProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalSemaphorePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalSemaphorePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalSemaphorePropertiesValue = unsafe.Sizeof([1]C.VkExternalSemaphoreProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalSemaphoreProperties) Ref() *C.VkExternalSemaphoreProperties {
	if x == nil {
		return nil
	}
	return x.ref87ec1054
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalSemaphoreProperties) Free() {
	if x != nil && x.allocs87ec1054 != nil {
		x.allocs87ec1054.(*cgoAllocMap).Free()
		x.ref87ec1054 = nil
	}
}

// NewExternalSemaphorePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalSemaphorePropertiesRef(ref unsafe.Pointer) *ExternalSemaphoreProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalSemaphoreProperties)
	obj.ref87ec1054 = (*C.VkExternalSemaphoreProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalSemaphoreProperties) PassRef() (*C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87ec1054 != nil {
		return x.ref87ec1054, nil
	}
	mem87ec1054 := allocExternalSemaphorePropertiesMemory(1)
	ref87ec1054 := (*C.VkExternalSemaphoreProperties)(mem87ec1054)
	allocs87ec1054 := new(cgoAllocMap)
	allocs87ec1054.Add(mem87ec1054)

	var csType_allocs *cgoAllocMap
	ref87ec1054.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs87ec1054.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref87ec1054.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs87ec1054.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref87ec1054.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref87ec1054.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalSemaphoreFeatures_allocs *cgoAllocMap
	ref87ec1054.externalSemaphoreFeatures, cexternalSemaphoreFeatures_allocs = (C.VkExternalSemaphoreFeatureFlags)(x.ExternalSemaphoreFeatures), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexternalSemaphoreFeatures_allocs)

	x.ref87ec1054 = ref87ec1054
	x.allocs87ec1054 = allocs87ec1054
	return ref87ec1054, allocs87ec1054

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalSemaphoreProperties) PassValue() (C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x.ref87ec1054 != nil {
		return *x.ref87ec1054, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalSemaphoreProperties) Deref() {
	if x.ref87ec1054 == nil {
		return
	}
	x.SType = (StructureType)(x.ref87ec1054.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref87ec1054.pNext))
	x.ExportFromImportedHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.compatibleHandleTypes)
	x.ExternalSemaphoreFeatures = (ExternalSemaphoreFeatureFlags)(x.ref87ec1054.externalSemaphoreFeatures)
}

// allocPhysicalDeviceMaintenance3PropertiesMemory allocates memory for type C.VkPhysicalDeviceMaintenance3Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMaintenance3PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMaintenance3PropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMaintenance3PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMaintenance3Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMaintenance3Properties) Ref() *C.VkPhysicalDeviceMaintenance3Properties {
	if x == nil {
		return nil
	}
	return x.ref12c07777
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	if x != nil && x.allocs12c07777 != nil {
		x.allocs12c07777.(*cgoAllocMap).Free()
		x.ref12c07777 = nil
	}
}

// NewPhysicalDeviceMaintenance3PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMaintenance3PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMaintenance3Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMaintenance3Properties)
	obj.ref12c07777 = (*C.VkPhysicalDeviceMaintenance3Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMaintenance3Properties) PassRef() (*C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12c07777 != nil {
		return x.ref12c07777, nil
	}
	mem12c07777 := allocPhysicalDeviceMaintenance3PropertiesMemory(1)
	ref12c07777 := (*C.VkPhysicalDeviceMaintenance3Properties)(mem12c07777)
	allocs12c07777 := new(cgoAllocMap)
	allocs12c07777.Add(mem12c07777)

	var csType_allocs *cgoAllocMap
	ref12c07777.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12c07777.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12c07777.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12c07777.Borrow(cpNext_allocs)

	var cmaxPerSetDescriptors_allocs *cgoAllocMap
	ref12c07777.maxPerSetDescriptors, cmaxPerSetDescriptors_allocs = (C.uint32_t)(x.MaxPerSetDescriptors), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxPerSetDescriptors_allocs)

	var cmaxMemoryAllocationSize_allocs *cgoAllocMap
	ref12c07777.maxMemoryAllocationSize, cmaxMemoryAllocationSize_allocs = (C.VkDeviceSize)(x.MaxMemoryAllocationSize), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxMemoryAllocationSize_allocs)

	x.ref12c07777 = ref12c07777
	x.allocs12c07777 = allocs12c07777
	return ref12c07777, allocs12c07777

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) PassValue() (C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x.ref12c07777 != nil {
		return *x.ref12c07777, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMaintenance3Properties) Deref() {
	if x.ref12c07777 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12c07777.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12c07777.pNext))
	x.MaxPerSetDescriptors = (uint32)(x.ref12c07777.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.ref12c07777.maxMemoryAllocationSize)
}

// allocDescriptorSetLayoutSupportMemory allocates memory for type C.VkDescriptorSetLayoutSupport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutSupportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutSupportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutSupportValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutSupport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutSupport) Ref() *C.VkDescriptorSetLayoutSupport {
	if x == nil {
		return nil
	}
	return x.ref5802686c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutSupport) Free() {
	if x != nil && x.allocs5802686c != nil {
		x.allocs5802686c.(*cgoAllocMap).Free()
		x.ref5802686c = nil
	}
}

// NewDescriptorSetLayoutSupportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutSupportRef(ref unsafe.Pointer) *DescriptorSetLayoutSupport {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutSupport)
	obj.ref5802686c = (*C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutSupport) PassRef() (*C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5802686c != nil {
		return x.ref5802686c, nil
	}
	mem5802686c := allocDescriptorSetLayoutSupportMemory(1)
	ref5802686c := (*C.VkDescriptorSetLayoutSupport)(mem5802686c)
	allocs5802686c := new(cgoAllocMap)
	allocs5802686c.Add(mem5802686c)

	var csType_allocs *cgoAllocMap
	ref5802686c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5802686c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5802686c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5802686c.Borrow(cpNext_allocs)

	var csupported_allocs *cgoAllocMap
	ref5802686c.supported, csupported_allocs = (C.VkBool32)(x.Supported), cgoAllocsUnknown
	allocs5802686c.Borrow(csupported_allocs)

	x.ref5802686c = ref5802686c
	x.allocs5802686c = allocs5802686c
	return ref5802686c, allocs5802686c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutSupport) PassValue() (C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x.ref5802686c != nil {
		return *x.ref5802686c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutSupport) Deref() {
	if x.ref5802686c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5802686c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5802686c.pNext))
	x.Supported = (Bool32)(x.ref5802686c.supported)
}

// allocPhysicalDeviceShaderDrawParameterFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderDrawParameterFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderDrawParameterFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderDrawParameterFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderDrawParameterFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderDrawParameterFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Ref() *C.VkPhysicalDeviceShaderDrawParameterFeatures {
	if x == nil {
		return nil
	}
	return x.ref23259ea6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Free() {
	if x != nil && x.allocs23259ea6 != nil {
		x.allocs23259ea6.(*cgoAllocMap).Free()
		x.ref23259ea6 = nil
	}
}

// NewPhysicalDeviceShaderDrawParameterFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderDrawParameterFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderDrawParameterFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderDrawParameterFeatures)
	obj.ref23259ea6 = (*C.VkPhysicalDeviceShaderDrawParameterFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) PassRef() (*C.VkPhysicalDeviceShaderDrawParameterFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref23259ea6 != nil {
		return x.ref23259ea6, nil
	}
	mem23259ea6 := allocPhysicalDeviceShaderDrawParameterFeaturesMemory(1)
	ref23259ea6 := (*C.VkPhysicalDeviceShaderDrawParameterFeatures)(mem23259ea6)
	allocs23259ea6 := new(cgoAllocMap)
	allocs23259ea6.Add(mem23259ea6)

	var csType_allocs *cgoAllocMap
	ref23259ea6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs23259ea6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref23259ea6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs23259ea6.Borrow(cpNext_allocs)

	var cshaderDrawParameters_allocs *cgoAllocMap
	ref23259ea6.shaderDrawParameters, cshaderDrawParameters_allocs = (C.VkBool32)(x.ShaderDrawParameters), cgoAllocsUnknown
	allocs23259ea6.Borrow(cshaderDrawParameters_allocs)

	x.ref23259ea6 = ref23259ea6
	x.allocs23259ea6 = allocs23259ea6
	return ref23259ea6, allocs23259ea6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderDrawParameterFeatures) PassValue() (C.VkPhysicalDeviceShaderDrawParameterFeatures, *cgoAllocMap) {
	if x.ref23259ea6 != nil {
		return *x.ref23259ea6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Deref() {
	if x.ref23259ea6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref23259ea6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref23259ea6.pNext))
	x.ShaderDrawParameters = (Bool32)(x.ref23259ea6.shaderDrawParameters)
}

// allocSurfaceCapabilitiesKHRMemory allocates memory for type C.VkSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilitiesKHR) Ref() *C.VkSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref11d5f596
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilitiesKHR) Free() {
	if x != nil && x.allocs11d5f596 != nil {
		x.allocs11d5f596.(*cgoAllocMap).Free()
		x.ref11d5f596 = nil
	}
}

// NewSurfaceCapabilitiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilitiesKHRRef(ref unsafe.Pointer) *SurfaceCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilitiesKHR)
	obj.ref11d5f596 = (*C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilitiesKHR) PassRef() (*C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11d5f596 != nil {
		return x.ref11d5f596, nil
	}
	mem11d5f596 := allocSurfaceCapabilitiesKHRMemory(1)
	ref11d5f596 := (*C.VkSurfaceCapabilitiesKHR)(mem11d5f596)
	allocs11d5f596 := new(cgoAllocMap)
	allocs11d5f596.Add(mem11d5f596)

	var cminImageCount_allocs *cgoAllocMap
	ref11d5f596.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref11d5f596.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref11d5f596.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs11d5f596.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref11d5f596.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs11d5f596.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref11d5f596.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs11d5f596.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref11d5f596.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref11d5f596.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref11d5f596.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs11d5f596.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref11d5f596.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref11d5f596.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedUsageFlags_allocs)

	x.ref11d5f596 = ref11d5f596
	x.allocs11d5f596 = allocs11d5f596
	return ref11d5f596, allocs11d5f596

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilitiesKHR) PassValue() (C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref11d5f596 != nil {
		return *x.ref11d5f596, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilitiesKHR) Deref() {
	if x.ref11d5f596 == nil {
		return
	}
	x.MinImageCount = (uint32)(x.ref11d5f596.minImageCount)
	x.MaxImageCount = (uint32)(x.ref11d5f596.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.currentExtent))
	x.MinImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.minImageExtent))
	x.MaxImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.maxImageExtent))
	x.MaxImageArrayLayers = (uint32)(x.ref11d5f596.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlagsKHR)(x.ref11d5f596.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBitsKHR)(x.ref11d5f596.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlagsKHR)(x.ref11d5f596.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref11d5f596.supportedUsageFlags)
}

// allocSurfaceFormatKHRMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormatKHRValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormatKHR) Ref() *C.VkSurfaceFormatKHR {
	if x == nil {
		return nil
	}
	return x.refedaf82ca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormatKHR) Free() {
	if x != nil && x.allocsedaf82ca != nil {
		x.allocsedaf82ca.(*cgoAllocMap).Free()
		x.refedaf82ca = nil
	}
}

// NewSurfaceFormatKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormatKHRRef(ref unsafe.Pointer) *SurfaceFormatKHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormatKHR)
	obj.refedaf82ca = (*C.VkSurfaceFormatKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormatKHR) PassRef() (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedaf82ca != nil {
		return x.refedaf82ca, nil
	}
	memedaf82ca := allocSurfaceFormatKHRMemory(1)
	refedaf82ca := (*C.VkSurfaceFormatKHR)(memedaf82ca)
	allocsedaf82ca := new(cgoAllocMap)
	allocsedaf82ca.Add(memedaf82ca)

	var cformat_allocs *cgoAllocMap
	refedaf82ca.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsedaf82ca.Borrow(cformat_allocs)

	var ccolorSpace_allocs *cgoAllocMap
	refedaf82ca.colorSpace, ccolorSpace_allocs = (C.VkColorSpaceKHR)(x.ColorSpace), cgoAllocsUnknown
	allocsedaf82ca.Borrow(ccolorSpace_allocs)

	x.refedaf82ca = refedaf82ca
	x.allocsedaf82ca = allocsedaf82ca
	return refedaf82ca, allocsedaf82ca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormatKHR) PassValue() (C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x.refedaf82ca != nil {
		return *x.refedaf82ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormatKHR) Deref() {
	if x.refedaf82ca == nil {
		return
	}
	x.Format = (Format)(x.refedaf82ca.format)
	x.ColorSpace = (ColorSpaceKHR)(x.refedaf82ca.colorSpace)
}

// allocSwapchainCreateInfoKHRMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCreateInfoKHRValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCreateInfoKHR) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCreateInfoKHR) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCreateInfoKHRRef(ref unsafe.Pointer) *SwapchainCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCreateInfoKHR)
	obj.refdb619e1c = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCreateInfoKHR) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoKHRMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	allocsdb619e1c.Add(memdb619e1c)

	var csType_allocs *cgoAllocMap
	refdb619e1c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb619e1c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refdb619e1c.flags, cflags_allocs = (C.VkSwapchainCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cflags_allocs)

	var csurface_allocs *cgoAllocMap
	refdb619e1c.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csurface_allocs)

	var cminImageCount_allocs *cgoAllocMap
	refdb619e1c.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cminImageCount_allocs)

	var cimageFormat_allocs *cgoAllocMap
	refdb619e1c.imageFormat, cimageFormat_allocs = (C.VkFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageFormat_allocs)

	var cimageColorSpace_allocs *cgoAllocMap
	refdb619e1c.imageColorSpace, cimageColorSpace_allocs = (C.VkColorSpaceKHR)(x.ImageColorSpace), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageColorSpace_allocs)

	var cimageExtent_allocs *cgoAllocMap
	refdb619e1c.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocsdb619e1c.Borrow(cimageExtent_allocs)

	var cimageArrayLayers_allocs *cgoAllocMap
	refdb619e1c.imageArrayLayers, cimageArrayLayers_allocs = (C.uint32_t)(x.ImageArrayLayers), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageArrayLayers_allocs)

	var cimageUsage_allocs *cgoAllocMap
	refdb619e1c.imageUsage, cimageUsage_allocs = (C.VkImageUsageFlags)(x.ImageUsage), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageUsage_allocs)

	var cimageSharingMode_allocs *cgoAllocMap
	refdb619e1c.imageSharingMode, cimageSharingMode_allocs = (C.VkSharingMode)(x.ImageSharingMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageSharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refdb619e1c.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)

	var cpreTransform_allocs *cgoAllocMap
	refdb619e1c.preTransform, cpreTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpreTransform_allocs)

	var ccompositeAlpha_allocs *cgoAllocMap
	refdb619e1c.compositeAlpha, ccompositeAlpha_allocs = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha), cgoAllocsUnknown
	allocsdb619e1c.Borrow(ccompositeAlpha_allocs)

	var cpresentMode_allocs *cgoAllocMap
	refdb619e1c.presentMode, cpresentMode_allocs = (C.VkPresentModeKHR)(x.PresentMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpresentMode_allocs)

	var cclipped_allocs *cgoAllocMap
	refdb619e1c.clipped, cclipped_allocs = (C.VkBool32)(x.Clipped), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cclipped_allocs)

	var coldSwapchain_allocs *cgoAllocMap
	refdb619e1c.oldSwapchain, coldSwapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(coldSwapchain_allocs)

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCreateInfoKHR) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCreateInfoKHR) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlagsKHR)(x.refdb619e1c.flags)
	x.Surface = *(*SurfaceKHR)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpaceKHR)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.refdb619e1c.imageExtent))
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxffe3496 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxffe3496.Data = unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices)
	hxffe3496.Cap = 0x7fffffff
	// hxffe3496.Len = ?

	x.PreTransform = (SurfaceTransformFlagBitsKHR)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBitsKHR)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentModeKHR)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*SwapchainKHR)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoKHRMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentInfoKHRValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentInfoKHR) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentInfoKHR) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentInfoKHRRef(ref unsafe.Pointer) *PresentInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PresentInfoKHR)
	obj.ref1d0e82d4 = (*C.VkPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentInfoKHR) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoKHRMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	allocs1d0e82d4.Add(mem1d0e82d4)

	var csType_allocs *cgoAllocMap
	ref1d0e82d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d0e82d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref1d0e82d4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref1d0e82d4.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cswapchainCount_allocs)

	var cpSwapchains_allocs *cgoAllocMap
	ref1d0e82d4.pSwapchains, cpSwapchains_allocs = (*C.VkSwapchainKHR)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpSwapchains_allocs)

	var cpImageIndices_allocs *cgoAllocMap
	ref1d0e82d4.pImageIndices, cpImageIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpImageIndices_allocs)

	var cpResults_allocs *cgoAllocMap
	ref1d0e82d4.pResults, cpResults_allocs = (*C.VkResult)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PResults)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpResults_allocs)

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentInfoKHR) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentInfoKHR) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf5d48a6.Data = unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores)
	hxf5d48a6.Cap = 0x7fffffff
	// hxf5d48a6.Len = ?

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxf685469 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxf685469.Data = unsafe.Pointer(x.ref1d0e82d4.pSwapchains)
	hxf685469.Cap = 0x7fffffff
	// hxf685469.Len = ?

	hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxf03a9a7.Data = unsafe.Pointer(x.ref1d0e82d4.pImageIndices)
	hxf03a9a7.Cap = 0x7fffffff
	// hxf03a9a7.Len = ?

	hxff24242 := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxff24242.Data = unsafe.Pointer(x.ref1d0e82d4.pResults)
	hxff24242.Cap = 0x7fffffff
	// hxff24242.Len = ?

}

// allocImageSwapchainCreateInfoKHRMemory allocates memory for type C.VkImageSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSwapchainCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSwapchainCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSwapchainCreateInfoKHRValue = unsafe.Sizeof([1]C.VkImageSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSwapchainCreateInfoKHR) Ref() *C.VkImageSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd83cc5d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSwapchainCreateInfoKHR) Free() {
	if x != nil && x.allocsd83cc5d0 != nil {
		x.allocsd83cc5d0.(*cgoAllocMap).Free()
		x.refd83cc5d0 = nil
	}
}

// NewImageSwapchainCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSwapchainCreateInfoKHRRef(ref unsafe.Pointer) *ImageSwapchainCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageSwapchainCreateInfoKHR)
	obj.refd83cc5d0 = (*C.VkImageSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSwapchainCreateInfoKHR) PassRef() (*C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd83cc5d0 != nil {
		return x.refd83cc5d0, nil
	}
	memd83cc5d0 := allocImageSwapchainCreateInfoKHRMemory(1)
	refd83cc5d0 := (*C.VkImageSwapchainCreateInfoKHR)(memd83cc5d0)
	allocsd83cc5d0 := new(cgoAllocMap)
	allocsd83cc5d0.Add(memd83cc5d0)

	var csType_allocs *cgoAllocMap
	refd83cc5d0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd83cc5d0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	refd83cc5d0.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cswapchain_allocs)

	x.refd83cc5d0 = refd83cc5d0
	x.allocsd83cc5d0 = allocsd83cc5d0
	return refd83cc5d0, allocsd83cc5d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSwapchainCreateInfoKHR) PassValue() (C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refd83cc5d0 != nil {
		return *x.refd83cc5d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSwapchainCreateInfoKHR) Deref() {
	if x.refd83cc5d0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd83cc5d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd83cc5d0.pNext))
	x.Swapchain = *(*SwapchainKHR)(unsafe.Pointer(&x.refd83cc5d0.swapchain))
}

// allocBindImageMemorySwapchainInfoKHRMemory allocates memory for type C.VkBindImageMemorySwapchainInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemorySwapchainInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemorySwapchainInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemorySwapchainInfoKHRValue = unsafe.Sizeof([1]C.VkBindImageMemorySwapchainInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemorySwapchainInfoKHR) Ref() *C.VkBindImageMemorySwapchainInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1aa25cb6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemorySwapchainInfoKHR) Free() {
	if x != nil && x.allocs1aa25cb6 != nil {
		x.allocs1aa25cb6.(*cgoAllocMap).Free()
		x.ref1aa25cb6 = nil
	}
}

// NewBindImageMemorySwapchainInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemorySwapchainInfoKHRRef(ref unsafe.Pointer) *BindImageMemorySwapchainInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemorySwapchainInfoKHR)
	obj.ref1aa25cb6 = (*C.VkBindImageMemorySwapchainInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemorySwapchainInfoKHR) PassRef() (*C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1aa25cb6 != nil {
		return x.ref1aa25cb6, nil
	}
	mem1aa25cb6 := allocBindImageMemorySwapchainInfoKHRMemory(1)
	ref1aa25cb6 := (*C.VkBindImageMemorySwapchainInfoKHR)(mem1aa25cb6)
	allocs1aa25cb6 := new(cgoAllocMap)
	allocs1aa25cb6.Add(mem1aa25cb6)

	var csType_allocs *cgoAllocMap
	ref1aa25cb6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1aa25cb6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref1aa25cb6.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cswapchain_allocs)

	var cimageIndex_allocs *cgoAllocMap
	ref1aa25cb6.imageIndex, cimageIndex_allocs = (C.uint32_t)(x.ImageIndex), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cimageIndex_allocs)

	x.ref1aa25cb6 = ref1aa25cb6
	x.allocs1aa25cb6 = allocs1aa25cb6
	return ref1aa25cb6, allocs1aa25cb6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemorySwapchainInfoKHR) PassValue() (C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x.ref1aa25cb6 != nil {
		return *x.ref1aa25cb6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemorySwapchainInfoKHR) Deref() {
	if x.ref1aa25cb6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1aa25cb6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1aa25cb6.pNext))
	x.Swapchain = *(*SwapchainKHR)(unsafe.Pointer(&x.ref1aa25cb6.swapchain))
	x.ImageIndex = (uint32)(x.ref1aa25cb6.imageIndex)
}

// allocAcquireNextImageInfoKHRMemory allocates memory for type C.VkAcquireNextImageInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcquireNextImageInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcquireNextImageInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAcquireNextImageInfoKHRValue = unsafe.Sizeof([1]C.VkAcquireNextImageInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcquireNextImageInfoKHR) Ref() *C.VkAcquireNextImageInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref588806a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcquireNextImageInfoKHR) Free() {
	if x != nil && x.allocs588806a5 != nil {
		x.allocs588806a5.(*cgoAllocMap).Free()
		x.ref588806a5 = nil
	}
}

// NewAcquireNextImageInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcquireNextImageInfoKHRRef(ref unsafe.Pointer) *AcquireNextImageInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(AcquireNextImageInfoKHR)
	obj.ref588806a5 = (*C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcquireNextImageInfoKHR) PassRef() (*C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref588806a5 != nil {
		return x.ref588806a5, nil
	}
	mem588806a5 := allocAcquireNextImageInfoKHRMemory(1)
	ref588806a5 := (*C.VkAcquireNextImageInfoKHR)(mem588806a5)
	allocs588806a5 := new(cgoAllocMap)
	allocs588806a5.Add(mem588806a5)

	var csType_allocs *cgoAllocMap
	ref588806a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs588806a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref588806a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs588806a5.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref588806a5.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs588806a5.Borrow(cswapchain_allocs)

	var ctimeout_allocs *cgoAllocMap
	ref588806a5.timeout, ctimeout_allocs = (C.uint64_t)(x.Timeout), cgoAllocsUnknown
	allocs588806a5.Borrow(ctimeout_allocs)

	var csemaphore_allocs *cgoAllocMap
	ref588806a5.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocs588806a5.Borrow(csemaphore_allocs)

	var cfence_allocs *cgoAllocMap
	ref588806a5.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs588806a5.Borrow(cfence_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref588806a5.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs588806a5.Borrow(cdeviceMask_allocs)

	x.ref588806a5 = ref588806a5
	x.allocs588806a5 = allocs588806a5
	return ref588806a5, allocs588806a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcquireNextImageInfoKHR) PassValue() (C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x.ref588806a5 != nil {
		return *x.ref588806a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcquireNextImageInfoKHR) Deref() {
	if x.ref588806a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref588806a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref588806a5.pNext))
	x.Swapchain = *(*SwapchainKHR)(unsafe.Pointer(&x.ref588806a5.swapchain))
	x.Timeout = (uint64)(x.ref588806a5.timeout)
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref588806a5.semaphore))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref588806a5.fence))
	x.DeviceMask = (uint32)(x.ref588806a5.deviceMask)
}

// allocDeviceGroupPresentCapabilitiesKHRMemory allocates memory for type C.VkDeviceGroupPresentCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupPresentCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentCapabilitiesKHR) Ref() *C.VkDeviceGroupPresentCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.refa3962c81
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentCapabilitiesKHR) Free() {
	if x != nil && x.allocsa3962c81 != nil {
		x.allocsa3962c81.(*cgoAllocMap).Free()
		x.refa3962c81 = nil
	}
}

// NewDeviceGroupPresentCapabilitiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentCapabilitiesKHRRef(ref unsafe.Pointer) *DeviceGroupPresentCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentCapabilitiesKHR)
	obj.refa3962c81 = (*C.VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentCapabilitiesKHR) PassRef() (*C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3962c81 != nil {
		return x.refa3962c81, nil
	}
	mema3962c81 := allocDeviceGroupPresentCapabilitiesKHRMemory(1)
	refa3962c81 := (*C.VkDeviceGroupPresentCapabilitiesKHR)(mema3962c81)
	allocsa3962c81 := new(cgoAllocMap)
	allocsa3962c81.Add(mema3962c81)

	var csType_allocs *cgoAllocMap
	refa3962c81.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3962c81.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3962c81.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpNext_allocs)

	var cpresentMask_allocs *cgoAllocMap
	refa3962c81.presentMask, cpresentMask_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.PresentMask)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpresentMask_allocs)

	var cmodes_allocs *cgoAllocMap
	refa3962c81.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocsa3962c81.Borrow(cmodes_allocs)

	x.refa3962c81 = refa3962c81
	x.allocsa3962c81 = allocsa3962c81
	return refa3962c81, allocsa3962c81

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentCapabilitiesKHR) PassValue() (C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x.refa3962c81 != nil {
		return *x.refa3962c81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentCapabilitiesKHR) Deref() {
	if x.refa3962c81 == nil {
		return
	}
	x.SType = (StructureType)(x.refa3962c81.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3962c81.pNext))
	x.PresentMask = *(*[32]uint32)(unsafe.Pointer(&x.refa3962c81.presentMask))
	x.Modes = (DeviceGroupPresentModeFlagsKHR)(x.refa3962c81.modes)
}

// allocDeviceGroupPresentInfoKHRMemory allocates memory for type C.VkDeviceGroupPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupPresentInfoKHRValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentInfoKHR) Ref() *C.VkDeviceGroupPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.reff6912d09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentInfoKHR) Free() {
	if x != nil && x.allocsf6912d09 != nil {
		x.allocsf6912d09.(*cgoAllocMap).Free()
		x.reff6912d09 = nil
	}
}

// NewDeviceGroupPresentInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentInfoKHRRef(ref unsafe.Pointer) *DeviceGroupPresentInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentInfoKHR)
	obj.reff6912d09 = (*C.VkDeviceGroupPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentInfoKHR) PassRef() (*C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6912d09 != nil {
		return x.reff6912d09, nil
	}
	memf6912d09 := allocDeviceGroupPresentInfoKHRMemory(1)
	reff6912d09 := (*C.VkDeviceGroupPresentInfoKHR)(memf6912d09)
	allocsf6912d09 := new(cgoAllocMap)
	allocsf6912d09.Add(memf6912d09)

	var csType_allocs *cgoAllocMap
	reff6912d09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf6912d09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff6912d09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf6912d09.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	reff6912d09.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocsf6912d09.Borrow(cswapchainCount_allocs)

	var cpDeviceMasks_allocs *cgoAllocMap
	reff6912d09.pDeviceMasks, cpDeviceMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks)).Data)), cgoAllocsUnknown
	allocsf6912d09.Borrow(cpDeviceMasks_allocs)

	var cmode_allocs *cgoAllocMap
	reff6912d09.mode, cmode_allocs = (C.VkDeviceGroupPresentModeFlagBitsKHR)(x.Mode), cgoAllocsUnknown
	allocsf6912d09.Borrow(cmode_allocs)

	x.reff6912d09 = reff6912d09
	x.allocsf6912d09 = allocsf6912d09
	return reff6912d09, allocsf6912d09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentInfoKHR) PassValue() (C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x.reff6912d09 != nil {
		return *x.reff6912d09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentInfoKHR) Deref() {
	if x.reff6912d09 == nil {
		return
	}
	x.SType = (StructureType)(x.reff6912d09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff6912d09.pNext))
	x.SwapchainCount = (uint32)(x.reff6912d09.swapchainCount)
	hxfe93325 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks))
	hxfe93325.Data = unsafe.Pointer(x.reff6912d09.pDeviceMasks)
	hxfe93325.Cap = 0x7fffffff
	// hxfe93325.Len = ?

	x.Mode = (DeviceGroupPresentModeFlagBitsKHR)(x.reff6912d09.mode)
}

// allocDeviceGroupSwapchainCreateInfoKHRMemory allocates memory for type C.VkDeviceGroupSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSwapchainCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSwapchainCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupSwapchainCreateInfoKHRValue = unsafe.Sizeof([1]C.VkDeviceGroupSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSwapchainCreateInfoKHR) Ref() *C.VkDeviceGroupSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref44ae0c0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSwapchainCreateInfoKHR) Free() {
	if x != nil && x.allocs44ae0c0e != nil {
		x.allocs44ae0c0e.(*cgoAllocMap).Free()
		x.ref44ae0c0e = nil
	}
}

// NewDeviceGroupSwapchainCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSwapchainCreateInfoKHRRef(ref unsafe.Pointer) *DeviceGroupSwapchainCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSwapchainCreateInfoKHR)
	obj.ref44ae0c0e = (*C.VkDeviceGroupSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSwapchainCreateInfoKHR) PassRef() (*C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44ae0c0e != nil {
		return x.ref44ae0c0e, nil
	}
	mem44ae0c0e := allocDeviceGroupSwapchainCreateInfoKHRMemory(1)
	ref44ae0c0e := (*C.VkDeviceGroupSwapchainCreateInfoKHR)(mem44ae0c0e)
	allocs44ae0c0e := new(cgoAllocMap)
	allocs44ae0c0e.Add(mem44ae0c0e)

	var csType_allocs *cgoAllocMap
	ref44ae0c0e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref44ae0c0e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cpNext_allocs)

	var cmodes_allocs *cgoAllocMap
	ref44ae0c0e.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cmodes_allocs)

	x.ref44ae0c0e = ref44ae0c0e
	x.allocs44ae0c0e = allocs44ae0c0e
	return ref44ae0c0e, allocs44ae0c0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSwapchainCreateInfoKHR) PassValue() (C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.ref44ae0c0e != nil {
		return *x.ref44ae0c0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSwapchainCreateInfoKHR) Deref() {
	if x.ref44ae0c0e == nil {
		return
	}
	x.SType = (StructureType)(x.ref44ae0c0e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref44ae0c0e.pNext))
	x.Modes = (DeviceGroupPresentModeFlagsKHR)(x.ref44ae0c0e.modes)
}

// allocDisplayPropertiesKHRMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPropertiesKHR) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPropertiesKHR) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPropertiesKHRRef(ref unsafe.Pointer) *DisplayPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPropertiesKHR)
	obj.reffe2a7187 = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPropertiesKHR) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesKHRMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	allocsfe2a7187.Add(memfe2a7187)

	var cdisplay_allocs *cgoAllocMap
	reffe2a7187.display, cdisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display)), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cdisplay_allocs)

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = unpackPCharString(x.DisplayName)
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	var cphysicalDimensions_allocs *cgoAllocMap
	reffe2a7187.physicalDimensions, cphysicalDimensions_allocs = x.PhysicalDimensions.PassValue()
	allocsfe2a7187.Borrow(cphysicalDimensions_allocs)

	var cphysicalResolution_allocs *cgoAllocMap
	reffe2a7187.physicalResolution, cphysicalResolution_allocs = x.PhysicalResolution.PassValue()
	allocsfe2a7187.Borrow(cphysicalResolution_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	reffe2a7187.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocsfe2a7187.Borrow(csupportedTransforms_allocs)

	var cplaneReorderPossible_allocs *cgoAllocMap
	reffe2a7187.planeReorderPossible, cplaneReorderPossible_allocs = (C.VkBool32)(x.PlaneReorderPossible), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cplaneReorderPossible_allocs)

	var cpersistentContent_allocs *cgoAllocMap
	reffe2a7187.persistentContent, cpersistentContent_allocs = (C.VkBool32)(x.PersistentContent), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cpersistentContent_allocs)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPropertiesKHR) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPropertiesKHR) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*DisplayKHR)(unsafe.Pointer(&x.reffe2a7187.display))
	x.DisplayName = packPCharString(x.reffe2a7187.displayName)
	x.PhysicalDimensions = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalDimensions))
	x.PhysicalResolution = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalResolution))
	x.SupportedTransforms = (SurfaceTransformFlagsKHR)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplayModeParametersKHRMemory allocates memory for type C.VkDisplayModeParametersKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeParametersKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeParametersKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeParametersKHRValue = unsafe.Sizeof([1]C.VkDisplayModeParametersKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeParametersKHR) Ref() *C.VkDisplayModeParametersKHR {
	if x == nil {
		return nil
	}
	return x.refe016f77f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeParametersKHR) Free() {
	if x != nil && x.allocse016f77f != nil {
		x.allocse016f77f.(*cgoAllocMap).Free()
		x.refe016f77f = nil
	}
}

// NewDisplayModeParametersKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeParametersKHRRef(ref unsafe.Pointer) *DisplayModeParametersKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeParametersKHR)
	obj.refe016f77f = (*C.VkDisplayModeParametersKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeParametersKHR) PassRef() (*C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe016f77f != nil {
		return x.refe016f77f, nil
	}
	meme016f77f := allocDisplayModeParametersKHRMemory(1)
	refe016f77f := (*C.VkDisplayModeParametersKHR)(meme016f77f)
	allocse016f77f := new(cgoAllocMap)
	allocse016f77f.Add(meme016f77f)

	var cvisibleRegion_allocs *cgoAllocMap
	refe016f77f.visibleRegion, cvisibleRegion_allocs = x.VisibleRegion.PassValue()
	allocse016f77f.Borrow(cvisibleRegion_allocs)

	var crefreshRate_allocs *cgoAllocMap
	refe016f77f.refreshRate, crefreshRate_allocs = (C.uint32_t)(x.RefreshRate), cgoAllocsUnknown
	allocse016f77f.Borrow(crefreshRate_allocs)

	x.refe016f77f = refe016f77f
	x.allocse016f77f = allocse016f77f
	return refe016f77f, allocse016f77f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeParametersKHR) PassValue() (C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x.refe016f77f != nil {
		return *x.refe016f77f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeParametersKHR) Deref() {
	if x.refe016f77f == nil {
		return
	}
	x.VisibleRegion = *NewExtent2DRef(unsafe.Pointer(&x.refe016f77f.visibleRegion))
	x.RefreshRate = (uint32)(x.refe016f77f.refreshRate)
}

// allocDisplayModePropertiesKHRMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModePropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModePropertiesKHR) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModePropertiesKHR) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModePropertiesKHRRef(ref unsafe.Pointer) *DisplayModePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModePropertiesKHR)
	obj.ref5e3abaaa = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModePropertiesKHR) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesKHRMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	allocs5e3abaaa.Add(mem5e3abaaa)

	var cdisplayMode_allocs *cgoAllocMap
	ref5e3abaaa.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs5e3abaaa.Borrow(cdisplayMode_allocs)

	var cparameters_allocs *cgoAllocMap
	ref5e3abaaa.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs5e3abaaa.Borrow(cparameters_allocs)

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModePropertiesKHR) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModePropertiesKHR) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayModeKHR)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *NewDisplayModeParametersKHRRef(unsafe.Pointer(&x.ref5e3abaaa.parameters))
}

// allocDisplayModeCreateInfoKHRMemory allocates memory for type C.VkDisplayModeCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeCreateInfoKHRValue = unsafe.Sizeof([1]C.VkDisplayModeCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeCreateInfoKHR) Ref() *C.VkDisplayModeCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref392fca31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeCreateInfoKHR) Free() {
	if x != nil && x.allocs392fca31 != nil {
		x.allocs392fca31.(*cgoAllocMap).Free()
		x.ref392fca31 = nil
	}
}

// NewDisplayModeCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeCreateInfoKHRRef(ref unsafe.Pointer) *DisplayModeCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeCreateInfoKHR)
	obj.ref392fca31 = (*C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeCreateInfoKHR) PassRef() (*C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref392fca31 != nil {
		return x.ref392fca31, nil
	}
	mem392fca31 := allocDisplayModeCreateInfoKHRMemory(1)
	ref392fca31 := (*C.VkDisplayModeCreateInfoKHR)(mem392fca31)
	allocs392fca31 := new(cgoAllocMap)
	allocs392fca31.Add(mem392fca31)

	var csType_allocs *cgoAllocMap
	ref392fca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs392fca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref392fca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs392fca31.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref392fca31.flags, cflags_allocs = (C.VkDisplayModeCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs392fca31.Borrow(cflags_allocs)

	var cparameters_allocs *cgoAllocMap
	ref392fca31.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs392fca31.Borrow(cparameters_allocs)

	x.ref392fca31 = ref392fca31
	x.allocs392fca31 = allocs392fca31
	return ref392fca31, allocs392fca31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeCreateInfoKHR) PassValue() (C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x.ref392fca31 != nil {
		return *x.ref392fca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeCreateInfoKHR) Deref() {
	if x.ref392fca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref392fca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref392fca31.pNext))
	x.Flags = (DisplayModeCreateFlagsKHR)(x.ref392fca31.flags)
	x.Parameters = *NewDisplayModeParametersKHRRef(unsafe.Pointer(&x.ref392fca31.parameters))
}

// allocDisplayPlaneCapabilitiesKHRMemory allocates memory for type C.VkDisplayPlaneCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilitiesKHR) Ref() *C.VkDisplayPlaneCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref6f31fcaf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilitiesKHR) Free() {
	if x != nil && x.allocs6f31fcaf != nil {
		x.allocs6f31fcaf.(*cgoAllocMap).Free()
		x.ref6f31fcaf = nil
	}
}

// NewDisplayPlaneCapabilitiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilitiesKHRRef(ref unsafe.Pointer) *DisplayPlaneCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilitiesKHR)
	obj.ref6f31fcaf = (*C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilitiesKHR) PassRef() (*C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f31fcaf != nil {
		return x.ref6f31fcaf, nil
	}
	mem6f31fcaf := allocDisplayPlaneCapabilitiesKHRMemory(1)
	ref6f31fcaf := (*C.VkDisplayPlaneCapabilitiesKHR)(mem6f31fcaf)
	allocs6f31fcaf := new(cgoAllocMap)
	allocs6f31fcaf.Add(mem6f31fcaf)

	var csupportedAlpha_allocs *cgoAllocMap
	ref6f31fcaf.supportedAlpha, csupportedAlpha_allocs = (C.VkDisplayPlaneAlphaFlagsKHR)(x.SupportedAlpha), cgoAllocsUnknown
	allocs6f31fcaf.Borrow(csupportedAlpha_allocs)

	var cminSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.minSrcPosition, cminSrcPosition_allocs = x.MinSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cminSrcPosition_allocs)

	var cmaxSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcPosition, cmaxSrcPosition_allocs = x.MaxSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcPosition_allocs)

	var cminSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.minSrcExtent, cminSrcExtent_allocs = x.MinSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cminSrcExtent_allocs)

	var cmaxSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcExtent, cmaxSrcExtent_allocs = x.MaxSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcExtent_allocs)

	var cminDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.minDstPosition, cminDstPosition_allocs = x.MinDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cminDstPosition_allocs)

	var cmaxDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxDstPosition, cmaxDstPosition_allocs = x.MaxDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstPosition_allocs)

	var cminDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.minDstExtent, cminDstExtent_allocs = x.MinDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cminDstExtent_allocs)

	var cmaxDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxDstExtent, cmaxDstExtent_allocs = x.MaxDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstExtent_allocs)

	x.ref6f31fcaf = ref6f31fcaf
	x.allocs6f31fcaf = allocs6f31fcaf
	return ref6f31fcaf, allocs6f31fcaf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilitiesKHR) PassValue() (C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x.ref6f31fcaf != nil {
		return *x.ref6f31fcaf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilitiesKHR) Deref() {
	if x.ref6f31fcaf == nil {
		return
	}
	x.SupportedAlpha = (DisplayPlaneAlphaFlagsKHR)(x.ref6f31fcaf.supportedAlpha)
	x.MinSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcPosition))
	x.MaxSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcPosition))
	x.MinSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcExtent))
	x.MaxSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcExtent))
	x.MinDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstPosition))
	x.MaxDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstPosition))
	x.MinDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstExtent))
	x.MaxDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstExtent))
}

// allocDisplayPlanePropertiesKHRMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlanePropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlanePropertiesKHR) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlanePropertiesKHR) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlanePropertiesKHRRef(ref unsafe.Pointer) *DisplayPlanePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlanePropertiesKHR)
	obj.refce3db3f6 = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlanePropertiesKHR) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesKHRMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	allocsce3db3f6.Add(memce3db3f6)

	var ccurrentDisplay_allocs *cgoAllocMap
	refce3db3f6.currentDisplay, ccurrentDisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay)), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentDisplay_allocs)

	var ccurrentStackIndex_allocs *cgoAllocMap
	refce3db3f6.currentStackIndex, ccurrentStackIndex_allocs = (C.uint32_t)(x.CurrentStackIndex), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentStackIndex_allocs)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlanePropertiesKHR) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlanePropertiesKHR) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*DisplayKHR)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplaySurfaceCreateInfoKHRMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoKHRValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplaySurfaceCreateInfoKHR) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplaySurfaceCreateInfoKHR) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplaySurfaceCreateInfoKHRRef(ref unsafe.Pointer) *DisplaySurfaceCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplaySurfaceCreateInfoKHR)
	obj.ref58445c35 = (*C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplaySurfaceCreateInfoKHR) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoKHRMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	allocs58445c35.Add(mem58445c35)

	var csType_allocs *cgoAllocMap
	ref58445c35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58445c35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58445c35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58445c35.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref58445c35.flags, cflags_allocs = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs58445c35.Borrow(cflags_allocs)

	var cdisplayMode_allocs *cgoAllocMap
	ref58445c35.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs58445c35.Borrow(cdisplayMode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	ref58445c35.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneIndex_allocs)

	var cplaneStackIndex_allocs *cgoAllocMap
	ref58445c35.planeStackIndex, cplaneStackIndex_allocs = (C.uint32_t)(x.PlaneStackIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneStackIndex_allocs)

	var ctransform_allocs *cgoAllocMap
	ref58445c35.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs58445c35.Borrow(ctransform_allocs)

	var cglobalAlpha_allocs *cgoAllocMap
	ref58445c35.globalAlpha, cglobalAlpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs58445c35.Borrow(cglobalAlpha_allocs)

	var calphaMode_allocs *cgoAllocMap
	ref58445c35.alphaMode, calphaMode_allocs = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode), cgoAllocsUnknown
	allocs58445c35.Borrow(calphaMode_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref58445c35.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs58445c35.Borrow(cimageExtent_allocs)

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplaySurfaceCreateInfoKHR) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplaySurfaceCreateInfoKHR) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlagsKHR)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayModeKHR)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBitsKHR)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBitsKHR)(x.ref58445c35.alphaMode)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref58445c35.imageExtent))
}

// allocDisplayPresentInfoKHRMemory allocates memory for type C.VkDisplayPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPresentInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPresentInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPresentInfoKHRValue = unsafe.Sizeof([1]C.VkDisplayPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPresentInfoKHR) Ref() *C.VkDisplayPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref8d2571e4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPresentInfoKHR) Free() {
	if x != nil && x.allocs8d2571e4 != nil {
		x.allocs8d2571e4.(*cgoAllocMap).Free()
		x.ref8d2571e4 = nil
	}
}

// NewDisplayPresentInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPresentInfoKHRRef(ref unsafe.Pointer) *DisplayPresentInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPresentInfoKHR)
	obj.ref8d2571e4 = (*C.VkDisplayPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPresentInfoKHR) PassRef() (*C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d2571e4 != nil {
		return x.ref8d2571e4, nil
	}
	mem8d2571e4 := allocDisplayPresentInfoKHRMemory(1)
	ref8d2571e4 := (*C.VkDisplayPresentInfoKHR)(mem8d2571e4)
	allocs8d2571e4 := new(cgoAllocMap)
	allocs8d2571e4.Add(mem8d2571e4)

	var csType_allocs *cgoAllocMap
	ref8d2571e4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d2571e4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d2571e4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpNext_allocs)

	var csrcRect_allocs *cgoAllocMap
	ref8d2571e4.srcRect, csrcRect_allocs = x.SrcRect.PassValue()
	allocs8d2571e4.Borrow(csrcRect_allocs)

	var cdstRect_allocs *cgoAllocMap
	ref8d2571e4.dstRect, cdstRect_allocs = x.DstRect.PassValue()
	allocs8d2571e4.Borrow(cdstRect_allocs)

	var cpersistent_allocs *cgoAllocMap
	ref8d2571e4.persistent, cpersistent_allocs = (C.VkBool32)(x.Persistent), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpersistent_allocs)

	x.ref8d2571e4 = ref8d2571e4
	x.allocs8d2571e4 = allocs8d2571e4
	return ref8d2571e4, allocs8d2571e4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPresentInfoKHR) PassValue() (C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x.ref8d2571e4 != nil {
		return *x.ref8d2571e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPresentInfoKHR) Deref() {
	if x.ref8d2571e4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d2571e4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d2571e4.pNext))
	x.SrcRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.srcRect))
	x.DstRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.dstRect))
	x.Persistent = (Bool32)(x.ref8d2571e4.persistent)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassMultiviewCreateInfoKHR) Ref() *C.VkRenderPassMultiviewCreateInfo {
	if x == nil {
		return nil
	}
	return x.refee413e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassMultiviewCreateInfoKHR) Free() {
	if x != nil && x.allocsee413e05 != nil {
		x.allocsee413e05.(*cgoAllocMap).Free()
		x.refee413e05 = nil
	}
}

// NewRenderPassMultiviewCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassMultiviewCreateInfoKHRRef(ref unsafe.Pointer) *RenderPassMultiviewCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassMultiviewCreateInfoKHR)
	obj.refee413e05 = (*C.VkRenderPassMultiviewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassMultiviewCreateInfoKHR) PassRef() (*C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee413e05 != nil {
		return x.refee413e05, nil
	}
	memee413e05 := allocRenderPassMultiviewCreateInfoMemory(1)
	refee413e05 := (*C.VkRenderPassMultiviewCreateInfo)(memee413e05)
	allocsee413e05 := new(cgoAllocMap)
	allocsee413e05.Add(memee413e05)

	var csType_allocs *cgoAllocMap
	refee413e05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsee413e05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refee413e05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpNext_allocs)

	var csubpassCount_allocs *cgoAllocMap
	refee413e05.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocsee413e05.Borrow(csubpassCount_allocs)

	var cpViewMasks_allocs *cgoAllocMap
	refee413e05.pViewMasks, cpViewMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewMasks_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	refee413e05.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocsee413e05.Borrow(cdependencyCount_allocs)

	var cpViewOffsets_allocs *cgoAllocMap
	refee413e05.pViewOffsets, cpViewOffsets_allocs = (*C.int32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewOffsets)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewOffsets_allocs)

	var ccorrelationMaskCount_allocs *cgoAllocMap
	refee413e05.correlationMaskCount, ccorrelationMaskCount_allocs = (C.uint32_t)(x.CorrelationMaskCount), cgoAllocsUnknown
	allocsee413e05.Borrow(ccorrelationMaskCount_allocs)

	var cpCorrelationMasks_allocs *cgoAllocMap
	refee413e05.pCorrelationMasks, cpCorrelationMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpCorrelationMasks_allocs)

	x.refee413e05 = refee413e05
	x.allocsee413e05 = allocsee413e05
	return refee413e05, allocsee413e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassMultiviewCreateInfoKHR) PassValue() (C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x.refee413e05 != nil {
		return *x.refee413e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassMultiviewCreateInfoKHR) Deref() {
	if x.refee413e05 == nil {
		return
	}
	x.SType = (StructureType)(x.refee413e05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee413e05.pNext))
	x.SubpassCount = (uint32)(x.refee413e05.subpassCount)
	hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&x.PViewMasks))
	hxf09ea94.Data = unsafe.Pointer(x.refee413e05.pViewMasks)
	hxf09ea94.Cap = 0x7fffffff
	// hxf09ea94.Len = ?

	x.DependencyCount = (uint32)(x.refee413e05.dependencyCount)
	hxfd687ee := (*sliceHeader)(unsafe.Pointer(&x.PViewOffsets))
	hxfd687ee.Data = unsafe.Pointer(x.refee413e05.pViewOffsets)
	hxfd687ee.Cap = 0x7fffffff
	// hxfd687ee.Len = ?

	x.CorrelationMaskCount = (uint32)(x.refee413e05.correlationMaskCount)
	hxf15a567 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks))
	hxf15a567.Data = unsafe.Pointer(x.refee413e05.pCorrelationMasks)
	hxf15a567.Cap = 0x7fffffff
	// hxf15a567.Len = ?

}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewFeaturesKHR) Ref() *C.VkPhysicalDeviceMultiviewFeatures {
	if x == nil {
		return nil
	}
	return x.refd7a7434b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewFeaturesKHR) Free() {
	if x != nil && x.allocsd7a7434b != nil {
		x.allocsd7a7434b.(*cgoAllocMap).Free()
		x.refd7a7434b = nil
	}
}

// NewPhysicalDeviceMultiviewFeaturesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewFeaturesKHRRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewFeaturesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewFeaturesKHR)
	obj.refd7a7434b = (*C.VkPhysicalDeviceMultiviewFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewFeaturesKHR) PassRef() (*C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7a7434b != nil {
		return x.refd7a7434b, nil
	}
	memd7a7434b := allocPhysicalDeviceMultiviewFeaturesMemory(1)
	refd7a7434b := (*C.VkPhysicalDeviceMultiviewFeatures)(memd7a7434b)
	allocsd7a7434b := new(cgoAllocMap)
	allocsd7a7434b.Add(memd7a7434b)

	var csType_allocs *cgoAllocMap
	refd7a7434b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7a7434b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7a7434b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cpNext_allocs)

	var cmultiview_allocs *cgoAllocMap
	refd7a7434b.multiview, cmultiview_allocs = (C.VkBool32)(x.Multiview), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiview_allocs)

	var cmultiviewGeometryShader_allocs *cgoAllocMap
	refd7a7434b.multiviewGeometryShader, cmultiviewGeometryShader_allocs = (C.VkBool32)(x.MultiviewGeometryShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewGeometryShader_allocs)

	var cmultiviewTessellationShader_allocs *cgoAllocMap
	refd7a7434b.multiviewTessellationShader, cmultiviewTessellationShader_allocs = (C.VkBool32)(x.MultiviewTessellationShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewTessellationShader_allocs)

	x.refd7a7434b = refd7a7434b
	x.allocsd7a7434b = allocsd7a7434b
	return refd7a7434b, allocsd7a7434b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewFeaturesKHR) PassValue() (C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x.refd7a7434b != nil {
		return *x.refd7a7434b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewFeaturesKHR) Deref() {
	if x.refd7a7434b == nil {
		return
	}
	x.SType = (StructureType)(x.refd7a7434b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7a7434b.pNext))
	x.Multiview = (Bool32)(x.refd7a7434b.multiview)
	x.MultiviewGeometryShader = (Bool32)(x.refd7a7434b.multiviewGeometryShader)
	x.MultiviewTessellationShader = (Bool32)(x.refd7a7434b.multiviewTessellationShader)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewPropertiesKHR) Ref() *C.VkPhysicalDeviceMultiviewProperties {
	if x == nil {
		return nil
	}
	return x.ref95110029
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewPropertiesKHR) Free() {
	if x != nil && x.allocs95110029 != nil {
		x.allocs95110029.(*cgoAllocMap).Free()
		x.ref95110029 = nil
	}
}

// NewPhysicalDeviceMultiviewPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPropertiesKHRRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewPropertiesKHR)
	obj.ref95110029 = (*C.VkPhysicalDeviceMultiviewProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewPropertiesKHR) PassRef() (*C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95110029 != nil {
		return x.ref95110029, nil
	}
	mem95110029 := allocPhysicalDeviceMultiviewPropertiesMemory(1)
	ref95110029 := (*C.VkPhysicalDeviceMultiviewProperties)(mem95110029)
	allocs95110029 := new(cgoAllocMap)
	allocs95110029.Add(mem95110029)

	var csType_allocs *cgoAllocMap
	ref95110029.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95110029.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95110029.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95110029.Borrow(cpNext_allocs)

	var cmaxMultiviewViewCount_allocs *cgoAllocMap
	ref95110029.maxMultiviewViewCount, cmaxMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMultiviewViewCount), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewViewCount_allocs)

	var cmaxMultiviewInstanceIndex_allocs *cgoAllocMap
	ref95110029.maxMultiviewInstanceIndex, cmaxMultiviewInstanceIndex_allocs = (C.uint32_t)(x.MaxMultiviewInstanceIndex), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewInstanceIndex_allocs)

	x.ref95110029 = ref95110029
	x.allocs95110029 = allocs95110029
	return ref95110029, allocs95110029

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewPropertiesKHR) PassValue() (C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x.ref95110029 != nil {
		return *x.ref95110029, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewPropertiesKHR) Deref() {
	if x.ref95110029 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95110029.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95110029.pNext))
	x.MaxMultiviewViewCount = (uint32)(x.ref95110029.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.ref95110029.maxMultiviewInstanceIndex)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures2KHR) Ref() *C.VkPhysicalDeviceFeatures2 {
	if x == nil {
		return nil
	}
	return x.refff6ed04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures2KHR) Free() {
	if x != nil && x.allocsff6ed04 != nil {
		x.allocsff6ed04.(*cgoAllocMap).Free()
		x.refff6ed04 = nil
	}
}

// NewPhysicalDeviceFeatures2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeatures2KHRRef(ref unsafe.Pointer) *PhysicalDeviceFeatures2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures2KHR)
	obj.refff6ed04 = (*C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures2KHR) PassRef() (*C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff6ed04 != nil {
		return x.refff6ed04, nil
	}
	memff6ed04 := allocPhysicalDeviceFeatures2Memory(1)
	refff6ed04 := (*C.VkPhysicalDeviceFeatures2)(memff6ed04)
	allocsff6ed04 := new(cgoAllocMap)
	allocsff6ed04.Add(memff6ed04)

	var csType_allocs *cgoAllocMap
	refff6ed04.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff6ed04.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff6ed04.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff6ed04.Borrow(cpNext_allocs)

	var cfeatures_allocs *cgoAllocMap
	refff6ed04.features, cfeatures_allocs = x.Features.PassValue()
	allocsff6ed04.Borrow(cfeatures_allocs)

	x.refff6ed04 = refff6ed04
	x.allocsff6ed04 = allocsff6ed04
	return refff6ed04, allocsff6ed04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures2KHR) PassValue() (C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x.refff6ed04 != nil {
		return *x.refff6ed04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures2KHR) Deref() {
	if x.refff6ed04 == nil {
		return
	}
	x.SType = (StructureType)(x.refff6ed04.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff6ed04.pNext))
	x.Features = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&x.refff6ed04.features))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties2KHR) Ref() *C.VkPhysicalDeviceProperties2 {
	if x == nil {
		return nil
	}
	return x.ref947bd13e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties2KHR) Free() {
	if x != nil && x.allocs947bd13e != nil {
		x.allocs947bd13e.(*cgoAllocMap).Free()
		x.ref947bd13e = nil
	}
}

// NewPhysicalDeviceProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProperties2KHRRef(ref unsafe.Pointer) *PhysicalDeviceProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties2KHR)
	obj.ref947bd13e = (*C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties2KHR) PassRef() (*C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref947bd13e != nil {
		return x.ref947bd13e, nil
	}
	mem947bd13e := allocPhysicalDeviceProperties2Memory(1)
	ref947bd13e := (*C.VkPhysicalDeviceProperties2)(mem947bd13e)
	allocs947bd13e := new(cgoAllocMap)
	allocs947bd13e.Add(mem947bd13e)

	var csType_allocs *cgoAllocMap
	ref947bd13e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs947bd13e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref947bd13e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs947bd13e.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref947bd13e.properties, cproperties_allocs = x.Properties.PassValue()
	allocs947bd13e.Borrow(cproperties_allocs)

	x.ref947bd13e = ref947bd13e
	x.allocs947bd13e = allocs947bd13e
	return ref947bd13e, allocs947bd13e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties2KHR) PassValue() (C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x.ref947bd13e != nil {
		return *x.ref947bd13e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties2KHR) Deref() {
	if x.ref947bd13e == nil {
		return
	}
	x.SType = (StructureType)(x.ref947bd13e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref947bd13e.pNext))
	x.Properties = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&x.ref947bd13e.properties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties2KHR) Ref() *C.VkFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.refddc6af2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties2KHR) Free() {
	if x != nil && x.allocsddc6af2a != nil {
		x.allocsddc6af2a.(*cgoAllocMap).Free()
		x.refddc6af2a = nil
	}
}

// NewFormatProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatProperties2KHRRef(ref unsafe.Pointer) *FormatProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties2KHR)
	obj.refddc6af2a = (*C.VkFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties2KHR) PassRef() (*C.VkFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refddc6af2a != nil {
		return x.refddc6af2a, nil
	}
	memddc6af2a := allocFormatProperties2Memory(1)
	refddc6af2a := (*C.VkFormatProperties2)(memddc6af2a)
	allocsddc6af2a := new(cgoAllocMap)
	allocsddc6af2a.Add(memddc6af2a)

	var csType_allocs *cgoAllocMap
	refddc6af2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsddc6af2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refddc6af2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsddc6af2a.Borrow(cpNext_allocs)

	var cformatProperties_allocs *cgoAllocMap
	refddc6af2a.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocsddc6af2a.Borrow(cformatProperties_allocs)

	x.refddc6af2a = refddc6af2a
	x.allocsddc6af2a = allocsddc6af2a
	return refddc6af2a, allocsddc6af2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties2KHR) PassValue() (C.VkFormatProperties2, *cgoAllocMap) {
	if x.refddc6af2a != nil {
		return *x.refddc6af2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties2KHR) Deref() {
	if x.refddc6af2a == nil {
		return
	}
	x.SType = (StructureType)(x.refddc6af2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refddc6af2a.pNext))
	x.FormatProperties = *NewFormatPropertiesRef(unsafe.Pointer(&x.refddc6af2a.formatProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties2KHR) Ref() *C.VkImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref224187e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties2KHR) Free() {
	if x != nil && x.allocs224187e7 != nil {
		x.allocs224187e7.(*cgoAllocMap).Free()
		x.ref224187e7 = nil
	}
}

// NewImageFormatProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatProperties2KHRRef(ref unsafe.Pointer) *ImageFormatProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties2KHR)
	obj.ref224187e7 = (*C.VkImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties2KHR) PassRef() (*C.VkImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref224187e7 != nil {
		return x.ref224187e7, nil
	}
	mem224187e7 := allocImageFormatProperties2Memory(1)
	ref224187e7 := (*C.VkImageFormatProperties2)(mem224187e7)
	allocs224187e7 := new(cgoAllocMap)
	allocs224187e7.Add(mem224187e7)

	var csType_allocs *cgoAllocMap
	ref224187e7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs224187e7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref224187e7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs224187e7.Borrow(cpNext_allocs)

	var cimageFormatProperties_allocs *cgoAllocMap
	ref224187e7.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocs224187e7.Borrow(cimageFormatProperties_allocs)

	x.ref224187e7 = ref224187e7
	x.allocs224187e7 = allocs224187e7
	return ref224187e7, allocs224187e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties2KHR) PassValue() (C.VkImageFormatProperties2, *cgoAllocMap) {
	if x.ref224187e7 != nil {
		return *x.ref224187e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties2KHR) Deref() {
	if x.ref224187e7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref224187e7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref224187e7.pNext))
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.ref224187e7.imageFormatProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageFormatInfo2KHR) Ref() *C.VkPhysicalDeviceImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref5934b445
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageFormatInfo2KHR) Free() {
	if x != nil && x.allocs5934b445 != nil {
		x.allocs5934b445.(*cgoAllocMap).Free()
		x.ref5934b445 = nil
	}
}

// NewPhysicalDeviceImageFormatInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageFormatInfo2KHRRef(ref unsafe.Pointer) *PhysicalDeviceImageFormatInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageFormatInfo2KHR)
	obj.ref5934b445 = (*C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageFormatInfo2KHR) PassRef() (*C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5934b445 != nil {
		return x.ref5934b445, nil
	}
	mem5934b445 := allocPhysicalDeviceImageFormatInfo2Memory(1)
	ref5934b445 := (*C.VkPhysicalDeviceImageFormatInfo2)(mem5934b445)
	allocs5934b445 := new(cgoAllocMap)
	allocs5934b445.Add(mem5934b445)

	var csType_allocs *cgoAllocMap
	ref5934b445.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5934b445.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5934b445.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5934b445.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref5934b445.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs5934b445.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref5934b445._type, c_type_allocs = (C.VkImageType)(x._type), cgoAllocsUnknown
	allocs5934b445.Borrow(c_type_allocs)

	var ctiling_allocs *cgoAllocMap
	ref5934b445.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs5934b445.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	ref5934b445.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs5934b445.Borrow(cusage_allocs)

	var cflags_allocs *cgoAllocMap
	ref5934b445.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5934b445.Borrow(cflags_allocs)

	x.ref5934b445 = ref5934b445
	x.allocs5934b445 = allocs5934b445
	return ref5934b445, allocs5934b445

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageFormatInfo2KHR) PassValue() (C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x.ref5934b445 != nil {
		return *x.ref5934b445, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageFormatInfo2KHR) Deref() {
	if x.ref5934b445 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5934b445.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5934b445.pNext))
	x.Format = (Format)(x.ref5934b445.format)
	x._type = (ImageType)(x.ref5934b445._type)
	x.Tiling = (ImageTiling)(x.ref5934b445.tiling)
	x.Usage = (ImageUsageFlags)(x.ref5934b445.usage)
	x.Flags = (ImageCreateFlags)(x.ref5934b445.flags)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties2KHR) Ref() *C.VkQueueFamilyProperties2 {
	if x == nil {
		return nil
	}
	return x.ref85bf626c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties2KHR) Free() {
	if x != nil && x.allocs85bf626c != nil {
		x.allocs85bf626c.(*cgoAllocMap).Free()
		x.ref85bf626c = nil
	}
}

// NewQueueFamilyProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyProperties2KHRRef(ref unsafe.Pointer) *QueueFamilyProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties2KHR)
	obj.ref85bf626c = (*C.VkQueueFamilyProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties2KHR) PassRef() (*C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85bf626c != nil {
		return x.ref85bf626c, nil
	}
	mem85bf626c := allocQueueFamilyProperties2Memory(1)
	ref85bf626c := (*C.VkQueueFamilyProperties2)(mem85bf626c)
	allocs85bf626c := new(cgoAllocMap)
	allocs85bf626c.Add(mem85bf626c)

	var csType_allocs *cgoAllocMap
	ref85bf626c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85bf626c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85bf626c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85bf626c.Borrow(cpNext_allocs)

	var cqueueFamilyProperties_allocs *cgoAllocMap
	ref85bf626c.queueFamilyProperties, cqueueFamilyProperties_allocs = x.QueueFamilyProperties.PassValue()
	allocs85bf626c.Borrow(cqueueFamilyProperties_allocs)

	x.ref85bf626c = ref85bf626c
	x.allocs85bf626c = allocs85bf626c
	return ref85bf626c, allocs85bf626c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties2KHR) PassValue() (C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x.ref85bf626c != nil {
		return *x.ref85bf626c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties2KHR) Deref() {
	if x.ref85bf626c == nil {
		return
	}
	x.SType = (StructureType)(x.ref85bf626c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85bf626c.pNext))
	x.QueueFamilyProperties = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&x.ref85bf626c.queueFamilyProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties2KHR) Ref() *C.VkPhysicalDeviceMemoryProperties2 {
	if x == nil {
		return nil
	}
	return x.refd9e39b19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties2KHR) Free() {
	if x != nil && x.allocsd9e39b19 != nil {
		x.allocsd9e39b19.(*cgoAllocMap).Free()
		x.refd9e39b19 = nil
	}
}

// NewPhysicalDeviceMemoryProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryProperties2KHRRef(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties2KHR)
	obj.refd9e39b19 = (*C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties2KHR) PassRef() (*C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9e39b19 != nil {
		return x.refd9e39b19, nil
	}
	memd9e39b19 := allocPhysicalDeviceMemoryProperties2Memory(1)
	refd9e39b19 := (*C.VkPhysicalDeviceMemoryProperties2)(memd9e39b19)
	allocsd9e39b19 := new(cgoAllocMap)
	allocsd9e39b19.Add(memd9e39b19)

	var csType_allocs *cgoAllocMap
	refd9e39b19.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9e39b19.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9e39b19.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9e39b19.Borrow(cpNext_allocs)

	var cmemoryProperties_allocs *cgoAllocMap
	refd9e39b19.memoryProperties, cmemoryProperties_allocs = x.MemoryProperties.PassValue()
	allocsd9e39b19.Borrow(cmemoryProperties_allocs)

	x.refd9e39b19 = refd9e39b19
	x.allocsd9e39b19 = allocsd9e39b19
	return refd9e39b19, allocsd9e39b19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties2KHR) PassValue() (C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x.refd9e39b19 != nil {
		return *x.refd9e39b19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties2KHR) Deref() {
	if x.refd9e39b19 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9e39b19.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9e39b19.pNext))
	x.MemoryProperties = *NewPhysicalDeviceMemoryPropertiesRef(unsafe.Pointer(&x.refd9e39b19.memoryProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties2KHR) Ref() *C.VkSparseImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref6b48294b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties2KHR) Free() {
	if x != nil && x.allocs6b48294b != nil {
		x.allocs6b48294b.(*cgoAllocMap).Free()
		x.ref6b48294b = nil
	}
}

// NewSparseImageFormatProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatProperties2KHRRef(ref unsafe.Pointer) *SparseImageFormatProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties2KHR)
	obj.ref6b48294b = (*C.VkSparseImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties2KHR) PassRef() (*C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b48294b != nil {
		return x.ref6b48294b, nil
	}
	mem6b48294b := allocSparseImageFormatProperties2Memory(1)
	ref6b48294b := (*C.VkSparseImageFormatProperties2)(mem6b48294b)
	allocs6b48294b := new(cgoAllocMap)
	allocs6b48294b.Add(mem6b48294b)

	var csType_allocs *cgoAllocMap
	ref6b48294b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6b48294b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6b48294b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6b48294b.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref6b48294b.properties, cproperties_allocs = x.Properties.PassValue()
	allocs6b48294b.Borrow(cproperties_allocs)

	x.ref6b48294b = ref6b48294b
	x.allocs6b48294b = allocs6b48294b
	return ref6b48294b, allocs6b48294b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties2KHR) PassValue() (C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x.ref6b48294b != nil {
		return *x.ref6b48294b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties2KHR) Deref() {
	if x.ref6b48294b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6b48294b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6b48294b.pNext))
	x.Properties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref6b48294b.properties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseImageFormatInfo2KHR) Ref() *C.VkPhysicalDeviceSparseImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref566d5513
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2KHR) Free() {
	if x != nil && x.allocs566d5513 != nil {
		x.allocs566d5513.(*cgoAllocMap).Free()
		x.ref566d5513 = nil
	}
}

// NewPhysicalDeviceSparseImageFormatInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparseImageFormatInfo2KHRRef(ref unsafe.Pointer) *PhysicalDeviceSparseImageFormatInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseImageFormatInfo2KHR)
	obj.ref566d5513 = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2KHR) PassRef() (*C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref566d5513 != nil {
		return x.ref566d5513, nil
	}
	mem566d5513 := allocPhysicalDeviceSparseImageFormatInfo2Memory(1)
	ref566d5513 := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(mem566d5513)
	allocs566d5513 := new(cgoAllocMap)
	allocs566d5513.Add(mem566d5513)

	var csType_allocs *cgoAllocMap
	ref566d5513.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs566d5513.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref566d5513.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs566d5513.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref566d5513.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs566d5513.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref566d5513._type, c_type_allocs = (C.VkImageType)(x._type), cgoAllocsUnknown
	allocs566d5513.Borrow(c_type_allocs)

	var csamples_allocs *cgoAllocMap
	ref566d5513.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocs566d5513.Borrow(csamples_allocs)

	var cusage_allocs *cgoAllocMap
	ref566d5513.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs566d5513.Borrow(cusage_allocs)

	var ctiling_allocs *cgoAllocMap
	ref566d5513.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs566d5513.Borrow(ctiling_allocs)

	x.ref566d5513 = ref566d5513
	x.allocs566d5513 = allocs566d5513
	return ref566d5513, allocs566d5513

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2KHR) PassValue() (C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x.ref566d5513 != nil {
		return *x.ref566d5513, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseImageFormatInfo2KHR) Deref() {
	if x.ref566d5513 == nil {
		return
	}
	x.SType = (StructureType)(x.ref566d5513.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref566d5513.pNext))
	x.Format = (Format)(x.ref566d5513.format)
	x._type = (ImageType)(x.ref566d5513._type)
	x.Samples = (SampleCountFlagBits)(x.ref566d5513.samples)
	x.Usage = (ImageUsageFlags)(x.ref566d5513.usage)
	x.Tiling = (ImageTiling)(x.ref566d5513.tiling)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateFlagsInfoKHR) Ref() *C.VkMemoryAllocateFlagsInfo {
	if x == nil {
		return nil
	}
	return x.ref7ca6664
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateFlagsInfoKHR) Free() {
	if x != nil && x.allocs7ca6664 != nil {
		x.allocs7ca6664.(*cgoAllocMap).Free()
		x.ref7ca6664 = nil
	}
}

// NewMemoryAllocateFlagsInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateFlagsInfoKHRRef(ref unsafe.Pointer) *MemoryAllocateFlagsInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateFlagsInfoKHR)
	obj.ref7ca6664 = (*C.VkMemoryAllocateFlagsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateFlagsInfoKHR) PassRef() (*C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ca6664 != nil {
		return x.ref7ca6664, nil
	}
	mem7ca6664 := allocMemoryAllocateFlagsInfoMemory(1)
	ref7ca6664 := (*C.VkMemoryAllocateFlagsInfo)(mem7ca6664)
	allocs7ca6664 := new(cgoAllocMap)
	allocs7ca6664.Add(mem7ca6664)

	var csType_allocs *cgoAllocMap
	ref7ca6664.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ca6664.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ca6664.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ca6664.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7ca6664.flags, cflags_allocs = (C.VkMemoryAllocateFlags)(x.Flags), cgoAllocsUnknown
	allocs7ca6664.Borrow(cflags_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref7ca6664.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs7ca6664.Borrow(cdeviceMask_allocs)

	x.ref7ca6664 = ref7ca6664
	x.allocs7ca6664 = allocs7ca6664
	return ref7ca6664, allocs7ca6664

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateFlagsInfoKHR) PassValue() (C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x.ref7ca6664 != nil {
		return *x.ref7ca6664, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateFlagsInfoKHR) Deref() {
	if x.ref7ca6664 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ca6664.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ca6664.pNext))
	x.Flags = (MemoryAllocateFlags)(x.ref7ca6664.flags)
	x.DeviceMask = (uint32)(x.ref7ca6664.deviceMask)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupRenderPassBeginInfoKHR) Ref() *C.VkDeviceGroupRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref139f3599
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupRenderPassBeginInfoKHR) Free() {
	if x != nil && x.allocs139f3599 != nil {
		x.allocs139f3599.(*cgoAllocMap).Free()
		x.ref139f3599 = nil
	}
}

// NewDeviceGroupRenderPassBeginInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupRenderPassBeginInfoKHRRef(ref unsafe.Pointer) *DeviceGroupRenderPassBeginInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupRenderPassBeginInfoKHR)
	obj.ref139f3599 = (*C.VkDeviceGroupRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupRenderPassBeginInfoKHR) PassRef() (*C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref139f3599 != nil {
		return x.ref139f3599, nil
	}
	mem139f3599 := allocDeviceGroupRenderPassBeginInfoMemory(1)
	ref139f3599 := (*C.VkDeviceGroupRenderPassBeginInfo)(mem139f3599)
	allocs139f3599 := new(cgoAllocMap)
	allocs139f3599.Add(mem139f3599)

	var csType_allocs *cgoAllocMap
	ref139f3599.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs139f3599.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref139f3599.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs139f3599.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref139f3599.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceMask_allocs)

	var cdeviceRenderAreaCount_allocs *cgoAllocMap
	ref139f3599.deviceRenderAreaCount, cdeviceRenderAreaCount_allocs = (C.uint32_t)(x.DeviceRenderAreaCount), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceRenderAreaCount_allocs)

	var cpDeviceRenderAreas_allocs *cgoAllocMap
	ref139f3599.pDeviceRenderAreas, cpDeviceRenderAreas_allocs = unpackSRect2D(x.PDeviceRenderAreas)
	allocs139f3599.Borrow(cpDeviceRenderAreas_allocs)

	x.ref139f3599 = ref139f3599
	x.allocs139f3599 = allocs139f3599
	return ref139f3599, allocs139f3599

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupRenderPassBeginInfoKHR) PassValue() (C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref139f3599 != nil {
		return *x.ref139f3599, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupRenderPassBeginInfoKHR) Deref() {
	if x.ref139f3599 == nil {
		return
	}
	x.SType = (StructureType)(x.ref139f3599.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref139f3599.pNext))
	x.DeviceMask = (uint32)(x.ref139f3599.deviceMask)
	x.DeviceRenderAreaCount = (uint32)(x.ref139f3599.deviceRenderAreaCount)
	packSRect2D(x.PDeviceRenderAreas, x.ref139f3599.pDeviceRenderAreas)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupCommandBufferBeginInfoKHR) Ref() *C.VkDeviceGroupCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.refb9a8f0cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupCommandBufferBeginInfoKHR) Free() {
	if x != nil && x.allocsb9a8f0cd != nil {
		x.allocsb9a8f0cd.(*cgoAllocMap).Free()
		x.refb9a8f0cd = nil
	}
}

// NewDeviceGroupCommandBufferBeginInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupCommandBufferBeginInfoKHRRef(ref unsafe.Pointer) *DeviceGroupCommandBufferBeginInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupCommandBufferBeginInfoKHR)
	obj.refb9a8f0cd = (*C.VkDeviceGroupCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupCommandBufferBeginInfoKHR) PassRef() (*C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9a8f0cd != nil {
		return x.refb9a8f0cd, nil
	}
	memb9a8f0cd := allocDeviceGroupCommandBufferBeginInfoMemory(1)
	refb9a8f0cd := (*C.VkDeviceGroupCommandBufferBeginInfo)(memb9a8f0cd)
	allocsb9a8f0cd := new(cgoAllocMap)
	allocsb9a8f0cd.Add(memb9a8f0cd)

	var csType_allocs *cgoAllocMap
	refb9a8f0cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb9a8f0cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	refb9a8f0cd.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cdeviceMask_allocs)

	x.refb9a8f0cd = refb9a8f0cd
	x.allocsb9a8f0cd = allocsb9a8f0cd
	return refb9a8f0cd, allocsb9a8f0cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupCommandBufferBeginInfoKHR) PassValue() (C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x.refb9a8f0cd != nil {
		return *x.refb9a8f0cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupCommandBufferBeginInfoKHR) Deref() {
	if x.refb9a8f0cd == nil {
		return
	}
	x.SType = (StructureType)(x.refb9a8f0cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb9a8f0cd.pNext))
	x.DeviceMask = (uint32)(x.refb9a8f0cd.deviceMask)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSubmitInfoKHR) Ref() *C.VkDeviceGroupSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refea4e7ce4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSubmitInfoKHR) Free() {
	if x != nil && x.allocsea4e7ce4 != nil {
		x.allocsea4e7ce4.(*cgoAllocMap).Free()
		x.refea4e7ce4 = nil
	}
}

// NewDeviceGroupSubmitInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSubmitInfoKHRRef(ref unsafe.Pointer) *DeviceGroupSubmitInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSubmitInfoKHR)
	obj.refea4e7ce4 = (*C.VkDeviceGroupSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSubmitInfoKHR) PassRef() (*C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea4e7ce4 != nil {
		return x.refea4e7ce4, nil
	}
	memea4e7ce4 := allocDeviceGroupSubmitInfoMemory(1)
	refea4e7ce4 := (*C.VkDeviceGroupSubmitInfo)(memea4e7ce4)
	allocsea4e7ce4 := new(cgoAllocMap)
	allocsea4e7ce4.Add(memea4e7ce4)

	var csType_allocs *cgoAllocMap
	refea4e7ce4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea4e7ce4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pWaitSemaphoreDeviceIndices, cpWaitSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpWaitSemaphoreDeviceIndices_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refea4e7ce4.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(ccommandBufferCount_allocs)

	var cpCommandBufferDeviceMasks_allocs *cgoAllocMap
	refea4e7ce4.pCommandBufferDeviceMasks, cpCommandBufferDeviceMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpCommandBufferDeviceMasks_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pSignalSemaphoreDeviceIndices, cpSignalSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpSignalSemaphoreDeviceIndices_allocs)

	x.refea4e7ce4 = refea4e7ce4
	x.allocsea4e7ce4 = allocsea4e7ce4
	return refea4e7ce4, allocsea4e7ce4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSubmitInfoKHR) PassValue() (C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x.refea4e7ce4 != nil {
		return *x.refea4e7ce4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSubmitInfoKHR) Deref() {
	if x.refea4e7ce4 == nil {
		return
	}
	x.SType = (StructureType)(x.refea4e7ce4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea4e7ce4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refea4e7ce4.waitSemaphoreCount)
	hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices))
	hxf8aebb5.Data = unsafe.Pointer(x.refea4e7ce4.pWaitSemaphoreDeviceIndices)
	hxf8aebb5.Cap = 0x7fffffff
	// hxf8aebb5.Len = ?

	x.CommandBufferCount = (uint32)(x.refea4e7ce4.commandBufferCount)
	hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks))
	hxf5d30cf.Data = unsafe.Pointer(x.refea4e7ce4.pCommandBufferDeviceMasks)
	hxf5d30cf.Cap = 0x7fffffff
	// hxf5d30cf.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.refea4e7ce4.signalSemaphoreCount)
	hxf882e98 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices))
	hxf882e98.Data = unsafe.Pointer(x.refea4e7ce4.pSignalSemaphoreDeviceIndices)
	hxf882e98.Cap = 0x7fffffff
	// hxf882e98.Len = ?

}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupBindSparseInfoKHR) Ref() *C.VkDeviceGroupBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.ref5b5446cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupBindSparseInfoKHR) Free() {
	if x != nil && x.allocs5b5446cd != nil {
		x.allocs5b5446cd.(*cgoAllocMap).Free()
		x.ref5b5446cd = nil
	}
}

// NewDeviceGroupBindSparseInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupBindSparseInfoKHRRef(ref unsafe.Pointer) *DeviceGroupBindSparseInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupBindSparseInfoKHR)
	obj.ref5b5446cd = (*C.VkDeviceGroupBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupBindSparseInfoKHR) PassRef() (*C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b5446cd != nil {
		return x.ref5b5446cd, nil
	}
	mem5b5446cd := allocDeviceGroupBindSparseInfoMemory(1)
	ref5b5446cd := (*C.VkDeviceGroupBindSparseInfo)(mem5b5446cd)
	allocs5b5446cd := new(cgoAllocMap)
	allocs5b5446cd.Add(mem5b5446cd)

	var csType_allocs *cgoAllocMap
	ref5b5446cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5b5446cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5b5446cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cpNext_allocs)

	var cresourceDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.resourceDeviceIndex, cresourceDeviceIndex_allocs = (C.uint32_t)(x.ResourceDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cresourceDeviceIndex_allocs)

	var cmemoryDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.memoryDeviceIndex, cmemoryDeviceIndex_allocs = (C.uint32_t)(x.MemoryDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cmemoryDeviceIndex_allocs)

	x.ref5b5446cd = ref5b5446cd
	x.allocs5b5446cd = allocs5b5446cd
	return ref5b5446cd, allocs5b5446cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupBindSparseInfoKHR) PassValue() (C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x.ref5b5446cd != nil {
		return *x.ref5b5446cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupBindSparseInfoKHR) Deref() {
	if x.ref5b5446cd == nil {
		return
	}
	x.SType = (StructureType)(x.ref5b5446cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5b5446cd.pNext))
	x.ResourceDeviceIndex = (uint32)(x.ref5b5446cd.resourceDeviceIndex)
	x.MemoryDeviceIndex = (uint32)(x.ref5b5446cd.memoryDeviceIndex)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryDeviceGroupInfoKHR) Ref() *C.VkBindBufferMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.reff136b64f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryDeviceGroupInfoKHR) Free() {
	if x != nil && x.allocsf136b64f != nil {
		x.allocsf136b64f.(*cgoAllocMap).Free()
		x.reff136b64f = nil
	}
}

// NewBindBufferMemoryDeviceGroupInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryDeviceGroupInfoKHRRef(ref unsafe.Pointer) *BindBufferMemoryDeviceGroupInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryDeviceGroupInfoKHR)
	obj.reff136b64f = (*C.VkBindBufferMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryDeviceGroupInfoKHR) PassRef() (*C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff136b64f != nil {
		return x.reff136b64f, nil
	}
	memf136b64f := allocBindBufferMemoryDeviceGroupInfoMemory(1)
	reff136b64f := (*C.VkBindBufferMemoryDeviceGroupInfo)(memf136b64f)
	allocsf136b64f := new(cgoAllocMap)
	allocsf136b64f.Add(memf136b64f)

	var csType_allocs *cgoAllocMap
	reff136b64f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf136b64f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff136b64f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	reff136b64f.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocsf136b64f.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	reff136b64f.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpDeviceIndices_allocs)

	x.reff136b64f = reff136b64f
	x.allocsf136b64f = allocsf136b64f
	return reff136b64f, allocsf136b64f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryDeviceGroupInfoKHR) PassValue() (C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.reff136b64f != nil {
		return *x.reff136b64f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryDeviceGroupInfoKHR) Deref() {
	if x.reff136b64f == nil {
		return
	}
	x.SType = (StructureType)(x.reff136b64f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff136b64f.pNext))
	x.DeviceIndexCount = (uint32)(x.reff136b64f.deviceIndexCount)
	hxf992404 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf992404.Data = unsafe.Pointer(x.reff136b64f.pDeviceIndices)
	hxf992404.Cap = 0x7fffffff
	// hxf992404.Len = ?

}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryDeviceGroupInfoKHR) Ref() *C.VkBindImageMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.ref24f026a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryDeviceGroupInfoKHR) Free() {
	if x != nil && x.allocs24f026a5 != nil {
		x.allocs24f026a5.(*cgoAllocMap).Free()
		x.ref24f026a5 = nil
	}
}

// NewBindImageMemoryDeviceGroupInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryDeviceGroupInfoKHRRef(ref unsafe.Pointer) *BindImageMemoryDeviceGroupInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryDeviceGroupInfoKHR)
	obj.ref24f026a5 = (*C.VkBindImageMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryDeviceGroupInfoKHR) PassRef() (*C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f026a5 != nil {
		return x.ref24f026a5, nil
	}
	mem24f026a5 := allocBindImageMemoryDeviceGroupInfoMemory(1)
	ref24f026a5 := (*C.VkBindImageMemoryDeviceGroupInfo)(mem24f026a5)
	allocs24f026a5 := new(cgoAllocMap)
	allocs24f026a5.Add(mem24f026a5)

	var csType_allocs *cgoAllocMap
	ref24f026a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs24f026a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref24f026a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	ref24f026a5.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	ref24f026a5.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpDeviceIndices_allocs)

	var csplitInstanceBindRegionCount_allocs *cgoAllocMap
	ref24f026a5.splitInstanceBindRegionCount, csplitInstanceBindRegionCount_allocs = (C.uint32_t)(x.SplitInstanceBindRegionCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(csplitInstanceBindRegionCount_allocs)

	var cpSplitInstanceBindRegions_allocs *cgoAllocMap
	ref24f026a5.pSplitInstanceBindRegions, cpSplitInstanceBindRegions_allocs = unpackSRect2D(x.PSplitInstanceBindRegions)
	allocs24f026a5.Borrow(cpSplitInstanceBindRegions_allocs)

	x.ref24f026a5 = ref24f026a5
	x.allocs24f026a5 = allocs24f026a5
	return ref24f026a5, allocs24f026a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryDeviceGroupInfoKHR) PassValue() (C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.ref24f026a5 != nil {
		return *x.ref24f026a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryDeviceGroupInfoKHR) Deref() {
	if x.ref24f026a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f026a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f026a5.pNext))
	x.DeviceIndexCount = (uint32)(x.ref24f026a5.deviceIndexCount)
	hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf8e0dd2.Data = unsafe.Pointer(x.ref24f026a5.pDeviceIndices)
	hxf8e0dd2.Cap = 0x7fffffff
	// hxf8e0dd2.Len = ?

	x.SplitInstanceBindRegionCount = (uint32)(x.ref24f026a5.splitInstanceBindRegionCount)
	packSRect2D(x.PSplitInstanceBindRegions, x.ref24f026a5.pSplitInstanceBindRegions)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceGroupPropertiesKHR) Ref() *C.VkPhysicalDeviceGroupProperties {
	if x == nil {
		return nil
	}
	return x.ref2aa9a663
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceGroupPropertiesKHR) Free() {
	if x != nil && x.allocs2aa9a663 != nil {
		x.allocs2aa9a663.(*cgoAllocMap).Free()
		x.ref2aa9a663 = nil
	}
}

// NewPhysicalDeviceGroupPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceGroupPropertiesKHRRef(ref unsafe.Pointer) *PhysicalDeviceGroupPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceGroupPropertiesKHR)
	obj.ref2aa9a663 = (*C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceGroupPropertiesKHR) PassRef() (*C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa9a663 != nil {
		return x.ref2aa9a663, nil
	}
	mem2aa9a663 := allocPhysicalDeviceGroupPropertiesMemory(1)
	ref2aa9a663 := (*C.VkPhysicalDeviceGroupProperties)(mem2aa9a663)
	allocs2aa9a663 := new(cgoAllocMap)
	allocs2aa9a663.Add(mem2aa9a663)

	var csType_allocs *cgoAllocMap
	ref2aa9a663.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2aa9a663.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	ref2aa9a663.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDeviceCount_allocs)

	var cphysicalDevices_allocs *cgoAllocMap
	ref2aa9a663.physicalDevices, cphysicalDevices_allocs = *(*[32]C.VkPhysicalDevice)(unsafe.Pointer(&x.PhysicalDevices)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDevices_allocs)

	var csubsetAllocation_allocs *cgoAllocMap
	ref2aa9a663.subsetAllocation, csubsetAllocation_allocs = (C.VkBool32)(x.SubsetAllocation), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csubsetAllocation_allocs)

	x.ref2aa9a663 = ref2aa9a663
	x.allocs2aa9a663 = allocs2aa9a663
	return ref2aa9a663, allocs2aa9a663

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceGroupPropertiesKHR) PassValue() (C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x.ref2aa9a663 != nil {
		return *x.ref2aa9a663, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceGroupPropertiesKHR) Deref() {
	if x.ref2aa9a663 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2aa9a663.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2aa9a663.pNext))
	x.PhysicalDeviceCount = (uint32)(x.ref2aa9a663.physicalDeviceCount)
	x.PhysicalDevices = *(*[32]PhysicalDevice)(unsafe.Pointer(&x.ref2aa9a663.physicalDevices))
	x.SubsetAllocation = (Bool32)(x.ref2aa9a663.subsetAllocation)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupDeviceCreateInfoKHR) Ref() *C.VkDeviceGroupDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb2275723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupDeviceCreateInfoKHR) Free() {
	if x != nil && x.allocsb2275723 != nil {
		x.allocsb2275723.(*cgoAllocMap).Free()
		x.refb2275723 = nil
	}
}

// NewDeviceGroupDeviceCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupDeviceCreateInfoKHRRef(ref unsafe.Pointer) *DeviceGroupDeviceCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupDeviceCreateInfoKHR)
	obj.refb2275723 = (*C.VkDeviceGroupDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupDeviceCreateInfoKHR) PassRef() (*C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2275723 != nil {
		return x.refb2275723, nil
	}
	memb2275723 := allocDeviceGroupDeviceCreateInfoMemory(1)
	refb2275723 := (*C.VkDeviceGroupDeviceCreateInfo)(memb2275723)
	allocsb2275723 := new(cgoAllocMap)
	allocsb2275723.Add(memb2275723)

	var csType_allocs *cgoAllocMap
	refb2275723.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2275723.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2275723.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	refb2275723.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocsb2275723.Borrow(cphysicalDeviceCount_allocs)

	var cpPhysicalDevices_allocs *cgoAllocMap
	refb2275723.pPhysicalDevices, cpPhysicalDevices_allocs = (*C.VkPhysicalDevice)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices)).Data)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpPhysicalDevices_allocs)

	x.refb2275723 = refb2275723
	x.allocsb2275723 = allocsb2275723
	return refb2275723, allocsb2275723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupDeviceCreateInfoKHR) PassValue() (C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x.refb2275723 != nil {
		return *x.refb2275723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupDeviceCreateInfoKHR) Deref() {
	if x.refb2275723 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2275723.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2275723.pNext))
	x.PhysicalDeviceCount = (uint32)(x.refb2275723.physicalDeviceCount)
	hxf44d909 := (*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices))
	hxf44d909.Data = unsafe.Pointer(x.refb2275723.pPhysicalDevices)
	hxf44d909.Cap = 0x7fffffff
	// hxf44d909.Len = ?

}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryPropertiesKHR) Ref() *C.VkExternalMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref4b738f01
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryPropertiesKHR) Free() {
	if x != nil && x.allocs4b738f01 != nil {
		x.allocs4b738f01.(*cgoAllocMap).Free()
		x.ref4b738f01 = nil
	}
}

// NewExternalMemoryPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryPropertiesKHRRef(ref unsafe.Pointer) *ExternalMemoryPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryPropertiesKHR)
	obj.ref4b738f01 = (*C.VkExternalMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryPropertiesKHR) PassRef() (*C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b738f01 != nil {
		return x.ref4b738f01, nil
	}
	mem4b738f01 := allocExternalMemoryPropertiesMemory(1)
	ref4b738f01 := (*C.VkExternalMemoryProperties)(mem4b738f01)
	allocs4b738f01 := new(cgoAllocMap)
	allocs4b738f01.Add(mem4b738f01)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	ref4b738f01.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlags)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref4b738f01.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref4b738f01.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(ccompatibleHandleTypes_allocs)

	x.ref4b738f01 = ref4b738f01
	x.allocs4b738f01 = allocs4b738f01
	return ref4b738f01, allocs4b738f01

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryPropertiesKHR) PassValue() (C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x.ref4b738f01 != nil {
		return *x.ref4b738f01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryPropertiesKHR) Deref() {
	if x.ref4b738f01 == nil {
		return
	}
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlags)(x.ref4b738f01.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.compatibleHandleTypes)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalImageFormatInfoKHR) Ref() *C.VkPhysicalDeviceExternalImageFormatInfo {
	if x == nil {
		return nil
	}
	return x.refc839c724
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalImageFormatInfoKHR) Free() {
	if x != nil && x.allocsc839c724 != nil {
		x.allocsc839c724.(*cgoAllocMap).Free()
		x.refc839c724 = nil
	}
}

// NewPhysicalDeviceExternalImageFormatInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalImageFormatInfoKHRRef(ref unsafe.Pointer) *PhysicalDeviceExternalImageFormatInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalImageFormatInfoKHR)
	obj.refc839c724 = (*C.VkPhysicalDeviceExternalImageFormatInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalImageFormatInfoKHR) PassRef() (*C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc839c724 != nil {
		return x.refc839c724, nil
	}
	memc839c724 := allocPhysicalDeviceExternalImageFormatInfoMemory(1)
	refc839c724 := (*C.VkPhysicalDeviceExternalImageFormatInfo)(memc839c724)
	allocsc839c724 := new(cgoAllocMap)
	allocsc839c724.Add(memc839c724)

	var csType_allocs *cgoAllocMap
	refc839c724.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc839c724.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc839c724.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc839c724.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	refc839c724.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc839c724.Borrow(chandleType_allocs)

	x.refc839c724 = refc839c724
	x.allocsc839c724 = allocsc839c724
	return refc839c724, allocsc839c724

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfoKHR) PassValue() (C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x.refc839c724 != nil {
		return *x.refc839c724, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalImageFormatInfoKHR) Deref() {
	if x.refc839c724 == nil {
		return
	}
	x.SType = (StructureType)(x.refc839c724.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc839c724.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.refc839c724.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatPropertiesKHR) Ref() *C.VkExternalImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.refd404c4b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatPropertiesKHR) Free() {
	if x != nil && x.allocsd404c4b5 != nil {
		x.allocsd404c4b5.(*cgoAllocMap).Free()
		x.refd404c4b5 = nil
	}
}

// NewExternalImageFormatPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesKHRRef(ref unsafe.Pointer) *ExternalImageFormatPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatPropertiesKHR)
	obj.refd404c4b5 = (*C.VkExternalImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatPropertiesKHR) PassRef() (*C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd404c4b5 != nil {
		return x.refd404c4b5, nil
	}
	memd404c4b5 := allocExternalImageFormatPropertiesMemory(1)
	refd404c4b5 := (*C.VkExternalImageFormatProperties)(memd404c4b5)
	allocsd404c4b5 := new(cgoAllocMap)
	allocsd404c4b5.Add(memd404c4b5)

	var csType_allocs *cgoAllocMap
	refd404c4b5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd404c4b5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd404c4b5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd404c4b5.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	refd404c4b5.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocsd404c4b5.Borrow(cexternalMemoryProperties_allocs)

	x.refd404c4b5 = refd404c4b5
	x.allocsd404c4b5 = allocsd404c4b5
	return refd404c4b5, allocsd404c4b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatPropertiesKHR) PassValue() (C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x.refd404c4b5 != nil {
		return *x.refd404c4b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatPropertiesKHR) Deref() {
	if x.refd404c4b5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd404c4b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd404c4b5.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.refd404c4b5.externalMemoryProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalBufferInfoKHR) Ref() *C.VkPhysicalDeviceExternalBufferInfo {
	if x == nil {
		return nil
	}
	return x.ref8d758947
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalBufferInfoKHR) Free() {
	if x != nil && x.allocs8d758947 != nil {
		x.allocs8d758947.(*cgoAllocMap).Free()
		x.ref8d758947 = nil
	}
}

// NewPhysicalDeviceExternalBufferInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalBufferInfoKHRRef(ref unsafe.Pointer) *PhysicalDeviceExternalBufferInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalBufferInfoKHR)
	obj.ref8d758947 = (*C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalBufferInfoKHR) PassRef() (*C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d758947 != nil {
		return x.ref8d758947, nil
	}
	mem8d758947 := allocPhysicalDeviceExternalBufferInfoMemory(1)
	ref8d758947 := (*C.VkPhysicalDeviceExternalBufferInfo)(mem8d758947)
	allocs8d758947 := new(cgoAllocMap)
	allocs8d758947.Add(mem8d758947)

	var csType_allocs *cgoAllocMap
	ref8d758947.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d758947.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d758947.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d758947.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref8d758947.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs8d758947.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	ref8d758947.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs8d758947.Borrow(cusage_allocs)

	var chandleType_allocs *cgoAllocMap
	ref8d758947.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs8d758947.Borrow(chandleType_allocs)

	x.ref8d758947 = ref8d758947
	x.allocs8d758947 = allocs8d758947
	return ref8d758947, allocs8d758947

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalBufferInfoKHR) PassValue() (C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x.ref8d758947 != nil {
		return *x.ref8d758947, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalBufferInfoKHR) Deref() {
	if x.ref8d758947 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d758947.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d758947.pNext))
	x.Flags = (BufferCreateFlags)(x.ref8d758947.flags)
	x.Usage = (BufferUsageFlags)(x.ref8d758947.usage)
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref8d758947.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalBufferPropertiesKHR) Ref() *C.VkExternalBufferProperties {
	if x == nil {
		return nil
	}
	return x.ref12f7c546
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalBufferPropertiesKHR) Free() {
	if x != nil && x.allocs12f7c546 != nil {
		x.allocs12f7c546.(*cgoAllocMap).Free()
		x.ref12f7c546 = nil
	}
}

// NewExternalBufferPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalBufferPropertiesKHRRef(ref unsafe.Pointer) *ExternalBufferPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalBufferPropertiesKHR)
	obj.ref12f7c546 = (*C.VkExternalBufferProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalBufferPropertiesKHR) PassRef() (*C.VkExternalBufferProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12f7c546 != nil {
		return x.ref12f7c546, nil
	}
	mem12f7c546 := allocExternalBufferPropertiesMemory(1)
	ref12f7c546 := (*C.VkExternalBufferProperties)(mem12f7c546)
	allocs12f7c546 := new(cgoAllocMap)
	allocs12f7c546.Add(mem12f7c546)

	var csType_allocs *cgoAllocMap
	ref12f7c546.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12f7c546.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12f7c546.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12f7c546.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	ref12f7c546.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocs12f7c546.Borrow(cexternalMemoryProperties_allocs)

	x.ref12f7c546 = ref12f7c546
	x.allocs12f7c546 = allocs12f7c546
	return ref12f7c546, allocs12f7c546

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalBufferPropertiesKHR) PassValue() (C.VkExternalBufferProperties, *cgoAllocMap) {
	if x.ref12f7c546 != nil {
		return *x.ref12f7c546, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalBufferPropertiesKHR) Deref() {
	if x.ref12f7c546 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12f7c546.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12f7c546.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.ref12f7c546.externalMemoryProperties))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIDPropertiesKHR) Ref() *C.VkPhysicalDeviceIDProperties {
	if x == nil {
		return nil
	}
	return x.refe990a9f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIDPropertiesKHR) Free() {
	if x != nil && x.allocse990a9f3 != nil {
		x.allocse990a9f3.(*cgoAllocMap).Free()
		x.refe990a9f3 = nil
	}
}

// NewPhysicalDeviceIDPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIDPropertiesKHRRef(ref unsafe.Pointer) *PhysicalDeviceIDPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIDPropertiesKHR)
	obj.refe990a9f3 = (*C.VkPhysicalDeviceIDProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIDPropertiesKHR) PassRef() (*C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe990a9f3 != nil {
		return x.refe990a9f3, nil
	}
	meme990a9f3 := allocPhysicalDeviceIDPropertiesMemory(1)
	refe990a9f3 := (*C.VkPhysicalDeviceIDProperties)(meme990a9f3)
	allocse990a9f3 := new(cgoAllocMap)
	allocse990a9f3.Add(meme990a9f3)

	var csType_allocs *cgoAllocMap
	refe990a9f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse990a9f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe990a9f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cpNext_allocs)

	var cdeviceUUID_allocs *cgoAllocMap
	refe990a9f3.deviceUUID, cdeviceUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceUUID_allocs)

	var cdriverUUID_allocs *cgoAllocMap
	refe990a9f3.driverUUID, cdriverUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdriverUUID_allocs)

	var cdeviceLUID_allocs *cgoAllocMap
	refe990a9f3.deviceLUID, cdeviceLUID_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUID_allocs)

	var cdeviceNodeMask_allocs *cgoAllocMap
	refe990a9f3.deviceNodeMask, cdeviceNodeMask_allocs = (C.uint32_t)(x.DeviceNodeMask), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceNodeMask_allocs)

	var cdeviceLUIDValid_allocs *cgoAllocMap
	refe990a9f3.deviceLUIDValid, cdeviceLUIDValid_allocs = (C.VkBool32)(x.DeviceLUIDValid), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUIDValid_allocs)

	x.refe990a9f3 = refe990a9f3
	x.allocse990a9f3 = allocse990a9f3
	return refe990a9f3, allocse990a9f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIDPropertiesKHR) PassValue() (C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x.refe990a9f3 != nil {
		return *x.refe990a9f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIDPropertiesKHR) Deref() {
	if x.refe990a9f3 == nil {
		return
	}
	x.SType = (StructureType)(x.refe990a9f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe990a9f3.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refe990a9f3.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refe990a9f3.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refe990a9f3.deviceLUIDValid)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfoKHR) Ref() *C.VkExternalMemoryImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.refdaf1185e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfoKHR) Free() {
	if x != nil && x.allocsdaf1185e != nil {
		x.allocsdaf1185e.(*cgoAllocMap).Free()
		x.refdaf1185e = nil
	}
}

// NewExternalMemoryImageCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoKHRRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfoKHR)
	obj.refdaf1185e = (*C.VkExternalMemoryImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfoKHR) PassRef() (*C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdaf1185e != nil {
		return x.refdaf1185e, nil
	}
	memdaf1185e := allocExternalMemoryImageCreateInfoMemory(1)
	refdaf1185e := (*C.VkExternalMemoryImageCreateInfo)(memdaf1185e)
	allocsdaf1185e := new(cgoAllocMap)
	allocsdaf1185e.Add(memdaf1185e)

	var csType_allocs *cgoAllocMap
	refdaf1185e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdaf1185e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdaf1185e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdaf1185e.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refdaf1185e.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsdaf1185e.Borrow(chandleTypes_allocs)

	x.refdaf1185e = refdaf1185e
	x.allocsdaf1185e = allocsdaf1185e
	return refdaf1185e, allocsdaf1185e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfoKHR) PassValue() (C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x.refdaf1185e != nil {
		return *x.refdaf1185e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfoKHR) Deref() {
	if x.refdaf1185e == nil {
		return
	}
	x.SType = (StructureType)(x.refdaf1185e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdaf1185e.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refdaf1185e.handleTypes)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryBufferCreateInfoKHR) Ref() *C.VkExternalMemoryBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refd33a9423
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryBufferCreateInfoKHR) Free() {
	if x != nil && x.allocsd33a9423 != nil {
		x.allocsd33a9423.(*cgoAllocMap).Free()
		x.refd33a9423 = nil
	}
}

// NewExternalMemoryBufferCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryBufferCreateInfoKHRRef(ref unsafe.Pointer) *ExternalMemoryBufferCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryBufferCreateInfoKHR)
	obj.refd33a9423 = (*C.VkExternalMemoryBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryBufferCreateInfoKHR) PassRef() (*C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd33a9423 != nil {
		return x.refd33a9423, nil
	}
	memd33a9423 := allocExternalMemoryBufferCreateInfoMemory(1)
	refd33a9423 := (*C.VkExternalMemoryBufferCreateInfo)(memd33a9423)
	allocsd33a9423 := new(cgoAllocMap)
	allocsd33a9423.Add(memd33a9423)

	var csType_allocs *cgoAllocMap
	refd33a9423.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd33a9423.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd33a9423.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd33a9423.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refd33a9423.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsd33a9423.Borrow(chandleTypes_allocs)

	x.refd33a9423 = refd33a9423
	x.allocsd33a9423 = allocsd33a9423
	return refd33a9423, allocsd33a9423

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryBufferCreateInfoKHR) PassValue() (C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x.refd33a9423 != nil {
		return *x.refd33a9423, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryBufferCreateInfoKHR) Deref() {
	if x.refd33a9423 == nil {
		return
	}
	x.SType = (StructureType)(x.refd33a9423.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd33a9423.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refd33a9423.handleTypes)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfoKHR) Ref() *C.VkExportMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refeb76ec64
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfoKHR) Free() {
	if x != nil && x.allocseb76ec64 != nil {
		x.allocseb76ec64.(*cgoAllocMap).Free()
		x.refeb76ec64 = nil
	}
}

// NewExportMemoryAllocateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoKHRRef(ref unsafe.Pointer) *ExportMemoryAllocateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfoKHR)
	obj.refeb76ec64 = (*C.VkExportMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfoKHR) PassRef() (*C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb76ec64 != nil {
		return x.refeb76ec64, nil
	}
	memeb76ec64 := allocExportMemoryAllocateInfoMemory(1)
	refeb76ec64 := (*C.VkExportMemoryAllocateInfo)(memeb76ec64)
	allocseb76ec64 := new(cgoAllocMap)
	allocseb76ec64.Add(memeb76ec64)

	var csType_allocs *cgoAllocMap
	refeb76ec64.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseb76ec64.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeb76ec64.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseb76ec64.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refeb76ec64.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocseb76ec64.Borrow(chandleTypes_allocs)

	x.refeb76ec64 = refeb76ec64
	x.allocseb76ec64 = allocseb76ec64
	return refeb76ec64, allocseb76ec64

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfoKHR) PassValue() (C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x.refeb76ec64 != nil {
		return *x.refeb76ec64, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfoKHR) Deref() {
	if x.refeb76ec64 == nil {
		return
	}
	x.SType = (StructureType)(x.refeb76ec64.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeb76ec64.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refeb76ec64.handleTypes)
}

// allocImportMemoryFdInfoKHRMemory allocates memory for type C.VkImportMemoryFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportMemoryFdInfoKHRValue = unsafe.Sizeof([1]C.VkImportMemoryFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryFdInfoKHR) Ref() *C.VkImportMemoryFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref73f83287
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryFdInfoKHR) Free() {
	if x != nil && x.allocs73f83287 != nil {
		x.allocs73f83287.(*cgoAllocMap).Free()
		x.ref73f83287 = nil
	}
}

// NewImportMemoryFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryFdInfoKHRRef(ref unsafe.Pointer) *ImportMemoryFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryFdInfoKHR)
	obj.ref73f83287 = (*C.VkImportMemoryFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryFdInfoKHR) PassRef() (*C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73f83287 != nil {
		return x.ref73f83287, nil
	}
	mem73f83287 := allocImportMemoryFdInfoKHRMemory(1)
	ref73f83287 := (*C.VkImportMemoryFdInfoKHR)(mem73f83287)
	allocs73f83287 := new(cgoAllocMap)
	allocs73f83287.Add(mem73f83287)

	var csType_allocs *cgoAllocMap
	ref73f83287.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73f83287.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73f83287.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73f83287.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref73f83287.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs73f83287.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref73f83287.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs73f83287.Borrow(cfd_allocs)

	x.ref73f83287 = ref73f83287
	x.allocs73f83287 = allocs73f83287
	return ref73f83287, allocs73f83287

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryFdInfoKHR) PassValue() (C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x.ref73f83287 != nil {
		return *x.ref73f83287, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryFdInfoKHR) Deref() {
	if x.ref73f83287 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73f83287.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73f83287.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref73f83287.handleType)
	x.Fd = (int32)(x.ref73f83287.fd)
}

// allocMemoryFdPropertiesKHRMemory allocates memory for type C.VkMemoryFdPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryFdPropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryFdPropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryFdPropertiesKHRValue = unsafe.Sizeof([1]C.VkMemoryFdPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryFdPropertiesKHR) Ref() *C.VkMemoryFdPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref51e16d38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryFdPropertiesKHR) Free() {
	if x != nil && x.allocs51e16d38 != nil {
		x.allocs51e16d38.(*cgoAllocMap).Free()
		x.ref51e16d38 = nil
	}
}

// NewMemoryFdPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryFdPropertiesKHRRef(ref unsafe.Pointer) *MemoryFdPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryFdPropertiesKHR)
	obj.ref51e16d38 = (*C.VkMemoryFdPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryFdPropertiesKHR) PassRef() (*C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51e16d38 != nil {
		return x.ref51e16d38, nil
	}
	mem51e16d38 := allocMemoryFdPropertiesKHRMemory(1)
	ref51e16d38 := (*C.VkMemoryFdPropertiesKHR)(mem51e16d38)
	allocs51e16d38 := new(cgoAllocMap)
	allocs51e16d38.Add(mem51e16d38)

	var csType_allocs *cgoAllocMap
	ref51e16d38.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs51e16d38.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref51e16d38.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs51e16d38.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref51e16d38.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs51e16d38.Borrow(cmemoryTypeBits_allocs)

	x.ref51e16d38 = ref51e16d38
	x.allocs51e16d38 = allocs51e16d38
	return ref51e16d38, allocs51e16d38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryFdPropertiesKHR) PassValue() (C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x.ref51e16d38 != nil {
		return *x.ref51e16d38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryFdPropertiesKHR) Deref() {
	if x.ref51e16d38 == nil {
		return
	}
	x.SType = (StructureType)(x.ref51e16d38.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51e16d38.pNext))
	x.MemoryTypeBits = (uint32)(x.ref51e16d38.memoryTypeBits)
}

// allocMemoryGetFdInfoKHRMemory allocates memory for type C.VkMemoryGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryGetFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryGetFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryGetFdInfoKHRValue = unsafe.Sizeof([1]C.VkMemoryGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryGetFdInfoKHR) Ref() *C.VkMemoryGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref75a079b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryGetFdInfoKHR) Free() {
	if x != nil && x.allocs75a079b1 != nil {
		x.allocs75a079b1.(*cgoAllocMap).Free()
		x.ref75a079b1 = nil
	}
}

// NewMemoryGetFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryGetFdInfoKHRRef(ref unsafe.Pointer) *MemoryGetFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryGetFdInfoKHR)
	obj.ref75a079b1 = (*C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryGetFdInfoKHR) PassRef() (*C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75a079b1 != nil {
		return x.ref75a079b1, nil
	}
	mem75a079b1 := allocMemoryGetFdInfoKHRMemory(1)
	ref75a079b1 := (*C.VkMemoryGetFdInfoKHR)(mem75a079b1)
	allocs75a079b1 := new(cgoAllocMap)
	allocs75a079b1.Add(mem75a079b1)

	var csType_allocs *cgoAllocMap
	ref75a079b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75a079b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75a079b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref75a079b1.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cmemory_allocs)

	var chandleType_allocs *cgoAllocMap
	ref75a079b1.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs75a079b1.Borrow(chandleType_allocs)

	x.ref75a079b1 = ref75a079b1
	x.allocs75a079b1 = allocs75a079b1
	return ref75a079b1, allocs75a079b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryGetFdInfoKHR) PassValue() (C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x.ref75a079b1 != nil {
		return *x.ref75a079b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryGetFdInfoKHR) Deref() {
	if x.ref75a079b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75a079b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75a079b1.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref75a079b1.memory))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref75a079b1.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalSemaphoreInfoKHR) Ref() *C.VkPhysicalDeviceExternalSemaphoreInfo {
	if x == nil {
		return nil
	}
	return x.ref5981d29e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfoKHR) Free() {
	if x != nil && x.allocs5981d29e != nil {
		x.allocs5981d29e.(*cgoAllocMap).Free()
		x.ref5981d29e = nil
	}
}

// NewPhysicalDeviceExternalSemaphoreInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalSemaphoreInfoKHRRef(ref unsafe.Pointer) *PhysicalDeviceExternalSemaphoreInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalSemaphoreInfoKHR)
	obj.ref5981d29e = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfoKHR) PassRef() (*C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5981d29e != nil {
		return x.ref5981d29e, nil
	}
	mem5981d29e := allocPhysicalDeviceExternalSemaphoreInfoMemory(1)
	ref5981d29e := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(mem5981d29e)
	allocs5981d29e := new(cgoAllocMap)
	allocs5981d29e.Add(mem5981d29e)

	var csType_allocs *cgoAllocMap
	ref5981d29e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5981d29e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5981d29e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5981d29e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref5981d29e.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs5981d29e.Borrow(chandleType_allocs)

	x.ref5981d29e = ref5981d29e
	x.allocs5981d29e = allocs5981d29e
	return ref5981d29e, allocs5981d29e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfoKHR) PassValue() (C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x.ref5981d29e != nil {
		return *x.ref5981d29e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalSemaphoreInfoKHR) Deref() {
	if x.ref5981d29e == nil {
		return
	}
	x.SType = (StructureType)(x.ref5981d29e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5981d29e.pNext))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.ref5981d29e.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalSemaphorePropertiesKHR) Ref() *C.VkExternalSemaphoreProperties {
	if x == nil {
		return nil
	}
	return x.ref87ec1054
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalSemaphorePropertiesKHR) Free() {
	if x != nil && x.allocs87ec1054 != nil {
		x.allocs87ec1054.(*cgoAllocMap).Free()
		x.ref87ec1054 = nil
	}
}

// NewExternalSemaphorePropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalSemaphorePropertiesKHRRef(ref unsafe.Pointer) *ExternalSemaphorePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalSemaphorePropertiesKHR)
	obj.ref87ec1054 = (*C.VkExternalSemaphoreProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalSemaphorePropertiesKHR) PassRef() (*C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87ec1054 != nil {
		return x.ref87ec1054, nil
	}
	mem87ec1054 := allocExternalSemaphorePropertiesMemory(1)
	ref87ec1054 := (*C.VkExternalSemaphoreProperties)(mem87ec1054)
	allocs87ec1054 := new(cgoAllocMap)
	allocs87ec1054.Add(mem87ec1054)

	var csType_allocs *cgoAllocMap
	ref87ec1054.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs87ec1054.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref87ec1054.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs87ec1054.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref87ec1054.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref87ec1054.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalSemaphoreFeatures_allocs *cgoAllocMap
	ref87ec1054.externalSemaphoreFeatures, cexternalSemaphoreFeatures_allocs = (C.VkExternalSemaphoreFeatureFlags)(x.ExternalSemaphoreFeatures), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexternalSemaphoreFeatures_allocs)

	x.ref87ec1054 = ref87ec1054
	x.allocs87ec1054 = allocs87ec1054
	return ref87ec1054, allocs87ec1054

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalSemaphorePropertiesKHR) PassValue() (C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x.ref87ec1054 != nil {
		return *x.ref87ec1054, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalSemaphorePropertiesKHR) Deref() {
	if x.ref87ec1054 == nil {
		return
	}
	x.SType = (StructureType)(x.ref87ec1054.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref87ec1054.pNext))
	x.ExportFromImportedHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.compatibleHandleTypes)
	x.ExternalSemaphoreFeatures = (ExternalSemaphoreFeatureFlags)(x.ref87ec1054.externalSemaphoreFeatures)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportSemaphoreCreateInfoKHR) Ref() *C.VkExportSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref17b8d6c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportSemaphoreCreateInfoKHR) Free() {
	if x != nil && x.allocs17b8d6c5 != nil {
		x.allocs17b8d6c5.(*cgoAllocMap).Free()
		x.ref17b8d6c5 = nil
	}
}

// NewExportSemaphoreCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportSemaphoreCreateInfoKHRRef(ref unsafe.Pointer) *ExportSemaphoreCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExportSemaphoreCreateInfoKHR)
	obj.ref17b8d6c5 = (*C.VkExportSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportSemaphoreCreateInfoKHR) PassRef() (*C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17b8d6c5 != nil {
		return x.ref17b8d6c5, nil
	}
	mem17b8d6c5 := allocExportSemaphoreCreateInfoMemory(1)
	ref17b8d6c5 := (*C.VkExportSemaphoreCreateInfo)(mem17b8d6c5)
	allocs17b8d6c5 := new(cgoAllocMap)
	allocs17b8d6c5.Add(mem17b8d6c5)

	var csType_allocs *cgoAllocMap
	ref17b8d6c5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref17b8d6c5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref17b8d6c5.handleTypes, chandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(chandleTypes_allocs)

	x.ref17b8d6c5 = ref17b8d6c5
	x.allocs17b8d6c5 = allocs17b8d6c5
	return ref17b8d6c5, allocs17b8d6c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportSemaphoreCreateInfoKHR) PassValue() (C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x.ref17b8d6c5 != nil {
		return *x.ref17b8d6c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportSemaphoreCreateInfoKHR) Deref() {
	if x.ref17b8d6c5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref17b8d6c5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref17b8d6c5.pNext))
	x.HandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref17b8d6c5.handleTypes)
}

// allocImportSemaphoreFdInfoKHRMemory allocates memory for type C.VkImportSemaphoreFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportSemaphoreFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportSemaphoreFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportSemaphoreFdInfoKHRValue = unsafe.Sizeof([1]C.VkImportSemaphoreFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportSemaphoreFdInfoKHR) Ref() *C.VkImportSemaphoreFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbc2f829a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportSemaphoreFdInfoKHR) Free() {
	if x != nil && x.allocsbc2f829a != nil {
		x.allocsbc2f829a.(*cgoAllocMap).Free()
		x.refbc2f829a = nil
	}
}

// NewImportSemaphoreFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportSemaphoreFdInfoKHRRef(ref unsafe.Pointer) *ImportSemaphoreFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImportSemaphoreFdInfoKHR)
	obj.refbc2f829a = (*C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportSemaphoreFdInfoKHR) PassRef() (*C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc2f829a != nil {
		return x.refbc2f829a, nil
	}
	membc2f829a := allocImportSemaphoreFdInfoKHRMemory(1)
	refbc2f829a := (*C.VkImportSemaphoreFdInfoKHR)(membc2f829a)
	allocsbc2f829a := new(cgoAllocMap)
	allocsbc2f829a.Add(membc2f829a)

	var csType_allocs *cgoAllocMap
	refbc2f829a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc2f829a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refbc2f829a.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csemaphore_allocs)

	var cflags_allocs *cgoAllocMap
	refbc2f829a.flags, cflags_allocs = (C.VkSemaphoreImportFlags)(x.Flags), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	refbc2f829a.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	refbc2f829a.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cfd_allocs)

	x.refbc2f829a = refbc2f829a
	x.allocsbc2f829a = allocsbc2f829a
	return refbc2f829a, allocsbc2f829a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportSemaphoreFdInfoKHR) PassValue() (C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x.refbc2f829a != nil {
		return *x.refbc2f829a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportSemaphoreFdInfoKHR) Deref() {
	if x.refbc2f829a == nil {
		return
	}
	x.SType = (StructureType)(x.refbc2f829a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc2f829a.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refbc2f829a.semaphore))
	x.Flags = (SemaphoreImportFlags)(x.refbc2f829a.flags)
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refbc2f829a.handleType)
	x.Fd = (int32)(x.refbc2f829a.fd)
}

// allocSemaphoreGetFdInfoKHRMemory allocates memory for type C.VkSemaphoreGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreGetFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreGetFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreGetFdInfoKHRValue = unsafe.Sizeof([1]C.VkSemaphoreGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreGetFdInfoKHR) Ref() *C.VkSemaphoreGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9bd07cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreGetFdInfoKHR) Free() {
	if x != nil && x.allocsd9bd07cf != nil {
		x.allocsd9bd07cf.(*cgoAllocMap).Free()
		x.refd9bd07cf = nil
	}
}

// NewSemaphoreGetFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreGetFdInfoKHRRef(ref unsafe.Pointer) *SemaphoreGetFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreGetFdInfoKHR)
	obj.refd9bd07cf = (*C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreGetFdInfoKHR) PassRef() (*C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9bd07cf != nil {
		return x.refd9bd07cf, nil
	}
	memd9bd07cf := allocSemaphoreGetFdInfoKHRMemory(1)
	refd9bd07cf := (*C.VkSemaphoreGetFdInfoKHR)(memd9bd07cf)
	allocsd9bd07cf := new(cgoAllocMap)
	allocsd9bd07cf.Add(memd9bd07cf)

	var csType_allocs *cgoAllocMap
	refd9bd07cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9bd07cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refd9bd07cf.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csemaphore_allocs)

	var chandleType_allocs *cgoAllocMap
	refd9bd07cf.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(chandleType_allocs)

	x.refd9bd07cf = refd9bd07cf
	x.allocsd9bd07cf = allocsd9bd07cf
	return refd9bd07cf, allocsd9bd07cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreGetFdInfoKHR) PassValue() (C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x.refd9bd07cf != nil {
		return *x.refd9bd07cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreGetFdInfoKHR) Deref() {
	if x.refd9bd07cf == nil {
		return
	}
	x.SType = (StructureType)(x.refd9bd07cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9bd07cf.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refd9bd07cf.semaphore))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refd9bd07cf.handleType)
}

// allocPhysicalDevicePushDescriptorPropertiesKHRMemory allocates memory for type C.VkPhysicalDevicePushDescriptorPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePushDescriptorPropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePushDescriptorPropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePushDescriptorPropertiesKHRValue = unsafe.Sizeof([1]C.VkPhysicalDevicePushDescriptorPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePushDescriptorPropertiesKHR) Ref() *C.VkPhysicalDevicePushDescriptorPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref8c58a1a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePushDescriptorPropertiesKHR) Free() {
	if x != nil && x.allocs8c58a1a5 != nil {
		x.allocs8c58a1a5.(*cgoAllocMap).Free()
		x.ref8c58a1a5 = nil
	}
}

// NewPhysicalDevicePushDescriptorPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePushDescriptorPropertiesKHRRef(ref unsafe.Pointer) *PhysicalDevicePushDescriptorPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePushDescriptorPropertiesKHR)
	obj.ref8c58a1a5 = (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePushDescriptorPropertiesKHR) PassRef() (*C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c58a1a5 != nil {
		return x.ref8c58a1a5, nil
	}
	mem8c58a1a5 := allocPhysicalDevicePushDescriptorPropertiesKHRMemory(1)
	ref8c58a1a5 := (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(mem8c58a1a5)
	allocs8c58a1a5 := new(cgoAllocMap)
	allocs8c58a1a5.Add(mem8c58a1a5)

	var csType_allocs *cgoAllocMap
	ref8c58a1a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8c58a1a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cpNext_allocs)

	var cmaxPushDescriptors_allocs *cgoAllocMap
	ref8c58a1a5.maxPushDescriptors, cmaxPushDescriptors_allocs = (C.uint32_t)(x.MaxPushDescriptors), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cmaxPushDescriptors_allocs)

	x.ref8c58a1a5 = ref8c58a1a5
	x.allocs8c58a1a5 = allocs8c58a1a5
	return ref8c58a1a5, allocs8c58a1a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePushDescriptorPropertiesKHR) PassValue() (C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x.ref8c58a1a5 != nil {
		return *x.ref8c58a1a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePushDescriptorPropertiesKHR) Deref() {
	if x.ref8c58a1a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8c58a1a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8c58a1a5.pNext))
	x.MaxPushDescriptors = (uint32)(x.ref8c58a1a5.maxPushDescriptors)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice16BitStorageFeaturesKHR) Ref() *C.VkPhysicalDevice16BitStorageFeatures {
	if x == nil {
		return nil
	}
	return x.refa90fed14
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice16BitStorageFeaturesKHR) Free() {
	if x != nil && x.allocsa90fed14 != nil {
		x.allocsa90fed14.(*cgoAllocMap).Free()
		x.refa90fed14 = nil
	}
}

// NewPhysicalDevice16BitStorageFeaturesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice16BitStorageFeaturesKHRRef(ref unsafe.Pointer) *PhysicalDevice16BitStorageFeaturesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice16BitStorageFeaturesKHR)
	obj.refa90fed14 = (*C.VkPhysicalDevice16BitStorageFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice16BitStorageFeaturesKHR) PassRef() (*C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa90fed14 != nil {
		return x.refa90fed14, nil
	}
	mema90fed14 := allocPhysicalDevice16BitStorageFeaturesMemory(1)
	refa90fed14 := (*C.VkPhysicalDevice16BitStorageFeatures)(mema90fed14)
	allocsa90fed14 := new(cgoAllocMap)
	allocsa90fed14.Add(mema90fed14)

	var csType_allocs *cgoAllocMap
	refa90fed14.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa90fed14.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa90fed14.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa90fed14.Borrow(cpNext_allocs)

	var cstorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.storageBuffer16BitAccess, cstorageBuffer16BitAccess_allocs = (C.VkBool32)(x.StorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageBuffer16BitAccess_allocs)

	var cuniformAndStorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.uniformAndStorageBuffer16BitAccess, cuniformAndStorageBuffer16BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cuniformAndStorageBuffer16BitAccess_allocs)

	var cstoragePushConstant16_allocs *cgoAllocMap
	refa90fed14.storagePushConstant16, cstoragePushConstant16_allocs = (C.VkBool32)(x.StoragePushConstant16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstoragePushConstant16_allocs)

	var cstorageInputOutput16_allocs *cgoAllocMap
	refa90fed14.storageInputOutput16, cstorageInputOutput16_allocs = (C.VkBool32)(x.StorageInputOutput16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageInputOutput16_allocs)

	x.refa90fed14 = refa90fed14
	x.allocsa90fed14 = allocsa90fed14
	return refa90fed14, allocsa90fed14

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice16BitStorageFeaturesKHR) PassValue() (C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x.refa90fed14 != nil {
		return *x.refa90fed14, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice16BitStorageFeaturesKHR) Deref() {
	if x.refa90fed14 == nil {
		return
	}
	x.SType = (StructureType)(x.refa90fed14.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa90fed14.pNext))
	x.StorageBuffer16BitAccess = (Bool32)(x.refa90fed14.storageBuffer16BitAccess)
	x.UniformAndStorageBuffer16BitAccess = (Bool32)(x.refa90fed14.uniformAndStorageBuffer16BitAccess)
	x.StoragePushConstant16 = (Bool32)(x.refa90fed14.storagePushConstant16)
	x.StorageInputOutput16 = (Bool32)(x.refa90fed14.storageInputOutput16)
}

// allocRectLayerKHRMemory allocates memory for type C.VkRectLayerKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectLayerKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectLayerKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectLayerKHRValue = unsafe.Sizeof([1]C.VkRectLayerKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RectLayerKHR) Ref() *C.VkRectLayerKHR {
	if x == nil {
		return nil
	}
	return x.refaf248476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RectLayerKHR) Free() {
	if x != nil && x.allocsaf248476 != nil {
		x.allocsaf248476.(*cgoAllocMap).Free()
		x.refaf248476 = nil
	}
}

// NewRectLayerKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectLayerKHRRef(ref unsafe.Pointer) *RectLayerKHR {
	if ref == nil {
		return nil
	}
	obj := new(RectLayerKHR)
	obj.refaf248476 = (*C.VkRectLayerKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RectLayerKHR) PassRef() (*C.VkRectLayerKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf248476 != nil {
		return x.refaf248476, nil
	}
	memaf248476 := allocRectLayerKHRMemory(1)
	refaf248476 := (*C.VkRectLayerKHR)(memaf248476)
	allocsaf248476 := new(cgoAllocMap)
	allocsaf248476.Add(memaf248476)

	var coffset_allocs *cgoAllocMap
	refaf248476.offset, coffset_allocs = x.Offset.PassValue()
	allocsaf248476.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	refaf248476.extent, cextent_allocs = x.Extent.PassValue()
	allocsaf248476.Borrow(cextent_allocs)

	var clayer_allocs *cgoAllocMap
	refaf248476.layer, clayer_allocs = (C.uint32_t)(x.Layer), cgoAllocsUnknown
	allocsaf248476.Borrow(clayer_allocs)

	x.refaf248476 = refaf248476
	x.allocsaf248476 = allocsaf248476
	return refaf248476, allocsaf248476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RectLayerKHR) PassValue() (C.VkRectLayerKHR, *cgoAllocMap) {
	if x.refaf248476 != nil {
		return *x.refaf248476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RectLayerKHR) Deref() {
	if x.refaf248476 == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.refaf248476.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.refaf248476.extent))
	x.Layer = (uint32)(x.refaf248476.layer)
}

// allocPresentRegionKHRMemory allocates memory for type C.VkPresentRegionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentRegionKHRValue = unsafe.Sizeof([1]C.VkPresentRegionKHR{})

// unpackSRectLayerKHR transforms a sliced Go data structure into plain C format.
func unpackSRectLayerKHR(x []RectLayerKHR) (unpacked *C.VkRectLayerKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRectLayerKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectLayerKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRectLayerKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRectLayerKHR)(h.Data)
	return
}

// packSRectLayerKHR reads sliced Go data structure out from plain C format.
func packSRectLayerKHR(v []RectLayerKHR, ptr0 *C.VkRectLayerKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectLayerKHRValue]C.VkRectLayerKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectLayerKHRRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegionKHR) Ref() *C.VkPresentRegionKHR {
	if x == nil {
		return nil
	}
	return x.refbbc0d1b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegionKHR) Free() {
	if x != nil && x.allocsbbc0d1b9 != nil {
		x.allocsbbc0d1b9.(*cgoAllocMap).Free()
		x.refbbc0d1b9 = nil
	}
}

// NewPresentRegionKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionKHRRef(ref unsafe.Pointer) *PresentRegionKHR {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegionKHR)
	obj.refbbc0d1b9 = (*C.VkPresentRegionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegionKHR) PassRef() (*C.VkPresentRegionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbc0d1b9 != nil {
		return x.refbbc0d1b9, nil
	}
	membbc0d1b9 := allocPresentRegionKHRMemory(1)
	refbbc0d1b9 := (*C.VkPresentRegionKHR)(membbc0d1b9)
	allocsbbc0d1b9 := new(cgoAllocMap)
	allocsbbc0d1b9.Add(membbc0d1b9)

	var crectangleCount_allocs *cgoAllocMap
	refbbc0d1b9.rectangleCount, crectangleCount_allocs = (C.uint32_t)(x.RectangleCount), cgoAllocsUnknown
	allocsbbc0d1b9.Borrow(crectangleCount_allocs)

	var cpRectangles_allocs *cgoAllocMap
	refbbc0d1b9.pRectangles, cpRectangles_allocs = unpackSRectLayerKHR(x.PRectangles)
	allocsbbc0d1b9.Borrow(cpRectangles_allocs)

	x.refbbc0d1b9 = refbbc0d1b9
	x.allocsbbc0d1b9 = allocsbbc0d1b9
	return refbbc0d1b9, allocsbbc0d1b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegionKHR) PassValue() (C.VkPresentRegionKHR, *cgoAllocMap) {
	if x.refbbc0d1b9 != nil {
		return *x.refbbc0d1b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegionKHR) Deref() {
	if x.refbbc0d1b9 == nil {
		return
	}
	x.RectangleCount = (uint32)(x.refbbc0d1b9.rectangleCount)
	packSRectLayerKHR(x.PRectangles, x.refbbc0d1b9.pRectangles)
}

// allocPresentRegionsKHRMemory allocates memory for type C.VkPresentRegionsKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionsKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionsKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentRegionsKHRValue = unsafe.Sizeof([1]C.VkPresentRegionsKHR{})

// unpackSPresentRegionKHR transforms a sliced Go data structure into plain C format.
func unpackSPresentRegionKHR(x []PresentRegionKHR) (unpacked *C.VkPresentRegionKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPresentRegionKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPresentRegionKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentRegionKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentRegionKHR)(h.Data)
	return
}

// packSPresentRegionKHR reads sliced Go data structure out from plain C format.
func packSPresentRegionKHR(v []PresentRegionKHR, ptr0 *C.VkPresentRegionKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentRegionKHRValue]C.VkPresentRegionKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentRegionKHRRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegionsKHR) Ref() *C.VkPresentRegionsKHR {
	if x == nil {
		return nil
	}
	return x.ref62958060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegionsKHR) Free() {
	if x != nil && x.allocs62958060 != nil {
		x.allocs62958060.(*cgoAllocMap).Free()
		x.ref62958060 = nil
	}
}

// NewPresentRegionsKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionsKHRRef(ref unsafe.Pointer) *PresentRegionsKHR {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegionsKHR)
	obj.ref62958060 = (*C.VkPresentRegionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegionsKHR) PassRef() (*C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref62958060 != nil {
		return x.ref62958060, nil
	}
	mem62958060 := allocPresentRegionsKHRMemory(1)
	ref62958060 := (*C.VkPresentRegionsKHR)(mem62958060)
	allocs62958060 := new(cgoAllocMap)
	allocs62958060.Add(mem62958060)

	var csType_allocs *cgoAllocMap
	ref62958060.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs62958060.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref62958060.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs62958060.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref62958060.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs62958060.Borrow(cswapchainCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref62958060.pRegions, cpRegions_allocs = unpackSPresentRegionKHR(x.PRegions)
	allocs62958060.Borrow(cpRegions_allocs)

	x.ref62958060 = ref62958060
	x.allocs62958060 = allocs62958060
	return ref62958060, allocs62958060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegionsKHR) PassValue() (C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x.ref62958060 != nil {
		return *x.ref62958060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegionsKHR) Deref() {
	if x.ref62958060 == nil {
		return
	}
	x.SType = (StructureType)(x.ref62958060.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref62958060.pNext))
	x.SwapchainCount = (uint32)(x.ref62958060.swapchainCount)
	packSPresentRegionKHR(x.PRegions, x.ref62958060.pRegions)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateEntryKHR) Ref() *C.VkDescriptorUpdateTemplateEntry {
	if x == nil {
		return nil
	}
	return x.refabf78fb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateEntryKHR) Free() {
	if x != nil && x.allocsabf78fb7 != nil {
		x.allocsabf78fb7.(*cgoAllocMap).Free()
		x.refabf78fb7 = nil
	}
}

// NewDescriptorUpdateTemplateEntryKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateEntryKHRRef(ref unsafe.Pointer) *DescriptorUpdateTemplateEntryKHR {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateEntryKHR)
	obj.refabf78fb7 = (*C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateEntryKHR) PassRef() (*C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf78fb7 != nil {
		return x.refabf78fb7, nil
	}
	memabf78fb7 := allocDescriptorUpdateTemplateEntryMemory(1)
	refabf78fb7 := (*C.VkDescriptorUpdateTemplateEntry)(memabf78fb7)
	allocsabf78fb7 := new(cgoAllocMap)
	allocsabf78fb7.Add(memabf78fb7)

	var cdstBinding_allocs *cgoAllocMap
	refabf78fb7.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	refabf78fb7.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refabf78fb7.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	refabf78fb7.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorType_allocs)

	var coffset_allocs *cgoAllocMap
	refabf78fb7.offset, coffset_allocs = (C.size_t)(x.Offset), cgoAllocsUnknown
	allocsabf78fb7.Borrow(coffset_allocs)

	var cstride_allocs *cgoAllocMap
	refabf78fb7.stride, cstride_allocs = (C.size_t)(x.Stride), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cstride_allocs)

	x.refabf78fb7 = refabf78fb7
	x.allocsabf78fb7 = allocsabf78fb7
	return refabf78fb7, allocsabf78fb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateEntryKHR) PassValue() (C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x.refabf78fb7 != nil {
		return *x.refabf78fb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateEntryKHR) Deref() {
	if x.refabf78fb7 == nil {
		return
	}
	x.DstBinding = (uint32)(x.refabf78fb7.dstBinding)
	x.DstArrayElement = (uint32)(x.refabf78fb7.dstArrayElement)
	x.DescriptorCount = (uint32)(x.refabf78fb7.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.refabf78fb7.descriptorType)
	x.Offset = (uint)(x.refabf78fb7.offset)
	x.Stride = (uint)(x.refabf78fb7.stride)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateCreateInfoKHR) Ref() *C.VkDescriptorUpdateTemplateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2af95951
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateCreateInfoKHR) Free() {
	if x != nil && x.allocs2af95951 != nil {
		x.allocs2af95951.(*cgoAllocMap).Free()
		x.ref2af95951 = nil
	}
}

// NewDescriptorUpdateTemplateCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateCreateInfoKHRRef(ref unsafe.Pointer) *DescriptorUpdateTemplateCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateCreateInfoKHR)
	obj.ref2af95951 = (*C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateCreateInfoKHR) PassRef() (*C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2af95951 != nil {
		return x.ref2af95951, nil
	}
	mem2af95951 := allocDescriptorUpdateTemplateCreateInfoMemory(1)
	ref2af95951 := (*C.VkDescriptorUpdateTemplateCreateInfo)(mem2af95951)
	allocs2af95951 := new(cgoAllocMap)
	allocs2af95951.Add(mem2af95951)

	var csType_allocs *cgoAllocMap
	ref2af95951.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2af95951.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2af95951.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2af95951.flags, cflags_allocs = (C.VkDescriptorUpdateTemplateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2af95951.Borrow(cflags_allocs)

	var cdescriptorUpdateEntryCount_allocs *cgoAllocMap
	ref2af95951.descriptorUpdateEntryCount, cdescriptorUpdateEntryCount_allocs = (C.uint32_t)(x.DescriptorUpdateEntryCount), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorUpdateEntryCount_allocs)

	var cpDescriptorUpdateEntries_allocs *cgoAllocMap
	ref2af95951.pDescriptorUpdateEntries, cpDescriptorUpdateEntries_allocs = unpackSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries)
	allocs2af95951.Borrow(cpDescriptorUpdateEntries_allocs)

	var ctemplateType_allocs *cgoAllocMap
	ref2af95951.templateType, ctemplateType_allocs = (C.VkDescriptorUpdateTemplateType)(x.TemplateType), cgoAllocsUnknown
	allocs2af95951.Borrow(ctemplateType_allocs)

	var cdescriptorSetLayout_allocs *cgoAllocMap
	ref2af95951.descriptorSetLayout, cdescriptorSetLayout_allocs = *(*C.VkDescriptorSetLayout)(unsafe.Pointer(&x.DescriptorSetLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorSetLayout_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2af95951.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineBindPoint_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref2af95951.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineLayout_allocs)

	var cset_allocs *cgoAllocMap
	ref2af95951.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs2af95951.Borrow(cset_allocs)

	x.ref2af95951 = ref2af95951
	x.allocs2af95951 = allocs2af95951
	return ref2af95951, allocs2af95951

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateCreateInfoKHR) PassValue() (C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x.ref2af95951 != nil {
		return *x.ref2af95951, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateCreateInfoKHR) Deref() {
	if x.ref2af95951 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2af95951.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2af95951.pNext))
	x.Flags = (DescriptorUpdateTemplateCreateFlags)(x.ref2af95951.flags)
	x.DescriptorUpdateEntryCount = (uint32)(x.ref2af95951.descriptorUpdateEntryCount)
	packSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries, x.ref2af95951.pDescriptorUpdateEntries)
	x.TemplateType = (DescriptorUpdateTemplateType)(x.ref2af95951.templateType)
	x.DescriptorSetLayout = *(*DescriptorSetLayout)(unsafe.Pointer(&x.ref2af95951.descriptorSetLayout))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2af95951.pipelineBindPoint)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref2af95951.pipelineLayout))
	x.Set = (uint32)(x.ref2af95951.set)
}

// allocAttachmentDescription2KHRMemory allocates memory for type C.VkAttachmentDescription2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescription2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescription2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescription2KHRValue = unsafe.Sizeof([1]C.VkAttachmentDescription2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription2KHR) Ref() *C.VkAttachmentDescription2KHR {
	if x == nil {
		return nil
	}
	return x.refe0fc3d48
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription2KHR) Free() {
	if x != nil && x.allocse0fc3d48 != nil {
		x.allocse0fc3d48.(*cgoAllocMap).Free()
		x.refe0fc3d48 = nil
	}
}

// NewAttachmentDescription2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescription2KHRRef(ref unsafe.Pointer) *AttachmentDescription2KHR {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription2KHR)
	obj.refe0fc3d48 = (*C.VkAttachmentDescription2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription2KHR) PassRef() (*C.VkAttachmentDescription2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe0fc3d48 != nil {
		return x.refe0fc3d48, nil
	}
	meme0fc3d48 := allocAttachmentDescription2KHRMemory(1)
	refe0fc3d48 := (*C.VkAttachmentDescription2KHR)(meme0fc3d48)
	allocse0fc3d48 := new(cgoAllocMap)
	allocse0fc3d48.Add(meme0fc3d48)

	var csType_allocs *cgoAllocMap
	refe0fc3d48.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse0fc3d48.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe0fc3d48.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe0fc3d48.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refe0fc3d48.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refe0fc3d48.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocse0fc3d48.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refe0fc3d48.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refe0fc3d48.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refe0fc3d48.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refe0fc3d48.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refe0fc3d48.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refe0fc3d48.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cfinalLayout_allocs)

	x.refe0fc3d48 = refe0fc3d48
	x.allocse0fc3d48 = allocse0fc3d48
	return refe0fc3d48, allocse0fc3d48

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription2KHR) PassValue() (C.VkAttachmentDescription2KHR, *cgoAllocMap) {
	if x.refe0fc3d48 != nil {
		return *x.refe0fc3d48, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription2KHR) Deref() {
	if x.refe0fc3d48 == nil {
		return
	}
	x.SType = (StructureType)(x.refe0fc3d48.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe0fc3d48.pNext))
	x.Flags = (AttachmentDescriptionFlags)(x.refe0fc3d48.flags)
	x.Format = (Format)(x.refe0fc3d48.format)
	x.Samples = (SampleCountFlagBits)(x.refe0fc3d48.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refe0fc3d48.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refe0fc3d48.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refe0fc3d48.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refe0fc3d48.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refe0fc3d48.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refe0fc3d48.finalLayout)
}

// allocAttachmentReference2KHRMemory allocates memory for type C.VkAttachmentReference2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReference2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReference2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReference2KHRValue = unsafe.Sizeof([1]C.VkAttachmentReference2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference2KHR) Ref() *C.VkAttachmentReference2KHR {
	if x == nil {
		return nil
	}
	return x.refa31684a1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference2KHR) Free() {
	if x != nil && x.allocsa31684a1 != nil {
		x.allocsa31684a1.(*cgoAllocMap).Free()
		x.refa31684a1 = nil
	}
}

// NewAttachmentReference2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReference2KHRRef(ref unsafe.Pointer) *AttachmentReference2KHR {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference2KHR)
	obj.refa31684a1 = (*C.VkAttachmentReference2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference2KHR) PassRef() (*C.VkAttachmentReference2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa31684a1 != nil {
		return x.refa31684a1, nil
	}
	mema31684a1 := allocAttachmentReference2KHRMemory(1)
	refa31684a1 := (*C.VkAttachmentReference2KHR)(mema31684a1)
	allocsa31684a1 := new(cgoAllocMap)
	allocsa31684a1.Add(mema31684a1)

	var csType_allocs *cgoAllocMap
	refa31684a1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa31684a1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa31684a1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa31684a1.Borrow(cpNext_allocs)

	var cattachment_allocs *cgoAllocMap
	refa31684a1.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsa31684a1.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refa31684a1.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsa31684a1.Borrow(clayout_allocs)

	var caspectMask_allocs *cgoAllocMap
	refa31684a1.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsa31684a1.Borrow(caspectMask_allocs)

	x.refa31684a1 = refa31684a1
	x.allocsa31684a1 = allocsa31684a1
	return refa31684a1, allocsa31684a1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference2KHR) PassValue() (C.VkAttachmentReference2KHR, *cgoAllocMap) {
	if x.refa31684a1 != nil {
		return *x.refa31684a1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference2KHR) Deref() {
	if x.refa31684a1 == nil {
		return
	}
	x.SType = (StructureType)(x.refa31684a1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa31684a1.pNext))
	x.Attachment = (uint32)(x.refa31684a1.attachment)
	x.Layout = (ImageLayout)(x.refa31684a1.layout)
	x.AspectMask = (ImageAspectFlags)(x.refa31684a1.aspectMask)
}

// allocSubpassDescription2KHRMemory allocates memory for type C.VkSubpassDescription2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescription2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescription2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescription2KHRValue = unsafe.Sizeof([1]C.VkSubpassDescription2KHR{})

// unpackSAttachmentReference2KHR transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference2KHR(x []AttachmentReference2KHR) (unpacked *C.VkAttachmentReference2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReference2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference2KHR)(h.Data)
	return
}

// packSAttachmentReference2KHR reads sliced Go data structure out from plain C format.
func packSAttachmentReference2KHR(v []AttachmentReference2KHR, ptr0 *C.VkAttachmentReference2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReference2KHRValue]C.VkAttachmentReference2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReference2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription2KHR) Ref() *C.VkSubpassDescription2KHR {
	if x == nil {
		return nil
	}
	return x.ref89a293f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription2KHR) Free() {
	if x != nil && x.allocs89a293f3 != nil {
		x.allocs89a293f3.(*cgoAllocMap).Free()
		x.ref89a293f3 = nil
	}
}

// NewSubpassDescription2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescription2KHRRef(ref unsafe.Pointer) *SubpassDescription2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription2KHR)
	obj.ref89a293f3 = (*C.VkSubpassDescription2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription2KHR) PassRef() (*C.VkSubpassDescription2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89a293f3 != nil {
		return x.ref89a293f3, nil
	}
	mem89a293f3 := allocSubpassDescription2KHRMemory(1)
	ref89a293f3 := (*C.VkSubpassDescription2KHR)(mem89a293f3)
	allocs89a293f3 := new(cgoAllocMap)
	allocs89a293f3.Add(mem89a293f3)

	var csType_allocs *cgoAllocMap
	ref89a293f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs89a293f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref89a293f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref89a293f3.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocs89a293f3.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref89a293f3.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpipelineBindPoint_allocs)

	var cviewMask_allocs *cgoAllocMap
	ref89a293f3.viewMask, cviewMask_allocs = (C.uint32_t)(x.ViewMask), cgoAllocsUnknown
	allocs89a293f3.Borrow(cviewMask_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	ref89a293f3.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference2KHR(x.PInputAttachments)
	allocs89a293f3.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	ref89a293f3.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference2KHR(x.PColorAttachments)
	allocs89a293f3.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	ref89a293f3.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference2KHR(x.PResolveAttachments)
	allocs89a293f3.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	ref89a293f3.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference2KHR(x.PDepthStencilAttachment)
	allocs89a293f3.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	ref89a293f3.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpPreserveAttachments_allocs)

	x.ref89a293f3 = ref89a293f3
	x.allocs89a293f3 = allocs89a293f3
	return ref89a293f3, allocs89a293f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription2KHR) PassValue() (C.VkSubpassDescription2KHR, *cgoAllocMap) {
	if x.ref89a293f3 != nil {
		return *x.ref89a293f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription2KHR) Deref() {
	if x.ref89a293f3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref89a293f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref89a293f3.pNext))
	x.Flags = (SubpassDescriptionFlags)(x.ref89a293f3.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref89a293f3.pipelineBindPoint)
	x.ViewMask = (uint32)(x.ref89a293f3.viewMask)
	x.InputAttachmentCount = (uint32)(x.ref89a293f3.inputAttachmentCount)
	packSAttachmentReference2KHR(x.PInputAttachments, x.ref89a293f3.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.ref89a293f3.colorAttachmentCount)
	packSAttachmentReference2KHR(x.PColorAttachments, x.ref89a293f3.pColorAttachments)
	packSAttachmentReference2KHR(x.PResolveAttachments, x.ref89a293f3.pResolveAttachments)
	packSAttachmentReference2KHR(x.PDepthStencilAttachment, x.ref89a293f3.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.ref89a293f3.preserveAttachmentCount)
	hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxfa835e7.Data = unsafe.Pointer(x.ref89a293f3.pPreserveAttachments)
	hxfa835e7.Cap = 0x7fffffff
	// hxfa835e7.Len = ?

}

// allocSubpassDependency2KHRMemory allocates memory for type C.VkSubpassDependency2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependency2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependency2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependency2KHRValue = unsafe.Sizeof([1]C.VkSubpassDependency2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency2KHR) Ref() *C.VkSubpassDependency2KHR {
	if x == nil {
		return nil
	}
	return x.ref985e0998
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency2KHR) Free() {
	if x != nil && x.allocs985e0998 != nil {
		x.allocs985e0998.(*cgoAllocMap).Free()
		x.ref985e0998 = nil
	}
}

// NewSubpassDependency2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependency2KHRRef(ref unsafe.Pointer) *SubpassDependency2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency2KHR)
	obj.ref985e0998 = (*C.VkSubpassDependency2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency2KHR) PassRef() (*C.VkSubpassDependency2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref985e0998 != nil {
		return x.ref985e0998, nil
	}
	mem985e0998 := allocSubpassDependency2KHRMemory(1)
	ref985e0998 := (*C.VkSubpassDependency2KHR)(mem985e0998)
	allocs985e0998 := new(cgoAllocMap)
	allocs985e0998.Add(mem985e0998)

	var csType_allocs *cgoAllocMap
	ref985e0998.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs985e0998.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref985e0998.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs985e0998.Borrow(cpNext_allocs)

	var csrcSubpass_allocs *cgoAllocMap
	ref985e0998.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	ref985e0998.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	ref985e0998.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	ref985e0998.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref985e0998.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref985e0998.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	ref985e0998.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocs985e0998.Borrow(cdependencyFlags_allocs)

	var cviewOffset_allocs *cgoAllocMap
	ref985e0998.viewOffset, cviewOffset_allocs = (C.int32_t)(x.ViewOffset), cgoAllocsUnknown
	allocs985e0998.Borrow(cviewOffset_allocs)

	x.ref985e0998 = ref985e0998
	x.allocs985e0998 = allocs985e0998
	return ref985e0998, allocs985e0998

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency2KHR) PassValue() (C.VkSubpassDependency2KHR, *cgoAllocMap) {
	if x.ref985e0998 != nil {
		return *x.ref985e0998, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency2KHR) Deref() {
	if x.ref985e0998 == nil {
		return
	}
	x.SType = (StructureType)(x.ref985e0998.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref985e0998.pNext))
	x.SrcSubpass = (uint32)(x.ref985e0998.srcSubpass)
	x.DstSubpass = (uint32)(x.ref985e0998.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.ref985e0998.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.ref985e0998.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.ref985e0998.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref985e0998.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.ref985e0998.dependencyFlags)
	x.ViewOffset = (int32)(x.ref985e0998.viewOffset)
}

// allocRenderPassCreateInfo2KHRMemory allocates memory for type C.VkRenderPassCreateInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfo2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfo2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfo2KHRValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo2KHR{})

// unpackSAttachmentDescription2KHR transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription2KHR(x []AttachmentDescription2KHR) (unpacked *C.VkAttachmentDescription2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescription2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription2KHR)(h.Data)
	return
}

// unpackSSubpassDescription2KHR transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription2KHR(x []SubpassDescription2KHR) (unpacked *C.VkSubpassDescription2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescription2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription2KHR)(h.Data)
	return
}

// unpackSSubpassDependency2KHR transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency2KHR(x []SubpassDependency2KHR) (unpacked *C.VkSubpassDependency2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependency2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency2KHR)(h.Data)
	return
}

// packSAttachmentDescription2KHR reads sliced Go data structure out from plain C format.
func packSAttachmentDescription2KHR(v []AttachmentDescription2KHR, ptr0 *C.VkAttachmentDescription2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescription2KHRValue]C.VkAttachmentDescription2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescription2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription2KHR reads sliced Go data structure out from plain C format.
func packSSubpassDescription2KHR(v []SubpassDescription2KHR, ptr0 *C.VkSubpassDescription2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescription2KHRValue]C.VkSubpassDescription2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescription2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency2KHR reads sliced Go data structure out from plain C format.
func packSSubpassDependency2KHR(v []SubpassDependency2KHR, ptr0 *C.VkSubpassDependency2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependency2KHRValue]C.VkSubpassDependency2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependency2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo2KHR) Ref() *C.VkRenderPassCreateInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref1d4774de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo2KHR) Free() {
	if x != nil && x.allocs1d4774de != nil {
		x.allocs1d4774de.(*cgoAllocMap).Free()
		x.ref1d4774de = nil
	}
}

// NewRenderPassCreateInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfo2KHRRef(ref unsafe.Pointer) *RenderPassCreateInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo2KHR)
	obj.ref1d4774de = (*C.VkRenderPassCreateInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo2KHR) PassRef() (*C.VkRenderPassCreateInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d4774de != nil {
		return x.ref1d4774de, nil
	}
	mem1d4774de := allocRenderPassCreateInfo2KHRMemory(1)
	ref1d4774de := (*C.VkRenderPassCreateInfo2KHR)(mem1d4774de)
	allocs1d4774de := new(cgoAllocMap)
	allocs1d4774de.Add(mem1d4774de)

	var csType_allocs *cgoAllocMap
	ref1d4774de.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d4774de.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d4774de.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d4774de.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref1d4774de.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs1d4774de.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref1d4774de.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref1d4774de.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription2KHR(x.PAttachments)
	allocs1d4774de.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref1d4774de.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref1d4774de.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription2KHR(x.PSubpasses)
	allocs1d4774de.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref1d4774de.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref1d4774de.pDependencies, cpDependencies_allocs = unpackSSubpassDependency2KHR(x.PDependencies)
	allocs1d4774de.Borrow(cpDependencies_allocs)

	var ccorrelatedViewMaskCount_allocs *cgoAllocMap
	ref1d4774de.correlatedViewMaskCount, ccorrelatedViewMaskCount_allocs = (C.uint32_t)(x.CorrelatedViewMaskCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(ccorrelatedViewMaskCount_allocs)

	var cpCorrelatedViewMasks_allocs *cgoAllocMap
	ref1d4774de.pCorrelatedViewMasks, cpCorrelatedViewMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks)).Data)), cgoAllocsUnknown
	allocs1d4774de.Borrow(cpCorrelatedViewMasks_allocs)

	x.ref1d4774de = ref1d4774de
	x.allocs1d4774de = allocs1d4774de
	return ref1d4774de, allocs1d4774de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo2KHR) PassValue() (C.VkRenderPassCreateInfo2KHR, *cgoAllocMap) {
	if x.ref1d4774de != nil {
		return *x.ref1d4774de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo2KHR) Deref() {
	if x.ref1d4774de == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d4774de.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d4774de.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref1d4774de.flags)
	x.AttachmentCount = (uint32)(x.ref1d4774de.attachmentCount)
	packSAttachmentDescription2KHR(x.PAttachments, x.ref1d4774de.pAttachments)
	x.SubpassCount = (uint32)(x.ref1d4774de.subpassCount)
	packSSubpassDescription2KHR(x.PSubpasses, x.ref1d4774de.pSubpasses)
	x.DependencyCount = (uint32)(x.ref1d4774de.dependencyCount)
	packSSubpassDependency2KHR(x.PDependencies, x.ref1d4774de.pDependencies)
	x.CorrelatedViewMaskCount = (uint32)(x.ref1d4774de.correlatedViewMaskCount)
	hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks))
	hxf8eae10.Data = unsafe.Pointer(x.ref1d4774de.pCorrelatedViewMasks)
	hxf8eae10.Cap = 0x7fffffff
	// hxf8eae10.Len = ?

}

// allocSubpassBeginInfoKHRMemory allocates memory for type C.VkSubpassBeginInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassBeginInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassBeginInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassBeginInfoKHRValue = unsafe.Sizeof([1]C.VkSubpassBeginInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassBeginInfoKHR) Ref() *C.VkSubpassBeginInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref7b9f19b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassBeginInfoKHR) Free() {
	if x != nil && x.allocs7b9f19b8 != nil {
		x.allocs7b9f19b8.(*cgoAllocMap).Free()
		x.ref7b9f19b8 = nil
	}
}

// NewSubpassBeginInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassBeginInfoKHRRef(ref unsafe.Pointer) *SubpassBeginInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SubpassBeginInfoKHR)
	obj.ref7b9f19b8 = (*C.VkSubpassBeginInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassBeginInfoKHR) PassRef() (*C.VkSubpassBeginInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b9f19b8 != nil {
		return x.ref7b9f19b8, nil
	}
	mem7b9f19b8 := allocSubpassBeginInfoKHRMemory(1)
	ref7b9f19b8 := (*C.VkSubpassBeginInfoKHR)(mem7b9f19b8)
	allocs7b9f19b8 := new(cgoAllocMap)
	allocs7b9f19b8.Add(mem7b9f19b8)

	var csType_allocs *cgoAllocMap
	ref7b9f19b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7b9f19b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(cpNext_allocs)

	var ccontents_allocs *cgoAllocMap
	ref7b9f19b8.contents, ccontents_allocs = (C.VkSubpassContents)(x.Contents), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(ccontents_allocs)

	x.ref7b9f19b8 = ref7b9f19b8
	x.allocs7b9f19b8 = allocs7b9f19b8
	return ref7b9f19b8, allocs7b9f19b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassBeginInfoKHR) PassValue() (C.VkSubpassBeginInfoKHR, *cgoAllocMap) {
	if x.ref7b9f19b8 != nil {
		return *x.ref7b9f19b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassBeginInfoKHR) Deref() {
	if x.ref7b9f19b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7b9f19b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7b9f19b8.pNext))
	x.Contents = (SubpassContents)(x.ref7b9f19b8.contents)
}

// allocSubpassEndInfoKHRMemory allocates memory for type C.VkSubpassEndInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassEndInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassEndInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassEndInfoKHRValue = unsafe.Sizeof([1]C.VkSubpassEndInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassEndInfoKHR) Ref() *C.VkSubpassEndInfoKHR {
	if x == nil {
		return nil
	}
	return x.refb755d027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassEndInfoKHR) Free() {
	if x != nil && x.allocsb755d027 != nil {
		x.allocsb755d027.(*cgoAllocMap).Free()
		x.refb755d027 = nil
	}
}

// NewSubpassEndInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassEndInfoKHRRef(ref unsafe.Pointer) *SubpassEndInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SubpassEndInfoKHR)
	obj.refb755d027 = (*C.VkSubpassEndInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassEndInfoKHR) PassRef() (*C.VkSubpassEndInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb755d027 != nil {
		return x.refb755d027, nil
	}
	memb755d027 := allocSubpassEndInfoKHRMemory(1)
	refb755d027 := (*C.VkSubpassEndInfoKHR)(memb755d027)
	allocsb755d027 := new(cgoAllocMap)
	allocsb755d027.Add(memb755d027)

	var csType_allocs *cgoAllocMap
	refb755d027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb755d027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb755d027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb755d027.Borrow(cpNext_allocs)

	x.refb755d027 = refb755d027
	x.allocsb755d027 = allocsb755d027
	return refb755d027, allocsb755d027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassEndInfoKHR) PassValue() (C.VkSubpassEndInfoKHR, *cgoAllocMap) {
	if x.refb755d027 != nil {
		return *x.refb755d027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassEndInfoKHR) Deref() {
	if x.refb755d027 == nil {
		return
	}
	x.SType = (StructureType)(x.refb755d027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb755d027.pNext))
}

// allocSharedPresentSurfaceCapabilitiesKHRMemory allocates memory for type C.VkSharedPresentSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSharedPresentSurfaceCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSharedPresentSurfaceCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSharedPresentSurfaceCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkSharedPresentSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SharedPresentSurfaceCapabilitiesKHR) Ref() *C.VkSharedPresentSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref3f98a814
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SharedPresentSurfaceCapabilitiesKHR) Free() {
	if x != nil && x.allocs3f98a814 != nil {
		x.allocs3f98a814.(*cgoAllocMap).Free()
		x.ref3f98a814 = nil
	}
}

// NewSharedPresentSurfaceCapabilitiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSharedPresentSurfaceCapabilitiesKHRRef(ref unsafe.Pointer) *SharedPresentSurfaceCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(SharedPresentSurfaceCapabilitiesKHR)
	obj.ref3f98a814 = (*C.VkSharedPresentSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SharedPresentSurfaceCapabilitiesKHR) PassRef() (*C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3f98a814 != nil {
		return x.ref3f98a814, nil
	}
	mem3f98a814 := allocSharedPresentSurfaceCapabilitiesKHRMemory(1)
	ref3f98a814 := (*C.VkSharedPresentSurfaceCapabilitiesKHR)(mem3f98a814)
	allocs3f98a814 := new(cgoAllocMap)
	allocs3f98a814.Add(mem3f98a814)

	var csType_allocs *cgoAllocMap
	ref3f98a814.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3f98a814.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3f98a814.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3f98a814.Borrow(cpNext_allocs)

	var csharedPresentSupportedUsageFlags_allocs *cgoAllocMap
	ref3f98a814.sharedPresentSupportedUsageFlags, csharedPresentSupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SharedPresentSupportedUsageFlags), cgoAllocsUnknown
	allocs3f98a814.Borrow(csharedPresentSupportedUsageFlags_allocs)

	x.ref3f98a814 = ref3f98a814
	x.allocs3f98a814 = allocs3f98a814
	return ref3f98a814, allocs3f98a814

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SharedPresentSurfaceCapabilitiesKHR) PassValue() (C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref3f98a814 != nil {
		return *x.ref3f98a814, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SharedPresentSurfaceCapabilitiesKHR) Deref() {
	if x.ref3f98a814 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3f98a814.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3f98a814.pNext))
	x.SharedPresentSupportedUsageFlags = (ImageUsageFlags)(x.ref3f98a814.sharedPresentSupportedUsageFlags)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalFenceInfoKHR) Ref() *C.VkPhysicalDeviceExternalFenceInfo {
	if x == nil {
		return nil
	}
	return x.ref9bb660cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalFenceInfoKHR) Free() {
	if x != nil && x.allocs9bb660cc != nil {
		x.allocs9bb660cc.(*cgoAllocMap).Free()
		x.ref9bb660cc = nil
	}
}

// NewPhysicalDeviceExternalFenceInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalFenceInfoKHRRef(ref unsafe.Pointer) *PhysicalDeviceExternalFenceInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalFenceInfoKHR)
	obj.ref9bb660cc = (*C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalFenceInfoKHR) PassRef() (*C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb660cc != nil {
		return x.ref9bb660cc, nil
	}
	mem9bb660cc := allocPhysicalDeviceExternalFenceInfoMemory(1)
	ref9bb660cc := (*C.VkPhysicalDeviceExternalFenceInfo)(mem9bb660cc)
	allocs9bb660cc := new(cgoAllocMap)
	allocs9bb660cc.Add(mem9bb660cc)

	var csType_allocs *cgoAllocMap
	ref9bb660cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9bb660cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9bb660cc.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref9bb660cc.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(chandleType_allocs)

	x.ref9bb660cc = ref9bb660cc
	x.allocs9bb660cc = allocs9bb660cc
	return ref9bb660cc, allocs9bb660cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalFenceInfoKHR) PassValue() (C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x.ref9bb660cc != nil {
		return *x.ref9bb660cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalFenceInfoKHR) Deref() {
	if x.ref9bb660cc == nil {
		return
	}
	x.SType = (StructureType)(x.ref9bb660cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9bb660cc.pNext))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref9bb660cc.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalFencePropertiesKHR) Ref() *C.VkExternalFenceProperties {
	if x == nil {
		return nil
	}
	return x.ref18806773
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalFencePropertiesKHR) Free() {
	if x != nil && x.allocs18806773 != nil {
		x.allocs18806773.(*cgoAllocMap).Free()
		x.ref18806773 = nil
	}
}

// NewExternalFencePropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalFencePropertiesKHRRef(ref unsafe.Pointer) *ExternalFencePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExternalFencePropertiesKHR)
	obj.ref18806773 = (*C.VkExternalFenceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalFencePropertiesKHR) PassRef() (*C.VkExternalFenceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18806773 != nil {
		return x.ref18806773, nil
	}
	mem18806773 := allocExternalFencePropertiesMemory(1)
	ref18806773 := (*C.VkExternalFenceProperties)(mem18806773)
	allocs18806773 := new(cgoAllocMap)
	allocs18806773.Add(mem18806773)

	var csType_allocs *cgoAllocMap
	ref18806773.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18806773.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18806773.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18806773.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref18806773.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref18806773.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalFenceFeatures_allocs *cgoAllocMap
	ref18806773.externalFenceFeatures, cexternalFenceFeatures_allocs = (C.VkExternalFenceFeatureFlags)(x.ExternalFenceFeatures), cgoAllocsUnknown
	allocs18806773.Borrow(cexternalFenceFeatures_allocs)

	x.ref18806773 = ref18806773
	x.allocs18806773 = allocs18806773
	return ref18806773, allocs18806773

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalFencePropertiesKHR) PassValue() (C.VkExternalFenceProperties, *cgoAllocMap) {
	if x.ref18806773 != nil {
		return *x.ref18806773, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalFencePropertiesKHR) Deref() {
	if x.ref18806773 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18806773.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18806773.pNext))
	x.ExportFromImportedHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.compatibleHandleTypes)
	x.ExternalFenceFeatures = (ExternalFenceFeatureFlags)(x.ref18806773.externalFenceFeatures)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportFenceCreateInfoKHR) Ref() *C.VkExportFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fef8c3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportFenceCreateInfoKHR) Free() {
	if x != nil && x.allocs5fef8c3a != nil {
		x.allocs5fef8c3a.(*cgoAllocMap).Free()
		x.ref5fef8c3a = nil
	}
}

// NewExportFenceCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportFenceCreateInfoKHRRef(ref unsafe.Pointer) *ExportFenceCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ExportFenceCreateInfoKHR)
	obj.ref5fef8c3a = (*C.VkExportFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportFenceCreateInfoKHR) PassRef() (*C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fef8c3a != nil {
		return x.ref5fef8c3a, nil
	}
	mem5fef8c3a := allocExportFenceCreateInfoMemory(1)
	ref5fef8c3a := (*C.VkExportFenceCreateInfo)(mem5fef8c3a)
	allocs5fef8c3a := new(cgoAllocMap)
	allocs5fef8c3a.Add(mem5fef8c3a)

	var csType_allocs *cgoAllocMap
	ref5fef8c3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fef8c3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5fef8c3a.handleTypes, chandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(chandleTypes_allocs)

	x.ref5fef8c3a = ref5fef8c3a
	x.allocs5fef8c3a = allocs5fef8c3a
	return ref5fef8c3a, allocs5fef8c3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportFenceCreateInfoKHR) PassValue() (C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x.ref5fef8c3a != nil {
		return *x.ref5fef8c3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportFenceCreateInfoKHR) Deref() {
	if x.ref5fef8c3a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fef8c3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fef8c3a.pNext))
	x.HandleTypes = (ExternalFenceHandleTypeFlags)(x.ref5fef8c3a.handleTypes)
}

// allocImportFenceFdInfoKHRMemory allocates memory for type C.VkImportFenceFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportFenceFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportFenceFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportFenceFdInfoKHRValue = unsafe.Sizeof([1]C.VkImportFenceFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportFenceFdInfoKHR) Ref() *C.VkImportFenceFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref86ebd28c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportFenceFdInfoKHR) Free() {
	if x != nil && x.allocs86ebd28c != nil {
		x.allocs86ebd28c.(*cgoAllocMap).Free()
		x.ref86ebd28c = nil
	}
}

// NewImportFenceFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportFenceFdInfoKHRRef(ref unsafe.Pointer) *ImportFenceFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImportFenceFdInfoKHR)
	obj.ref86ebd28c = (*C.VkImportFenceFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportFenceFdInfoKHR) PassRef() (*C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86ebd28c != nil {
		return x.ref86ebd28c, nil
	}
	mem86ebd28c := allocImportFenceFdInfoKHRMemory(1)
	ref86ebd28c := (*C.VkImportFenceFdInfoKHR)(mem86ebd28c)
	allocs86ebd28c := new(cgoAllocMap)
	allocs86ebd28c.Add(mem86ebd28c)

	var csType_allocs *cgoAllocMap
	ref86ebd28c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86ebd28c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	ref86ebd28c.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfence_allocs)

	var cflags_allocs *cgoAllocMap
	ref86ebd28c.flags, cflags_allocs = (C.VkFenceImportFlags)(x.Flags), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	ref86ebd28c.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref86ebd28c.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfd_allocs)

	x.ref86ebd28c = ref86ebd28c
	x.allocs86ebd28c = allocs86ebd28c
	return ref86ebd28c, allocs86ebd28c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportFenceFdInfoKHR) PassValue() (C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x.ref86ebd28c != nil {
		return *x.ref86ebd28c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportFenceFdInfoKHR) Deref() {
	if x.ref86ebd28c == nil {
		return
	}
	x.SType = (StructureType)(x.ref86ebd28c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86ebd28c.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref86ebd28c.fence))
	x.Flags = (FenceImportFlags)(x.ref86ebd28c.flags)
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref86ebd28c.handleType)
	x.Fd = (int32)(x.ref86ebd28c.fd)
}

// allocFenceGetFdInfoKHRMemory allocates memory for type C.VkFenceGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceGetFdInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceGetFdInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceGetFdInfoKHRValue = unsafe.Sizeof([1]C.VkFenceGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceGetFdInfoKHR) Ref() *C.VkFenceGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refc2668bc3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceGetFdInfoKHR) Free() {
	if x != nil && x.allocsc2668bc3 != nil {
		x.allocsc2668bc3.(*cgoAllocMap).Free()
		x.refc2668bc3 = nil
	}
}

// NewFenceGetFdInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceGetFdInfoKHRRef(ref unsafe.Pointer) *FenceGetFdInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(FenceGetFdInfoKHR)
	obj.refc2668bc3 = (*C.VkFenceGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceGetFdInfoKHR) PassRef() (*C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2668bc3 != nil {
		return x.refc2668bc3, nil
	}
	memc2668bc3 := allocFenceGetFdInfoKHRMemory(1)
	refc2668bc3 := (*C.VkFenceGetFdInfoKHR)(memc2668bc3)
	allocsc2668bc3 := new(cgoAllocMap)
	allocsc2668bc3.Add(memc2668bc3)

	var csType_allocs *cgoAllocMap
	refc2668bc3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc2668bc3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	refc2668bc3.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cfence_allocs)

	var chandleType_allocs *cgoAllocMap
	refc2668bc3.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(chandleType_allocs)

	x.refc2668bc3 = refc2668bc3
	x.allocsc2668bc3 = allocsc2668bc3
	return refc2668bc3, allocsc2668bc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceGetFdInfoKHR) PassValue() (C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x.refc2668bc3 != nil {
		return *x.refc2668bc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceGetFdInfoKHR) Deref() {
	if x.refc2668bc3 == nil {
		return
	}
	x.SType = (StructureType)(x.refc2668bc3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc2668bc3.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.refc2668bc3.fence))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.refc2668bc3.handleType)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePointClippingPropertiesKHR) Ref() *C.VkPhysicalDevicePointClippingProperties {
	if x == nil {
		return nil
	}
	return x.ref5afbd22f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePointClippingPropertiesKHR) Free() {
	if x != nil && x.allocs5afbd22f != nil {
		x.allocs5afbd22f.(*cgoAllocMap).Free()
		x.ref5afbd22f = nil
	}
}

// NewPhysicalDevicePointClippingPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePointClippingPropertiesKHRRef(ref unsafe.Pointer) *PhysicalDevicePointClippingPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePointClippingPropertiesKHR)
	obj.ref5afbd22f = (*C.VkPhysicalDevicePointClippingProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePointClippingPropertiesKHR) PassRef() (*C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5afbd22f != nil {
		return x.ref5afbd22f, nil
	}
	mem5afbd22f := allocPhysicalDevicePointClippingPropertiesMemory(1)
	ref5afbd22f := (*C.VkPhysicalDevicePointClippingProperties)(mem5afbd22f)
	allocs5afbd22f := new(cgoAllocMap)
	allocs5afbd22f.Add(mem5afbd22f)

	var csType_allocs *cgoAllocMap
	ref5afbd22f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5afbd22f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5afbd22f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpNext_allocs)

	var cpointClippingBehavior_allocs *cgoAllocMap
	ref5afbd22f.pointClippingBehavior, cpointClippingBehavior_allocs = (C.VkPointClippingBehavior)(x.PointClippingBehavior), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpointClippingBehavior_allocs)

	x.ref5afbd22f = ref5afbd22f
	x.allocs5afbd22f = allocs5afbd22f
	return ref5afbd22f, allocs5afbd22f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePointClippingPropertiesKHR) PassValue() (C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x.ref5afbd22f != nil {
		return *x.ref5afbd22f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePointClippingPropertiesKHR) Deref() {
	if x.ref5afbd22f == nil {
		return
	}
	x.SType = (StructureType)(x.ref5afbd22f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5afbd22f.pNext))
	x.PointClippingBehavior = (PointClippingBehavior)(x.ref5afbd22f.pointClippingBehavior)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassInputAttachmentAspectCreateInfoKHR) Ref() *C.VkRenderPassInputAttachmentAspectCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref34eaa5c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfoKHR) Free() {
	if x != nil && x.allocs34eaa5c7 != nil {
		x.allocs34eaa5c7.(*cgoAllocMap).Free()
		x.ref34eaa5c7 = nil
	}
}

// NewRenderPassInputAttachmentAspectCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassInputAttachmentAspectCreateInfoKHRRef(ref unsafe.Pointer) *RenderPassInputAttachmentAspectCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassInputAttachmentAspectCreateInfoKHR)
	obj.ref34eaa5c7 = (*C.VkRenderPassInputAttachmentAspectCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfoKHR) PassRef() (*C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34eaa5c7 != nil {
		return x.ref34eaa5c7, nil
	}
	mem34eaa5c7 := allocRenderPassInputAttachmentAspectCreateInfoMemory(1)
	ref34eaa5c7 := (*C.VkRenderPassInputAttachmentAspectCreateInfo)(mem34eaa5c7)
	allocs34eaa5c7 := new(cgoAllocMap)
	allocs34eaa5c7.Add(mem34eaa5c7)

	var csType_allocs *cgoAllocMap
	ref34eaa5c7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref34eaa5c7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(cpNext_allocs)

	var caspectReferenceCount_allocs *cgoAllocMap
	ref34eaa5c7.aspectReferenceCount, caspectReferenceCount_allocs = (C.uint32_t)(x.AspectReferenceCount), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(caspectReferenceCount_allocs)

	var cpAspectReferences_allocs *cgoAllocMap
	ref34eaa5c7.pAspectReferences, cpAspectReferences_allocs = unpackSInputAttachmentAspectReference(x.PAspectReferences)
	allocs34eaa5c7.Borrow(cpAspectReferences_allocs)

	x.ref34eaa5c7 = ref34eaa5c7
	x.allocs34eaa5c7 = allocs34eaa5c7
	return ref34eaa5c7, allocs34eaa5c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfoKHR) PassValue() (C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x.ref34eaa5c7 != nil {
		return *x.ref34eaa5c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassInputAttachmentAspectCreateInfoKHR) Deref() {
	if x.ref34eaa5c7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34eaa5c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34eaa5c7.pNext))
	x.AspectReferenceCount = (uint32)(x.ref34eaa5c7.aspectReferenceCount)
	packSInputAttachmentAspectReference(x.PAspectReferences, x.ref34eaa5c7.pAspectReferences)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InputAttachmentAspectReferenceKHR) Ref() *C.VkInputAttachmentAspectReference {
	if x == nil {
		return nil
	}
	return x.ref4f7194e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InputAttachmentAspectReferenceKHR) Free() {
	if x != nil && x.allocs4f7194e6 != nil {
		x.allocs4f7194e6.(*cgoAllocMap).Free()
		x.ref4f7194e6 = nil
	}
}

// NewInputAttachmentAspectReferenceKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInputAttachmentAspectReferenceKHRRef(ref unsafe.Pointer) *InputAttachmentAspectReferenceKHR {
	if ref == nil {
		return nil
	}
	obj := new(InputAttachmentAspectReferenceKHR)
	obj.ref4f7194e6 = (*C.VkInputAttachmentAspectReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InputAttachmentAspectReferenceKHR) PassRef() (*C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f7194e6 != nil {
		return x.ref4f7194e6, nil
	}
	mem4f7194e6 := allocInputAttachmentAspectReferenceMemory(1)
	ref4f7194e6 := (*C.VkInputAttachmentAspectReference)(mem4f7194e6)
	allocs4f7194e6 := new(cgoAllocMap)
	allocs4f7194e6.Add(mem4f7194e6)

	var csubpass_allocs *cgoAllocMap
	ref4f7194e6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs4f7194e6.Borrow(csubpass_allocs)

	var cinputAttachmentIndex_allocs *cgoAllocMap
	ref4f7194e6.inputAttachmentIndex, cinputAttachmentIndex_allocs = (C.uint32_t)(x.InputAttachmentIndex), cgoAllocsUnknown
	allocs4f7194e6.Borrow(cinputAttachmentIndex_allocs)

	var caspectMask_allocs *cgoAllocMap
	ref4f7194e6.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs4f7194e6.Borrow(caspectMask_allocs)

	x.ref4f7194e6 = ref4f7194e6
	x.allocs4f7194e6 = allocs4f7194e6
	return ref4f7194e6, allocs4f7194e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InputAttachmentAspectReferenceKHR) PassValue() (C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x.ref4f7194e6 != nil {
		return *x.ref4f7194e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InputAttachmentAspectReferenceKHR) Deref() {
	if x.ref4f7194e6 == nil {
		return
	}
	x.Subpass = (uint32)(x.ref4f7194e6.subpass)
	x.InputAttachmentIndex = (uint32)(x.ref4f7194e6.inputAttachmentIndex)
	x.AspectMask = (ImageAspectFlags)(x.ref4f7194e6.aspectMask)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewUsageCreateInfoKHR) Ref() *C.VkImageViewUsageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref3791cec9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewUsageCreateInfoKHR) Free() {
	if x != nil && x.allocs3791cec9 != nil {
		x.allocs3791cec9.(*cgoAllocMap).Free()
		x.ref3791cec9 = nil
	}
}

// NewImageViewUsageCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewUsageCreateInfoKHRRef(ref unsafe.Pointer) *ImageViewUsageCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewUsageCreateInfoKHR)
	obj.ref3791cec9 = (*C.VkImageViewUsageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewUsageCreateInfoKHR) PassRef() (*C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3791cec9 != nil {
		return x.ref3791cec9, nil
	}
	mem3791cec9 := allocImageViewUsageCreateInfoMemory(1)
	ref3791cec9 := (*C.VkImageViewUsageCreateInfo)(mem3791cec9)
	allocs3791cec9 := new(cgoAllocMap)
	allocs3791cec9.Add(mem3791cec9)

	var csType_allocs *cgoAllocMap
	ref3791cec9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3791cec9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3791cec9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3791cec9.Borrow(cpNext_allocs)

	var cusage_allocs *cgoAllocMap
	ref3791cec9.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs3791cec9.Borrow(cusage_allocs)

	x.ref3791cec9 = ref3791cec9
	x.allocs3791cec9 = allocs3791cec9
	return ref3791cec9, allocs3791cec9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewUsageCreateInfoKHR) PassValue() (C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x.ref3791cec9 != nil {
		return *x.ref3791cec9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewUsageCreateInfoKHR) Deref() {
	if x.ref3791cec9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3791cec9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3791cec9.pNext))
	x.Usage = (ImageUsageFlags)(x.ref3791cec9.usage)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationDomainOriginStateCreateInfoKHR) Ref() *C.VkPipelineTessellationDomainOriginStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref58ef29bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfoKHR) Free() {
	if x != nil && x.allocs58ef29bf != nil {
		x.allocs58ef29bf.(*cgoAllocMap).Free()
		x.ref58ef29bf = nil
	}
}

// NewPipelineTessellationDomainOriginStateCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationDomainOriginStateCreateInfoKHRRef(ref unsafe.Pointer) *PipelineTessellationDomainOriginStateCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationDomainOriginStateCreateInfoKHR)
	obj.ref58ef29bf = (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfoKHR) PassRef() (*C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58ef29bf != nil {
		return x.ref58ef29bf, nil
	}
	mem58ef29bf := allocPipelineTessellationDomainOriginStateCreateInfoMemory(1)
	ref58ef29bf := (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(mem58ef29bf)
	allocs58ef29bf := new(cgoAllocMap)
	allocs58ef29bf.Add(mem58ef29bf)

	var csType_allocs *cgoAllocMap
	ref58ef29bf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58ef29bf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58ef29bf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cpNext_allocs)

	var cdomainOrigin_allocs *cgoAllocMap
	ref58ef29bf.domainOrigin, cdomainOrigin_allocs = (C.VkTessellationDomainOrigin)(x.DomainOrigin), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cdomainOrigin_allocs)

	x.ref58ef29bf = ref58ef29bf
	x.allocs58ef29bf = allocs58ef29bf
	return ref58ef29bf, allocs58ef29bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfoKHR) PassValue() (C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x.ref58ef29bf != nil {
		return *x.ref58ef29bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationDomainOriginStateCreateInfoKHR) Deref() {
	if x.ref58ef29bf == nil {
		return
	}
	x.SType = (StructureType)(x.ref58ef29bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58ef29bf.pNext))
	x.DomainOrigin = (TessellationDomainOrigin)(x.ref58ef29bf.domainOrigin)
}

// allocPhysicalDeviceSurfaceInfo2KHRMemory allocates memory for type C.VkPhysicalDeviceSurfaceInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSurfaceInfo2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSurfaceInfo2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSurfaceInfo2KHRValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSurfaceInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSurfaceInfo2KHR) Ref() *C.VkPhysicalDeviceSurfaceInfo2KHR {
	if x == nil {
		return nil
	}
	return x.refd22370ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSurfaceInfo2KHR) Free() {
	if x != nil && x.allocsd22370ae != nil {
		x.allocsd22370ae.(*cgoAllocMap).Free()
		x.refd22370ae = nil
	}
}

// NewPhysicalDeviceSurfaceInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSurfaceInfo2KHRRef(ref unsafe.Pointer) *PhysicalDeviceSurfaceInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSurfaceInfo2KHR)
	obj.refd22370ae = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSurfaceInfo2KHR) PassRef() (*C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd22370ae != nil {
		return x.refd22370ae, nil
	}
	memd22370ae := allocPhysicalDeviceSurfaceInfo2KHRMemory(1)
	refd22370ae := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(memd22370ae)
	allocsd22370ae := new(cgoAllocMap)
	allocsd22370ae.Add(memd22370ae)

	var csType_allocs *cgoAllocMap
	refd22370ae.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd22370ae.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd22370ae.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd22370ae.Borrow(cpNext_allocs)

	var csurface_allocs *cgoAllocMap
	refd22370ae.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsd22370ae.Borrow(csurface_allocs)

	x.refd22370ae = refd22370ae
	x.allocsd22370ae = allocsd22370ae
	return refd22370ae, allocsd22370ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSurfaceInfo2KHR) PassValue() (C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x.refd22370ae != nil {
		return *x.refd22370ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSurfaceInfo2KHR) Deref() {
	if x.refd22370ae == nil {
		return
	}
	x.SType = (StructureType)(x.refd22370ae.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd22370ae.pNext))
	x.Surface = *(*SurfaceKHR)(unsafe.Pointer(&x.refd22370ae.surface))
}

// allocSurfaceCapabilities2KHRMemory allocates memory for type C.VkSurfaceCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilities2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilities2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilities2KHRValue = unsafe.Sizeof([1]C.VkSurfaceCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities2KHR) Ref() *C.VkSurfaceCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refea469745
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities2KHR) Free() {
	if x != nil && x.allocsea469745 != nil {
		x.allocsea469745.(*cgoAllocMap).Free()
		x.refea469745 = nil
	}
}

// NewSurfaceCapabilities2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilities2KHRRef(ref unsafe.Pointer) *SurfaceCapabilities2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities2KHR)
	obj.refea469745 = (*C.VkSurfaceCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities2KHR) PassRef() (*C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea469745 != nil {
		return x.refea469745, nil
	}
	memea469745 := allocSurfaceCapabilities2KHRMemory(1)
	refea469745 := (*C.VkSurfaceCapabilities2KHR)(memea469745)
	allocsea469745 := new(cgoAllocMap)
	allocsea469745.Add(memea469745)

	var csType_allocs *cgoAllocMap
	refea469745.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea469745.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea469745.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea469745.Borrow(cpNext_allocs)

	var csurfaceCapabilities_allocs *cgoAllocMap
	refea469745.surfaceCapabilities, csurfaceCapabilities_allocs = x.SurfaceCapabilities.PassValue()
	allocsea469745.Borrow(csurfaceCapabilities_allocs)

	x.refea469745 = refea469745
	x.allocsea469745 = allocsea469745
	return refea469745, allocsea469745

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities2KHR) PassValue() (C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x.refea469745 != nil {
		return *x.refea469745, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities2KHR) Deref() {
	if x.refea469745 == nil {
		return
	}
	x.SType = (StructureType)(x.refea469745.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea469745.pNext))
	x.SurfaceCapabilities = *NewSurfaceCapabilitiesKHRRef(unsafe.Pointer(&x.refea469745.surfaceCapabilities))
}

// allocSurfaceFormat2KHRMemory allocates memory for type C.VkSurfaceFormat2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormat2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormat2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormat2KHRValue = unsafe.Sizeof([1]C.VkSurfaceFormat2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormat2KHR) Ref() *C.VkSurfaceFormat2KHR {
	if x == nil {
		return nil
	}
	return x.ref8867f0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormat2KHR) Free() {
	if x != nil && x.allocs8867f0ed != nil {
		x.allocs8867f0ed.(*cgoAllocMap).Free()
		x.ref8867f0ed = nil
	}
}

// NewSurfaceFormat2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormat2KHRRef(ref unsafe.Pointer) *SurfaceFormat2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormat2KHR)
	obj.ref8867f0ed = (*C.VkSurfaceFormat2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormat2KHR) PassRef() (*C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8867f0ed != nil {
		return x.ref8867f0ed, nil
	}
	mem8867f0ed := allocSurfaceFormat2KHRMemory(1)
	ref8867f0ed := (*C.VkSurfaceFormat2KHR)(mem8867f0ed)
	allocs8867f0ed := new(cgoAllocMap)
	allocs8867f0ed.Add(mem8867f0ed)

	var csType_allocs *cgoAllocMap
	ref8867f0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8867f0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8867f0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8867f0ed.Borrow(cpNext_allocs)

	var csurfaceFormat_allocs *cgoAllocMap
	ref8867f0ed.surfaceFormat, csurfaceFormat_allocs = x.SurfaceFormat.PassValue()
	allocs8867f0ed.Borrow(csurfaceFormat_allocs)

	x.ref8867f0ed = ref8867f0ed
	x.allocs8867f0ed = allocs8867f0ed
	return ref8867f0ed, allocs8867f0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormat2KHR) PassValue() (C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x.ref8867f0ed != nil {
		return *x.ref8867f0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormat2KHR) Deref() {
	if x.ref8867f0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref8867f0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8867f0ed.pNext))
	x.SurfaceFormat = *NewSurfaceFormatKHRRef(unsafe.Pointer(&x.ref8867f0ed.surfaceFormat))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVariablePointerFeaturesKHR) Ref() *C.VkPhysicalDeviceVariablePointerFeatures {
	if x == nil {
		return nil
	}
	return x.refdedd8372
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVariablePointerFeaturesKHR) Free() {
	if x != nil && x.allocsdedd8372 != nil {
		x.allocsdedd8372.(*cgoAllocMap).Free()
		x.refdedd8372 = nil
	}
}

// NewPhysicalDeviceVariablePointerFeaturesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVariablePointerFeaturesKHRRef(ref unsafe.Pointer) *PhysicalDeviceVariablePointerFeaturesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVariablePointerFeaturesKHR)
	obj.refdedd8372 = (*C.VkPhysicalDeviceVariablePointerFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVariablePointerFeaturesKHR) PassRef() (*C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdedd8372 != nil {
		return x.refdedd8372, nil
	}
	memdedd8372 := allocPhysicalDeviceVariablePointerFeaturesMemory(1)
	refdedd8372 := (*C.VkPhysicalDeviceVariablePointerFeatures)(memdedd8372)
	allocsdedd8372 := new(cgoAllocMap)
	allocsdedd8372.Add(memdedd8372)

	var csType_allocs *cgoAllocMap
	refdedd8372.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdedd8372.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdedd8372.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdedd8372.Borrow(cpNext_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refdedd8372.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refdedd8372.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointers_allocs)

	x.refdedd8372 = refdedd8372
	x.allocsdedd8372 = allocsdedd8372
	return refdedd8372, allocsdedd8372

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVariablePointerFeaturesKHR) PassValue() (C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x.refdedd8372 != nil {
		return *x.refdedd8372, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVariablePointerFeaturesKHR) Deref() {
	if x.refdedd8372 == nil {
		return
	}
	x.SType = (StructureType)(x.refdedd8372.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdedd8372.pNext))
	x.VariablePointersStorageBuffer = (Bool32)(x.refdedd8372.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refdedd8372.variablePointers)
}

// allocDisplayProperties2KHRMemory allocates memory for type C.VkDisplayProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayProperties2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayProperties2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayProperties2KHRValue = unsafe.Sizeof([1]C.VkDisplayProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties2KHR) Ref() *C.VkDisplayProperties2KHR {
	if x == nil {
		return nil
	}
	return x.ref80194833
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties2KHR) Free() {
	if x != nil && x.allocs80194833 != nil {
		x.allocs80194833.(*cgoAllocMap).Free()
		x.ref80194833 = nil
	}
}

// NewDisplayProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayProperties2KHRRef(ref unsafe.Pointer) *DisplayProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties2KHR)
	obj.ref80194833 = (*C.VkDisplayProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties2KHR) PassRef() (*C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80194833 != nil {
		return x.ref80194833, nil
	}
	mem80194833 := allocDisplayProperties2KHRMemory(1)
	ref80194833 := (*C.VkDisplayProperties2KHR)(mem80194833)
	allocs80194833 := new(cgoAllocMap)
	allocs80194833.Add(mem80194833)

	var csType_allocs *cgoAllocMap
	ref80194833.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80194833.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80194833.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80194833.Borrow(cpNext_allocs)

	var cdisplayProperties_allocs *cgoAllocMap
	ref80194833.displayProperties, cdisplayProperties_allocs = x.DisplayProperties.PassValue()
	allocs80194833.Borrow(cdisplayProperties_allocs)

	x.ref80194833 = ref80194833
	x.allocs80194833 = allocs80194833
	return ref80194833, allocs80194833

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties2KHR) PassValue() (C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x.ref80194833 != nil {
		return *x.ref80194833, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties2KHR) Deref() {
	if x.ref80194833 == nil {
		return
	}
	x.SType = (StructureType)(x.ref80194833.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80194833.pNext))
	x.DisplayProperties = *NewDisplayPropertiesKHRRef(unsafe.Pointer(&x.ref80194833.displayProperties))
}

// allocDisplayPlaneProperties2KHRMemory allocates memory for type C.VkDisplayPlaneProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneProperties2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneProperties2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneProperties2KHRValue = unsafe.Sizeof([1]C.VkDisplayPlaneProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties2KHR) Ref() *C.VkDisplayPlaneProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refa72b1e5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties2KHR) Free() {
	if x != nil && x.allocsa72b1e5b != nil {
		x.allocsa72b1e5b.(*cgoAllocMap).Free()
		x.refa72b1e5b = nil
	}
}

// NewDisplayPlaneProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneProperties2KHRRef(ref unsafe.Pointer) *DisplayPlaneProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties2KHR)
	obj.refa72b1e5b = (*C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties2KHR) PassRef() (*C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa72b1e5b != nil {
		return x.refa72b1e5b, nil
	}
	mema72b1e5b := allocDisplayPlaneProperties2KHRMemory(1)
	refa72b1e5b := (*C.VkDisplayPlaneProperties2KHR)(mema72b1e5b)
	allocsa72b1e5b := new(cgoAllocMap)
	allocsa72b1e5b.Add(mema72b1e5b)

	var csType_allocs *cgoAllocMap
	refa72b1e5b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa72b1e5b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(cpNext_allocs)

	var cdisplayPlaneProperties_allocs *cgoAllocMap
	refa72b1e5b.displayPlaneProperties, cdisplayPlaneProperties_allocs = x.DisplayPlaneProperties.PassValue()
	allocsa72b1e5b.Borrow(cdisplayPlaneProperties_allocs)

	x.refa72b1e5b = refa72b1e5b
	x.allocsa72b1e5b = allocsa72b1e5b
	return refa72b1e5b, allocsa72b1e5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties2KHR) PassValue() (C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x.refa72b1e5b != nil {
		return *x.refa72b1e5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties2KHR) Deref() {
	if x.refa72b1e5b == nil {
		return
	}
	x.SType = (StructureType)(x.refa72b1e5b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa72b1e5b.pNext))
	x.DisplayPlaneProperties = *NewDisplayPlanePropertiesKHRRef(unsafe.Pointer(&x.refa72b1e5b.displayPlaneProperties))
}

// allocDisplayModeProperties2KHRMemory allocates memory for type C.VkDisplayModeProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeProperties2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeProperties2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeProperties2KHRValue = unsafe.Sizeof([1]C.VkDisplayModeProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties2KHR) Ref() *C.VkDisplayModeProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refc566048d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties2KHR) Free() {
	if x != nil && x.allocsc566048d != nil {
		x.allocsc566048d.(*cgoAllocMap).Free()
		x.refc566048d = nil
	}
}

// NewDisplayModeProperties2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeProperties2KHRRef(ref unsafe.Pointer) *DisplayModeProperties2KHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties2KHR)
	obj.refc566048d = (*C.VkDisplayModeProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties2KHR) PassRef() (*C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc566048d != nil {
		return x.refc566048d, nil
	}
	memc566048d := allocDisplayModeProperties2KHRMemory(1)
	refc566048d := (*C.VkDisplayModeProperties2KHR)(memc566048d)
	allocsc566048d := new(cgoAllocMap)
	allocsc566048d.Add(memc566048d)

	var csType_allocs *cgoAllocMap
	refc566048d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc566048d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc566048d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc566048d.Borrow(cpNext_allocs)

	var cdisplayModeProperties_allocs *cgoAllocMap
	refc566048d.displayModeProperties, cdisplayModeProperties_allocs = x.DisplayModeProperties.PassValue()
	allocsc566048d.Borrow(cdisplayModeProperties_allocs)

	x.refc566048d = refc566048d
	x.allocsc566048d = allocsc566048d
	return refc566048d, allocsc566048d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties2KHR) PassValue() (C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x.refc566048d != nil {
		return *x.refc566048d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties2KHR) Deref() {
	if x.refc566048d == nil {
		return
	}
	x.SType = (StructureType)(x.refc566048d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc566048d.pNext))
	x.DisplayModeProperties = *NewDisplayModePropertiesKHRRef(unsafe.Pointer(&x.refc566048d.displayModeProperties))
}

// allocDisplayPlaneInfo2KHRMemory allocates memory for type C.VkDisplayPlaneInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneInfo2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneInfo2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneInfo2KHRValue = unsafe.Sizeof([1]C.VkDisplayPlaneInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneInfo2KHR) Ref() *C.VkDisplayPlaneInfo2KHR {
	if x == nil {
		return nil
	}
	return x.reff355ccbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneInfo2KHR) Free() {
	if x != nil && x.allocsf355ccbf != nil {
		x.allocsf355ccbf.(*cgoAllocMap).Free()
		x.reff355ccbf = nil
	}
}

// NewDisplayPlaneInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneInfo2KHRRef(ref unsafe.Pointer) *DisplayPlaneInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneInfo2KHR)
	obj.reff355ccbf = (*C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneInfo2KHR) PassRef() (*C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff355ccbf != nil {
		return x.reff355ccbf, nil
	}
	memf355ccbf := allocDisplayPlaneInfo2KHRMemory(1)
	reff355ccbf := (*C.VkDisplayPlaneInfo2KHR)(memf355ccbf)
	allocsf355ccbf := new(cgoAllocMap)
	allocsf355ccbf.Add(memf355ccbf)

	var csType_allocs *cgoAllocMap
	reff355ccbf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf355ccbf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff355ccbf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cpNext_allocs)

	var cmode_allocs *cgoAllocMap
	reff355ccbf.mode, cmode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.Mode)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cmode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	reff355ccbf.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cplaneIndex_allocs)

	x.reff355ccbf = reff355ccbf
	x.allocsf355ccbf = allocsf355ccbf
	return reff355ccbf, allocsf355ccbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneInfo2KHR) PassValue() (C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x.reff355ccbf != nil {
		return *x.reff355ccbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneInfo2KHR) Deref() {
	if x.reff355ccbf == nil {
		return
	}
	x.SType = (StructureType)(x.reff355ccbf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff355ccbf.pNext))
	x.Mode = *(*DisplayModeKHR)(unsafe.Pointer(&x.reff355ccbf.mode))
	x.PlaneIndex = (uint32)(x.reff355ccbf.planeIndex)
}

// allocDisplayPlaneCapabilities2KHRMemory allocates memory for type C.VkDisplayPlaneCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilities2KHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilities2KHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilities2KHRValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilities2KHR) Ref() *C.VkDisplayPlaneCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refb53dfb44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilities2KHR) Free() {
	if x != nil && x.allocsb53dfb44 != nil {
		x.allocsb53dfb44.(*cgoAllocMap).Free()
		x.refb53dfb44 = nil
	}
}

// NewDisplayPlaneCapabilities2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilities2KHRRef(ref unsafe.Pointer) *DisplayPlaneCapabilities2KHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilities2KHR)
	obj.refb53dfb44 = (*C.VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilities2KHR) PassRef() (*C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb53dfb44 != nil {
		return x.refb53dfb44, nil
	}
	memb53dfb44 := allocDisplayPlaneCapabilities2KHRMemory(1)
	refb53dfb44 := (*C.VkDisplayPlaneCapabilities2KHR)(memb53dfb44)
	allocsb53dfb44 := new(cgoAllocMap)
	allocsb53dfb44.Add(memb53dfb44)

	var csType_allocs *cgoAllocMap
	refb53dfb44.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb53dfb44.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb53dfb44.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb53dfb44.Borrow(cpNext_allocs)

	var ccapabilities_allocs *cgoAllocMap
	refb53dfb44.capabilities, ccapabilities_allocs = x.Capabilities.PassValue()
	allocsb53dfb44.Borrow(ccapabilities_allocs)

	x.refb53dfb44 = refb53dfb44
	x.allocsb53dfb44 = allocsb53dfb44
	return refb53dfb44, allocsb53dfb44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilities2KHR) PassValue() (C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x.refb53dfb44 != nil {
		return *x.refb53dfb44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilities2KHR) Deref() {
	if x.refb53dfb44 == nil {
		return
	}
	x.SType = (StructureType)(x.refb53dfb44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb53dfb44.pNext))
	x.Capabilities = *NewDisplayPlaneCapabilitiesKHRRef(unsafe.Pointer(&x.refb53dfb44.capabilities))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedRequirementsKHR) Ref() *C.VkMemoryDedicatedRequirements {
	if x == nil {
		return nil
	}
	return x.refaa924122
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedRequirementsKHR) Free() {
	if x != nil && x.allocsaa924122 != nil {
		x.allocsaa924122.(*cgoAllocMap).Free()
		x.refaa924122 = nil
	}
}

// NewMemoryDedicatedRequirementsKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedRequirementsKHRRef(ref unsafe.Pointer) *MemoryDedicatedRequirementsKHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedRequirementsKHR)
	obj.refaa924122 = (*C.VkMemoryDedicatedRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedRequirementsKHR) PassRef() (*C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa924122 != nil {
		return x.refaa924122, nil
	}
	memaa924122 := allocMemoryDedicatedRequirementsMemory(1)
	refaa924122 := (*C.VkMemoryDedicatedRequirements)(memaa924122)
	allocsaa924122 := new(cgoAllocMap)
	allocsaa924122.Add(memaa924122)

	var csType_allocs *cgoAllocMap
	refaa924122.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaa924122.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaa924122.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaa924122.Borrow(cpNext_allocs)

	var cprefersDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.prefersDedicatedAllocation, cprefersDedicatedAllocation_allocs = (C.VkBool32)(x.PrefersDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(cprefersDedicatedAllocation_allocs)

	var crequiresDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.requiresDedicatedAllocation, crequiresDedicatedAllocation_allocs = (C.VkBool32)(x.RequiresDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(crequiresDedicatedAllocation_allocs)

	x.refaa924122 = refaa924122
	x.allocsaa924122 = allocsaa924122
	return refaa924122, allocsaa924122

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedRequirementsKHR) PassValue() (C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x.refaa924122 != nil {
		return *x.refaa924122, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedRequirementsKHR) Deref() {
	if x.refaa924122 == nil {
		return
	}
	x.SType = (StructureType)(x.refaa924122.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaa924122.pNext))
	x.PrefersDedicatedAllocation = (Bool32)(x.refaa924122.prefersDedicatedAllocation)
	x.RequiresDedicatedAllocation = (Bool32)(x.refaa924122.requiresDedicatedAllocation)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedAllocateInfoKHR) Ref() *C.VkMemoryDedicatedAllocateInfo {
	if x == nil {
		return nil
	}
	return x.reff8fabe62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedAllocateInfoKHR) Free() {
	if x != nil && x.allocsf8fabe62 != nil {
		x.allocsf8fabe62.(*cgoAllocMap).Free()
		x.reff8fabe62 = nil
	}
}

// NewMemoryDedicatedAllocateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedAllocateInfoKHRRef(ref unsafe.Pointer) *MemoryDedicatedAllocateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedAllocateInfoKHR)
	obj.reff8fabe62 = (*C.VkMemoryDedicatedAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedAllocateInfoKHR) PassRef() (*C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fabe62 != nil {
		return x.reff8fabe62, nil
	}
	memf8fabe62 := allocMemoryDedicatedAllocateInfoMemory(1)
	reff8fabe62 := (*C.VkMemoryDedicatedAllocateInfo)(memf8fabe62)
	allocsf8fabe62 := new(cgoAllocMap)
	allocsf8fabe62.Add(memf8fabe62)

	var csType_allocs *cgoAllocMap
	reff8fabe62.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf8fabe62.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff8fabe62.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	reff8fabe62.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff8fabe62.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cbuffer_allocs)

	x.reff8fabe62 = reff8fabe62
	x.allocsf8fabe62 = allocsf8fabe62
	return reff8fabe62, allocsf8fabe62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedAllocateInfoKHR) PassValue() (C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x.reff8fabe62 != nil {
		return *x.reff8fabe62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedAllocateInfoKHR) Deref() {
	if x.reff8fabe62 == nil {
		return
	}
	x.SType = (StructureType)(x.reff8fabe62.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff8fabe62.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.reff8fabe62.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff8fabe62.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryRequirementsInfo2KHR) Ref() *C.VkBufferMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.reff54a2a42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryRequirementsInfo2KHR) Free() {
	if x != nil && x.allocsf54a2a42 != nil {
		x.allocsf54a2a42.(*cgoAllocMap).Free()
		x.reff54a2a42 = nil
	}
}

// NewBufferMemoryRequirementsInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryRequirementsInfo2KHRRef(ref unsafe.Pointer) *BufferMemoryRequirementsInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryRequirementsInfo2KHR)
	obj.reff54a2a42 = (*C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryRequirementsInfo2KHR) PassRef() (*C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff54a2a42 != nil {
		return x.reff54a2a42, nil
	}
	memf54a2a42 := allocBufferMemoryRequirementsInfo2Memory(1)
	reff54a2a42 := (*C.VkBufferMemoryRequirementsInfo2)(memf54a2a42)
	allocsf54a2a42 := new(cgoAllocMap)
	allocsf54a2a42.Add(memf54a2a42)

	var csType_allocs *cgoAllocMap
	reff54a2a42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf54a2a42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff54a2a42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff54a2a42.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cbuffer_allocs)

	x.reff54a2a42 = reff54a2a42
	x.allocsf54a2a42 = allocsf54a2a42
	return reff54a2a42, allocsf54a2a42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryRequirementsInfo2KHR) PassValue() (C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.reff54a2a42 != nil {
		return *x.reff54a2a42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryRequirementsInfo2KHR) Deref() {
	if x.reff54a2a42 == nil {
		return
	}
	x.SType = (StructureType)(x.reff54a2a42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff54a2a42.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff54a2a42.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryRequirementsInfo2KHR) Ref() *C.VkImageMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref75b3ca05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryRequirementsInfo2KHR) Free() {
	if x != nil && x.allocs75b3ca05 != nil {
		x.allocs75b3ca05.(*cgoAllocMap).Free()
		x.ref75b3ca05 = nil
	}
}

// NewImageMemoryRequirementsInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryRequirementsInfo2KHRRef(ref unsafe.Pointer) *ImageMemoryRequirementsInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryRequirementsInfo2KHR)
	obj.ref75b3ca05 = (*C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryRequirementsInfo2KHR) PassRef() (*C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75b3ca05 != nil {
		return x.ref75b3ca05, nil
	}
	mem75b3ca05 := allocImageMemoryRequirementsInfo2Memory(1)
	ref75b3ca05 := (*C.VkImageMemoryRequirementsInfo2)(mem75b3ca05)
	allocs75b3ca05 := new(cgoAllocMap)
	allocs75b3ca05.Add(mem75b3ca05)

	var csType_allocs *cgoAllocMap
	ref75b3ca05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75b3ca05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75b3ca05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref75b3ca05.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cimage_allocs)

	x.ref75b3ca05 = ref75b3ca05
	x.allocs75b3ca05 = allocs75b3ca05
	return ref75b3ca05, allocs75b3ca05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryRequirementsInfo2KHR) PassValue() (C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref75b3ca05 != nil {
		return *x.ref75b3ca05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryRequirementsInfo2KHR) Deref() {
	if x.ref75b3ca05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75b3ca05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75b3ca05.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref75b3ca05.image))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSparseMemoryRequirementsInfo2KHR) Ref() *C.VkImageSparseMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref878956f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSparseMemoryRequirementsInfo2KHR) Free() {
	if x != nil && x.allocs878956f7 != nil {
		x.allocs878956f7.(*cgoAllocMap).Free()
		x.ref878956f7 = nil
	}
}

// NewImageSparseMemoryRequirementsInfo2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSparseMemoryRequirementsInfo2KHRRef(ref unsafe.Pointer) *ImageSparseMemoryRequirementsInfo2KHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageSparseMemoryRequirementsInfo2KHR)
	obj.ref878956f7 = (*C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSparseMemoryRequirementsInfo2KHR) PassRef() (*C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878956f7 != nil {
		return x.ref878956f7, nil
	}
	mem878956f7 := allocImageSparseMemoryRequirementsInfo2Memory(1)
	ref878956f7 := (*C.VkImageSparseMemoryRequirementsInfo2)(mem878956f7)
	allocs878956f7 := new(cgoAllocMap)
	allocs878956f7.Add(mem878956f7)

	var csType_allocs *cgoAllocMap
	ref878956f7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878956f7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878956f7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878956f7.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref878956f7.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs878956f7.Borrow(cimage_allocs)

	x.ref878956f7 = ref878956f7
	x.allocs878956f7 = allocs878956f7
	return ref878956f7, allocs878956f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2KHR) PassValue() (C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref878956f7 != nil {
		return *x.ref878956f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSparseMemoryRequirementsInfo2KHR) Deref() {
	if x.ref878956f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref878956f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878956f7.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref878956f7.image))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements2KHR) Ref() *C.VkMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refc0e75f21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements2KHR) Free() {
	if x != nil && x.allocsc0e75f21 != nil {
		x.allocsc0e75f21.(*cgoAllocMap).Free()
		x.refc0e75f21 = nil
	}
}

// NewMemoryRequirements2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirements2KHRRef(ref unsafe.Pointer) *MemoryRequirements2KHR {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements2KHR)
	obj.refc0e75f21 = (*C.VkMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements2KHR) PassRef() (*C.VkMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0e75f21 != nil {
		return x.refc0e75f21, nil
	}
	memc0e75f21 := allocMemoryRequirements2Memory(1)
	refc0e75f21 := (*C.VkMemoryRequirements2)(memc0e75f21)
	allocsc0e75f21 := new(cgoAllocMap)
	allocsc0e75f21.Add(memc0e75f21)

	var csType_allocs *cgoAllocMap
	refc0e75f21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0e75f21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0e75f21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0e75f21.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refc0e75f21.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsc0e75f21.Borrow(cmemoryRequirements_allocs)

	x.refc0e75f21 = refc0e75f21
	x.allocsc0e75f21 = allocsc0e75f21
	return refc0e75f21, allocsc0e75f21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements2KHR) PassValue() (C.VkMemoryRequirements2, *cgoAllocMap) {
	if x.refc0e75f21 != nil {
		return *x.refc0e75f21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements2KHR) Deref() {
	if x.refc0e75f21 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0e75f21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0e75f21.pNext))
	x.MemoryRequirements = *NewMemoryRequirementsRef(unsafe.Pointer(&x.refc0e75f21.memoryRequirements))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements2KHR) Ref() *C.VkSparseImageMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refb8da955c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements2KHR) Free() {
	if x != nil && x.allocsb8da955c != nil {
		x.allocsb8da955c.(*cgoAllocMap).Free()
		x.refb8da955c = nil
	}
}

// NewSparseImageMemoryRequirements2KHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirements2KHRRef(ref unsafe.Pointer) *SparseImageMemoryRequirements2KHR {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements2KHR)
	obj.refb8da955c = (*C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements2KHR) PassRef() (*C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8da955c != nil {
		return x.refb8da955c, nil
	}
	memb8da955c := allocSparseImageMemoryRequirements2Memory(1)
	refb8da955c := (*C.VkSparseImageMemoryRequirements2)(memb8da955c)
	allocsb8da955c := new(cgoAllocMap)
	allocsb8da955c.Add(memb8da955c)

	var csType_allocs *cgoAllocMap
	refb8da955c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8da955c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8da955c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8da955c.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refb8da955c.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsb8da955c.Borrow(cmemoryRequirements_allocs)

	x.refb8da955c = refb8da955c
	x.allocsb8da955c = allocsb8da955c
	return refb8da955c, allocsb8da955c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements2KHR) PassValue() (C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x.refb8da955c != nil {
		return *x.refb8da955c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements2KHR) Deref() {
	if x.refb8da955c == nil {
		return
	}
	x.SType = (StructureType)(x.refb8da955c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8da955c.pNext))
	x.MemoryRequirements = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&x.refb8da955c.memoryRequirements))
}

// allocImageFormatListCreateInfoKHRMemory allocates memory for type C.VkImageFormatListCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatListCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatListCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatListCreateInfoKHRValue = unsafe.Sizeof([1]C.VkImageFormatListCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatListCreateInfoKHR) Ref() *C.VkImageFormatListCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref815daf8c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatListCreateInfoKHR) Free() {
	if x != nil && x.allocs815daf8c != nil {
		x.allocs815daf8c.(*cgoAllocMap).Free()
		x.ref815daf8c = nil
	}
}

// NewImageFormatListCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatListCreateInfoKHRRef(ref unsafe.Pointer) *ImageFormatListCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatListCreateInfoKHR)
	obj.ref815daf8c = (*C.VkImageFormatListCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatListCreateInfoKHR) PassRef() (*C.VkImageFormatListCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref815daf8c != nil {
		return x.ref815daf8c, nil
	}
	mem815daf8c := allocImageFormatListCreateInfoKHRMemory(1)
	ref815daf8c := (*C.VkImageFormatListCreateInfoKHR)(mem815daf8c)
	allocs815daf8c := new(cgoAllocMap)
	allocs815daf8c.Add(mem815daf8c)

	var csType_allocs *cgoAllocMap
	ref815daf8c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs815daf8c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref815daf8c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs815daf8c.Borrow(cpNext_allocs)

	var cviewFormatCount_allocs *cgoAllocMap
	ref815daf8c.viewFormatCount, cviewFormatCount_allocs = (C.uint32_t)(x.ViewFormatCount), cgoAllocsUnknown
	allocs815daf8c.Borrow(cviewFormatCount_allocs)

	var cpViewFormats_allocs *cgoAllocMap
	ref815daf8c.pViewFormats, cpViewFormats_allocs = (*C.VkFormat)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)).Data)), cgoAllocsUnknown
	allocs815daf8c.Borrow(cpViewFormats_allocs)

	x.ref815daf8c = ref815daf8c
	x.allocs815daf8c = allocs815daf8c
	return ref815daf8c, allocs815daf8c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatListCreateInfoKHR) PassValue() (C.VkImageFormatListCreateInfoKHR, *cgoAllocMap) {
	if x.ref815daf8c != nil {
		return *x.ref815daf8c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatListCreateInfoKHR) Deref() {
	if x.ref815daf8c == nil {
		return
	}
	x.SType = (StructureType)(x.ref815daf8c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref815daf8c.pNext))
	x.ViewFormatCount = (uint32)(x.ref815daf8c.viewFormatCount)
	hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxfeb55cf.Data = unsafe.Pointer(x.ref815daf8c.pViewFormats)
	hxfeb55cf.Cap = 0x7fffffff
	// hxfeb55cf.Len = ?

}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionCreateInfoKHR) Ref() *C.VkSamplerYcbcrConversionCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9875bff7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionCreateInfoKHR) Free() {
	if x != nil && x.allocs9875bff7 != nil {
		x.allocs9875bff7.(*cgoAllocMap).Free()
		x.ref9875bff7 = nil
	}
}

// NewSamplerYcbcrConversionCreateInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionCreateInfoKHRRef(ref unsafe.Pointer) *SamplerYcbcrConversionCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionCreateInfoKHR)
	obj.ref9875bff7 = (*C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionCreateInfoKHR) PassRef() (*C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9875bff7 != nil {
		return x.ref9875bff7, nil
	}
	mem9875bff7 := allocSamplerYcbcrConversionCreateInfoMemory(1)
	ref9875bff7 := (*C.VkSamplerYcbcrConversionCreateInfo)(mem9875bff7)
	allocs9875bff7 := new(cgoAllocMap)
	allocs9875bff7.Add(mem9875bff7)

	var csType_allocs *cgoAllocMap
	ref9875bff7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9875bff7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9875bff7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9875bff7.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref9875bff7.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs9875bff7.Borrow(cformat_allocs)

	var cycbcrModel_allocs *cgoAllocMap
	ref9875bff7.ycbcrModel, cycbcrModel_allocs = (C.VkSamplerYcbcrModelConversion)(x.YcbcrModel), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrModel_allocs)

	var cycbcrRange_allocs *cgoAllocMap
	ref9875bff7.ycbcrRange, cycbcrRange_allocs = (C.VkSamplerYcbcrRange)(x.YcbcrRange), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrRange_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref9875bff7.components, ccomponents_allocs = x.Components.PassValue()
	allocs9875bff7.Borrow(ccomponents_allocs)

	var cxChromaOffset_allocs *cgoAllocMap
	ref9875bff7.xChromaOffset, cxChromaOffset_allocs = (C.VkChromaLocation)(x.XChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cxChromaOffset_allocs)

	var cyChromaOffset_allocs *cgoAllocMap
	ref9875bff7.yChromaOffset, cyChromaOffset_allocs = (C.VkChromaLocation)(x.YChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cyChromaOffset_allocs)

	var cchromaFilter_allocs *cgoAllocMap
	ref9875bff7.chromaFilter, cchromaFilter_allocs = (C.VkFilter)(x.ChromaFilter), cgoAllocsUnknown
	allocs9875bff7.Borrow(cchromaFilter_allocs)

	var cforceExplicitReconstruction_allocs *cgoAllocMap
	ref9875bff7.forceExplicitReconstruction, cforceExplicitReconstruction_allocs = (C.VkBool32)(x.ForceExplicitReconstruction), cgoAllocsUnknown
	allocs9875bff7.Borrow(cforceExplicitReconstruction_allocs)

	x.ref9875bff7 = ref9875bff7
	x.allocs9875bff7 = allocs9875bff7
	return ref9875bff7, allocs9875bff7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionCreateInfoKHR) PassValue() (C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x.ref9875bff7 != nil {
		return *x.ref9875bff7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionCreateInfoKHR) Deref() {
	if x.ref9875bff7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9875bff7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9875bff7.pNext))
	x.Format = (Format)(x.ref9875bff7.format)
	x.YcbcrModel = (SamplerYcbcrModelConversion)(x.ref9875bff7.ycbcrModel)
	x.YcbcrRange = (SamplerYcbcrRange)(x.ref9875bff7.ycbcrRange)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref9875bff7.components))
	x.XChromaOffset = (ChromaLocation)(x.ref9875bff7.xChromaOffset)
	x.YChromaOffset = (ChromaLocation)(x.ref9875bff7.yChromaOffset)
	x.ChromaFilter = (Filter)(x.ref9875bff7.chromaFilter)
	x.ForceExplicitReconstruction = (Bool32)(x.ref9875bff7.forceExplicitReconstruction)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionInfoKHR) Ref() *C.VkSamplerYcbcrConversionInfo {
	if x == nil {
		return nil
	}
	return x.ref11ff5547
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionInfoKHR) Free() {
	if x != nil && x.allocs11ff5547 != nil {
		x.allocs11ff5547.(*cgoAllocMap).Free()
		x.ref11ff5547 = nil
	}
}

// NewSamplerYcbcrConversionInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionInfoKHRRef(ref unsafe.Pointer) *SamplerYcbcrConversionInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionInfoKHR)
	obj.ref11ff5547 = (*C.VkSamplerYcbcrConversionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionInfoKHR) PassRef() (*C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11ff5547 != nil {
		return x.ref11ff5547, nil
	}
	mem11ff5547 := allocSamplerYcbcrConversionInfoMemory(1)
	ref11ff5547 := (*C.VkSamplerYcbcrConversionInfo)(mem11ff5547)
	allocs11ff5547 := new(cgoAllocMap)
	allocs11ff5547.Add(mem11ff5547)

	var csType_allocs *cgoAllocMap
	ref11ff5547.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs11ff5547.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref11ff5547.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cpNext_allocs)

	var cconversion_allocs *cgoAllocMap
	ref11ff5547.conversion, cconversion_allocs = *(*C.VkSamplerYcbcrConversion)(unsafe.Pointer(&x.Conversion)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cconversion_allocs)

	x.ref11ff5547 = ref11ff5547
	x.allocs11ff5547 = allocs11ff5547
	return ref11ff5547, allocs11ff5547

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionInfoKHR) PassValue() (C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x.ref11ff5547 != nil {
		return *x.ref11ff5547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionInfoKHR) Deref() {
	if x.ref11ff5547 == nil {
		return
	}
	x.SType = (StructureType)(x.ref11ff5547.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref11ff5547.pNext))
	x.Conversion = *(*SamplerYcbcrConversion)(unsafe.Pointer(&x.ref11ff5547.conversion))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImagePlaneMemoryInfoKHR) Ref() *C.VkBindImagePlaneMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref56b81476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImagePlaneMemoryInfoKHR) Free() {
	if x != nil && x.allocs56b81476 != nil {
		x.allocs56b81476.(*cgoAllocMap).Free()
		x.ref56b81476 = nil
	}
}

// NewBindImagePlaneMemoryInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImagePlaneMemoryInfoKHRRef(ref unsafe.Pointer) *BindImagePlaneMemoryInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindImagePlaneMemoryInfoKHR)
	obj.ref56b81476 = (*C.VkBindImagePlaneMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImagePlaneMemoryInfoKHR) PassRef() (*C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56b81476 != nil {
		return x.ref56b81476, nil
	}
	mem56b81476 := allocBindImagePlaneMemoryInfoMemory(1)
	ref56b81476 := (*C.VkBindImagePlaneMemoryInfo)(mem56b81476)
	allocs56b81476 := new(cgoAllocMap)
	allocs56b81476.Add(mem56b81476)

	var csType_allocs *cgoAllocMap
	ref56b81476.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs56b81476.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref56b81476.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs56b81476.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	ref56b81476.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocs56b81476.Borrow(cplaneAspect_allocs)

	x.ref56b81476 = ref56b81476
	x.allocs56b81476 = allocs56b81476
	return ref56b81476, allocs56b81476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImagePlaneMemoryInfoKHR) PassValue() (C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x.ref56b81476 != nil {
		return *x.ref56b81476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImagePlaneMemoryInfoKHR) Deref() {
	if x.ref56b81476 == nil {
		return
	}
	x.SType = (StructureType)(x.ref56b81476.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref56b81476.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.ref56b81476.planeAspect)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImagePlaneMemoryRequirementsInfoKHR) Ref() *C.VkImagePlaneMemoryRequirementsInfo {
	if x == nil {
		return nil
	}
	return x.refefec131f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImagePlaneMemoryRequirementsInfoKHR) Free() {
	if x != nil && x.allocsefec131f != nil {
		x.allocsefec131f.(*cgoAllocMap).Free()
		x.refefec131f = nil
	}
}

// NewImagePlaneMemoryRequirementsInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImagePlaneMemoryRequirementsInfoKHRRef(ref unsafe.Pointer) *ImagePlaneMemoryRequirementsInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(ImagePlaneMemoryRequirementsInfoKHR)
	obj.refefec131f = (*C.VkImagePlaneMemoryRequirementsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImagePlaneMemoryRequirementsInfoKHR) PassRef() (*C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefec131f != nil {
		return x.refefec131f, nil
	}
	memefec131f := allocImagePlaneMemoryRequirementsInfoMemory(1)
	refefec131f := (*C.VkImagePlaneMemoryRequirementsInfo)(memefec131f)
	allocsefec131f := new(cgoAllocMap)
	allocsefec131f.Add(memefec131f)

	var csType_allocs *cgoAllocMap
	refefec131f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsefec131f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refefec131f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsefec131f.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	refefec131f.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocsefec131f.Borrow(cplaneAspect_allocs)

	x.refefec131f = refefec131f
	x.allocsefec131f = allocsefec131f
	return refefec131f, allocsefec131f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImagePlaneMemoryRequirementsInfoKHR) PassValue() (C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x.refefec131f != nil {
		return *x.refefec131f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImagePlaneMemoryRequirementsInfoKHR) Deref() {
	if x.refefec131f == nil {
		return
	}
	x.SType = (StructureType)(x.refefec131f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refefec131f.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.refefec131f.planeAspect)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerYcbcrConversionFeaturesKHR) Ref() *C.VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	if x == nil {
		return nil
	}
	return x.ref1d054d67
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeaturesKHR) Free() {
	if x != nil && x.allocs1d054d67 != nil {
		x.allocs1d054d67.(*cgoAllocMap).Free()
		x.ref1d054d67 = nil
	}
}

// NewPhysicalDeviceSamplerYcbcrConversionFeaturesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerYcbcrConversionFeaturesKHRRef(ref unsafe.Pointer) *PhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerYcbcrConversionFeaturesKHR)
	obj.ref1d054d67 = (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeaturesKHR) PassRef() (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d054d67 != nil {
		return x.ref1d054d67, nil
	}
	mem1d054d67 := allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(1)
	ref1d054d67 := (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(mem1d054d67)
	allocs1d054d67 := new(cgoAllocMap)
	allocs1d054d67.Add(mem1d054d67)

	var csType_allocs *cgoAllocMap
	ref1d054d67.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d054d67.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d054d67.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d054d67.Borrow(cpNext_allocs)

	var csamplerYcbcrConversion_allocs *cgoAllocMap
	ref1d054d67.samplerYcbcrConversion, csamplerYcbcrConversion_allocs = (C.VkBool32)(x.SamplerYcbcrConversion), cgoAllocsUnknown
	allocs1d054d67.Borrow(csamplerYcbcrConversion_allocs)

	x.ref1d054d67 = ref1d054d67
	x.allocs1d054d67 = allocs1d054d67
	return ref1d054d67, allocs1d054d67

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeaturesKHR) PassValue() (C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x.ref1d054d67 != nil {
		return *x.ref1d054d67, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerYcbcrConversionFeaturesKHR) Deref() {
	if x.ref1d054d67 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d054d67.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d054d67.pNext))
	x.SamplerYcbcrConversion = (Bool32)(x.ref1d054d67.samplerYcbcrConversion)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionImageFormatPropertiesKHR) Ref() *C.VkSamplerYcbcrConversionImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref6bc79530
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionImageFormatPropertiesKHR) Free() {
	if x != nil && x.allocs6bc79530 != nil {
		x.allocs6bc79530.(*cgoAllocMap).Free()
		x.ref6bc79530 = nil
	}
}

// NewSamplerYcbcrConversionImageFormatPropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionImageFormatPropertiesKHRRef(ref unsafe.Pointer) *SamplerYcbcrConversionImageFormatPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionImageFormatPropertiesKHR)
	obj.ref6bc79530 = (*C.VkSamplerYcbcrConversionImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionImageFormatPropertiesKHR) PassRef() (*C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc79530 != nil {
		return x.ref6bc79530, nil
	}
	mem6bc79530 := allocSamplerYcbcrConversionImageFormatPropertiesMemory(1)
	ref6bc79530 := (*C.VkSamplerYcbcrConversionImageFormatProperties)(mem6bc79530)
	allocs6bc79530 := new(cgoAllocMap)
	allocs6bc79530.Add(mem6bc79530)

	var csType_allocs *cgoAllocMap
	ref6bc79530.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bc79530.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bc79530.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bc79530.Borrow(cpNext_allocs)

	var ccombinedImageSamplerDescriptorCount_allocs *cgoAllocMap
	ref6bc79530.combinedImageSamplerDescriptorCount, ccombinedImageSamplerDescriptorCount_allocs = (C.uint32_t)(x.CombinedImageSamplerDescriptorCount), cgoAllocsUnknown
	allocs6bc79530.Borrow(ccombinedImageSamplerDescriptorCount_allocs)

	x.ref6bc79530 = ref6bc79530
	x.allocs6bc79530 = allocs6bc79530
	return ref6bc79530, allocs6bc79530

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionImageFormatPropertiesKHR) PassValue() (C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x.ref6bc79530 != nil {
		return *x.ref6bc79530, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionImageFormatPropertiesKHR) Deref() {
	if x.ref6bc79530 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bc79530.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc79530.pNext))
	x.CombinedImageSamplerDescriptorCount = (uint32)(x.ref6bc79530.combinedImageSamplerDescriptorCount)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryInfoKHR) Ref() *C.VkBindBufferMemoryInfo {
	if x == nil {
		return nil
	}
	return x.refd392322d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryInfoKHR) Free() {
	if x != nil && x.allocsd392322d != nil {
		x.allocsd392322d.(*cgoAllocMap).Free()
		x.refd392322d = nil
	}
}

// NewBindBufferMemoryInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryInfoKHRRef(ref unsafe.Pointer) *BindBufferMemoryInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryInfoKHR)
	obj.refd392322d = (*C.VkBindBufferMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryInfoKHR) PassRef() (*C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd392322d != nil {
		return x.refd392322d, nil
	}
	memd392322d := allocBindBufferMemoryInfoMemory(1)
	refd392322d := (*C.VkBindBufferMemoryInfo)(memd392322d)
	allocsd392322d := new(cgoAllocMap)
	allocsd392322d.Add(memd392322d)

	var csType_allocs *cgoAllocMap
	refd392322d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd392322d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd392322d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd392322d.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd392322d.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd392322d.Borrow(cbuffer_allocs)

	var cmemory_allocs *cgoAllocMap
	refd392322d.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	refd392322d.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemoryOffset_allocs)

	x.refd392322d = refd392322d
	x.allocsd392322d = allocsd392322d
	return refd392322d, allocsd392322d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryInfoKHR) PassValue() (C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x.refd392322d != nil {
		return *x.refd392322d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryInfoKHR) Deref() {
	if x.refd392322d == nil {
		return
	}
	x.SType = (StructureType)(x.refd392322d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd392322d.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refd392322d.buffer))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refd392322d.memory))
	x.MemoryOffset = (DeviceSize)(x.refd392322d.memoryOffset)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryInfoKHR) Ref() *C.VkBindImageMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref767a2113
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryInfoKHR) Free() {
	if x != nil && x.allocs767a2113 != nil {
		x.allocs767a2113.(*cgoAllocMap).Free()
		x.ref767a2113 = nil
	}
}

// NewBindImageMemoryInfoKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryInfoKHRRef(ref unsafe.Pointer) *BindImageMemoryInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryInfoKHR)
	obj.ref767a2113 = (*C.VkBindImageMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryInfoKHR) PassRef() (*C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref767a2113 != nil {
		return x.ref767a2113, nil
	}
	mem767a2113 := allocBindImageMemoryInfoMemory(1)
	ref767a2113 := (*C.VkBindImageMemoryInfo)(mem767a2113)
	allocs767a2113 := new(cgoAllocMap)
	allocs767a2113.Add(mem767a2113)

	var csType_allocs *cgoAllocMap
	ref767a2113.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs767a2113.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref767a2113.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs767a2113.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref767a2113.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs767a2113.Borrow(cimage_allocs)

	var cmemory_allocs *cgoAllocMap
	ref767a2113.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref767a2113.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemoryOffset_allocs)

	x.ref767a2113 = ref767a2113
	x.allocs767a2113 = allocs767a2113
	return ref767a2113, allocs767a2113

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryInfoKHR) PassValue() (C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x.ref767a2113 != nil {
		return *x.ref767a2113, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryInfoKHR) Deref() {
	if x.ref767a2113 == nil {
		return
	}
	x.SType = (StructureType)(x.ref767a2113.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref767a2113.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref767a2113.image))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref767a2113.memory))
	x.MemoryOffset = (DeviceSize)(x.ref767a2113.memoryOffset)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMaintenance3PropertiesKHR) Ref() *C.VkPhysicalDeviceMaintenance3Properties {
	if x == nil {
		return nil
	}
	return x.ref12c07777
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMaintenance3PropertiesKHR) Free() {
	if x != nil && x.allocs12c07777 != nil {
		x.allocs12c07777.(*cgoAllocMap).Free()
		x.ref12c07777 = nil
	}
}

// NewPhysicalDeviceMaintenance3PropertiesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMaintenance3PropertiesKHRRef(ref unsafe.Pointer) *PhysicalDeviceMaintenance3PropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMaintenance3PropertiesKHR)
	obj.ref12c07777 = (*C.VkPhysicalDeviceMaintenance3Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMaintenance3PropertiesKHR) PassRef() (*C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12c07777 != nil {
		return x.ref12c07777, nil
	}
	mem12c07777 := allocPhysicalDeviceMaintenance3PropertiesMemory(1)
	ref12c07777 := (*C.VkPhysicalDeviceMaintenance3Properties)(mem12c07777)
	allocs12c07777 := new(cgoAllocMap)
	allocs12c07777.Add(mem12c07777)

	var csType_allocs *cgoAllocMap
	ref12c07777.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12c07777.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12c07777.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12c07777.Borrow(cpNext_allocs)

	var cmaxPerSetDescriptors_allocs *cgoAllocMap
	ref12c07777.maxPerSetDescriptors, cmaxPerSetDescriptors_allocs = (C.uint32_t)(x.MaxPerSetDescriptors), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxPerSetDescriptors_allocs)

	var cmaxMemoryAllocationSize_allocs *cgoAllocMap
	ref12c07777.maxMemoryAllocationSize, cmaxMemoryAllocationSize_allocs = (C.VkDeviceSize)(x.MaxMemoryAllocationSize), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxMemoryAllocationSize_allocs)

	x.ref12c07777 = ref12c07777
	x.allocs12c07777 = allocs12c07777
	return ref12c07777, allocs12c07777

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMaintenance3PropertiesKHR) PassValue() (C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x.ref12c07777 != nil {
		return *x.ref12c07777, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMaintenance3PropertiesKHR) Deref() {
	if x.ref12c07777 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12c07777.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12c07777.pNext))
	x.MaxPerSetDescriptors = (uint32)(x.ref12c07777.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.ref12c07777.maxMemoryAllocationSize)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutSupportKHR) Ref() *C.VkDescriptorSetLayoutSupport {
	if x == nil {
		return nil
	}
	return x.ref5802686c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutSupportKHR) Free() {
	if x != nil && x.allocs5802686c != nil {
		x.allocs5802686c.(*cgoAllocMap).Free()
		x.ref5802686c = nil
	}
}

// NewDescriptorSetLayoutSupportKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutSupportKHRRef(ref unsafe.Pointer) *DescriptorSetLayoutSupportKHR {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutSupportKHR)
	obj.ref5802686c = (*C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutSupportKHR) PassRef() (*C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5802686c != nil {
		return x.ref5802686c, nil
	}
	mem5802686c := allocDescriptorSetLayoutSupportMemory(1)
	ref5802686c := (*C.VkDescriptorSetLayoutSupport)(mem5802686c)
	allocs5802686c := new(cgoAllocMap)
	allocs5802686c.Add(mem5802686c)

	var csType_allocs *cgoAllocMap
	ref5802686c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5802686c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5802686c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5802686c.Borrow(cpNext_allocs)

	var csupported_allocs *cgoAllocMap
	ref5802686c.supported, csupported_allocs = (C.VkBool32)(x.Supported), cgoAllocsUnknown
	allocs5802686c.Borrow(csupported_allocs)

	x.ref5802686c = ref5802686c
	x.allocs5802686c = allocs5802686c
	return ref5802686c, allocs5802686c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutSupportKHR) PassValue() (C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x.ref5802686c != nil {
		return *x.ref5802686c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutSupportKHR) Deref() {
	if x.ref5802686c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5802686c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5802686c.pNext))
	x.Supported = (Bool32)(x.ref5802686c.supported)
}

// allocPhysicalDevice8BitStorageFeaturesKHRMemory allocates memory for type C.VkPhysicalDevice8BitStorageFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice8BitStorageFeaturesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice8BitStorageFeaturesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevice8BitStorageFeaturesKHRValue = unsafe.Sizeof([1]C.VkPhysicalDevice8BitStorageFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice8BitStorageFeaturesKHR) Ref() *C.VkPhysicalDevice8BitStorageFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref906ef48e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice8BitStorageFeaturesKHR) Free() {
	if x != nil && x.allocs906ef48e != nil {
		x.allocs906ef48e.(*cgoAllocMap).Free()
		x.ref906ef48e = nil
	}
}

// NewPhysicalDevice8BitStorageFeaturesKHRRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice8BitStorageFeaturesKHRRef(ref unsafe.Pointer) *PhysicalDevice8BitStorageFeaturesKHR {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice8BitStorageFeaturesKHR)
	obj.ref906ef48e = (*C.VkPhysicalDevice8BitStorageFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice8BitStorageFeaturesKHR) PassRef() (*C.VkPhysicalDevice8BitStorageFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref906ef48e != nil {
		return x.ref906ef48e, nil
	}
	mem906ef48e := allocPhysicalDevice8BitStorageFeaturesKHRMemory(1)
	ref906ef48e := (*C.VkPhysicalDevice8BitStorageFeaturesKHR)(mem906ef48e)
	allocs906ef48e := new(cgoAllocMap)
	allocs906ef48e.Add(mem906ef48e)

	var csType_allocs *cgoAllocMap
	ref906ef48e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs906ef48e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref906ef48e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs906ef48e.Borrow(cpNext_allocs)

	var cstorageBuffer8BitAccess_allocs *cgoAllocMap
	ref906ef48e.storageBuffer8BitAccess, cstorageBuffer8BitAccess_allocs = (C.VkBool32)(x.StorageBuffer8BitAccess), cgoAllocsUnknown
	allocs906ef48e.Borrow(cstorageBuffer8BitAccess_allocs)

	var cuniformAndStorageBuffer8BitAccess_allocs *cgoAllocMap
	ref906ef48e.uniformAndStorageBuffer8BitAccess, cuniformAndStorageBuffer8BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer8BitAccess), cgoAllocsUnknown
	allocs906ef48e.Borrow(cuniformAndStorageBuffer8BitAccess_allocs)

	var cstoragePushConstant8_allocs *cgoAllocMap
	ref906ef48e.storagePushConstant8, cstoragePushConstant8_allocs = (C.VkBool32)(x.StoragePushConstant8), cgoAllocsUnknown
	allocs906ef48e.Borrow(cstoragePushConstant8_allocs)

	x.ref906ef48e = ref906ef48e
	x.allocs906ef48e = allocs906ef48e
	return ref906ef48e, allocs906ef48e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice8BitStorageFeaturesKHR) PassValue() (C.VkPhysicalDevice8BitStorageFeaturesKHR, *cgoAllocMap) {
	if x.ref906ef48e != nil {
		return *x.ref906ef48e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice8BitStorageFeaturesKHR) Deref() {
	if x.ref906ef48e == nil {
		return
	}
	x.SType = (StructureType)(x.ref906ef48e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref906ef48e.pNext))
	x.StorageBuffer8BitAccess = (Bool32)(x.ref906ef48e.storageBuffer8BitAccess)
	x.UniformAndStorageBuffer8BitAccess = (Bool32)(x.ref906ef48e.uniformAndStorageBuffer8BitAccess)
	x.StoragePushConstant8 = (Bool32)(x.ref906ef48e.storagePushConstant8)
}

// allocDebugReportCallbackCreateInfoEXTMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoEXTValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugReportCallbackCreateInfoEXT) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugReportCallbackCreateInfoEXT) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugReportCallbackCreateInfoEXTRef(ref unsafe.Pointer) *DebugReportCallbackCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugReportCallbackCreateInfoEXT)
	obj.refc8238563 = (*C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugReportCallbackCreateInfoEXT) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoEXTMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	allocsc8238563.Add(memc8238563)

	var csType_allocs *cgoAllocMap
	refc8238563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8238563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8238563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc8238563.flags, cflags_allocs = (C.VkDebugReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsc8238563.Borrow(cflags_allocs)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refc8238563.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpUserData_allocs)

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugReportCallbackCreateInfoEXT) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugReportCallbackCreateInfoEXT) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlagsEXT)(x.refc8238563.flags)
	x.PfnCallback = *NewRef(unsafe.Pointer(&x.refc8238563.pfnCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// allocPipelineRasterizationStateRasterizationOrderAMDMemory allocates memory for type C.VkPipelineRasterizationStateRasterizationOrderAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateRasterizationOrderAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateRasterizationOrderAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateRasterizationOrderAMDValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateRasterizationOrderAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Ref() *C.VkPipelineRasterizationStateRasterizationOrderAMD {
	if x == nil {
		return nil
	}
	return x.ref5098cf82
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Free() {
	if x != nil && x.allocs5098cf82 != nil {
		x.allocs5098cf82.(*cgoAllocMap).Free()
		x.ref5098cf82 = nil
	}
}

// NewPipelineRasterizationStateRasterizationOrderAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateRasterizationOrderAMDRef(ref unsafe.Pointer) *PipelineRasterizationStateRasterizationOrderAMD {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateRasterizationOrderAMD)
	obj.ref5098cf82 = (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassRef() (*C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5098cf82 != nil {
		return x.ref5098cf82, nil
	}
	mem5098cf82 := allocPipelineRasterizationStateRasterizationOrderAMDMemory(1)
	ref5098cf82 := (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(mem5098cf82)
	allocs5098cf82 := new(cgoAllocMap)
	allocs5098cf82.Add(mem5098cf82)

	var csType_allocs *cgoAllocMap
	ref5098cf82.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5098cf82.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5098cf82.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5098cf82.Borrow(cpNext_allocs)

	var crasterizationOrder_allocs *cgoAllocMap
	ref5098cf82.rasterizationOrder, crasterizationOrder_allocs = (C.VkRasterizationOrderAMD)(x.RasterizationOrder), cgoAllocsUnknown
	allocs5098cf82.Borrow(crasterizationOrder_allocs)

	x.ref5098cf82 = ref5098cf82
	x.allocs5098cf82 = allocs5098cf82
	return ref5098cf82, allocs5098cf82

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateRasterizationOrderAMD) PassValue() (C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x.ref5098cf82 != nil {
		return *x.ref5098cf82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Deref() {
	if x.ref5098cf82 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5098cf82.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5098cf82.pNext))
	x.RasterizationOrder = (RasterizationOrderAMD)(x.ref5098cf82.rasterizationOrder)
}

// allocDebugMarkerObjectNameInfoEXTMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectNameInfoEXT) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectNameInfoEXT) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectNameInfoEXTRef(ref unsafe.Pointer) *DebugMarkerObjectNameInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectNameInfoEXT)
	obj.refe4983fab = (*C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectNameInfoEXT) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoEXTMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	allocse4983fab.Add(meme4983fab)

	var csType_allocs *cgoAllocMap
	refe4983fab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse4983fab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe4983fab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse4983fab.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refe4983fab.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocse4983fab.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refe4983fab.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocse4983fab.Borrow(cobject_allocs)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectNameInfoEXT) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectNameInfoEXT) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectTypeEXT)(x.refe4983fab.objectType)
	x.Object = (uint64)(x.refe4983fab.object)
	x.PObjectName = packPCharString(x.refe4983fab.pObjectName)
}

// allocDebugMarkerObjectTagInfoEXTMemory allocates memory for type C.VkDebugMarkerObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectTagInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectTagInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectTagInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectTagInfoEXT) Ref() *C.VkDebugMarkerObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa41a5c3b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectTagInfoEXT) Free() {
	if x != nil && x.allocsa41a5c3b != nil {
		x.allocsa41a5c3b.(*cgoAllocMap).Free()
		x.refa41a5c3b = nil
	}
}

// NewDebugMarkerObjectTagInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectTagInfoEXTRef(ref unsafe.Pointer) *DebugMarkerObjectTagInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectTagInfoEXT)
	obj.refa41a5c3b = (*C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectTagInfoEXT) PassRef() (*C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa41a5c3b != nil {
		return x.refa41a5c3b, nil
	}
	mema41a5c3b := allocDebugMarkerObjectTagInfoEXTMemory(1)
	refa41a5c3b := (*C.VkDebugMarkerObjectTagInfoEXT)(mema41a5c3b)
	allocsa41a5c3b := new(cgoAllocMap)
	allocsa41a5c3b.Add(mema41a5c3b)

	var csType_allocs *cgoAllocMap
	refa41a5c3b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa41a5c3b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refa41a5c3b.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refa41a5c3b.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobject_allocs)

	var ctagName_allocs *cgoAllocMap
	refa41a5c3b.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	refa41a5c3b.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	refa41a5c3b.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpTag_allocs)

	x.refa41a5c3b = refa41a5c3b
	x.allocsa41a5c3b = allocsa41a5c3b
	return refa41a5c3b, allocsa41a5c3b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectTagInfoEXT) PassValue() (C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x.refa41a5c3b != nil {
		return *x.refa41a5c3b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectTagInfoEXT) Deref() {
	if x.refa41a5c3b == nil {
		return
	}
	x.SType = (StructureType)(x.refa41a5c3b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pNext))
	x.ObjectType = (DebugReportObjectTypeEXT)(x.refa41a5c3b.objectType)
	x.Object = (uint64)(x.refa41a5c3b.object)
	x.TagName = (uint64)(x.refa41a5c3b.tagName)
	x.TagSize = (uint)(x.refa41a5c3b.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pTag))
}

// allocDebugMarkerMarkerInfoEXTMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerMarkerInfoEXT) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerMarkerInfoEXT) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerMarkerInfoEXTRef(ref unsafe.Pointer) *DebugMarkerMarkerInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerMarkerInfoEXT)
	obj.ref234b91fd = (*C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerMarkerInfoEXT) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoEXTMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	allocs234b91fd.Add(mem234b91fd)

	var csType_allocs *cgoAllocMap
	ref234b91fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs234b91fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref234b91fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs234b91fd.Borrow(cpNext_allocs)

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = unpackPCharString(x.PMarkerName)
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref234b91fd.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs234b91fd.Borrow(ccolor_allocs)

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerMarkerInfoEXT) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerMarkerInfoEXT) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	x.PMarkerName = packPCharString(x.ref234b91fd.pMarkerName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// allocDedicatedAllocationImageCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationImageCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationImageCreateInfoNV) Ref() *C.VkDedicatedAllocationImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref685d878b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) Free() {
	if x != nil && x.allocs685d878b != nil {
		x.allocs685d878b.(*cgoAllocMap).Free()
		x.ref685d878b = nil
	}
}

// NewDedicatedAllocationImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationImageCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationImageCreateInfoNV)
	obj.ref685d878b = (*C.VkDedicatedAllocationImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) PassRef() (*C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685d878b != nil {
		return x.ref685d878b, nil
	}
	mem685d878b := allocDedicatedAllocationImageCreateInfoNVMemory(1)
	ref685d878b := (*C.VkDedicatedAllocationImageCreateInfoNV)(mem685d878b)
	allocs685d878b := new(cgoAllocMap)
	allocs685d878b.Add(mem685d878b)

	var csType_allocs *cgoAllocMap
	ref685d878b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs685d878b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref685d878b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs685d878b.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	ref685d878b.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocs685d878b.Borrow(cdedicatedAllocation_allocs)

	x.ref685d878b = ref685d878b
	x.allocs685d878b = allocs685d878b
	return ref685d878b, allocs685d878b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationImageCreateInfoNV) PassValue() (C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x.ref685d878b != nil {
		return *x.ref685d878b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationImageCreateInfoNV) Deref() {
	if x.ref685d878b == nil {
		return
	}
	x.SType = (StructureType)(x.ref685d878b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref685d878b.pNext))
	x.DedicatedAllocation = (Bool32)(x.ref685d878b.dedicatedAllocation)
}

// allocDedicatedAllocationBufferCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationBufferCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationBufferCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationBufferCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationBufferCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationBufferCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationBufferCreateInfoNV) Ref() *C.VkDedicatedAllocationBufferCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refbc745a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) Free() {
	if x != nil && x.allocsbc745a8 != nil {
		x.allocsbc745a8.(*cgoAllocMap).Free()
		x.refbc745a8 = nil
	}
}

// NewDedicatedAllocationBufferCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationBufferCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationBufferCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationBufferCreateInfoNV)
	obj.refbc745a8 = (*C.VkDedicatedAllocationBufferCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) PassRef() (*C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc745a8 != nil {
		return x.refbc745a8, nil
	}
	membc745a8 := allocDedicatedAllocationBufferCreateInfoNVMemory(1)
	refbc745a8 := (*C.VkDedicatedAllocationBufferCreateInfoNV)(membc745a8)
	allocsbc745a8 := new(cgoAllocMap)
	allocsbc745a8.Add(membc745a8)

	var csType_allocs *cgoAllocMap
	refbc745a8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc745a8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc745a8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc745a8.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	refbc745a8.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocsbc745a8.Borrow(cdedicatedAllocation_allocs)

	x.refbc745a8 = refbc745a8
	x.allocsbc745a8 = allocsbc745a8
	return refbc745a8, allocsbc745a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationBufferCreateInfoNV) PassValue() (C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x.refbc745a8 != nil {
		return *x.refbc745a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationBufferCreateInfoNV) Deref() {
	if x.refbc745a8 == nil {
		return
	}
	x.SType = (StructureType)(x.refbc745a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc745a8.pNext))
	x.DedicatedAllocation = (Bool32)(x.refbc745a8.dedicatedAllocation)
}

// allocDedicatedAllocationMemoryAllocateInfoNVMemory allocates memory for type C.VkDedicatedAllocationMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationMemoryAllocateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Ref() *C.VkDedicatedAllocationMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a72b107
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs9a72b107 != nil {
		x.allocs9a72b107.(*cgoAllocMap).Free()
		x.ref9a72b107 = nil
	}
}

// NewDedicatedAllocationMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationMemoryAllocateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationMemoryAllocateInfoNV)
	obj.ref9a72b107 = (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) PassRef() (*C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a72b107 != nil {
		return x.ref9a72b107, nil
	}
	mem9a72b107 := allocDedicatedAllocationMemoryAllocateInfoNVMemory(1)
	ref9a72b107 := (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(mem9a72b107)
	allocs9a72b107 := new(cgoAllocMap)
	allocs9a72b107.Add(mem9a72b107)

	var csType_allocs *cgoAllocMap
	ref9a72b107.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a72b107.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a72b107.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref9a72b107.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref9a72b107.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cbuffer_allocs)

	x.ref9a72b107 = ref9a72b107
	x.allocs9a72b107 = allocs9a72b107
	return ref9a72b107, allocs9a72b107

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationMemoryAllocateInfoNV) PassValue() (C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref9a72b107 != nil {
		return *x.ref9a72b107, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Deref() {
	if x.ref9a72b107 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a72b107.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a72b107.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref9a72b107.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref9a72b107.buffer))
}

// allocTextureLODGatherFormatPropertiesAMDMemory allocates memory for type C.VkTextureLODGatherFormatPropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextureLODGatherFormatPropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextureLODGatherFormatPropertiesAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextureLODGatherFormatPropertiesAMDValue = unsafe.Sizeof([1]C.VkTextureLODGatherFormatPropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureLODGatherFormatPropertiesAMD) Ref() *C.VkTextureLODGatherFormatPropertiesAMD {
	if x == nil {
		return nil
	}
	return x.ref519ba3a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) Free() {
	if x != nil && x.allocs519ba3a9 != nil {
		x.allocs519ba3a9.(*cgoAllocMap).Free()
		x.ref519ba3a9 = nil
	}
}

// NewTextureLODGatherFormatPropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureLODGatherFormatPropertiesAMDRef(ref unsafe.Pointer) *TextureLODGatherFormatPropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(TextureLODGatherFormatPropertiesAMD)
	obj.ref519ba3a9 = (*C.VkTextureLODGatherFormatPropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) PassRef() (*C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref519ba3a9 != nil {
		return x.ref519ba3a9, nil
	}
	mem519ba3a9 := allocTextureLODGatherFormatPropertiesAMDMemory(1)
	ref519ba3a9 := (*C.VkTextureLODGatherFormatPropertiesAMD)(mem519ba3a9)
	allocs519ba3a9 := new(cgoAllocMap)
	allocs519ba3a9.Add(mem519ba3a9)

	var csType_allocs *cgoAllocMap
	ref519ba3a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref519ba3a9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs519ba3a9.Borrow(cpNext_allocs)

	var csupportsTextureGatherLODBiasAMD_allocs *cgoAllocMap
	ref519ba3a9.supportsTextureGatherLODBiasAMD, csupportsTextureGatherLODBiasAMD_allocs = (C.VkBool32)(x.SupportsTextureGatherLODBiasAMD), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csupportsTextureGatherLODBiasAMD_allocs)

	x.ref519ba3a9 = ref519ba3a9
	x.allocs519ba3a9 = allocs519ba3a9
	return ref519ba3a9, allocs519ba3a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureLODGatherFormatPropertiesAMD) PassValue() (C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x.ref519ba3a9 != nil {
		return *x.ref519ba3a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextureLODGatherFormatPropertiesAMD) Deref() {
	if x.ref519ba3a9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref519ba3a9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref519ba3a9.pNext))
	x.SupportsTextureGatherLODBiasAMD = (Bool32)(x.ref519ba3a9.supportsTextureGatherLODBiasAMD)
}

// allocShaderResourceUsageAMDMemory allocates memory for type C.VkShaderResourceUsageAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderResourceUsageAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderResourceUsageAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderResourceUsageAMDValue = unsafe.Sizeof([1]C.VkShaderResourceUsageAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderResourceUsageAMD) Ref() *C.VkShaderResourceUsageAMD {
	if x == nil {
		return nil
	}
	return x.ref8a688131
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderResourceUsageAMD) Free() {
	if x != nil && x.allocs8a688131 != nil {
		x.allocs8a688131.(*cgoAllocMap).Free()
		x.ref8a688131 = nil
	}
}

// NewShaderResourceUsageAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderResourceUsageAMDRef(ref unsafe.Pointer) *ShaderResourceUsageAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderResourceUsageAMD)
	obj.ref8a688131 = (*C.VkShaderResourceUsageAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderResourceUsageAMD) PassRef() (*C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a688131 != nil {
		return x.ref8a688131, nil
	}
	mem8a688131 := allocShaderResourceUsageAMDMemory(1)
	ref8a688131 := (*C.VkShaderResourceUsageAMD)(mem8a688131)
	allocs8a688131 := new(cgoAllocMap)
	allocs8a688131.Add(mem8a688131)

	var cnumUsedVgprs_allocs *cgoAllocMap
	ref8a688131.numUsedVgprs, cnumUsedVgprs_allocs = (C.uint32_t)(x.NumUsedVgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedVgprs_allocs)

	var cnumUsedSgprs_allocs *cgoAllocMap
	ref8a688131.numUsedSgprs, cnumUsedSgprs_allocs = (C.uint32_t)(x.NumUsedSgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedSgprs_allocs)

	var cldsSizePerLocalWorkGroup_allocs *cgoAllocMap
	ref8a688131.ldsSizePerLocalWorkGroup, cldsSizePerLocalWorkGroup_allocs = (C.uint32_t)(x.LdsSizePerLocalWorkGroup), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsSizePerLocalWorkGroup_allocs)

	var cldsUsageSizeInBytes_allocs *cgoAllocMap
	ref8a688131.ldsUsageSizeInBytes, cldsUsageSizeInBytes_allocs = (C.size_t)(x.LdsUsageSizeInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsUsageSizeInBytes_allocs)

	var cscratchMemUsageInBytes_allocs *cgoAllocMap
	ref8a688131.scratchMemUsageInBytes, cscratchMemUsageInBytes_allocs = (C.size_t)(x.ScratchMemUsageInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cscratchMemUsageInBytes_allocs)

	x.ref8a688131 = ref8a688131
	x.allocs8a688131 = allocs8a688131
	return ref8a688131, allocs8a688131

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderResourceUsageAMD) PassValue() (C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x.ref8a688131 != nil {
		return *x.ref8a688131, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderResourceUsageAMD) Deref() {
	if x.ref8a688131 == nil {
		return
	}
	x.NumUsedVgprs = (uint32)(x.ref8a688131.numUsedVgprs)
	x.NumUsedSgprs = (uint32)(x.ref8a688131.numUsedSgprs)
	x.LdsSizePerLocalWorkGroup = (uint32)(x.ref8a688131.ldsSizePerLocalWorkGroup)
	x.LdsUsageSizeInBytes = (uint)(x.ref8a688131.ldsUsageSizeInBytes)
	x.ScratchMemUsageInBytes = (uint)(x.ref8a688131.scratchMemUsageInBytes)
}

// allocShaderStatisticsInfoAMDMemory allocates memory for type C.VkShaderStatisticsInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderStatisticsInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderStatisticsInfoAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderStatisticsInfoAMDValue = unsafe.Sizeof([1]C.VkShaderStatisticsInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderStatisticsInfoAMD) Ref() *C.VkShaderStatisticsInfoAMD {
	if x == nil {
		return nil
	}
	return x.ref896a52bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderStatisticsInfoAMD) Free() {
	if x != nil && x.allocs896a52bf != nil {
		x.allocs896a52bf.(*cgoAllocMap).Free()
		x.ref896a52bf = nil
	}
}

// NewShaderStatisticsInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderStatisticsInfoAMDRef(ref unsafe.Pointer) *ShaderStatisticsInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderStatisticsInfoAMD)
	obj.ref896a52bf = (*C.VkShaderStatisticsInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderStatisticsInfoAMD) PassRef() (*C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref896a52bf != nil {
		return x.ref896a52bf, nil
	}
	mem896a52bf := allocShaderStatisticsInfoAMDMemory(1)
	ref896a52bf := (*C.VkShaderStatisticsInfoAMD)(mem896a52bf)
	allocs896a52bf := new(cgoAllocMap)
	allocs896a52bf.Add(mem896a52bf)

	var cshaderStageMask_allocs *cgoAllocMap
	ref896a52bf.shaderStageMask, cshaderStageMask_allocs = (C.VkShaderStageFlags)(x.ShaderStageMask), cgoAllocsUnknown
	allocs896a52bf.Borrow(cshaderStageMask_allocs)

	var cresourceUsage_allocs *cgoAllocMap
	ref896a52bf.resourceUsage, cresourceUsage_allocs = x.ResourceUsage.PassValue()
	allocs896a52bf.Borrow(cresourceUsage_allocs)

	var cnumPhysicalVgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalVgprs, cnumPhysicalVgprs_allocs = (C.uint32_t)(x.NumPhysicalVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalVgprs_allocs)

	var cnumPhysicalSgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalSgprs, cnumPhysicalSgprs_allocs = (C.uint32_t)(x.NumPhysicalSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalSgprs_allocs)

	var cnumAvailableVgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableVgprs, cnumAvailableVgprs_allocs = (C.uint32_t)(x.NumAvailableVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableVgprs_allocs)

	var cnumAvailableSgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableSgprs, cnumAvailableSgprs_allocs = (C.uint32_t)(x.NumAvailableSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableSgprs_allocs)

	var ccomputeWorkGroupSize_allocs *cgoAllocMap
	ref896a52bf.computeWorkGroupSize, ccomputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.ComputeWorkGroupSize)), cgoAllocsUnknown
	allocs896a52bf.Borrow(ccomputeWorkGroupSize_allocs)

	x.ref896a52bf = ref896a52bf
	x.allocs896a52bf = allocs896a52bf
	return ref896a52bf, allocs896a52bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderStatisticsInfoAMD) PassValue() (C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x.ref896a52bf != nil {
		return *x.ref896a52bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderStatisticsInfoAMD) Deref() {
	if x.ref896a52bf == nil {
		return
	}
	x.ShaderStageMask = (ShaderStageFlags)(x.ref896a52bf.shaderStageMask)
	x.ResourceUsage = *NewShaderResourceUsageAMDRef(unsafe.Pointer(&x.ref896a52bf.resourceUsage))
	x.NumPhysicalVgprs = (uint32)(x.ref896a52bf.numPhysicalVgprs)
	x.NumPhysicalSgprs = (uint32)(x.ref896a52bf.numPhysicalSgprs)
	x.NumAvailableVgprs = (uint32)(x.ref896a52bf.numAvailableVgprs)
	x.NumAvailableSgprs = (uint32)(x.ref896a52bf.numAvailableSgprs)
	x.ComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref896a52bf.computeWorkGroupSize))
}

// allocExternalImageFormatPropertiesNVMemory allocates memory for type C.VkExternalImageFormatPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesNVValue = unsafe.Sizeof([1]C.VkExternalImageFormatPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatPropertiesNV) Ref() *C.VkExternalImageFormatPropertiesNV {
	if x == nil {
		return nil
	}
	return x.refa8900ce5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatPropertiesNV) Free() {
	if x != nil && x.allocsa8900ce5 != nil {
		x.allocsa8900ce5.(*cgoAllocMap).Free()
		x.refa8900ce5 = nil
	}
}

// NewExternalImageFormatPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesNVRef(ref unsafe.Pointer) *ExternalImageFormatPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatPropertiesNV)
	obj.refa8900ce5 = (*C.VkExternalImageFormatPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatPropertiesNV) PassRef() (*C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8900ce5 != nil {
		return x.refa8900ce5, nil
	}
	mema8900ce5 := allocExternalImageFormatPropertiesNVMemory(1)
	refa8900ce5 := (*C.VkExternalImageFormatPropertiesNV)(mema8900ce5)
	allocsa8900ce5 := new(cgoAllocMap)
	allocsa8900ce5.Add(mema8900ce5)

	var cimageFormatProperties_allocs *cgoAllocMap
	refa8900ce5.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocsa8900ce5.Borrow(cimageFormatProperties_allocs)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	refa8900ce5.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlagsNV)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	refa8900ce5.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	refa8900ce5.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(ccompatibleHandleTypes_allocs)

	x.refa8900ce5 = refa8900ce5
	x.allocsa8900ce5 = allocsa8900ce5
	return refa8900ce5, allocsa8900ce5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatPropertiesNV) PassValue() (C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x.refa8900ce5 != nil {
		return *x.refa8900ce5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatPropertiesNV) Deref() {
	if x.refa8900ce5 == nil {
		return
	}
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.refa8900ce5.imageFormatProperties))
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlagsNV)(x.refa8900ce5.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.compatibleHandleTypes)
}

// allocExternalMemoryImageCreateInfoNVMemory allocates memory for type C.VkExternalMemoryImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfoNV) Ref() *C.VkExternalMemoryImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a7fb6c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfoNV) Free() {
	if x != nil && x.allocs9a7fb6c8 != nil {
		x.allocs9a7fb6c8.(*cgoAllocMap).Free()
		x.ref9a7fb6c8 = nil
	}
}

// NewExternalMemoryImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoNVRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfoNV)
	obj.ref9a7fb6c8 = (*C.VkExternalMemoryImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfoNV) PassRef() (*C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a7fb6c8 != nil {
		return x.ref9a7fb6c8, nil
	}
	mem9a7fb6c8 := allocExternalMemoryImageCreateInfoNVMemory(1)
	ref9a7fb6c8 := (*C.VkExternalMemoryImageCreateInfoNV)(mem9a7fb6c8)
	allocs9a7fb6c8 := new(cgoAllocMap)
	allocs9a7fb6c8.Add(mem9a7fb6c8)

	var csType_allocs *cgoAllocMap
	ref9a7fb6c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a7fb6c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref9a7fb6c8.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(chandleTypes_allocs)

	x.ref9a7fb6c8 = ref9a7fb6c8
	x.allocs9a7fb6c8 = allocs9a7fb6c8
	return ref9a7fb6c8, allocs9a7fb6c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfoNV) PassValue() (C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x.ref9a7fb6c8 != nil {
		return *x.ref9a7fb6c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfoNV) Deref() {
	if x.ref9a7fb6c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a7fb6c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a7fb6c8.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref9a7fb6c8.handleTypes)
}

// allocExportMemoryAllocateInfoNVMemory allocates memory for type C.VkExportMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfoNV) Ref() *C.VkExportMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5066f33
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs5066f33 != nil {
		x.allocs5066f33.(*cgoAllocMap).Free()
		x.ref5066f33 = nil
	}
}

// NewExportMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoNVRef(ref unsafe.Pointer) *ExportMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfoNV)
	obj.ref5066f33 = (*C.VkExportMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfoNV) PassRef() (*C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5066f33 != nil {
		return x.ref5066f33, nil
	}
	mem5066f33 := allocExportMemoryAllocateInfoNVMemory(1)
	ref5066f33 := (*C.VkExportMemoryAllocateInfoNV)(mem5066f33)
	allocs5066f33 := new(cgoAllocMap)
	allocs5066f33.Add(mem5066f33)

	var csType_allocs *cgoAllocMap
	ref5066f33.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5066f33.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5066f33.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5066f33.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5066f33.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs5066f33.Borrow(chandleTypes_allocs)

	x.ref5066f33 = ref5066f33
	x.allocs5066f33 = allocs5066f33
	return ref5066f33, allocs5066f33

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfoNV) PassValue() (C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref5066f33 != nil {
		return *x.ref5066f33, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfoNV) Deref() {
	if x.ref5066f33 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5066f33.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5066f33.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref5066f33.handleTypes)
}

// allocValidationFlagsEXTMemory allocates memory for type C.VkValidationFlagsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFlagsEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFlagsEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValidationFlagsEXTValue = unsafe.Sizeof([1]C.VkValidationFlagsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFlagsEXT) Ref() *C.VkValidationFlagsEXT {
	if x == nil {
		return nil
	}
	return x.refffe080ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFlagsEXT) Free() {
	if x != nil && x.allocsffe080ad != nil {
		x.allocsffe080ad.(*cgoAllocMap).Free()
		x.refffe080ad = nil
	}
}

// NewValidationFlagsEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFlagsEXTRef(ref unsafe.Pointer) *ValidationFlagsEXT {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFlagsEXT)
	obj.refffe080ad = (*C.VkValidationFlagsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFlagsEXT) PassRef() (*C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe080ad != nil {
		return x.refffe080ad, nil
	}
	memffe080ad := allocValidationFlagsEXTMemory(1)
	refffe080ad := (*C.VkValidationFlagsEXT)(memffe080ad)
	allocsffe080ad := new(cgoAllocMap)
	allocsffe080ad.Add(memffe080ad)

	var csType_allocs *cgoAllocMap
	refffe080ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffe080ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffe080ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffe080ad.Borrow(cpNext_allocs)

	var cdisabledValidationCheckCount_allocs *cgoAllocMap
	refffe080ad.disabledValidationCheckCount, cdisabledValidationCheckCount_allocs = (C.uint32_t)(x.DisabledValidationCheckCount), cgoAllocsUnknown
	allocsffe080ad.Borrow(cdisabledValidationCheckCount_allocs)

	var cpDisabledValidationChecks_allocs *cgoAllocMap
	refffe080ad.pDisabledValidationChecks, cpDisabledValidationChecks_allocs = (*C.VkValidationCheckEXT)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks)).Data)), cgoAllocsUnknown
	allocsffe080ad.Borrow(cpDisabledValidationChecks_allocs)

	x.refffe080ad = refffe080ad
	x.allocsffe080ad = allocsffe080ad
	return refffe080ad, allocsffe080ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFlagsEXT) PassValue() (C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x.refffe080ad != nil {
		return *x.refffe080ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFlagsEXT) Deref() {
	if x.refffe080ad == nil {
		return
	}
	x.SType = (StructureType)(x.refffe080ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe080ad.pNext))
	x.DisabledValidationCheckCount = (uint32)(x.refffe080ad.disabledValidationCheckCount)
	hxf458096 := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks))
	hxf458096.Data = unsafe.Pointer(x.refffe080ad.pDisabledValidationChecks)
	hxf458096.Cap = 0x7fffffff
	// hxf458096.Len = ?

}

// allocConditionalRenderingBeginInfoEXTMemory allocates memory for type C.VkConditionalRenderingBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConditionalRenderingBeginInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConditionalRenderingBeginInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfConditionalRenderingBeginInfoEXTValue = unsafe.Sizeof([1]C.VkConditionalRenderingBeginInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConditionalRenderingBeginInfoEXT) Ref() *C.VkConditionalRenderingBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref82da87c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConditionalRenderingBeginInfoEXT) Free() {
	if x != nil && x.allocs82da87c9 != nil {
		x.allocs82da87c9.(*cgoAllocMap).Free()
		x.ref82da87c9 = nil
	}
}

// NewConditionalRenderingBeginInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConditionalRenderingBeginInfoEXTRef(ref unsafe.Pointer) *ConditionalRenderingBeginInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(ConditionalRenderingBeginInfoEXT)
	obj.ref82da87c9 = (*C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConditionalRenderingBeginInfoEXT) PassRef() (*C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82da87c9 != nil {
		return x.ref82da87c9, nil
	}
	mem82da87c9 := allocConditionalRenderingBeginInfoEXTMemory(1)
	ref82da87c9 := (*C.VkConditionalRenderingBeginInfoEXT)(mem82da87c9)
	allocs82da87c9 := new(cgoAllocMap)
	allocs82da87c9.Add(mem82da87c9)

	var csType_allocs *cgoAllocMap
	ref82da87c9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82da87c9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82da87c9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref82da87c9.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref82da87c9.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs82da87c9.Borrow(coffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref82da87c9.flags, cflags_allocs = (C.VkConditionalRenderingFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs82da87c9.Borrow(cflags_allocs)

	x.ref82da87c9 = ref82da87c9
	x.allocs82da87c9 = allocs82da87c9
	return ref82da87c9, allocs82da87c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConditionalRenderingBeginInfoEXT) PassValue() (C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x.ref82da87c9 != nil {
		return *x.ref82da87c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConditionalRenderingBeginInfoEXT) Deref() {
	if x.ref82da87c9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref82da87c9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82da87c9.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref82da87c9.buffer))
	x.Offset = (DeviceSize)(x.ref82da87c9.offset)
	x.Flags = (ConditionalRenderingFlagsEXT)(x.ref82da87c9.flags)
}

// allocPhysicalDeviceConditionalRenderingFeaturesEXTMemory allocates memory for type C.VkPhysicalDeviceConditionalRenderingFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConditionalRenderingFeaturesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConditionalRenderingFeaturesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceConditionalRenderingFeaturesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConditionalRenderingFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConditionalRenderingFeaturesEXT) Ref() *C.VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref89d2a224
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConditionalRenderingFeaturesEXT) Free() {
	if x != nil && x.allocs89d2a224 != nil {
		x.allocs89d2a224.(*cgoAllocMap).Free()
		x.ref89d2a224 = nil
	}
}

// NewPhysicalDeviceConditionalRenderingFeaturesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConditionalRenderingFeaturesEXTRef(ref unsafe.Pointer) *PhysicalDeviceConditionalRenderingFeaturesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConditionalRenderingFeaturesEXT)
	obj.ref89d2a224 = (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConditionalRenderingFeaturesEXT) PassRef() (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89d2a224 != nil {
		return x.ref89d2a224, nil
	}
	mem89d2a224 := allocPhysicalDeviceConditionalRenderingFeaturesEXTMemory(1)
	ref89d2a224 := (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(mem89d2a224)
	allocs89d2a224 := new(cgoAllocMap)
	allocs89d2a224.Add(mem89d2a224)

	var csType_allocs *cgoAllocMap
	ref89d2a224.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs89d2a224.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref89d2a224.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs89d2a224.Borrow(cpNext_allocs)

	var cconditionalRendering_allocs *cgoAllocMap
	ref89d2a224.conditionalRendering, cconditionalRendering_allocs = (C.VkBool32)(x.ConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cconditionalRendering_allocs)

	var cinheritedConditionalRendering_allocs *cgoAllocMap
	ref89d2a224.inheritedConditionalRendering, cinheritedConditionalRendering_allocs = (C.VkBool32)(x.InheritedConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cinheritedConditionalRendering_allocs)

	x.ref89d2a224 = ref89d2a224
	x.allocs89d2a224 = allocs89d2a224
	return ref89d2a224, allocs89d2a224

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConditionalRenderingFeaturesEXT) PassValue() (C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x.ref89d2a224 != nil {
		return *x.ref89d2a224, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConditionalRenderingFeaturesEXT) Deref() {
	if x.ref89d2a224 == nil {
		return
	}
	x.SType = (StructureType)(x.ref89d2a224.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref89d2a224.pNext))
	x.ConditionalRendering = (Bool32)(x.ref89d2a224.conditionalRendering)
	x.InheritedConditionalRendering = (Bool32)(x.ref89d2a224.inheritedConditionalRendering)
}

// allocCommandBufferInheritanceConditionalRenderingInfoEXTMemory allocates memory for type C.VkCommandBufferInheritanceConditionalRenderingInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceConditionalRenderingInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceConditionalRenderingInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceConditionalRenderingInfoEXTValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceConditionalRenderingInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceConditionalRenderingInfoEXT) Ref() *C.VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref7155f49c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfoEXT) Free() {
	if x != nil && x.allocs7155f49c != nil {
		x.allocs7155f49c.(*cgoAllocMap).Free()
		x.ref7155f49c = nil
	}
}

// NewCommandBufferInheritanceConditionalRenderingInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceConditionalRenderingInfoEXTRef(ref unsafe.Pointer) *CommandBufferInheritanceConditionalRenderingInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceConditionalRenderingInfoEXT)
	obj.ref7155f49c = (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfoEXT) PassRef() (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7155f49c != nil {
		return x.ref7155f49c, nil
	}
	mem7155f49c := allocCommandBufferInheritanceConditionalRenderingInfoEXTMemory(1)
	ref7155f49c := (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(mem7155f49c)
	allocs7155f49c := new(cgoAllocMap)
	allocs7155f49c.Add(mem7155f49c)

	var csType_allocs *cgoAllocMap
	ref7155f49c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7155f49c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7155f49c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7155f49c.Borrow(cpNext_allocs)

	var cconditionalRenderingEnable_allocs *cgoAllocMap
	ref7155f49c.conditionalRenderingEnable, cconditionalRenderingEnable_allocs = (C.VkBool32)(x.ConditionalRenderingEnable), cgoAllocsUnknown
	allocs7155f49c.Borrow(cconditionalRenderingEnable_allocs)

	x.ref7155f49c = ref7155f49c
	x.allocs7155f49c = allocs7155f49c
	return ref7155f49c, allocs7155f49c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceConditionalRenderingInfoEXT) PassValue() (C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x.ref7155f49c != nil {
		return *x.ref7155f49c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceConditionalRenderingInfoEXT) Deref() {
	if x.ref7155f49c == nil {
		return
	}
	x.SType = (StructureType)(x.ref7155f49c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7155f49c.pNext))
	x.ConditionalRenderingEnable = (Bool32)(x.ref7155f49c.conditionalRenderingEnable)
}

// allocDeviceGeneratedCommandsFeaturesNVXMemory allocates memory for type C.VkDeviceGeneratedCommandsFeaturesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGeneratedCommandsFeaturesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGeneratedCommandsFeaturesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGeneratedCommandsFeaturesNVXValue = unsafe.Sizeof([1]C.VkDeviceGeneratedCommandsFeaturesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGeneratedCommandsFeaturesNVX) Ref() *C.VkDeviceGeneratedCommandsFeaturesNVX {
	if x == nil {
		return nil
	}
	return x.ref489899be
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGeneratedCommandsFeaturesNVX) Free() {
	if x != nil && x.allocs489899be != nil {
		x.allocs489899be.(*cgoAllocMap).Free()
		x.ref489899be = nil
	}
}

// NewDeviceGeneratedCommandsFeaturesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGeneratedCommandsFeaturesNVXRef(ref unsafe.Pointer) *DeviceGeneratedCommandsFeaturesNVX {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGeneratedCommandsFeaturesNVX)
	obj.ref489899be = (*C.VkDeviceGeneratedCommandsFeaturesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGeneratedCommandsFeaturesNVX) PassRef() (*C.VkDeviceGeneratedCommandsFeaturesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref489899be != nil {
		return x.ref489899be, nil
	}
	mem489899be := allocDeviceGeneratedCommandsFeaturesNVXMemory(1)
	ref489899be := (*C.VkDeviceGeneratedCommandsFeaturesNVX)(mem489899be)
	allocs489899be := new(cgoAllocMap)
	allocs489899be.Add(mem489899be)

	var csType_allocs *cgoAllocMap
	ref489899be.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs489899be.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref489899be.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs489899be.Borrow(cpNext_allocs)

	var ccomputeBindingPointSupport_allocs *cgoAllocMap
	ref489899be.computeBindingPointSupport, ccomputeBindingPointSupport_allocs = (C.VkBool32)(x.ComputeBindingPointSupport), cgoAllocsUnknown
	allocs489899be.Borrow(ccomputeBindingPointSupport_allocs)

	x.ref489899be = ref489899be
	x.allocs489899be = allocs489899be
	return ref489899be, allocs489899be

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGeneratedCommandsFeaturesNVX) PassValue() (C.VkDeviceGeneratedCommandsFeaturesNVX, *cgoAllocMap) {
	if x.ref489899be != nil {
		return *x.ref489899be, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGeneratedCommandsFeaturesNVX) Deref() {
	if x.ref489899be == nil {
		return
	}
	x.SType = (StructureType)(x.ref489899be.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref489899be.pNext))
	x.ComputeBindingPointSupport = (Bool32)(x.ref489899be.computeBindingPointSupport)
}

// allocDeviceGeneratedCommandsLimitsNVXMemory allocates memory for type C.VkDeviceGeneratedCommandsLimitsNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGeneratedCommandsLimitsNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGeneratedCommandsLimitsNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGeneratedCommandsLimitsNVXValue = unsafe.Sizeof([1]C.VkDeviceGeneratedCommandsLimitsNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGeneratedCommandsLimitsNVX) Ref() *C.VkDeviceGeneratedCommandsLimitsNVX {
	if x == nil {
		return nil
	}
	return x.refb2b76f40
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGeneratedCommandsLimitsNVX) Free() {
	if x != nil && x.allocsb2b76f40 != nil {
		x.allocsb2b76f40.(*cgoAllocMap).Free()
		x.refb2b76f40 = nil
	}
}

// NewDeviceGeneratedCommandsLimitsNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGeneratedCommandsLimitsNVXRef(ref unsafe.Pointer) *DeviceGeneratedCommandsLimitsNVX {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGeneratedCommandsLimitsNVX)
	obj.refb2b76f40 = (*C.VkDeviceGeneratedCommandsLimitsNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGeneratedCommandsLimitsNVX) PassRef() (*C.VkDeviceGeneratedCommandsLimitsNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2b76f40 != nil {
		return x.refb2b76f40, nil
	}
	memb2b76f40 := allocDeviceGeneratedCommandsLimitsNVXMemory(1)
	refb2b76f40 := (*C.VkDeviceGeneratedCommandsLimitsNVX)(memb2b76f40)
	allocsb2b76f40 := new(cgoAllocMap)
	allocsb2b76f40.Add(memb2b76f40)

	var csType_allocs *cgoAllocMap
	refb2b76f40.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2b76f40.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2b76f40.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cpNext_allocs)

	var cmaxIndirectCommandsLayoutTokenCount_allocs *cgoAllocMap
	refb2b76f40.maxIndirectCommandsLayoutTokenCount, cmaxIndirectCommandsLayoutTokenCount_allocs = (C.uint32_t)(x.MaxIndirectCommandsLayoutTokenCount), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cmaxIndirectCommandsLayoutTokenCount_allocs)

	var cmaxObjectEntryCounts_allocs *cgoAllocMap
	refb2b76f40.maxObjectEntryCounts, cmaxObjectEntryCounts_allocs = (C.uint32_t)(x.MaxObjectEntryCounts), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cmaxObjectEntryCounts_allocs)

	var cminSequenceCountBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minSequenceCountBufferOffsetAlignment, cminSequenceCountBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequenceCountBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminSequenceCountBufferOffsetAlignment_allocs)

	var cminSequenceIndexBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minSequenceIndexBufferOffsetAlignment, cminSequenceIndexBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequenceIndexBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminSequenceIndexBufferOffsetAlignment_allocs)

	var cminCommandsTokenBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minCommandsTokenBufferOffsetAlignment, cminCommandsTokenBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinCommandsTokenBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminCommandsTokenBufferOffsetAlignment_allocs)

	x.refb2b76f40 = refb2b76f40
	x.allocsb2b76f40 = allocsb2b76f40
	return refb2b76f40, allocsb2b76f40

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGeneratedCommandsLimitsNVX) PassValue() (C.VkDeviceGeneratedCommandsLimitsNVX, *cgoAllocMap) {
	if x.refb2b76f40 != nil {
		return *x.refb2b76f40, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGeneratedCommandsLimitsNVX) Deref() {
	if x.refb2b76f40 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2b76f40.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2b76f40.pNext))
	x.MaxIndirectCommandsLayoutTokenCount = (uint32)(x.refb2b76f40.maxIndirectCommandsLayoutTokenCount)
	x.MaxObjectEntryCounts = (uint32)(x.refb2b76f40.maxObjectEntryCounts)
	x.MinSequenceCountBufferOffsetAlignment = (uint32)(x.refb2b76f40.minSequenceCountBufferOffsetAlignment)
	x.MinSequenceIndexBufferOffsetAlignment = (uint32)(x.refb2b76f40.minSequenceIndexBufferOffsetAlignment)
	x.MinCommandsTokenBufferOffsetAlignment = (uint32)(x.refb2b76f40.minCommandsTokenBufferOffsetAlignment)
}

// allocIndirectCommandsTokenNVXMemory allocates memory for type C.VkIndirectCommandsTokenNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsTokenNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsTokenNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsTokenNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsTokenNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsTokenNVX) Ref() *C.VkIndirectCommandsTokenNVX {
	if x == nil {
		return nil
	}
	return x.ref8a2daca5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsTokenNVX) Free() {
	if x != nil && x.allocs8a2daca5 != nil {
		x.allocs8a2daca5.(*cgoAllocMap).Free()
		x.ref8a2daca5 = nil
	}
}

// NewIndirectCommandsTokenNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsTokenNVXRef(ref unsafe.Pointer) *IndirectCommandsTokenNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsTokenNVX)
	obj.ref8a2daca5 = (*C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsTokenNVX) PassRef() (*C.VkIndirectCommandsTokenNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a2daca5 != nil {
		return x.ref8a2daca5, nil
	}
	mem8a2daca5 := allocIndirectCommandsTokenNVXMemory(1)
	ref8a2daca5 := (*C.VkIndirectCommandsTokenNVX)(mem8a2daca5)
	allocs8a2daca5 := new(cgoAllocMap)
	allocs8a2daca5.Add(mem8a2daca5)

	var ctokenType_allocs *cgoAllocMap
	ref8a2daca5.tokenType, ctokenType_allocs = (C.VkIndirectCommandsTokenTypeNVX)(x.TokenType), cgoAllocsUnknown
	allocs8a2daca5.Borrow(ctokenType_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref8a2daca5.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs8a2daca5.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref8a2daca5.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs8a2daca5.Borrow(coffset_allocs)

	x.ref8a2daca5 = ref8a2daca5
	x.allocs8a2daca5 = allocs8a2daca5
	return ref8a2daca5, allocs8a2daca5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsTokenNVX) PassValue() (C.VkIndirectCommandsTokenNVX, *cgoAllocMap) {
	if x.ref8a2daca5 != nil {
		return *x.ref8a2daca5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsTokenNVX) Deref() {
	if x.ref8a2daca5 == nil {
		return
	}
	x.TokenType = (IndirectCommandsTokenTypeNVX)(x.ref8a2daca5.tokenType)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref8a2daca5.buffer))
	x.Offset = (DeviceSize)(x.ref8a2daca5.offset)
}

// allocIndirectCommandsLayoutTokenNVXMemory allocates memory for type C.VkIndirectCommandsLayoutTokenNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutTokenNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutTokenNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsLayoutTokenNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutTokenNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutTokenNVX) Ref() *C.VkIndirectCommandsLayoutTokenNVX {
	if x == nil {
		return nil
	}
	return x.refe421769
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutTokenNVX) Free() {
	if x != nil && x.allocse421769 != nil {
		x.allocse421769.(*cgoAllocMap).Free()
		x.refe421769 = nil
	}
}

// NewIndirectCommandsLayoutTokenNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutTokenNVXRef(ref unsafe.Pointer) *IndirectCommandsLayoutTokenNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutTokenNVX)
	obj.refe421769 = (*C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutTokenNVX) PassRef() (*C.VkIndirectCommandsLayoutTokenNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe421769 != nil {
		return x.refe421769, nil
	}
	meme421769 := allocIndirectCommandsLayoutTokenNVXMemory(1)
	refe421769 := (*C.VkIndirectCommandsLayoutTokenNVX)(meme421769)
	allocse421769 := new(cgoAllocMap)
	allocse421769.Add(meme421769)

	var ctokenType_allocs *cgoAllocMap
	refe421769.tokenType, ctokenType_allocs = (C.VkIndirectCommandsTokenTypeNVX)(x.TokenType), cgoAllocsUnknown
	allocse421769.Borrow(ctokenType_allocs)

	var cbindingUnit_allocs *cgoAllocMap
	refe421769.bindingUnit, cbindingUnit_allocs = (C.uint32_t)(x.BindingUnit), cgoAllocsUnknown
	allocse421769.Borrow(cbindingUnit_allocs)

	var cdynamicCount_allocs *cgoAllocMap
	refe421769.dynamicCount, cdynamicCount_allocs = (C.uint32_t)(x.DynamicCount), cgoAllocsUnknown
	allocse421769.Borrow(cdynamicCount_allocs)

	var cdivisor_allocs *cgoAllocMap
	refe421769.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocse421769.Borrow(cdivisor_allocs)

	x.refe421769 = refe421769
	x.allocse421769 = allocse421769
	return refe421769, allocse421769

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutTokenNVX) PassValue() (C.VkIndirectCommandsLayoutTokenNVX, *cgoAllocMap) {
	if x.refe421769 != nil {
		return *x.refe421769, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutTokenNVX) Deref() {
	if x.refe421769 == nil {
		return
	}
	x.TokenType = (IndirectCommandsTokenTypeNVX)(x.refe421769.tokenType)
	x.BindingUnit = (uint32)(x.refe421769.bindingUnit)
	x.DynamicCount = (uint32)(x.refe421769.dynamicCount)
	x.Divisor = (uint32)(x.refe421769.divisor)
}

// allocIndirectCommandsLayoutCreateInfoNVXMemory allocates memory for type C.VkIndirectCommandsLayoutCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsLayoutCreateInfoNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutCreateInfoNVX{})

// unpackSIndirectCommandsLayoutTokenNVX transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsLayoutTokenNVX(x []IndirectCommandsLayoutTokenNVX) (unpacked *C.VkIndirectCommandsLayoutTokenNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkIndirectCommandsLayoutTokenNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsLayoutTokenNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsLayoutTokenNVX)(h.Data)
	return
}

// packSIndirectCommandsLayoutTokenNVX reads sliced Go data structure out from plain C format.
func packSIndirectCommandsLayoutTokenNVX(v []IndirectCommandsLayoutTokenNVX, ptr0 *C.VkIndirectCommandsLayoutTokenNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsLayoutTokenNVXValue]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsLayoutTokenNVXRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutCreateInfoNVX) Ref() *C.VkIndirectCommandsLayoutCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref2a2866d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutCreateInfoNVX) Free() {
	if x != nil && x.allocs2a2866d5 != nil {
		x.allocs2a2866d5.(*cgoAllocMap).Free()
		x.ref2a2866d5 = nil
	}
}

// NewIndirectCommandsLayoutCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutCreateInfoNVXRef(ref unsafe.Pointer) *IndirectCommandsLayoutCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutCreateInfoNVX)
	obj.ref2a2866d5 = (*C.VkIndirectCommandsLayoutCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutCreateInfoNVX) PassRef() (*C.VkIndirectCommandsLayoutCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a2866d5 != nil {
		return x.ref2a2866d5, nil
	}
	mem2a2866d5 := allocIndirectCommandsLayoutCreateInfoNVXMemory(1)
	ref2a2866d5 := (*C.VkIndirectCommandsLayoutCreateInfoNVX)(mem2a2866d5)
	allocs2a2866d5 := new(cgoAllocMap)
	allocs2a2866d5.Add(mem2a2866d5)

	var csType_allocs *cgoAllocMap
	ref2a2866d5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a2866d5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a2866d5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cpNext_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2a2866d5.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cpipelineBindPoint_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a2866d5.flags, cflags_allocs = (C.VkIndirectCommandsLayoutUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cflags_allocs)

	var ctokenCount_allocs *cgoAllocMap
	ref2a2866d5.tokenCount, ctokenCount_allocs = (C.uint32_t)(x.TokenCount), cgoAllocsUnknown
	allocs2a2866d5.Borrow(ctokenCount_allocs)

	var cpTokens_allocs *cgoAllocMap
	ref2a2866d5.pTokens, cpTokens_allocs = unpackSIndirectCommandsLayoutTokenNVX(x.PTokens)
	allocs2a2866d5.Borrow(cpTokens_allocs)

	x.ref2a2866d5 = ref2a2866d5
	x.allocs2a2866d5 = allocs2a2866d5
	return ref2a2866d5, allocs2a2866d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutCreateInfoNVX) PassValue() (C.VkIndirectCommandsLayoutCreateInfoNVX, *cgoAllocMap) {
	if x.ref2a2866d5 != nil {
		return *x.ref2a2866d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutCreateInfoNVX) Deref() {
	if x.ref2a2866d5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a2866d5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a2866d5.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2a2866d5.pipelineBindPoint)
	x.Flags = (IndirectCommandsLayoutUsageFlagsNVX)(x.ref2a2866d5.flags)
	x.TokenCount = (uint32)(x.ref2a2866d5.tokenCount)
	packSIndirectCommandsLayoutTokenNVX(x.PTokens, x.ref2a2866d5.pTokens)
}

// allocCmdProcessCommandsInfoNVXMemory allocates memory for type C.VkCmdProcessCommandsInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmdProcessCommandsInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmdProcessCommandsInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmdProcessCommandsInfoNVXValue = unsafe.Sizeof([1]C.VkCmdProcessCommandsInfoNVX{})

// unpackSIndirectCommandsTokenNVX transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsTokenNVX(x []IndirectCommandsTokenNVX) (unpacked *C.VkIndirectCommandsTokenNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkIndirectCommandsTokenNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsTokenNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsTokenNVX)(h.Data)
	return
}

// packSIndirectCommandsTokenNVX reads sliced Go data structure out from plain C format.
func packSIndirectCommandsTokenNVX(v []IndirectCommandsTokenNVX, ptr0 *C.VkIndirectCommandsTokenNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsTokenNVXValue]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsTokenNVXRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmdProcessCommandsInfoNVX) Ref() *C.VkCmdProcessCommandsInfoNVX {
	if x == nil {
		return nil
	}
	return x.refcd94895d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmdProcessCommandsInfoNVX) Free() {
	if x != nil && x.allocscd94895d != nil {
		x.allocscd94895d.(*cgoAllocMap).Free()
		x.refcd94895d = nil
	}
}

// NewCmdProcessCommandsInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmdProcessCommandsInfoNVXRef(ref unsafe.Pointer) *CmdProcessCommandsInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(CmdProcessCommandsInfoNVX)
	obj.refcd94895d = (*C.VkCmdProcessCommandsInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmdProcessCommandsInfoNVX) PassRef() (*C.VkCmdProcessCommandsInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd94895d != nil {
		return x.refcd94895d, nil
	}
	memcd94895d := allocCmdProcessCommandsInfoNVXMemory(1)
	refcd94895d := (*C.VkCmdProcessCommandsInfoNVX)(memcd94895d)
	allocscd94895d := new(cgoAllocMap)
	allocscd94895d.Add(memcd94895d)

	var csType_allocs *cgoAllocMap
	refcd94895d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd94895d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd94895d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd94895d.Borrow(cpNext_allocs)

	var cobjectTable_allocs *cgoAllocMap
	refcd94895d.objectTable, cobjectTable_allocs = *(*C.VkObjectTableNVX)(unsafe.Pointer(&x.ObjectTable)), cgoAllocsUnknown
	allocscd94895d.Borrow(cobjectTable_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	refcd94895d.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNVX)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocscd94895d.Borrow(cindirectCommandsLayout_allocs)

	var cindirectCommandsTokenCount_allocs *cgoAllocMap
	refcd94895d.indirectCommandsTokenCount, cindirectCommandsTokenCount_allocs = (C.uint32_t)(x.IndirectCommandsTokenCount), cgoAllocsUnknown
	allocscd94895d.Borrow(cindirectCommandsTokenCount_allocs)

	var cpIndirectCommandsTokens_allocs *cgoAllocMap
	refcd94895d.pIndirectCommandsTokens, cpIndirectCommandsTokens_allocs = unpackSIndirectCommandsTokenNVX(x.PIndirectCommandsTokens)
	allocscd94895d.Borrow(cpIndirectCommandsTokens_allocs)

	var cmaxSequencesCount_allocs *cgoAllocMap
	refcd94895d.maxSequencesCount, cmaxSequencesCount_allocs = (C.uint32_t)(x.MaxSequencesCount), cgoAllocsUnknown
	allocscd94895d.Borrow(cmaxSequencesCount_allocs)

	var ctargetCommandBuffer_allocs *cgoAllocMap
	refcd94895d.targetCommandBuffer, ctargetCommandBuffer_allocs = *(*C.VkCommandBuffer)(unsafe.Pointer(&x.TargetCommandBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(ctargetCommandBuffer_allocs)

	var csequencesCountBuffer_allocs *cgoAllocMap
	refcd94895d.sequencesCountBuffer, csequencesCountBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesCountBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesCountBuffer_allocs)

	var csequencesCountOffset_allocs *cgoAllocMap
	refcd94895d.sequencesCountOffset, csequencesCountOffset_allocs = (C.VkDeviceSize)(x.SequencesCountOffset), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesCountOffset_allocs)

	var csequencesIndexBuffer_allocs *cgoAllocMap
	refcd94895d.sequencesIndexBuffer, csequencesIndexBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesIndexBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesIndexBuffer_allocs)

	var csequencesIndexOffset_allocs *cgoAllocMap
	refcd94895d.sequencesIndexOffset, csequencesIndexOffset_allocs = (C.VkDeviceSize)(x.SequencesIndexOffset), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesIndexOffset_allocs)

	x.refcd94895d = refcd94895d
	x.allocscd94895d = allocscd94895d
	return refcd94895d, allocscd94895d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmdProcessCommandsInfoNVX) PassValue() (C.VkCmdProcessCommandsInfoNVX, *cgoAllocMap) {
	if x.refcd94895d != nil {
		return *x.refcd94895d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmdProcessCommandsInfoNVX) Deref() {
	if x.refcd94895d == nil {
		return
	}
	x.SType = (StructureType)(x.refcd94895d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd94895d.pNext))
	x.ObjectTable = *(*ObjectTableNVX)(unsafe.Pointer(&x.refcd94895d.objectTable))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNVX)(unsafe.Pointer(&x.refcd94895d.indirectCommandsLayout))
	x.IndirectCommandsTokenCount = (uint32)(x.refcd94895d.indirectCommandsTokenCount)
	packSIndirectCommandsTokenNVX(x.PIndirectCommandsTokens, x.refcd94895d.pIndirectCommandsTokens)
	x.MaxSequencesCount = (uint32)(x.refcd94895d.maxSequencesCount)
	x.TargetCommandBuffer = *(*CommandBuffer)(unsafe.Pointer(&x.refcd94895d.targetCommandBuffer))
	x.SequencesCountBuffer = *(*Buffer)(unsafe.Pointer(&x.refcd94895d.sequencesCountBuffer))
	x.SequencesCountOffset = (DeviceSize)(x.refcd94895d.sequencesCountOffset)
	x.SequencesIndexBuffer = *(*Buffer)(unsafe.Pointer(&x.refcd94895d.sequencesIndexBuffer))
	x.SequencesIndexOffset = (DeviceSize)(x.refcd94895d.sequencesIndexOffset)
}

// allocCmdReserveSpaceForCommandsInfoNVXMemory allocates memory for type C.VkCmdReserveSpaceForCommandsInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmdReserveSpaceForCommandsInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmdReserveSpaceForCommandsInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmdReserveSpaceForCommandsInfoNVXValue = unsafe.Sizeof([1]C.VkCmdReserveSpaceForCommandsInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmdReserveSpaceForCommandsInfoNVX) Ref() *C.VkCmdReserveSpaceForCommandsInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref900bfee5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmdReserveSpaceForCommandsInfoNVX) Free() {
	if x != nil && x.allocs900bfee5 != nil {
		x.allocs900bfee5.(*cgoAllocMap).Free()
		x.ref900bfee5 = nil
	}
}

// NewCmdReserveSpaceForCommandsInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmdReserveSpaceForCommandsInfoNVXRef(ref unsafe.Pointer) *CmdReserveSpaceForCommandsInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(CmdReserveSpaceForCommandsInfoNVX)
	obj.ref900bfee5 = (*C.VkCmdReserveSpaceForCommandsInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmdReserveSpaceForCommandsInfoNVX) PassRef() (*C.VkCmdReserveSpaceForCommandsInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref900bfee5 != nil {
		return x.ref900bfee5, nil
	}
	mem900bfee5 := allocCmdReserveSpaceForCommandsInfoNVXMemory(1)
	ref900bfee5 := (*C.VkCmdReserveSpaceForCommandsInfoNVX)(mem900bfee5)
	allocs900bfee5 := new(cgoAllocMap)
	allocs900bfee5.Add(mem900bfee5)

	var csType_allocs *cgoAllocMap
	ref900bfee5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs900bfee5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref900bfee5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cpNext_allocs)

	var cobjectTable_allocs *cgoAllocMap
	ref900bfee5.objectTable, cobjectTable_allocs = *(*C.VkObjectTableNVX)(unsafe.Pointer(&x.ObjectTable)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cobjectTable_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	ref900bfee5.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNVX)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cindirectCommandsLayout_allocs)

	var cmaxSequencesCount_allocs *cgoAllocMap
	ref900bfee5.maxSequencesCount, cmaxSequencesCount_allocs = (C.uint32_t)(x.MaxSequencesCount), cgoAllocsUnknown
	allocs900bfee5.Borrow(cmaxSequencesCount_allocs)

	x.ref900bfee5 = ref900bfee5
	x.allocs900bfee5 = allocs900bfee5
	return ref900bfee5, allocs900bfee5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmdReserveSpaceForCommandsInfoNVX) PassValue() (C.VkCmdReserveSpaceForCommandsInfoNVX, *cgoAllocMap) {
	if x.ref900bfee5 != nil {
		return *x.ref900bfee5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmdReserveSpaceForCommandsInfoNVX) Deref() {
	if x.ref900bfee5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref900bfee5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref900bfee5.pNext))
	x.ObjectTable = *(*ObjectTableNVX)(unsafe.Pointer(&x.ref900bfee5.objectTable))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNVX)(unsafe.Pointer(&x.ref900bfee5.indirectCommandsLayout))
	x.MaxSequencesCount = (uint32)(x.ref900bfee5.maxSequencesCount)
}

// allocObjectTableCreateInfoNVXMemory allocates memory for type C.VkObjectTableCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableCreateInfoNVXValue = unsafe.Sizeof([1]C.VkObjectTableCreateInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableCreateInfoNVX) Ref() *C.VkObjectTableCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.refb4a6c9e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableCreateInfoNVX) Free() {
	if x != nil && x.allocsb4a6c9e1 != nil {
		x.allocsb4a6c9e1.(*cgoAllocMap).Free()
		x.refb4a6c9e1 = nil
	}
}

// NewObjectTableCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableCreateInfoNVXRef(ref unsafe.Pointer) *ObjectTableCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableCreateInfoNVX)
	obj.refb4a6c9e1 = (*C.VkObjectTableCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableCreateInfoNVX) PassRef() (*C.VkObjectTableCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb4a6c9e1 != nil {
		return x.refb4a6c9e1, nil
	}
	memb4a6c9e1 := allocObjectTableCreateInfoNVXMemory(1)
	refb4a6c9e1 := (*C.VkObjectTableCreateInfoNVX)(memb4a6c9e1)
	allocsb4a6c9e1 := new(cgoAllocMap)
	allocsb4a6c9e1.Add(memb4a6c9e1)

	var csType_allocs *cgoAllocMap
	refb4a6c9e1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb4a6c9e1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpNext_allocs)

	var cobjectCount_allocs *cgoAllocMap
	refb4a6c9e1.objectCount, cobjectCount_allocs = (C.uint32_t)(x.ObjectCount), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cobjectCount_allocs)

	var cpObjectEntryTypes_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryTypes, cpObjectEntryTypes_allocs = (*C.VkObjectEntryTypeNVX)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryTypes)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryTypes_allocs)

	var cpObjectEntryCounts_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryCounts, cpObjectEntryCounts_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryCounts)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryCounts_allocs)

	var cpObjectEntryUsageFlags_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryUsageFlags, cpObjectEntryUsageFlags_allocs = (*C.VkObjectEntryUsageFlagsNVX)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryUsageFlags)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryUsageFlags_allocs)

	var cmaxUniformBuffersPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxUniformBuffersPerDescriptor, cmaxUniformBuffersPerDescriptor_allocs = (C.uint32_t)(x.MaxUniformBuffersPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxUniformBuffersPerDescriptor_allocs)

	var cmaxStorageBuffersPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxStorageBuffersPerDescriptor, cmaxStorageBuffersPerDescriptor_allocs = (C.uint32_t)(x.MaxStorageBuffersPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxStorageBuffersPerDescriptor_allocs)

	var cmaxStorageImagesPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxStorageImagesPerDescriptor, cmaxStorageImagesPerDescriptor_allocs = (C.uint32_t)(x.MaxStorageImagesPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxStorageImagesPerDescriptor_allocs)

	var cmaxSampledImagesPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxSampledImagesPerDescriptor, cmaxSampledImagesPerDescriptor_allocs = (C.uint32_t)(x.MaxSampledImagesPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxSampledImagesPerDescriptor_allocs)

	var cmaxPipelineLayouts_allocs *cgoAllocMap
	refb4a6c9e1.maxPipelineLayouts, cmaxPipelineLayouts_allocs = (C.uint32_t)(x.MaxPipelineLayouts), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxPipelineLayouts_allocs)

	x.refb4a6c9e1 = refb4a6c9e1
	x.allocsb4a6c9e1 = allocsb4a6c9e1
	return refb4a6c9e1, allocsb4a6c9e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableCreateInfoNVX) PassValue() (C.VkObjectTableCreateInfoNVX, *cgoAllocMap) {
	if x.refb4a6c9e1 != nil {
		return *x.refb4a6c9e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableCreateInfoNVX) Deref() {
	if x.refb4a6c9e1 == nil {
		return
	}
	x.SType = (StructureType)(x.refb4a6c9e1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb4a6c9e1.pNext))
	x.ObjectCount = (uint32)(x.refb4a6c9e1.objectCount)
	hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryTypes))
	hxf9aab83.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryTypes)
	hxf9aab83.Cap = 0x7fffffff
	// hxf9aab83.Len = ?

	hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryCounts))
	hxf8b35a8.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryCounts)
	hxf8b35a8.Cap = 0x7fffffff
	// hxf8b35a8.Len = ?

	hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryUsageFlags))
	hxf8959c2.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryUsageFlags)
	hxf8959c2.Cap = 0x7fffffff
	// hxf8959c2.Len = ?

	x.MaxUniformBuffersPerDescriptor = (uint32)(x.refb4a6c9e1.maxUniformBuffersPerDescriptor)
	x.MaxStorageBuffersPerDescriptor = (uint32)(x.refb4a6c9e1.maxStorageBuffersPerDescriptor)
	x.MaxStorageImagesPerDescriptor = (uint32)(x.refb4a6c9e1.maxStorageImagesPerDescriptor)
	x.MaxSampledImagesPerDescriptor = (uint32)(x.refb4a6c9e1.maxSampledImagesPerDescriptor)
	x.MaxPipelineLayouts = (uint32)(x.refb4a6c9e1.maxPipelineLayouts)
}

// allocObjectTableEntryNVXMemory allocates memory for type C.VkObjectTableEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableEntryNVX) Ref() *C.VkObjectTableEntryNVX {
	if x == nil {
		return nil
	}
	return x.refb8f7ffef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableEntryNVX) Free() {
	if x != nil && x.allocsb8f7ffef != nil {
		x.allocsb8f7ffef.(*cgoAllocMap).Free()
		x.refb8f7ffef = nil
	}
}

// NewObjectTableEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableEntryNVXRef(ref unsafe.Pointer) *ObjectTableEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableEntryNVX)
	obj.refb8f7ffef = (*C.VkObjectTableEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableEntryNVX) PassRef() (*C.VkObjectTableEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8f7ffef != nil {
		return x.refb8f7ffef, nil
	}
	memb8f7ffef := allocObjectTableEntryNVXMemory(1)
	refb8f7ffef := (*C.VkObjectTableEntryNVX)(memb8f7ffef)
	allocsb8f7ffef := new(cgoAllocMap)
	allocsb8f7ffef.Add(memb8f7ffef)

	var c_type_allocs *cgoAllocMap
	refb8f7ffef._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocsb8f7ffef.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refb8f7ffef.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocsb8f7ffef.Borrow(cflags_allocs)

	x.refb8f7ffef = refb8f7ffef
	x.allocsb8f7ffef = allocsb8f7ffef
	return refb8f7ffef, allocsb8f7ffef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableEntryNVX) PassValue() (C.VkObjectTableEntryNVX, *cgoAllocMap) {
	if x.refb8f7ffef != nil {
		return *x.refb8f7ffef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableEntryNVX) Deref() {
	if x.refb8f7ffef == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.refb8f7ffef._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.refb8f7ffef.flags)
}

// allocObjectTablePipelineEntryNVXMemory allocates memory for type C.VkObjectTablePipelineEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTablePipelineEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTablePipelineEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTablePipelineEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTablePipelineEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTablePipelineEntryNVX) Ref() *C.VkObjectTablePipelineEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref8112859b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTablePipelineEntryNVX) Free() {
	if x != nil && x.allocs8112859b != nil {
		x.allocs8112859b.(*cgoAllocMap).Free()
		x.ref8112859b = nil
	}
}

// NewObjectTablePipelineEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTablePipelineEntryNVXRef(ref unsafe.Pointer) *ObjectTablePipelineEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTablePipelineEntryNVX)
	obj.ref8112859b = (*C.VkObjectTablePipelineEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTablePipelineEntryNVX) PassRef() (*C.VkObjectTablePipelineEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8112859b != nil {
		return x.ref8112859b, nil
	}
	mem8112859b := allocObjectTablePipelineEntryNVXMemory(1)
	ref8112859b := (*C.VkObjectTablePipelineEntryNVX)(mem8112859b)
	allocs8112859b := new(cgoAllocMap)
	allocs8112859b.Add(mem8112859b)

	var c_type_allocs *cgoAllocMap
	ref8112859b._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocs8112859b.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref8112859b.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs8112859b.Borrow(cflags_allocs)

	var cpipeline_allocs *cgoAllocMap
	ref8112859b.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocs8112859b.Borrow(cpipeline_allocs)

	x.ref8112859b = ref8112859b
	x.allocs8112859b = allocs8112859b
	return ref8112859b, allocs8112859b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTablePipelineEntryNVX) PassValue() (C.VkObjectTablePipelineEntryNVX, *cgoAllocMap) {
	if x.ref8112859b != nil {
		return *x.ref8112859b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTablePipelineEntryNVX) Deref() {
	if x.ref8112859b == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.ref8112859b._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref8112859b.flags)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.ref8112859b.pipeline))
}

// allocObjectTableDescriptorSetEntryNVXMemory allocates memory for type C.VkObjectTableDescriptorSetEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableDescriptorSetEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableDescriptorSetEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableDescriptorSetEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableDescriptorSetEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableDescriptorSetEntryNVX) Ref() *C.VkObjectTableDescriptorSetEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref6fc0d42f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableDescriptorSetEntryNVX) Free() {
	if x != nil && x.allocs6fc0d42f != nil {
		x.allocs6fc0d42f.(*cgoAllocMap).Free()
		x.ref6fc0d42f = nil
	}
}

// NewObjectTableDescriptorSetEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableDescriptorSetEntryNVXRef(ref unsafe.Pointer) *ObjectTableDescriptorSetEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableDescriptorSetEntryNVX)
	obj.ref6fc0d42f = (*C.VkObjectTableDescriptorSetEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableDescriptorSetEntryNVX) PassRef() (*C.VkObjectTableDescriptorSetEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6fc0d42f != nil {
		return x.ref6fc0d42f, nil
	}
	mem6fc0d42f := allocObjectTableDescriptorSetEntryNVXMemory(1)
	ref6fc0d42f := (*C.VkObjectTableDescriptorSetEntryNVX)(mem6fc0d42f)
	allocs6fc0d42f := new(cgoAllocMap)
	allocs6fc0d42f.Add(mem6fc0d42f)

	var c_type_allocs *cgoAllocMap
	ref6fc0d42f._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref6fc0d42f.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cflags_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref6fc0d42f.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cpipelineLayout_allocs)

	var cdescriptorSet_allocs *cgoAllocMap
	ref6fc0d42f.descriptorSet, cdescriptorSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DescriptorSet)), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cdescriptorSet_allocs)

	x.ref6fc0d42f = ref6fc0d42f
	x.allocs6fc0d42f = allocs6fc0d42f
	return ref6fc0d42f, allocs6fc0d42f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableDescriptorSetEntryNVX) PassValue() (C.VkObjectTableDescriptorSetEntryNVX, *cgoAllocMap) {
	if x.ref6fc0d42f != nil {
		return *x.ref6fc0d42f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableDescriptorSetEntryNVX) Deref() {
	if x.ref6fc0d42f == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.ref6fc0d42f._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref6fc0d42f.flags)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref6fc0d42f.pipelineLayout))
	x.DescriptorSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref6fc0d42f.descriptorSet))
}

// allocObjectTableVertexBufferEntryNVXMemory allocates memory for type C.VkObjectTableVertexBufferEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableVertexBufferEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableVertexBufferEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableVertexBufferEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableVertexBufferEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableVertexBufferEntryNVX) Ref() *C.VkObjectTableVertexBufferEntryNVX {
	if x == nil {
		return nil
	}
	return x.refe8a5908b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableVertexBufferEntryNVX) Free() {
	if x != nil && x.allocse8a5908b != nil {
		x.allocse8a5908b.(*cgoAllocMap).Free()
		x.refe8a5908b = nil
	}
}

// NewObjectTableVertexBufferEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableVertexBufferEntryNVXRef(ref unsafe.Pointer) *ObjectTableVertexBufferEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableVertexBufferEntryNVX)
	obj.refe8a5908b = (*C.VkObjectTableVertexBufferEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableVertexBufferEntryNVX) PassRef() (*C.VkObjectTableVertexBufferEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe8a5908b != nil {
		return x.refe8a5908b, nil
	}
	meme8a5908b := allocObjectTableVertexBufferEntryNVXMemory(1)
	refe8a5908b := (*C.VkObjectTableVertexBufferEntryNVX)(meme8a5908b)
	allocse8a5908b := new(cgoAllocMap)
	allocse8a5908b.Add(meme8a5908b)

	var c_type_allocs *cgoAllocMap
	refe8a5908b._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocse8a5908b.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refe8a5908b.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocse8a5908b.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	refe8a5908b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse8a5908b.Borrow(cbuffer_allocs)

	x.refe8a5908b = refe8a5908b
	x.allocse8a5908b = allocse8a5908b
	return refe8a5908b, allocse8a5908b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableVertexBufferEntryNVX) PassValue() (C.VkObjectTableVertexBufferEntryNVX, *cgoAllocMap) {
	if x.refe8a5908b != nil {
		return *x.refe8a5908b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableVertexBufferEntryNVX) Deref() {
	if x.refe8a5908b == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.refe8a5908b._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.refe8a5908b.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe8a5908b.buffer))
}

// allocObjectTableIndexBufferEntryNVXMemory allocates memory for type C.VkObjectTableIndexBufferEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableIndexBufferEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableIndexBufferEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableIndexBufferEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableIndexBufferEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableIndexBufferEntryNVX) Ref() *C.VkObjectTableIndexBufferEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref58a08650
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableIndexBufferEntryNVX) Free() {
	if x != nil && x.allocs58a08650 != nil {
		x.allocs58a08650.(*cgoAllocMap).Free()
		x.ref58a08650 = nil
	}
}

// NewObjectTableIndexBufferEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableIndexBufferEntryNVXRef(ref unsafe.Pointer) *ObjectTableIndexBufferEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableIndexBufferEntryNVX)
	obj.ref58a08650 = (*C.VkObjectTableIndexBufferEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableIndexBufferEntryNVX) PassRef() (*C.VkObjectTableIndexBufferEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58a08650 != nil {
		return x.ref58a08650, nil
	}
	mem58a08650 := allocObjectTableIndexBufferEntryNVXMemory(1)
	ref58a08650 := (*C.VkObjectTableIndexBufferEntryNVX)(mem58a08650)
	allocs58a08650 := new(cgoAllocMap)
	allocs58a08650.Add(mem58a08650)

	var c_type_allocs *cgoAllocMap
	ref58a08650._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocs58a08650.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref58a08650.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs58a08650.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref58a08650.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs58a08650.Borrow(cbuffer_allocs)

	var cindexType_allocs *cgoAllocMap
	ref58a08650.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocs58a08650.Borrow(cindexType_allocs)

	x.ref58a08650 = ref58a08650
	x.allocs58a08650 = allocs58a08650
	return ref58a08650, allocs58a08650

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableIndexBufferEntryNVX) PassValue() (C.VkObjectTableIndexBufferEntryNVX, *cgoAllocMap) {
	if x.ref58a08650 != nil {
		return *x.ref58a08650, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableIndexBufferEntryNVX) Deref() {
	if x.ref58a08650 == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.ref58a08650._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref58a08650.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref58a08650.buffer))
	x.IndexType = (IndexType)(x.ref58a08650.indexType)
}

// allocObjectTablePushConstantEntryNVXMemory allocates memory for type C.VkObjectTablePushConstantEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTablePushConstantEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTablePushConstantEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTablePushConstantEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTablePushConstantEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTablePushConstantEntryNVX) Ref() *C.VkObjectTablePushConstantEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref8c8421e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTablePushConstantEntryNVX) Free() {
	if x != nil && x.allocs8c8421e0 != nil {
		x.allocs8c8421e0.(*cgoAllocMap).Free()
		x.ref8c8421e0 = nil
	}
}

// NewObjectTablePushConstantEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTablePushConstantEntryNVXRef(ref unsafe.Pointer) *ObjectTablePushConstantEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTablePushConstantEntryNVX)
	obj.ref8c8421e0 = (*C.VkObjectTablePushConstantEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTablePushConstantEntryNVX) PassRef() (*C.VkObjectTablePushConstantEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c8421e0 != nil {
		return x.ref8c8421e0, nil
	}
	mem8c8421e0 := allocObjectTablePushConstantEntryNVXMemory(1)
	ref8c8421e0 := (*C.VkObjectTablePushConstantEntryNVX)(mem8c8421e0)
	allocs8c8421e0 := new(cgoAllocMap)
	allocs8c8421e0.Add(mem8c8421e0)

	var c_type_allocs *cgoAllocMap
	ref8c8421e0._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x._type), cgoAllocsUnknown
	allocs8c8421e0.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref8c8421e0.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cflags_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref8c8421e0.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cpipelineLayout_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8c8421e0.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cstageFlags_allocs)

	x.ref8c8421e0 = ref8c8421e0
	x.allocs8c8421e0 = allocs8c8421e0
	return ref8c8421e0, allocs8c8421e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTablePushConstantEntryNVX) PassValue() (C.VkObjectTablePushConstantEntryNVX, *cgoAllocMap) {
	if x.ref8c8421e0 != nil {
		return *x.ref8c8421e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTablePushConstantEntryNVX) Deref() {
	if x.ref8c8421e0 == nil {
		return
	}
	x._type = (ObjectEntryTypeNVX)(x.ref8c8421e0._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref8c8421e0.flags)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref8c8421e0.pipelineLayout))
	x.StageFlags = (ShaderStageFlags)(x.ref8c8421e0.stageFlags)
}

// allocViewportWScalingNVMemory allocates memory for type C.VkViewportWScalingNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportWScalingNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportWScalingNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportWScalingNVValue = unsafe.Sizeof([1]C.VkViewportWScalingNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportWScalingNV) Ref() *C.VkViewportWScalingNV {
	if x == nil {
		return nil
	}
	return x.ref7ea4590f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportWScalingNV) Free() {
	if x != nil && x.allocs7ea4590f != nil {
		x.allocs7ea4590f.(*cgoAllocMap).Free()
		x.ref7ea4590f = nil
	}
}

// NewViewportWScalingNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportWScalingNVRef(ref unsafe.Pointer) *ViewportWScalingNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportWScalingNV)
	obj.ref7ea4590f = (*C.VkViewportWScalingNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportWScalingNV) PassRef() (*C.VkViewportWScalingNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ea4590f != nil {
		return x.ref7ea4590f, nil
	}
	mem7ea4590f := allocViewportWScalingNVMemory(1)
	ref7ea4590f := (*C.VkViewportWScalingNV)(mem7ea4590f)
	allocs7ea4590f := new(cgoAllocMap)
	allocs7ea4590f.Add(mem7ea4590f)

	var cxcoeff_allocs *cgoAllocMap
	ref7ea4590f.xcoeff, cxcoeff_allocs = (C.float)(x.Xcoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cxcoeff_allocs)

	var cycoeff_allocs *cgoAllocMap
	ref7ea4590f.ycoeff, cycoeff_allocs = (C.float)(x.Ycoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cycoeff_allocs)

	x.ref7ea4590f = ref7ea4590f
	x.allocs7ea4590f = allocs7ea4590f
	return ref7ea4590f, allocs7ea4590f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportWScalingNV) PassValue() (C.VkViewportWScalingNV, *cgoAllocMap) {
	if x.ref7ea4590f != nil {
		return *x.ref7ea4590f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportWScalingNV) Deref() {
	if x.ref7ea4590f == nil {
		return
	}
	x.Xcoeff = (float32)(x.ref7ea4590f.xcoeff)
	x.Ycoeff = (float32)(x.ref7ea4590f.ycoeff)
}

// allocPipelineViewportWScalingStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportWScalingStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportWScalingStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportWScalingStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportWScalingStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportWScalingStateCreateInfoNV{})

// unpackSViewportWScalingNV transforms a sliced Go data structure into plain C format.
func unpackSViewportWScalingNV(x []ViewportWScalingNV) (unpacked *C.VkViewportWScalingNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewportWScalingNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportWScalingNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportWScalingNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportWScalingNV)(h.Data)
	return
}

// packSViewportWScalingNV reads sliced Go data structure out from plain C format.
func packSViewportWScalingNV(v []ViewportWScalingNV, ptr0 *C.VkViewportWScalingNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportWScalingNVValue]C.VkViewportWScalingNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportWScalingNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportWScalingStateCreateInfoNV) Ref() *C.VkPipelineViewportWScalingStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref3e532c0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) Free() {
	if x != nil && x.allocs3e532c0b != nil {
		x.allocs3e532c0b.(*cgoAllocMap).Free()
		x.ref3e532c0b = nil
	}
}

// NewPipelineViewportWScalingStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportWScalingStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportWScalingStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportWScalingStateCreateInfoNV)
	obj.ref3e532c0b = (*C.VkPipelineViewportWScalingStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) PassRef() (*C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e532c0b != nil {
		return x.ref3e532c0b, nil
	}
	mem3e532c0b := allocPipelineViewportWScalingStateCreateInfoNVMemory(1)
	ref3e532c0b := (*C.VkPipelineViewportWScalingStateCreateInfoNV)(mem3e532c0b)
	allocs3e532c0b := new(cgoAllocMap)
	allocs3e532c0b.Add(mem3e532c0b)

	var csType_allocs *cgoAllocMap
	ref3e532c0b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e532c0b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e532c0b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cpNext_allocs)

	var cviewportWScalingEnable_allocs *cgoAllocMap
	ref3e532c0b.viewportWScalingEnable, cviewportWScalingEnable_allocs = (C.VkBool32)(x.ViewportWScalingEnable), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportWScalingEnable_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref3e532c0b.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportCount_allocs)

	var cpViewportWScalings_allocs *cgoAllocMap
	ref3e532c0b.pViewportWScalings, cpViewportWScalings_allocs = unpackSViewportWScalingNV(x.PViewportWScalings)
	allocs3e532c0b.Borrow(cpViewportWScalings_allocs)

	x.ref3e532c0b = ref3e532c0b
	x.allocs3e532c0b = allocs3e532c0b
	return ref3e532c0b, allocs3e532c0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportWScalingStateCreateInfoNV) PassValue() (C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x.ref3e532c0b != nil {
		return *x.ref3e532c0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportWScalingStateCreateInfoNV) Deref() {
	if x.ref3e532c0b == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e532c0b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e532c0b.pNext))
	x.ViewportWScalingEnable = (Bool32)(x.ref3e532c0b.viewportWScalingEnable)
	x.ViewportCount = (uint32)(x.ref3e532c0b.viewportCount)
	packSViewportWScalingNV(x.PViewportWScalings, x.ref3e532c0b.pViewportWScalings)
}

// allocSurfaceCapabilities2EXTMemory allocates memory for type C.VkSurfaceCapabilities2EXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilities2EXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilities2EXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilities2EXTValue = unsafe.Sizeof([1]C.VkSurfaceCapabilities2EXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities2EXT) Ref() *C.VkSurfaceCapabilities2EXT {
	if x == nil {
		return nil
	}
	return x.ref43790d2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities2EXT) Free() {
	if x != nil && x.allocs43790d2b != nil {
		x.allocs43790d2b.(*cgoAllocMap).Free()
		x.ref43790d2b = nil
	}
}

// NewSurfaceCapabilities2EXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilities2EXTRef(ref unsafe.Pointer) *SurfaceCapabilities2EXT {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities2EXT)
	obj.ref43790d2b = (*C.VkSurfaceCapabilities2EXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities2EXT) PassRef() (*C.VkSurfaceCapabilities2EXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref43790d2b != nil {
		return x.ref43790d2b, nil
	}
	mem43790d2b := allocSurfaceCapabilities2EXTMemory(1)
	ref43790d2b := (*C.VkSurfaceCapabilities2EXT)(mem43790d2b)
	allocs43790d2b := new(cgoAllocMap)
	allocs43790d2b.Add(mem43790d2b)

	var csType_allocs *cgoAllocMap
	ref43790d2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs43790d2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref43790d2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs43790d2b.Borrow(cpNext_allocs)

	var cminImageCount_allocs *cgoAllocMap
	ref43790d2b.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs43790d2b.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref43790d2b.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs43790d2b.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref43790d2b.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs43790d2b.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref43790d2b.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs43790d2b.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref43790d2b.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs43790d2b.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref43790d2b.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs43790d2b.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref43790d2b.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs43790d2b.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref43790d2b.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs43790d2b.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref43790d2b.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs43790d2b.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref43790d2b.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs43790d2b.Borrow(csupportedUsageFlags_allocs)

	var csupportedSurfaceCounters_allocs *cgoAllocMap
	ref43790d2b.supportedSurfaceCounters, csupportedSurfaceCounters_allocs = (C.VkSurfaceCounterFlagsEXT)(x.SupportedSurfaceCounters), cgoAllocsUnknown
	allocs43790d2b.Borrow(csupportedSurfaceCounters_allocs)

	x.ref43790d2b = ref43790d2b
	x.allocs43790d2b = allocs43790d2b
	return ref43790d2b, allocs43790d2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities2EXT) PassValue() (C.VkSurfaceCapabilities2EXT, *cgoAllocMap) {
	if x.ref43790d2b != nil {
		return *x.ref43790d2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities2EXT) Deref() {
	if x.ref43790d2b == nil {
		return
	}
	x.SType = (StructureType)(x.ref43790d2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref43790d2b.pNext))
	x.MinImageCount = (uint32)(x.ref43790d2b.minImageCount)
	x.MaxImageCount = (uint32)(x.ref43790d2b.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref43790d2b.currentExtent))
	x.MinImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref43790d2b.minImageExtent))
	x.MaxImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref43790d2b.maxImageExtent))
	x.MaxImageArrayLayers = (uint32)(x.ref43790d2b.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlagsKHR)(x.ref43790d2b.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBitsKHR)(x.ref43790d2b.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlagsKHR)(x.ref43790d2b.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref43790d2b.supportedUsageFlags)
	x.SupportedSurfaceCounters = (SurfaceCounterFlagsEXT)(x.ref43790d2b.supportedSurfaceCounters)
}

// allocDisplayPowerInfoEXTMemory allocates memory for type C.VkDisplayPowerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPowerInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPowerInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPowerInfoEXTValue = unsafe.Sizeof([1]C.VkDisplayPowerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPowerInfoEXT) Ref() *C.VkDisplayPowerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref80fed52f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPowerInfoEXT) Free() {
	if x != nil && x.allocs80fed52f != nil {
		x.allocs80fed52f.(*cgoAllocMap).Free()
		x.ref80fed52f = nil
	}
}

// NewDisplayPowerInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPowerInfoEXTRef(ref unsafe.Pointer) *DisplayPowerInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPowerInfoEXT)
	obj.ref80fed52f = (*C.VkDisplayPowerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPowerInfoEXT) PassRef() (*C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80fed52f != nil {
		return x.ref80fed52f, nil
	}
	mem80fed52f := allocDisplayPowerInfoEXTMemory(1)
	ref80fed52f := (*C.VkDisplayPowerInfoEXT)(mem80fed52f)
	allocs80fed52f := new(cgoAllocMap)
	allocs80fed52f.Add(mem80fed52f)

	var csType_allocs *cgoAllocMap
	ref80fed52f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80fed52f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80fed52f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpNext_allocs)

	var cpowerState_allocs *cgoAllocMap
	ref80fed52f.powerState, cpowerState_allocs = (C.VkDisplayPowerStateEXT)(x.PowerState), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpowerState_allocs)

	x.ref80fed52f = ref80fed52f
	x.allocs80fed52f = allocs80fed52f
	return ref80fed52f, allocs80fed52f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPowerInfoEXT) PassValue() (C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x.ref80fed52f != nil {
		return *x.ref80fed52f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPowerInfoEXT) Deref() {
	if x.ref80fed52f == nil {
		return
	}
	x.SType = (StructureType)(x.ref80fed52f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80fed52f.pNext))
	x.PowerState = (DisplayPowerStateEXT)(x.ref80fed52f.powerState)
}

// allocDeviceEventInfoEXTMemory allocates memory for type C.VkDeviceEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceEventInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceEventInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceEventInfoEXTValue = unsafe.Sizeof([1]C.VkDeviceEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceEventInfoEXT) Ref() *C.VkDeviceEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref394b3fcb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceEventInfoEXT) Free() {
	if x != nil && x.allocs394b3fcb != nil {
		x.allocs394b3fcb.(*cgoAllocMap).Free()
		x.ref394b3fcb = nil
	}
}

// NewDeviceEventInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceEventInfoEXTRef(ref unsafe.Pointer) *DeviceEventInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DeviceEventInfoEXT)
	obj.ref394b3fcb = (*C.VkDeviceEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceEventInfoEXT) PassRef() (*C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394b3fcb != nil {
		return x.ref394b3fcb, nil
	}
	mem394b3fcb := allocDeviceEventInfoEXTMemory(1)
	ref394b3fcb := (*C.VkDeviceEventInfoEXT)(mem394b3fcb)
	allocs394b3fcb := new(cgoAllocMap)
	allocs394b3fcb.Add(mem394b3fcb)

	var csType_allocs *cgoAllocMap
	ref394b3fcb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs394b3fcb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref394b3fcb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cpNext_allocs)

	var cdeviceEvent_allocs *cgoAllocMap
	ref394b3fcb.deviceEvent, cdeviceEvent_allocs = (C.VkDeviceEventTypeEXT)(x.DeviceEvent), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cdeviceEvent_allocs)

	x.ref394b3fcb = ref394b3fcb
	x.allocs394b3fcb = allocs394b3fcb
	return ref394b3fcb, allocs394b3fcb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceEventInfoEXT) PassValue() (C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x.ref394b3fcb != nil {
		return *x.ref394b3fcb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceEventInfoEXT) Deref() {
	if x.ref394b3fcb == nil {
		return
	}
	x.SType = (StructureType)(x.ref394b3fcb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref394b3fcb.pNext))
	x.DeviceEvent = (DeviceEventTypeEXT)(x.ref394b3fcb.deviceEvent)
}

// allocDisplayEventInfoEXTMemory allocates memory for type C.VkDisplayEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayEventInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayEventInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayEventInfoEXTValue = unsafe.Sizeof([1]C.VkDisplayEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayEventInfoEXT) Ref() *C.VkDisplayEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa69f7302
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayEventInfoEXT) Free() {
	if x != nil && x.allocsa69f7302 != nil {
		x.allocsa69f7302.(*cgoAllocMap).Free()
		x.refa69f7302 = nil
	}
}

// NewDisplayEventInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayEventInfoEXTRef(ref unsafe.Pointer) *DisplayEventInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DisplayEventInfoEXT)
	obj.refa69f7302 = (*C.VkDisplayEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayEventInfoEXT) PassRef() (*C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa69f7302 != nil {
		return x.refa69f7302, nil
	}
	mema69f7302 := allocDisplayEventInfoEXTMemory(1)
	refa69f7302 := (*C.VkDisplayEventInfoEXT)(mema69f7302)
	allocsa69f7302 := new(cgoAllocMap)
	allocsa69f7302.Add(mema69f7302)

	var csType_allocs *cgoAllocMap
	refa69f7302.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa69f7302.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa69f7302.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa69f7302.Borrow(cpNext_allocs)

	var cdisplayEvent_allocs *cgoAllocMap
	refa69f7302.displayEvent, cdisplayEvent_allocs = (C.VkDisplayEventTypeEXT)(x.DisplayEvent), cgoAllocsUnknown
	allocsa69f7302.Borrow(cdisplayEvent_allocs)

	x.refa69f7302 = refa69f7302
	x.allocsa69f7302 = allocsa69f7302
	return refa69f7302, allocsa69f7302

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayEventInfoEXT) PassValue() (C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x.refa69f7302 != nil {
		return *x.refa69f7302, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayEventInfoEXT) Deref() {
	if x.refa69f7302 == nil {
		return
	}
	x.SType = (StructureType)(x.refa69f7302.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa69f7302.pNext))
	x.DisplayEvent = (DisplayEventTypeEXT)(x.refa69f7302.displayEvent)
}

// allocSwapchainCounterCreateInfoEXTMemory allocates memory for type C.VkSwapchainCounterCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCounterCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCounterCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCounterCreateInfoEXTValue = unsafe.Sizeof([1]C.VkSwapchainCounterCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCounterCreateInfoEXT) Ref() *C.VkSwapchainCounterCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9f21eca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCounterCreateInfoEXT) Free() {
	if x != nil && x.allocs9f21eca6 != nil {
		x.allocs9f21eca6.(*cgoAllocMap).Free()
		x.ref9f21eca6 = nil
	}
}

// NewSwapchainCounterCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCounterCreateInfoEXTRef(ref unsafe.Pointer) *SwapchainCounterCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCounterCreateInfoEXT)
	obj.ref9f21eca6 = (*C.VkSwapchainCounterCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCounterCreateInfoEXT) PassRef() (*C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9f21eca6 != nil {
		return x.ref9f21eca6, nil
	}
	mem9f21eca6 := allocSwapchainCounterCreateInfoEXTMemory(1)
	ref9f21eca6 := (*C.VkSwapchainCounterCreateInfoEXT)(mem9f21eca6)
	allocs9f21eca6 := new(cgoAllocMap)
	allocs9f21eca6.Add(mem9f21eca6)

	var csType_allocs *cgoAllocMap
	ref9f21eca6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9f21eca6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9f21eca6.Borrow(cpNext_allocs)

	var csurfaceCounters_allocs *cgoAllocMap
	ref9f21eca6.surfaceCounters, csurfaceCounters_allocs = (C.VkSurfaceCounterFlagsEXT)(x.SurfaceCounters), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csurfaceCounters_allocs)

	x.ref9f21eca6 = ref9f21eca6
	x.allocs9f21eca6 = allocs9f21eca6
	return ref9f21eca6, allocs9f21eca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCounterCreateInfoEXT) PassValue() (C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x.ref9f21eca6 != nil {
		return *x.ref9f21eca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCounterCreateInfoEXT) Deref() {
	if x.ref9f21eca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9f21eca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9f21eca6.pNext))
	x.SurfaceCounters = (SurfaceCounterFlagsEXT)(x.ref9f21eca6.surfaceCounters)
}

// allocRefreshCycleDurationGOOGLEMemory allocates memory for type C.VkRefreshCycleDurationGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRefreshCycleDurationGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRefreshCycleDurationGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRefreshCycleDurationGOOGLEValue = unsafe.Sizeof([1]C.VkRefreshCycleDurationGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RefreshCycleDurationGOOGLE) Ref() *C.VkRefreshCycleDurationGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref969cb55b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RefreshCycleDurationGOOGLE) Free() {
	if x != nil && x.allocs969cb55b != nil {
		x.allocs969cb55b.(*cgoAllocMap).Free()
		x.ref969cb55b = nil
	}
}

// NewRefreshCycleDurationGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRefreshCycleDurationGOOGLERef(ref unsafe.Pointer) *RefreshCycleDurationGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(RefreshCycleDurationGOOGLE)
	obj.ref969cb55b = (*C.VkRefreshCycleDurationGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RefreshCycleDurationGOOGLE) PassRef() (*C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref969cb55b != nil {
		return x.ref969cb55b, nil
	}
	mem969cb55b := allocRefreshCycleDurationGOOGLEMemory(1)
	ref969cb55b := (*C.VkRefreshCycleDurationGOOGLE)(mem969cb55b)
	allocs969cb55b := new(cgoAllocMap)
	allocs969cb55b.Add(mem969cb55b)

	var crefreshDuration_allocs *cgoAllocMap
	ref969cb55b.refreshDuration, crefreshDuration_allocs = (C.uint64_t)(x.RefreshDuration), cgoAllocsUnknown
	allocs969cb55b.Borrow(crefreshDuration_allocs)

	x.ref969cb55b = ref969cb55b
	x.allocs969cb55b = allocs969cb55b
	return ref969cb55b, allocs969cb55b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RefreshCycleDurationGOOGLE) PassValue() (C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x.ref969cb55b != nil {
		return *x.ref969cb55b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RefreshCycleDurationGOOGLE) Deref() {
	if x.ref969cb55b == nil {
		return
	}
	x.RefreshDuration = (uint64)(x.ref969cb55b.refreshDuration)
}

// allocPastPresentationTimingGOOGLEMemory allocates memory for type C.VkPastPresentationTimingGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPastPresentationTimingGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPastPresentationTimingGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPastPresentationTimingGOOGLEValue = unsafe.Sizeof([1]C.VkPastPresentationTimingGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PastPresentationTimingGOOGLE) Ref() *C.VkPastPresentationTimingGOOGLE {
	if x == nil {
		return nil
	}
	return x.refac8cf1d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PastPresentationTimingGOOGLE) Free() {
	if x != nil && x.allocsac8cf1d8 != nil {
		x.allocsac8cf1d8.(*cgoAllocMap).Free()
		x.refac8cf1d8 = nil
	}
}

// NewPastPresentationTimingGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPastPresentationTimingGOOGLERef(ref unsafe.Pointer) *PastPresentationTimingGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PastPresentationTimingGOOGLE)
	obj.refac8cf1d8 = (*C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PastPresentationTimingGOOGLE) PassRef() (*C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac8cf1d8 != nil {
		return x.refac8cf1d8, nil
	}
	memac8cf1d8 := allocPastPresentationTimingGOOGLEMemory(1)
	refac8cf1d8 := (*C.VkPastPresentationTimingGOOGLE)(memac8cf1d8)
	allocsac8cf1d8 := new(cgoAllocMap)
	allocsac8cf1d8.Add(memac8cf1d8)

	var cpresentID_allocs *cgoAllocMap
	refac8cf1d8.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	refac8cf1d8.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cdesiredPresentTime_allocs)

	var cactualPresentTime_allocs *cgoAllocMap
	refac8cf1d8.actualPresentTime, cactualPresentTime_allocs = (C.uint64_t)(x.ActualPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cactualPresentTime_allocs)

	var cearliestPresentTime_allocs *cgoAllocMap
	refac8cf1d8.earliestPresentTime, cearliestPresentTime_allocs = (C.uint64_t)(x.EarliestPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cearliestPresentTime_allocs)

	var cpresentMargin_allocs *cgoAllocMap
	refac8cf1d8.presentMargin, cpresentMargin_allocs = (C.uint64_t)(x.PresentMargin), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentMargin_allocs)

	x.refac8cf1d8 = refac8cf1d8
	x.allocsac8cf1d8 = allocsac8cf1d8
	return refac8cf1d8, allocsac8cf1d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PastPresentationTimingGOOGLE) PassValue() (C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x.refac8cf1d8 != nil {
		return *x.refac8cf1d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PastPresentationTimingGOOGLE) Deref() {
	if x.refac8cf1d8 == nil {
		return
	}
	x.PresentID = (uint32)(x.refac8cf1d8.presentID)
	x.DesiredPresentTime = (uint64)(x.refac8cf1d8.desiredPresentTime)
	x.ActualPresentTime = (uint64)(x.refac8cf1d8.actualPresentTime)
	x.EarliestPresentTime = (uint64)(x.refac8cf1d8.earliestPresentTime)
	x.PresentMargin = (uint64)(x.refac8cf1d8.presentMargin)
}

// allocPresentTimeGOOGLEMemory allocates memory for type C.VkPresentTimeGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimeGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimeGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentTimeGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimeGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimeGOOGLE) Ref() *C.VkPresentTimeGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref9cd90ade
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimeGOOGLE) Free() {
	if x != nil && x.allocs9cd90ade != nil {
		x.allocs9cd90ade.(*cgoAllocMap).Free()
		x.ref9cd90ade = nil
	}
}

// NewPresentTimeGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimeGOOGLERef(ref unsafe.Pointer) *PresentTimeGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimeGOOGLE)
	obj.ref9cd90ade = (*C.VkPresentTimeGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimeGOOGLE) PassRef() (*C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9cd90ade != nil {
		return x.ref9cd90ade, nil
	}
	mem9cd90ade := allocPresentTimeGOOGLEMemory(1)
	ref9cd90ade := (*C.VkPresentTimeGOOGLE)(mem9cd90ade)
	allocs9cd90ade := new(cgoAllocMap)
	allocs9cd90ade.Add(mem9cd90ade)

	var cpresentID_allocs *cgoAllocMap
	ref9cd90ade.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	ref9cd90ade.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cdesiredPresentTime_allocs)

	x.ref9cd90ade = ref9cd90ade
	x.allocs9cd90ade = allocs9cd90ade
	return ref9cd90ade, allocs9cd90ade

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimeGOOGLE) PassValue() (C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x.ref9cd90ade != nil {
		return *x.ref9cd90ade, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimeGOOGLE) Deref() {
	if x.ref9cd90ade == nil {
		return
	}
	x.PresentID = (uint32)(x.ref9cd90ade.presentID)
	x.DesiredPresentTime = (uint64)(x.ref9cd90ade.desiredPresentTime)
}

// allocPresentTimesInfoGOOGLEMemory allocates memory for type C.VkPresentTimesInfoGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimesInfoGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimesInfoGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentTimesInfoGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimesInfoGOOGLE{})

// unpackSPresentTimeGOOGLE transforms a sliced Go data structure into plain C format.
func unpackSPresentTimeGOOGLE(x []PresentTimeGOOGLE) (unpacked *C.VkPresentTimeGOOGLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPresentTimeGOOGLE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPresentTimeGOOGLEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentTimeGOOGLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentTimeGOOGLE)(h.Data)
	return
}

// packSPresentTimeGOOGLE reads sliced Go data structure out from plain C format.
func packSPresentTimeGOOGLE(v []PresentTimeGOOGLE, ptr0 *C.VkPresentTimeGOOGLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentTimeGOOGLEValue]C.VkPresentTimeGOOGLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentTimeGOOGLERef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimesInfoGOOGLE) Ref() *C.VkPresentTimesInfoGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref70eb8ab3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimesInfoGOOGLE) Free() {
	if x != nil && x.allocs70eb8ab3 != nil {
		x.allocs70eb8ab3.(*cgoAllocMap).Free()
		x.ref70eb8ab3 = nil
	}
}

// NewPresentTimesInfoGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimesInfoGOOGLERef(ref unsafe.Pointer) *PresentTimesInfoGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimesInfoGOOGLE)
	obj.ref70eb8ab3 = (*C.VkPresentTimesInfoGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimesInfoGOOGLE) PassRef() (*C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70eb8ab3 != nil {
		return x.ref70eb8ab3, nil
	}
	mem70eb8ab3 := allocPresentTimesInfoGOOGLEMemory(1)
	ref70eb8ab3 := (*C.VkPresentTimesInfoGOOGLE)(mem70eb8ab3)
	allocs70eb8ab3 := new(cgoAllocMap)
	allocs70eb8ab3.Add(mem70eb8ab3)

	var csType_allocs *cgoAllocMap
	ref70eb8ab3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref70eb8ab3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref70eb8ab3.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cswapchainCount_allocs)

	var cpTimes_allocs *cgoAllocMap
	ref70eb8ab3.pTimes, cpTimes_allocs = unpackSPresentTimeGOOGLE(x.PTimes)
	allocs70eb8ab3.Borrow(cpTimes_allocs)

	x.ref70eb8ab3 = ref70eb8ab3
	x.allocs70eb8ab3 = allocs70eb8ab3
	return ref70eb8ab3, allocs70eb8ab3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimesInfoGOOGLE) PassValue() (C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x.ref70eb8ab3 != nil {
		return *x.ref70eb8ab3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimesInfoGOOGLE) Deref() {
	if x.ref70eb8ab3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref70eb8ab3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70eb8ab3.pNext))
	x.SwapchainCount = (uint32)(x.ref70eb8ab3.swapchainCount)
	packSPresentTimeGOOGLE(x.PTimes, x.ref70eb8ab3.pTimes)
}

// allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory allocates memory for type C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Ref() *C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if x == nil {
		return nil
	}
	return x.refbaf399ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Free() {
	if x != nil && x.allocsbaf399ad != nil {
		x.allocsbaf399ad.(*cgoAllocMap).Free()
		x.refbaf399ad = nil
	}
}

// NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
	obj.refbaf399ad = (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassRef() (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbaf399ad != nil {
		return x.refbaf399ad, nil
	}
	membaf399ad := allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(1)
	refbaf399ad := (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(membaf399ad)
	allocsbaf399ad := new(cgoAllocMap)
	allocsbaf399ad.Add(membaf399ad)

	var csType_allocs *cgoAllocMap
	refbaf399ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbaf399ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbaf399ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cpNext_allocs)

	var cperViewPositionAllComponents_allocs *cgoAllocMap
	refbaf399ad.perViewPositionAllComponents, cperViewPositionAllComponents_allocs = (C.VkBool32)(x.PerViewPositionAllComponents), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cperViewPositionAllComponents_allocs)

	x.refbaf399ad = refbaf399ad
	x.allocsbaf399ad = allocsbaf399ad
	return refbaf399ad, allocsbaf399ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassValue() (C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x.refbaf399ad != nil {
		return *x.refbaf399ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Deref() {
	if x.refbaf399ad == nil {
		return
	}
	x.SType = (StructureType)(x.refbaf399ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbaf399ad.pNext))
	x.PerViewPositionAllComponents = (Bool32)(x.refbaf399ad.perViewPositionAllComponents)
}

// allocViewportSwizzleNVMemory allocates memory for type C.VkViewportSwizzleNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportSwizzleNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportSwizzleNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportSwizzleNVValue = unsafe.Sizeof([1]C.VkViewportSwizzleNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportSwizzleNV) Ref() *C.VkViewportSwizzleNV {
	if x == nil {
		return nil
	}
	return x.ref74ff2887
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportSwizzleNV) Free() {
	if x != nil && x.allocs74ff2887 != nil {
		x.allocs74ff2887.(*cgoAllocMap).Free()
		x.ref74ff2887 = nil
	}
}

// NewViewportSwizzleNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportSwizzleNVRef(ref unsafe.Pointer) *ViewportSwizzleNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportSwizzleNV)
	obj.ref74ff2887 = (*C.VkViewportSwizzleNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportSwizzleNV) PassRef() (*C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74ff2887 != nil {
		return x.ref74ff2887, nil
	}
	mem74ff2887 := allocViewportSwizzleNVMemory(1)
	ref74ff2887 := (*C.VkViewportSwizzleNV)(mem74ff2887)
	allocs74ff2887 := new(cgoAllocMap)
	allocs74ff2887.Add(mem74ff2887)

	var cx_allocs *cgoAllocMap
	ref74ff2887.x, cx_allocs = (C.VkViewportCoordinateSwizzleNV)(x.X), cgoAllocsUnknown
	allocs74ff2887.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref74ff2887.y, cy_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Y), cgoAllocsUnknown
	allocs74ff2887.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref74ff2887.z, cz_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Z), cgoAllocsUnknown
	allocs74ff2887.Borrow(cz_allocs)

	var cw_allocs *cgoAllocMap
	ref74ff2887.w, cw_allocs = (C.VkViewportCoordinateSwizzleNV)(x.W), cgoAllocsUnknown
	allocs74ff2887.Borrow(cw_allocs)

	x.ref74ff2887 = ref74ff2887
	x.allocs74ff2887 = allocs74ff2887
	return ref74ff2887, allocs74ff2887

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportSwizzleNV) PassValue() (C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x.ref74ff2887 != nil {
		return *x.ref74ff2887, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportSwizzleNV) Deref() {
	if x.ref74ff2887 == nil {
		return
	}
	x.X = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.x)
	x.Y = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.y)
	x.Z = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.z)
	x.W = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.w)
}

// allocPipelineViewportSwizzleStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportSwizzleStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportSwizzleStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportSwizzleStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportSwizzleStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportSwizzleStateCreateInfoNV{})

// unpackSViewportSwizzleNV transforms a sliced Go data structure into plain C format.
func unpackSViewportSwizzleNV(x []ViewportSwizzleNV) (unpacked *C.VkViewportSwizzleNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewportSwizzleNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportSwizzleNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportSwizzleNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportSwizzleNV)(h.Data)
	return
}

// packSViewportSwizzleNV reads sliced Go data structure out from plain C format.
func packSViewportSwizzleNV(v []ViewportSwizzleNV, ptr0 *C.VkViewportSwizzleNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportSwizzleNVValue]C.VkViewportSwizzleNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportSwizzleNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Ref() *C.VkPipelineViewportSwizzleStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5e90f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Free() {
	if x != nil && x.allocs5e90f24 != nil {
		x.allocs5e90f24.(*cgoAllocMap).Free()
		x.ref5e90f24 = nil
	}
}

// NewPipelineViewportSwizzleStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportSwizzleStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportSwizzleStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportSwizzleStateCreateInfoNV)
	obj.ref5e90f24 = (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) PassRef() (*C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e90f24 != nil {
		return x.ref5e90f24, nil
	}
	mem5e90f24 := allocPipelineViewportSwizzleStateCreateInfoNVMemory(1)
	ref5e90f24 := (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(mem5e90f24)
	allocs5e90f24 := new(cgoAllocMap)
	allocs5e90f24.Add(mem5e90f24)

	var csType_allocs *cgoAllocMap
	ref5e90f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e90f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e90f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e90f24.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5e90f24.flags, cflags_allocs = (C.VkPipelineViewportSwizzleStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs5e90f24.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref5e90f24.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs5e90f24.Borrow(cviewportCount_allocs)

	var cpViewportSwizzles_allocs *cgoAllocMap
	ref5e90f24.pViewportSwizzles, cpViewportSwizzles_allocs = unpackSViewportSwizzleNV(x.PViewportSwizzles)
	allocs5e90f24.Borrow(cpViewportSwizzles_allocs)

	x.ref5e90f24 = ref5e90f24
	x.allocs5e90f24 = allocs5e90f24
	return ref5e90f24, allocs5e90f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportSwizzleStateCreateInfoNV) PassValue() (C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x.ref5e90f24 != nil {
		return *x.ref5e90f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Deref() {
	if x.ref5e90f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e90f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e90f24.pNext))
	x.Flags = (PipelineViewportSwizzleStateCreateFlagsNV)(x.ref5e90f24.flags)
	x.ViewportCount = (uint32)(x.ref5e90f24.viewportCount)
	packSViewportSwizzleNV(x.PViewportSwizzles, x.ref5e90f24.pViewportSwizzles)
}

// allocPhysicalDeviceDiscardRectanglePropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceDiscardRectanglePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDiscardRectanglePropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDiscardRectanglePropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDiscardRectanglePropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDiscardRectanglePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDiscardRectanglePropertiesEXT) Ref() *C.VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.reffe8591da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDiscardRectanglePropertiesEXT) Free() {
	if x != nil && x.allocsfe8591da != nil {
		x.allocsfe8591da.(*cgoAllocMap).Free()
		x.reffe8591da = nil
	}
}

// NewPhysicalDeviceDiscardRectanglePropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDiscardRectanglePropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceDiscardRectanglePropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDiscardRectanglePropertiesEXT)
	obj.reffe8591da = (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDiscardRectanglePropertiesEXT) PassRef() (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe8591da != nil {
		return x.reffe8591da, nil
	}
	memfe8591da := allocPhysicalDeviceDiscardRectanglePropertiesEXTMemory(1)
	reffe8591da := (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(memfe8591da)
	allocsfe8591da := new(cgoAllocMap)
	allocsfe8591da.Add(memfe8591da)

	var csType_allocs *cgoAllocMap
	reffe8591da.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe8591da.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe8591da.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe8591da.Borrow(cpNext_allocs)

	var cmaxDiscardRectangles_allocs *cgoAllocMap
	reffe8591da.maxDiscardRectangles, cmaxDiscardRectangles_allocs = (C.uint32_t)(x.MaxDiscardRectangles), cgoAllocsUnknown
	allocsfe8591da.Borrow(cmaxDiscardRectangles_allocs)

	x.reffe8591da = reffe8591da
	x.allocsfe8591da = allocsfe8591da
	return reffe8591da, allocsfe8591da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDiscardRectanglePropertiesEXT) PassValue() (C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x.reffe8591da != nil {
		return *x.reffe8591da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDiscardRectanglePropertiesEXT) Deref() {
	if x.reffe8591da == nil {
		return
	}
	x.SType = (StructureType)(x.reffe8591da.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe8591da.pNext))
	x.MaxDiscardRectangles = (uint32)(x.reffe8591da.maxDiscardRectangles)
}

// allocPipelineDiscardRectangleStateCreateInfoEXTMemory allocates memory for type C.VkPipelineDiscardRectangleStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDiscardRectangleStateCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDiscardRectangleStateCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDiscardRectangleStateCreateInfoEXTValue = unsafe.Sizeof([1]C.VkPipelineDiscardRectangleStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDiscardRectangleStateCreateInfoEXT) Ref() *C.VkPipelineDiscardRectangleStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcdbb125e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDiscardRectangleStateCreateInfoEXT) Free() {
	if x != nil && x.allocscdbb125e != nil {
		x.allocscdbb125e.(*cgoAllocMap).Free()
		x.refcdbb125e = nil
	}
}

// NewPipelineDiscardRectangleStateCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDiscardRectangleStateCreateInfoEXTRef(ref unsafe.Pointer) *PipelineDiscardRectangleStateCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDiscardRectangleStateCreateInfoEXT)
	obj.refcdbb125e = (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDiscardRectangleStateCreateInfoEXT) PassRef() (*C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdbb125e != nil {
		return x.refcdbb125e, nil
	}
	memcdbb125e := allocPipelineDiscardRectangleStateCreateInfoEXTMemory(1)
	refcdbb125e := (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(memcdbb125e)
	allocscdbb125e := new(cgoAllocMap)
	allocscdbb125e.Add(memcdbb125e)

	var csType_allocs *cgoAllocMap
	refcdbb125e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscdbb125e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcdbb125e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscdbb125e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcdbb125e.flags, cflags_allocs = (C.VkPipelineDiscardRectangleStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocscdbb125e.Borrow(cflags_allocs)

	var cdiscardRectangleMode_allocs *cgoAllocMap
	refcdbb125e.discardRectangleMode, cdiscardRectangleMode_allocs = (C.VkDiscardRectangleModeEXT)(x.DiscardRectangleMode), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleMode_allocs)

	var cdiscardRectangleCount_allocs *cgoAllocMap
	refcdbb125e.discardRectangleCount, cdiscardRectangleCount_allocs = (C.uint32_t)(x.DiscardRectangleCount), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleCount_allocs)

	var cpDiscardRectangles_allocs *cgoAllocMap
	refcdbb125e.pDiscardRectangles, cpDiscardRectangles_allocs = unpackSRect2D(x.PDiscardRectangles)
	allocscdbb125e.Borrow(cpDiscardRectangles_allocs)

	x.refcdbb125e = refcdbb125e
	x.allocscdbb125e = allocscdbb125e
	return refcdbb125e, allocscdbb125e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDiscardRectangleStateCreateInfoEXT) PassValue() (C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcdbb125e != nil {
		return *x.refcdbb125e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDiscardRectangleStateCreateInfoEXT) Deref() {
	if x.refcdbb125e == nil {
		return
	}
	x.SType = (StructureType)(x.refcdbb125e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcdbb125e.pNext))
	x.Flags = (PipelineDiscardRectangleStateCreateFlagsEXT)(x.refcdbb125e.flags)
	x.DiscardRectangleMode = (DiscardRectangleModeEXT)(x.refcdbb125e.discardRectangleMode)
	x.DiscardRectangleCount = (uint32)(x.refcdbb125e.discardRectangleCount)
	packSRect2D(x.PDiscardRectangles, x.refcdbb125e.pDiscardRectangles)
}

// allocPhysicalDeviceConservativeRasterizationPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConservativeRasterizationPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConservativeRasterizationPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceConservativeRasterizationPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConservativeRasterizationPropertiesEXT) Ref() *C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref878f819c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConservativeRasterizationPropertiesEXT) Free() {
	if x != nil && x.allocs878f819c != nil {
		x.allocs878f819c.(*cgoAllocMap).Free()
		x.ref878f819c = nil
	}
}

// NewPhysicalDeviceConservativeRasterizationPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConservativeRasterizationPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceConservativeRasterizationPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConservativeRasterizationPropertiesEXT)
	obj.ref878f819c = (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConservativeRasterizationPropertiesEXT) PassRef() (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878f819c != nil {
		return x.ref878f819c, nil
	}
	mem878f819c := allocPhysicalDeviceConservativeRasterizationPropertiesEXTMemory(1)
	ref878f819c := (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(mem878f819c)
	allocs878f819c := new(cgoAllocMap)
	allocs878f819c.Add(mem878f819c)

	var csType_allocs *cgoAllocMap
	ref878f819c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878f819c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878f819c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878f819c.Borrow(cpNext_allocs)

	var cprimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.primitiveOverestimationSize, cprimitiveOverestimationSize_allocs = (C.float)(x.PrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveOverestimationSize_allocs)

	var cmaxExtraPrimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.maxExtraPrimitiveOverestimationSize, cmaxExtraPrimitiveOverestimationSize_allocs = (C.float)(x.MaxExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cmaxExtraPrimitiveOverestimationSize_allocs)

	var cextraPrimitiveOverestimationSizeGranularity_allocs *cgoAllocMap
	ref878f819c.extraPrimitiveOverestimationSizeGranularity, cextraPrimitiveOverestimationSizeGranularity_allocs = (C.float)(x.ExtraPrimitiveOverestimationSizeGranularity), cgoAllocsUnknown
	allocs878f819c.Borrow(cextraPrimitiveOverestimationSizeGranularity_allocs)

	var cprimitiveUnderestimation_allocs *cgoAllocMap
	ref878f819c.primitiveUnderestimation, cprimitiveUnderestimation_allocs = (C.VkBool32)(x.PrimitiveUnderestimation), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveUnderestimation_allocs)

	var cconservativePointAndLineRasterization_allocs *cgoAllocMap
	ref878f819c.conservativePointAndLineRasterization, cconservativePointAndLineRasterization_allocs = (C.VkBool32)(x.ConservativePointAndLineRasterization), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativePointAndLineRasterization_allocs)

	var cdegenerateTrianglesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateTrianglesRasterized, cdegenerateTrianglesRasterized_allocs = (C.VkBool32)(x.DegenerateTrianglesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateTrianglesRasterized_allocs)

	var cdegenerateLinesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateLinesRasterized, cdegenerateLinesRasterized_allocs = (C.VkBool32)(x.DegenerateLinesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateLinesRasterized_allocs)

	var cfullyCoveredFragmentShaderInputVariable_allocs *cgoAllocMap
	ref878f819c.fullyCoveredFragmentShaderInputVariable, cfullyCoveredFragmentShaderInputVariable_allocs = (C.VkBool32)(x.FullyCoveredFragmentShaderInputVariable), cgoAllocsUnknown
	allocs878f819c.Borrow(cfullyCoveredFragmentShaderInputVariable_allocs)

	var cconservativeRasterizationPostDepthCoverage_allocs *cgoAllocMap
	ref878f819c.conservativeRasterizationPostDepthCoverage, cconservativeRasterizationPostDepthCoverage_allocs = (C.VkBool32)(x.ConservativeRasterizationPostDepthCoverage), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativeRasterizationPostDepthCoverage_allocs)

	x.ref878f819c = ref878f819c
	x.allocs878f819c = allocs878f819c
	return ref878f819c, allocs878f819c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConservativeRasterizationPropertiesEXT) PassValue() (C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x.ref878f819c != nil {
		return *x.ref878f819c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConservativeRasterizationPropertiesEXT) Deref() {
	if x.ref878f819c == nil {
		return
	}
	x.SType = (StructureType)(x.ref878f819c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878f819c.pNext))
	x.PrimitiveOverestimationSize = (float32)(x.ref878f819c.primitiveOverestimationSize)
	x.MaxExtraPrimitiveOverestimationSize = (float32)(x.ref878f819c.maxExtraPrimitiveOverestimationSize)
	x.ExtraPrimitiveOverestimationSizeGranularity = (float32)(x.ref878f819c.extraPrimitiveOverestimationSizeGranularity)
	x.PrimitiveUnderestimation = (Bool32)(x.ref878f819c.primitiveUnderestimation)
	x.ConservativePointAndLineRasterization = (Bool32)(x.ref878f819c.conservativePointAndLineRasterization)
	x.DegenerateTrianglesRasterized = (Bool32)(x.ref878f819c.degenerateTrianglesRasterized)
	x.DegenerateLinesRasterized = (Bool32)(x.ref878f819c.degenerateLinesRasterized)
	x.FullyCoveredFragmentShaderInputVariable = (Bool32)(x.ref878f819c.fullyCoveredFragmentShaderInputVariable)
	x.ConservativeRasterizationPostDepthCoverage = (Bool32)(x.ref878f819c.conservativeRasterizationPostDepthCoverage)
}

// allocPipelineRasterizationConservativeStateCreateInfoEXTMemory allocates memory for type C.VkPipelineRasterizationConservativeStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationConservativeStateCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationConservativeStateCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationConservativeStateCreateInfoEXTValue = unsafe.Sizeof([1]C.VkPipelineRasterizationConservativeStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationConservativeStateCreateInfoEXT) Ref() *C.VkPipelineRasterizationConservativeStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe3cd0046
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfoEXT) Free() {
	if x != nil && x.allocse3cd0046 != nil {
		x.allocse3cd0046.(*cgoAllocMap).Free()
		x.refe3cd0046 = nil
	}
}

// NewPipelineRasterizationConservativeStateCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationConservativeStateCreateInfoEXTRef(ref unsafe.Pointer) *PipelineRasterizationConservativeStateCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationConservativeStateCreateInfoEXT)
	obj.refe3cd0046 = (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfoEXT) PassRef() (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3cd0046 != nil {
		return x.refe3cd0046, nil
	}
	meme3cd0046 := allocPipelineRasterizationConservativeStateCreateInfoEXTMemory(1)
	refe3cd0046 := (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(meme3cd0046)
	allocse3cd0046 := new(cgoAllocMap)
	allocse3cd0046.Add(meme3cd0046)

	var csType_allocs *cgoAllocMap
	refe3cd0046.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse3cd0046.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe3cd0046.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse3cd0046.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe3cd0046.flags, cflags_allocs = (C.VkPipelineRasterizationConservativeStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocse3cd0046.Borrow(cflags_allocs)

	var cconservativeRasterizationMode_allocs *cgoAllocMap
	refe3cd0046.conservativeRasterizationMode, cconservativeRasterizationMode_allocs = (C.VkConservativeRasterizationModeEXT)(x.ConservativeRasterizationMode), cgoAllocsUnknown
	allocse3cd0046.Borrow(cconservativeRasterizationMode_allocs)

	var cextraPrimitiveOverestimationSize_allocs *cgoAllocMap
	refe3cd0046.extraPrimitiveOverestimationSize, cextraPrimitiveOverestimationSize_allocs = (C.float)(x.ExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocse3cd0046.Borrow(cextraPrimitiveOverestimationSize_allocs)

	x.refe3cd0046 = refe3cd0046
	x.allocse3cd0046 = allocse3cd0046
	return refe3cd0046, allocse3cd0046

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationConservativeStateCreateInfoEXT) PassValue() (C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x.refe3cd0046 != nil {
		return *x.refe3cd0046, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationConservativeStateCreateInfoEXT) Deref() {
	if x.refe3cd0046 == nil {
		return
	}
	x.SType = (StructureType)(x.refe3cd0046.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe3cd0046.pNext))
	x.Flags = (PipelineRasterizationConservativeStateCreateFlagsEXT)(x.refe3cd0046.flags)
	x.ConservativeRasterizationMode = (ConservativeRasterizationModeEXT)(x.refe3cd0046.conservativeRasterizationMode)
	x.ExtraPrimitiveOverestimationSize = (float32)(x.refe3cd0046.extraPrimitiveOverestimationSize)
}

// allocXYColorEXTMemory allocates memory for type C.VkXYColorEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXYColorEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXYColorEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXYColorEXTValue = unsafe.Sizeof([1]C.VkXYColorEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XYColorEXT) Ref() *C.VkXYColorEXT {
	if x == nil {
		return nil
	}
	return x.refb8efaa5c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XYColorEXT) Free() {
	if x != nil && x.allocsb8efaa5c != nil {
		x.allocsb8efaa5c.(*cgoAllocMap).Free()
		x.refb8efaa5c = nil
	}
}

// NewXYColorEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXYColorEXTRef(ref unsafe.Pointer) *XYColorEXT {
	if ref == nil {
		return nil
	}
	obj := new(XYColorEXT)
	obj.refb8efaa5c = (*C.VkXYColorEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XYColorEXT) PassRef() (*C.VkXYColorEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8efaa5c != nil {
		return x.refb8efaa5c, nil
	}
	memb8efaa5c := allocXYColorEXTMemory(1)
	refb8efaa5c := (*C.VkXYColorEXT)(memb8efaa5c)
	allocsb8efaa5c := new(cgoAllocMap)
	allocsb8efaa5c.Add(memb8efaa5c)

	var cx_allocs *cgoAllocMap
	refb8efaa5c.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refb8efaa5c.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cy_allocs)

	x.refb8efaa5c = refb8efaa5c
	x.allocsb8efaa5c = allocsb8efaa5c
	return refb8efaa5c, allocsb8efaa5c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XYColorEXT) PassValue() (C.VkXYColorEXT, *cgoAllocMap) {
	if x.refb8efaa5c != nil {
		return *x.refb8efaa5c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XYColorEXT) Deref() {
	if x.refb8efaa5c == nil {
		return
	}
	x.X = (float32)(x.refb8efaa5c.x)
	x.Y = (float32)(x.refb8efaa5c.y)
}

// allocHdrMetadataEXTMemory allocates memory for type C.VkHdrMetadataEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHdrMetadataEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHdrMetadataEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHdrMetadataEXTValue = unsafe.Sizeof([1]C.VkHdrMetadataEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HdrMetadataEXT) Ref() *C.VkHdrMetadataEXT {
	if x == nil {
		return nil
	}
	return x.ref5fd28976
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HdrMetadataEXT) Free() {
	if x != nil && x.allocs5fd28976 != nil {
		x.allocs5fd28976.(*cgoAllocMap).Free()
		x.ref5fd28976 = nil
	}
}

// NewHdrMetadataEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHdrMetadataEXTRef(ref unsafe.Pointer) *HdrMetadataEXT {
	if ref == nil {
		return nil
	}
	obj := new(HdrMetadataEXT)
	obj.ref5fd28976 = (*C.VkHdrMetadataEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HdrMetadataEXT) PassRef() (*C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fd28976 != nil {
		return x.ref5fd28976, nil
	}
	mem5fd28976 := allocHdrMetadataEXTMemory(1)
	ref5fd28976 := (*C.VkHdrMetadataEXT)(mem5fd28976)
	allocs5fd28976 := new(cgoAllocMap)
	allocs5fd28976.Add(mem5fd28976)

	var csType_allocs *cgoAllocMap
	ref5fd28976.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fd28976.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fd28976.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fd28976.Borrow(cpNext_allocs)

	var cdisplayPrimaryRed_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryRed, cdisplayPrimaryRed_allocs = x.DisplayPrimaryRed.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryRed_allocs)

	var cdisplayPrimaryGreen_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryGreen, cdisplayPrimaryGreen_allocs = x.DisplayPrimaryGreen.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryGreen_allocs)

	var cdisplayPrimaryBlue_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryBlue, cdisplayPrimaryBlue_allocs = x.DisplayPrimaryBlue.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryBlue_allocs)

	var cwhitePoint_allocs *cgoAllocMap
	ref5fd28976.whitePoint, cwhitePoint_allocs = x.WhitePoint.PassValue()
	allocs5fd28976.Borrow(cwhitePoint_allocs)

	var cmaxLuminance_allocs *cgoAllocMap
	ref5fd28976.maxLuminance, cmaxLuminance_allocs = (C.float)(x.MaxLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxLuminance_allocs)

	var cminLuminance_allocs *cgoAllocMap
	ref5fd28976.minLuminance, cminLuminance_allocs = (C.float)(x.MinLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cminLuminance_allocs)

	var cmaxContentLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxContentLightLevel, cmaxContentLightLevel_allocs = (C.float)(x.MaxContentLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxContentLightLevel_allocs)

	var cmaxFrameAverageLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxFrameAverageLightLevel, cmaxFrameAverageLightLevel_allocs = (C.float)(x.MaxFrameAverageLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxFrameAverageLightLevel_allocs)

	x.ref5fd28976 = ref5fd28976
	x.allocs5fd28976 = allocs5fd28976
	return ref5fd28976, allocs5fd28976

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HdrMetadataEXT) PassValue() (C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x.ref5fd28976 != nil {
		return *x.ref5fd28976, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HdrMetadataEXT) Deref() {
	if x.ref5fd28976 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fd28976.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fd28976.pNext))
	x.DisplayPrimaryRed = *NewXYColorEXTRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryRed))
	x.DisplayPrimaryGreen = *NewXYColorEXTRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryGreen))
	x.DisplayPrimaryBlue = *NewXYColorEXTRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryBlue))
	x.WhitePoint = *NewXYColorEXTRef(unsafe.Pointer(&x.ref5fd28976.whitePoint))
	x.MaxLuminance = (float32)(x.ref5fd28976.maxLuminance)
	x.MinLuminance = (float32)(x.ref5fd28976.minLuminance)
	x.MaxContentLightLevel = (float32)(x.ref5fd28976.maxContentLightLevel)
	x.MaxFrameAverageLightLevel = (float32)(x.ref5fd28976.maxFrameAverageLightLevel)
}

// allocDebugUtilsObjectNameInfoEXTMemory allocates memory for type C.VkDebugUtilsObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectNameInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectNameInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsObjectNameInfoEXTValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectNameInfoEXT) Ref() *C.VkDebugUtilsObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5e73c2db
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectNameInfoEXT) Free() {
	if x != nil && x.allocs5e73c2db != nil {
		x.allocs5e73c2db.(*cgoAllocMap).Free()
		x.ref5e73c2db = nil
	}
}

// NewDebugUtilsObjectNameInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectNameInfoEXTRef(ref unsafe.Pointer) *DebugUtilsObjectNameInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectNameInfoEXT)
	obj.ref5e73c2db = (*C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectNameInfoEXT) PassRef() (*C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e73c2db != nil {
		return x.ref5e73c2db, nil
	}
	mem5e73c2db := allocDebugUtilsObjectNameInfoEXTMemory(1)
	ref5e73c2db := (*C.VkDebugUtilsObjectNameInfoEXT)(mem5e73c2db)
	allocs5e73c2db := new(cgoAllocMap)
	allocs5e73c2db.Add(mem5e73c2db)

	var csType_allocs *cgoAllocMap
	ref5e73c2db.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e73c2db.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref5e73c2db.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref5e73c2db.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectHandle_allocs)

	var cpObjectName_allocs *cgoAllocMap
	ref5e73c2db.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocs5e73c2db.Borrow(cpObjectName_allocs)

	x.ref5e73c2db = ref5e73c2db
	x.allocs5e73c2db = allocs5e73c2db
	return ref5e73c2db, allocs5e73c2db

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectNameInfoEXT) PassValue() (C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x.ref5e73c2db != nil {
		return *x.ref5e73c2db, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectNameInfoEXT) Deref() {
	if x.ref5e73c2db == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e73c2db.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e73c2db.pNext))
	x.ObjectType = (ObjectType)(x.ref5e73c2db.objectType)
	x.ObjectHandle = (uint64)(x.ref5e73c2db.objectHandle)
	x.PObjectName = packPCharString(x.ref5e73c2db.pObjectName)
}

// allocDebugUtilsObjectTagInfoEXTMemory allocates memory for type C.VkDebugUtilsObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectTagInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectTagInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsObjectTagInfoEXTValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectTagInfoEXT) Ref() *C.VkDebugUtilsObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9fd129cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectTagInfoEXT) Free() {
	if x != nil && x.allocs9fd129cf != nil {
		x.allocs9fd129cf.(*cgoAllocMap).Free()
		x.ref9fd129cf = nil
	}
}

// NewDebugUtilsObjectTagInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectTagInfoEXTRef(ref unsafe.Pointer) *DebugUtilsObjectTagInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectTagInfoEXT)
	obj.ref9fd129cf = (*C.VkDebugUtilsObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectTagInfoEXT) PassRef() (*C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9fd129cf != nil {
		return x.ref9fd129cf, nil
	}
	mem9fd129cf := allocDebugUtilsObjectTagInfoEXTMemory(1)
	ref9fd129cf := (*C.VkDebugUtilsObjectTagInfoEXT)(mem9fd129cf)
	allocs9fd129cf := new(cgoAllocMap)
	allocs9fd129cf.Add(mem9fd129cf)

	var csType_allocs *cgoAllocMap
	ref9fd129cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9fd129cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref9fd129cf.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref9fd129cf.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectHandle_allocs)

	var ctagName_allocs *cgoAllocMap
	ref9fd129cf.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	ref9fd129cf.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	ref9fd129cf.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpTag_allocs)

	x.ref9fd129cf = ref9fd129cf
	x.allocs9fd129cf = allocs9fd129cf
	return ref9fd129cf, allocs9fd129cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectTagInfoEXT) PassValue() (C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x.ref9fd129cf != nil {
		return *x.ref9fd129cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectTagInfoEXT) Deref() {
	if x.ref9fd129cf == nil {
		return
	}
	x.SType = (StructureType)(x.ref9fd129cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pNext))
	x.ObjectType = (ObjectType)(x.ref9fd129cf.objectType)
	x.ObjectHandle = (uint64)(x.ref9fd129cf.objectHandle)
	x.TagName = (uint64)(x.ref9fd129cf.tagName)
	x.TagSize = (uint)(x.ref9fd129cf.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pTag))
}

// allocDebugUtilsLabelEXTMemory allocates memory for type C.VkDebugUtilsLabelEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsLabelEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsLabelEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsLabelEXTValue = unsafe.Sizeof([1]C.VkDebugUtilsLabelEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsLabelEXT) Ref() *C.VkDebugUtilsLabelEXT {
	if x == nil {
		return nil
	}
	return x.ref8faaf7b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsLabelEXT) Free() {
	if x != nil && x.allocs8faaf7b1 != nil {
		x.allocs8faaf7b1.(*cgoAllocMap).Free()
		x.ref8faaf7b1 = nil
	}
}

// NewDebugUtilsLabelEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsLabelEXTRef(ref unsafe.Pointer) *DebugUtilsLabelEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsLabelEXT)
	obj.ref8faaf7b1 = (*C.VkDebugUtilsLabelEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsLabelEXT) PassRef() (*C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8faaf7b1 != nil {
		return x.ref8faaf7b1, nil
	}
	mem8faaf7b1 := allocDebugUtilsLabelEXTMemory(1)
	ref8faaf7b1 := (*C.VkDebugUtilsLabelEXT)(mem8faaf7b1)
	allocs8faaf7b1 := new(cgoAllocMap)
	allocs8faaf7b1.Add(mem8faaf7b1)

	var csType_allocs *cgoAllocMap
	ref8faaf7b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8faaf7b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(cpNext_allocs)

	var cpLabelName_allocs *cgoAllocMap
	ref8faaf7b1.pLabelName, cpLabelName_allocs = unpackPCharString(x.PLabelName)
	allocs8faaf7b1.Borrow(cpLabelName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref8faaf7b1.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(ccolor_allocs)

	x.ref8faaf7b1 = ref8faaf7b1
	x.allocs8faaf7b1 = allocs8faaf7b1
	return ref8faaf7b1, allocs8faaf7b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsLabelEXT) PassValue() (C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x.ref8faaf7b1 != nil {
		return *x.ref8faaf7b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsLabelEXT) Deref() {
	if x.ref8faaf7b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8faaf7b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8faaf7b1.pNext))
	x.PLabelName = packPCharString(x.ref8faaf7b1.pLabelName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref8faaf7b1.color))
}

// allocDebugUtilsMessengerCallbackDataEXTMemory allocates memory for type C.VkDebugUtilsMessengerCallbackDataEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsMessengerCallbackDataEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsMessengerCallbackDataEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsMessengerCallbackDataEXTValue = unsafe.Sizeof([1]C.VkDebugUtilsMessengerCallbackDataEXT{})

// unpackSDebugUtilsLabelEXT transforms a sliced Go data structure into plain C format.
func unpackSDebugUtilsLabelEXT(x []DebugUtilsLabelEXT) (unpacked *C.VkDebugUtilsLabelEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsLabelEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsLabelEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsLabelEXT)(h.Data)
	return
}

// unpackSDebugUtilsObjectNameInfoEXT transforms a sliced Go data structure into plain C format.
func unpackSDebugUtilsObjectNameInfoEXT(x []DebugUtilsObjectNameInfoEXT) (unpacked *C.VkDebugUtilsObjectNameInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsObjectNameInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsObjectNameInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsObjectNameInfoEXT)(h.Data)
	return
}

// packSDebugUtilsLabelEXT reads sliced Go data structure out from plain C format.
func packSDebugUtilsLabelEXT(v []DebugUtilsLabelEXT, ptr0 *C.VkDebugUtilsLabelEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugUtilsLabelEXTValue]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugUtilsLabelEXTRef(unsafe.Pointer(&ptr1))
	}
}

// packSDebugUtilsObjectNameInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugUtilsObjectNameInfoEXT(v []DebugUtilsObjectNameInfoEXT, ptr0 *C.VkDebugUtilsObjectNameInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugUtilsObjectNameInfoEXTValue]C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugUtilsObjectNameInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsMessengerCallbackDataEXT) Ref() *C.VkDebugUtilsMessengerCallbackDataEXT {
	if x == nil {
		return nil
	}
	return x.ref8bc88b5a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsMessengerCallbackDataEXT) Free() {
	if x != nil && x.allocs8bc88b5a != nil {
		x.allocs8bc88b5a.(*cgoAllocMap).Free()
		x.ref8bc88b5a = nil
	}
}

// NewDebugUtilsMessengerCallbackDataEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsMessengerCallbackDataEXTRef(ref unsafe.Pointer) *DebugUtilsMessengerCallbackDataEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsMessengerCallbackDataEXT)
	obj.ref8bc88b5a = (*C.VkDebugUtilsMessengerCallbackDataEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsMessengerCallbackDataEXT) PassRef() (*C.VkDebugUtilsMessengerCallbackDataEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8bc88b5a != nil {
		return x.ref8bc88b5a, nil
	}
	mem8bc88b5a := allocDebugUtilsMessengerCallbackDataEXTMemory(1)
	ref8bc88b5a := (*C.VkDebugUtilsMessengerCallbackDataEXT)(mem8bc88b5a)
	allocs8bc88b5a := new(cgoAllocMap)
	allocs8bc88b5a.Add(mem8bc88b5a)

	var csType_allocs *cgoAllocMap
	ref8bc88b5a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8bc88b5a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref8bc88b5a.flags, cflags_allocs = (C.VkDebugUtilsMessengerCallbackDataFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(cflags_allocs)

	var cpMessageIdName_allocs *cgoAllocMap
	ref8bc88b5a.pMessageIdName, cpMessageIdName_allocs = unpackPCharString(x.PMessageIdName)
	allocs8bc88b5a.Borrow(cpMessageIdName_allocs)

	var cmessageIdNumber_allocs *cgoAllocMap
	ref8bc88b5a.messageIdNumber, cmessageIdNumber_allocs = (C.int32_t)(x.MessageIdNumber), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(cmessageIdNumber_allocs)

	var cpMessage_allocs *cgoAllocMap
	ref8bc88b5a.pMessage, cpMessage_allocs = unpackPCharString(x.PMessage)
	allocs8bc88b5a.Borrow(cpMessage_allocs)

	var cqueueLabelCount_allocs *cgoAllocMap
	ref8bc88b5a.queueLabelCount, cqueueLabelCount_allocs = (C.uint32_t)(x.QueueLabelCount), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(cqueueLabelCount_allocs)

	var cpQueueLabels_allocs *cgoAllocMap
	ref8bc88b5a.pQueueLabels, cpQueueLabels_allocs = unpackSDebugUtilsLabelEXT(x.PQueueLabels)
	allocs8bc88b5a.Borrow(cpQueueLabels_allocs)

	var ccmdBufLabelCount_allocs *cgoAllocMap
	ref8bc88b5a.cmdBufLabelCount, ccmdBufLabelCount_allocs = (C.uint32_t)(x.CmdBufLabelCount), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(ccmdBufLabelCount_allocs)

	var cpCmdBufLabels_allocs *cgoAllocMap
	ref8bc88b5a.pCmdBufLabels, cpCmdBufLabels_allocs = unpackSDebugUtilsLabelEXT(x.PCmdBufLabels)
	allocs8bc88b5a.Borrow(cpCmdBufLabels_allocs)

	var cobjectCount_allocs *cgoAllocMap
	ref8bc88b5a.objectCount, cobjectCount_allocs = (C.uint32_t)(x.ObjectCount), cgoAllocsUnknown
	allocs8bc88b5a.Borrow(cobjectCount_allocs)

	var cpObjects_allocs *cgoAllocMap
	ref8bc88b5a.pObjects, cpObjects_allocs = unpackSDebugUtilsObjectNameInfoEXT(x.PObjects)
	allocs8bc88b5a.Borrow(cpObjects_allocs)

	x.ref8bc88b5a = ref8bc88b5a
	x.allocs8bc88b5a = allocs8bc88b5a
	return ref8bc88b5a, allocs8bc88b5a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsMessengerCallbackDataEXT) PassValue() (C.VkDebugUtilsMessengerCallbackDataEXT, *cgoAllocMap) {
	if x.ref8bc88b5a != nil {
		return *x.ref8bc88b5a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsMessengerCallbackDataEXT) Deref() {
	if x.ref8bc88b5a == nil {
		return
	}
	x.SType = (StructureType)(x.ref8bc88b5a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8bc88b5a.pNext))
	x.Flags = (DebugUtilsMessengerCallbackDataFlagsEXT)(x.ref8bc88b5a.flags)
	x.PMessageIdName = packPCharString(x.ref8bc88b5a.pMessageIdName)
	x.MessageIdNumber = (int32)(x.ref8bc88b5a.messageIdNumber)
	x.PMessage = packPCharString(x.ref8bc88b5a.pMessage)
	x.QueueLabelCount = (uint32)(x.ref8bc88b5a.queueLabelCount)
	packSDebugUtilsLabelEXT(x.PQueueLabels, x.ref8bc88b5a.pQueueLabels)
	x.CmdBufLabelCount = (uint32)(x.ref8bc88b5a.cmdBufLabelCount)
	packSDebugUtilsLabelEXT(x.PCmdBufLabels, x.ref8bc88b5a.pCmdBufLabels)
	x.ObjectCount = (uint32)(x.ref8bc88b5a.objectCount)
	packSDebugUtilsObjectNameInfoEXT(x.PObjects, x.ref8bc88b5a.pObjects)
}

// allocDebugUtilsMessengerCreateInfoEXTMemory allocates memory for type C.VkDebugUtilsMessengerCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsMessengerCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsMessengerCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsMessengerCreateInfoEXTValue = unsafe.Sizeof([1]C.VkDebugUtilsMessengerCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsMessengerCreateInfoEXT) Ref() *C.VkDebugUtilsMessengerCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5f49d96
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsMessengerCreateInfoEXT) Free() {
	if x != nil && x.allocs5f49d96 != nil {
		x.allocs5f49d96.(*cgoAllocMap).Free()
		x.ref5f49d96 = nil
	}
}

// NewDebugUtilsMessengerCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsMessengerCreateInfoEXTRef(ref unsafe.Pointer) *DebugUtilsMessengerCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsMessengerCreateInfoEXT)
	obj.ref5f49d96 = (*C.VkDebugUtilsMessengerCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsMessengerCreateInfoEXT) PassRef() (*C.VkDebugUtilsMessengerCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f49d96 != nil {
		return x.ref5f49d96, nil
	}
	mem5f49d96 := allocDebugUtilsMessengerCreateInfoEXTMemory(1)
	ref5f49d96 := (*C.VkDebugUtilsMessengerCreateInfoEXT)(mem5f49d96)
	allocs5f49d96 := new(cgoAllocMap)
	allocs5f49d96.Add(mem5f49d96)

	var csType_allocs *cgoAllocMap
	ref5f49d96.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5f49d96.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5f49d96.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5f49d96.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5f49d96.flags, cflags_allocs = (C.VkDebugUtilsMessengerCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs5f49d96.Borrow(cflags_allocs)

	var cmessageSeverity_allocs *cgoAllocMap
	ref5f49d96.messageSeverity, cmessageSeverity_allocs = (C.VkDebugUtilsMessageSeverityFlagsEXT)(x.MessageSeverity), cgoAllocsUnknown
	allocs5f49d96.Borrow(cmessageSeverity_allocs)

	var cmessageType_allocs *cgoAllocMap
	ref5f49d96.messageType, cmessageType_allocs = (C.VkDebugUtilsMessageTypeFlagsEXT)(x.MessageType), cgoAllocsUnknown
	allocs5f49d96.Borrow(cmessageType_allocs)

	var cpfnUserCallback_allocs *cgoAllocMap
	ref5f49d96.pfnUserCallback, cpfnUserCallback_allocs = x.PfnUserCallback.PassValue()
	allocs5f49d96.Borrow(cpfnUserCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	ref5f49d96.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocs5f49d96.Borrow(cpUserData_allocs)

	x.ref5f49d96 = ref5f49d96
	x.allocs5f49d96 = allocs5f49d96
	return ref5f49d96, allocs5f49d96

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsMessengerCreateInfoEXT) PassValue() (C.VkDebugUtilsMessengerCreateInfoEXT, *cgoAllocMap) {
	if x.ref5f49d96 != nil {
		return *x.ref5f49d96, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsMessengerCreateInfoEXT) Deref() {
	if x.ref5f49d96 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5f49d96.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5f49d96.pNext))
	x.Flags = (DebugUtilsMessengerCreateFlagsEXT)(x.ref5f49d96.flags)
	x.MessageSeverity = (DebugUtilsMessageSeverityFlagsEXT)(x.ref5f49d96.messageSeverity)
	x.MessageType = (DebugUtilsMessageTypeFlagsEXT)(x.ref5f49d96.messageType)
	x.PfnUserCallback = *NewRef(unsafe.Pointer(&x.ref5f49d96.pfnUserCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.ref5f49d96.pUserData))
}

// allocSamplerReductionModeCreateInfoEXTMemory allocates memory for type C.VkSamplerReductionModeCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerReductionModeCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerReductionModeCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerReductionModeCreateInfoEXTValue = unsafe.Sizeof([1]C.VkSamplerReductionModeCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerReductionModeCreateInfoEXT) Ref() *C.VkSamplerReductionModeCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.reff1cfd4e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerReductionModeCreateInfoEXT) Free() {
	if x != nil && x.allocsf1cfd4e3 != nil {
		x.allocsf1cfd4e3.(*cgoAllocMap).Free()
		x.reff1cfd4e3 = nil
	}
}

// NewSamplerReductionModeCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerReductionModeCreateInfoEXTRef(ref unsafe.Pointer) *SamplerReductionModeCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(SamplerReductionModeCreateInfoEXT)
	obj.reff1cfd4e3 = (*C.VkSamplerReductionModeCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerReductionModeCreateInfoEXT) PassRef() (*C.VkSamplerReductionModeCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1cfd4e3 != nil {
		return x.reff1cfd4e3, nil
	}
	memf1cfd4e3 := allocSamplerReductionModeCreateInfoEXTMemory(1)
	reff1cfd4e3 := (*C.VkSamplerReductionModeCreateInfoEXT)(memf1cfd4e3)
	allocsf1cfd4e3 := new(cgoAllocMap)
	allocsf1cfd4e3.Add(memf1cfd4e3)

	var csType_allocs *cgoAllocMap
	reff1cfd4e3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff1cfd4e3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(cpNext_allocs)

	var creductionMode_allocs *cgoAllocMap
	reff1cfd4e3.reductionMode, creductionMode_allocs = (C.VkSamplerReductionModeEXT)(x.ReductionMode), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(creductionMode_allocs)

	x.reff1cfd4e3 = reff1cfd4e3
	x.allocsf1cfd4e3 = allocsf1cfd4e3
	return reff1cfd4e3, allocsf1cfd4e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerReductionModeCreateInfoEXT) PassValue() (C.VkSamplerReductionModeCreateInfoEXT, *cgoAllocMap) {
	if x.reff1cfd4e3 != nil {
		return *x.reff1cfd4e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerReductionModeCreateInfoEXT) Deref() {
	if x.reff1cfd4e3 == nil {
		return
	}
	x.SType = (StructureType)(x.reff1cfd4e3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff1cfd4e3.pNext))
	x.ReductionMode = (SamplerReductionModeEXT)(x.reff1cfd4e3.reductionMode)
}

// allocPhysicalDeviceSamplerFilterMinmaxPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerFilterMinmaxPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerFilterMinmaxPropertiesEXT) Ref() *C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refcc32d100
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxPropertiesEXT) Free() {
	if x != nil && x.allocscc32d100 != nil {
		x.allocscc32d100.(*cgoAllocMap).Free()
		x.refcc32d100 = nil
	}
}

// NewPhysicalDeviceSamplerFilterMinmaxPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerFilterMinmaxPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerFilterMinmaxPropertiesEXT)
	obj.refcc32d100 = (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxPropertiesEXT) PassRef() (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc32d100 != nil {
		return x.refcc32d100, nil
	}
	memcc32d100 := allocPhysicalDeviceSamplerFilterMinmaxPropertiesEXTMemory(1)
	refcc32d100 := (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT)(memcc32d100)
	allocscc32d100 := new(cgoAllocMap)
	allocscc32d100.Add(memcc32d100)

	var csType_allocs *cgoAllocMap
	refcc32d100.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc32d100.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc32d100.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc32d100.Borrow(cpNext_allocs)

	var cfilterMinmaxSingleComponentFormats_allocs *cgoAllocMap
	refcc32d100.filterMinmaxSingleComponentFormats, cfilterMinmaxSingleComponentFormats_allocs = (C.VkBool32)(x.FilterMinmaxSingleComponentFormats), cgoAllocsUnknown
	allocscc32d100.Borrow(cfilterMinmaxSingleComponentFormats_allocs)

	var cfilterMinmaxImageComponentMapping_allocs *cgoAllocMap
	refcc32d100.filterMinmaxImageComponentMapping, cfilterMinmaxImageComponentMapping_allocs = (C.VkBool32)(x.FilterMinmaxImageComponentMapping), cgoAllocsUnknown
	allocscc32d100.Borrow(cfilterMinmaxImageComponentMapping_allocs)

	x.refcc32d100 = refcc32d100
	x.allocscc32d100 = allocscc32d100
	return refcc32d100, allocscc32d100

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxPropertiesEXT) PassValue() (C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, *cgoAllocMap) {
	if x.refcc32d100 != nil {
		return *x.refcc32d100, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerFilterMinmaxPropertiesEXT) Deref() {
	if x.refcc32d100 == nil {
		return
	}
	x.SType = (StructureType)(x.refcc32d100.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc32d100.pNext))
	x.FilterMinmaxSingleComponentFormats = (Bool32)(x.refcc32d100.filterMinmaxSingleComponentFormats)
	x.FilterMinmaxImageComponentMapping = (Bool32)(x.refcc32d100.filterMinmaxImageComponentMapping)
}

// allocSampleLocationEXTMemory allocates memory for type C.VkSampleLocationEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSampleLocationEXTValue = unsafe.Sizeof([1]C.VkSampleLocationEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocationEXT) Ref() *C.VkSampleLocationEXT {
	if x == nil {
		return nil
	}
	return x.refe7a2e761
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocationEXT) Free() {
	if x != nil && x.allocse7a2e761 != nil {
		x.allocse7a2e761.(*cgoAllocMap).Free()
		x.refe7a2e761 = nil
	}
}

// NewSampleLocationEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationEXTRef(ref unsafe.Pointer) *SampleLocationEXT {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocationEXT)
	obj.refe7a2e761 = (*C.VkSampleLocationEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocationEXT) PassRef() (*C.VkSampleLocationEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7a2e761 != nil {
		return x.refe7a2e761, nil
	}
	meme7a2e761 := allocSampleLocationEXTMemory(1)
	refe7a2e761 := (*C.VkSampleLocationEXT)(meme7a2e761)
	allocse7a2e761 := new(cgoAllocMap)
	allocse7a2e761.Add(meme7a2e761)

	var cx_allocs *cgoAllocMap
	refe7a2e761.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocse7a2e761.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refe7a2e761.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocse7a2e761.Borrow(cy_allocs)

	x.refe7a2e761 = refe7a2e761
	x.allocse7a2e761 = allocse7a2e761
	return refe7a2e761, allocse7a2e761

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocationEXT) PassValue() (C.VkSampleLocationEXT, *cgoAllocMap) {
	if x.refe7a2e761 != nil {
		return *x.refe7a2e761, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocationEXT) Deref() {
	if x.refe7a2e761 == nil {
		return
	}
	x.X = (float32)(x.refe7a2e761.x)
	x.Y = (float32)(x.refe7a2e761.y)
}

// allocSampleLocationsInfoEXTMemory allocates memory for type C.VkSampleLocationsInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationsInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationsInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSampleLocationsInfoEXTValue = unsafe.Sizeof([1]C.VkSampleLocationsInfoEXT{})

// unpackSSampleLocationEXT transforms a sliced Go data structure into plain C format.
func unpackSSampleLocationEXT(x []SampleLocationEXT) (unpacked *C.VkSampleLocationEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSampleLocationEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSampleLocationEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSampleLocationEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSampleLocationEXT)(h.Data)
	return
}

// packSSampleLocationEXT reads sliced Go data structure out from plain C format.
func packSSampleLocationEXT(v []SampleLocationEXT, ptr0 *C.VkSampleLocationEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSampleLocationEXTValue]C.VkSampleLocationEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSampleLocationEXTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocationsInfoEXT) Ref() *C.VkSampleLocationsInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd8f3bd2d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocationsInfoEXT) Free() {
	if x != nil && x.allocsd8f3bd2d != nil {
		x.allocsd8f3bd2d.(*cgoAllocMap).Free()
		x.refd8f3bd2d = nil
	}
}

// NewSampleLocationsInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationsInfoEXTRef(ref unsafe.Pointer) *SampleLocationsInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocationsInfoEXT)
	obj.refd8f3bd2d = (*C.VkSampleLocationsInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocationsInfoEXT) PassRef() (*C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8f3bd2d != nil {
		return x.refd8f3bd2d, nil
	}
	memd8f3bd2d := allocSampleLocationsInfoEXTMemory(1)
	refd8f3bd2d := (*C.VkSampleLocationsInfoEXT)(memd8f3bd2d)
	allocsd8f3bd2d := new(cgoAllocMap)
	allocsd8f3bd2d.Add(memd8f3bd2d)

	var csType_allocs *cgoAllocMap
	refd8f3bd2d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd8f3bd2d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(cpNext_allocs)

	var csampleLocationsPerPixel_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsPerPixel, csampleLocationsPerPixel_allocs = (C.VkSampleCountFlagBits)(x.SampleLocationsPerPixel), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsPerPixel_allocs)

	var csampleLocationGridSize_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationGridSize, csampleLocationGridSize_allocs = x.SampleLocationGridSize.PassValue()
	allocsd8f3bd2d.Borrow(csampleLocationGridSize_allocs)

	var csampleLocationsCount_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsCount, csampleLocationsCount_allocs = (C.uint32_t)(x.SampleLocationsCount), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsCount_allocs)

	var cpSampleLocations_allocs *cgoAllocMap
	refd8f3bd2d.pSampleLocations, cpSampleLocations_allocs = unpackSSampleLocationEXT(x.PSampleLocations)
	allocsd8f3bd2d.Borrow(cpSampleLocations_allocs)

	x.refd8f3bd2d = refd8f3bd2d
	x.allocsd8f3bd2d = allocsd8f3bd2d
	return refd8f3bd2d, allocsd8f3bd2d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocationsInfoEXT) PassValue() (C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x.refd8f3bd2d != nil {
		return *x.refd8f3bd2d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocationsInfoEXT) Deref() {
	if x.refd8f3bd2d == nil {
		return
	}
	x.SType = (StructureType)(x.refd8f3bd2d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8f3bd2d.pNext))
	x.SampleLocationsPerPixel = (SampleCountFlagBits)(x.refd8f3bd2d.sampleLocationsPerPixel)
	x.SampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refd8f3bd2d.sampleLocationGridSize))
	x.SampleLocationsCount = (uint32)(x.refd8f3bd2d.sampleLocationsCount)
	packSSampleLocationEXT(x.PSampleLocations, x.refd8f3bd2d.pSampleLocations)
}

// allocAttachmentSampleLocationsEXTMemory allocates memory for type C.VkAttachmentSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleLocationsEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleLocationsEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentSampleLocationsEXTValue = unsafe.Sizeof([1]C.VkAttachmentSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleLocationsEXT) Ref() *C.VkAttachmentSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref6a3dd41e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleLocationsEXT) Free() {
	if x != nil && x.allocs6a3dd41e != nil {
		x.allocs6a3dd41e.(*cgoAllocMap).Free()
		x.ref6a3dd41e = nil
	}
}

// NewAttachmentSampleLocationsEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleLocationsEXTRef(ref unsafe.Pointer) *AttachmentSampleLocationsEXT {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleLocationsEXT)
	obj.ref6a3dd41e = (*C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleLocationsEXT) PassRef() (*C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a3dd41e != nil {
		return x.ref6a3dd41e, nil
	}
	mem6a3dd41e := allocAttachmentSampleLocationsEXTMemory(1)
	ref6a3dd41e := (*C.VkAttachmentSampleLocationsEXT)(mem6a3dd41e)
	allocs6a3dd41e := new(cgoAllocMap)
	allocs6a3dd41e.Add(mem6a3dd41e)

	var cattachmentIndex_allocs *cgoAllocMap
	ref6a3dd41e.attachmentIndex, cattachmentIndex_allocs = (C.uint32_t)(x.AttachmentIndex), cgoAllocsUnknown
	allocs6a3dd41e.Borrow(cattachmentIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref6a3dd41e.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs6a3dd41e.Borrow(csampleLocationsInfo_allocs)

	x.ref6a3dd41e = ref6a3dd41e
	x.allocs6a3dd41e = allocs6a3dd41e
	return ref6a3dd41e, allocs6a3dd41e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleLocationsEXT) PassValue() (C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x.ref6a3dd41e != nil {
		return *x.ref6a3dd41e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleLocationsEXT) Deref() {
	if x.ref6a3dd41e == nil {
		return
	}
	x.AttachmentIndex = (uint32)(x.ref6a3dd41e.attachmentIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoEXTRef(unsafe.Pointer(&x.ref6a3dd41e.sampleLocationsInfo))
}

// allocSubpassSampleLocationsEXTMemory allocates memory for type C.VkSubpassSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassSampleLocationsEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassSampleLocationsEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassSampleLocationsEXTValue = unsafe.Sizeof([1]C.VkSubpassSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassSampleLocationsEXT) Ref() *C.VkSubpassSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref1f612812
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassSampleLocationsEXT) Free() {
	if x != nil && x.allocs1f612812 != nil {
		x.allocs1f612812.(*cgoAllocMap).Free()
		x.ref1f612812 = nil
	}
}

// NewSubpassSampleLocationsEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassSampleLocationsEXTRef(ref unsafe.Pointer) *SubpassSampleLocationsEXT {
	if ref == nil {
		return nil
	}
	obj := new(SubpassSampleLocationsEXT)
	obj.ref1f612812 = (*C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassSampleLocationsEXT) PassRef() (*C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f612812 != nil {
		return x.ref1f612812, nil
	}
	mem1f612812 := allocSubpassSampleLocationsEXTMemory(1)
	ref1f612812 := (*C.VkSubpassSampleLocationsEXT)(mem1f612812)
	allocs1f612812 := new(cgoAllocMap)
	allocs1f612812.Add(mem1f612812)

	var csubpassIndex_allocs *cgoAllocMap
	ref1f612812.subpassIndex, csubpassIndex_allocs = (C.uint32_t)(x.SubpassIndex), cgoAllocsUnknown
	allocs1f612812.Borrow(csubpassIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref1f612812.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs1f612812.Borrow(csampleLocationsInfo_allocs)

	x.ref1f612812 = ref1f612812
	x.allocs1f612812 = allocs1f612812
	return ref1f612812, allocs1f612812

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassSampleLocationsEXT) PassValue() (C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x.ref1f612812 != nil {
		return *x.ref1f612812, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassSampleLocationsEXT) Deref() {
	if x.ref1f612812 == nil {
		return
	}
	x.SubpassIndex = (uint32)(x.ref1f612812.subpassIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoEXTRef(unsafe.Pointer(&x.ref1f612812.sampleLocationsInfo))
}

// allocRenderPassSampleLocationsBeginInfoEXTMemory allocates memory for type C.VkRenderPassSampleLocationsBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassSampleLocationsBeginInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassSampleLocationsBeginInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassSampleLocationsBeginInfoEXTValue = unsafe.Sizeof([1]C.VkRenderPassSampleLocationsBeginInfoEXT{})

// unpackSAttachmentSampleLocationsEXT transforms a sliced Go data structure into plain C format.
func unpackSAttachmentSampleLocationsEXT(x []AttachmentSampleLocationsEXT) (unpacked *C.VkAttachmentSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentSampleLocationsEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentSampleLocationsEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentSampleLocationsEXT)(h.Data)
	return
}

// unpackSSubpassSampleLocationsEXT transforms a sliced Go data structure into plain C format.
func unpackSSubpassSampleLocationsEXT(x []SubpassSampleLocationsEXT) (unpacked *C.VkSubpassSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassSampleLocationsEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassSampleLocationsEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassSampleLocationsEXT)(h.Data)
	return
}

// packSAttachmentSampleLocationsEXT reads sliced Go data structure out from plain C format.
func packSAttachmentSampleLocationsEXT(v []AttachmentSampleLocationsEXT, ptr0 *C.VkAttachmentSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentSampleLocationsEXTValue]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentSampleLocationsEXTRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassSampleLocationsEXT reads sliced Go data structure out from plain C format.
func packSSubpassSampleLocationsEXT(v []SubpassSampleLocationsEXT, ptr0 *C.VkSubpassSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassSampleLocationsEXTValue]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassSampleLocationsEXTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassSampleLocationsBeginInfoEXT) Ref() *C.VkRenderPassSampleLocationsBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.refb61b51d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassSampleLocationsBeginInfoEXT) Free() {
	if x != nil && x.allocsb61b51d4 != nil {
		x.allocsb61b51d4.(*cgoAllocMap).Free()
		x.refb61b51d4 = nil
	}
}

// NewRenderPassSampleLocationsBeginInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassSampleLocationsBeginInfoEXTRef(ref unsafe.Pointer) *RenderPassSampleLocationsBeginInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassSampleLocationsBeginInfoEXT)
	obj.refb61b51d4 = (*C.VkRenderPassSampleLocationsBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassSampleLocationsBeginInfoEXT) PassRef() (*C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb61b51d4 != nil {
		return x.refb61b51d4, nil
	}
	memb61b51d4 := allocRenderPassSampleLocationsBeginInfoEXTMemory(1)
	refb61b51d4 := (*C.VkRenderPassSampleLocationsBeginInfoEXT)(memb61b51d4)
	allocsb61b51d4 := new(cgoAllocMap)
	allocsb61b51d4.Add(memb61b51d4)

	var csType_allocs *cgoAllocMap
	refb61b51d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb61b51d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb61b51d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpNext_allocs)

	var cattachmentInitialSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.attachmentInitialSampleLocationsCount, cattachmentInitialSampleLocationsCount_allocs = (C.uint32_t)(x.AttachmentInitialSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cattachmentInitialSampleLocationsCount_allocs)

	var cpAttachmentInitialSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pAttachmentInitialSampleLocations, cpAttachmentInitialSampleLocations_allocs = unpackSAttachmentSampleLocationsEXT(x.PAttachmentInitialSampleLocations)
	allocsb61b51d4.Borrow(cpAttachmentInitialSampleLocations_allocs)

	var cpostSubpassSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.postSubpassSampleLocationsCount, cpostSubpassSampleLocationsCount_allocs = (C.uint32_t)(x.PostSubpassSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpostSubpassSampleLocationsCount_allocs)

	var cpPostSubpassSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pPostSubpassSampleLocations, cpPostSubpassSampleLocations_allocs = unpackSSubpassSampleLocationsEXT(x.PPostSubpassSampleLocations)
	allocsb61b51d4.Borrow(cpPostSubpassSampleLocations_allocs)

	x.refb61b51d4 = refb61b51d4
	x.allocsb61b51d4 = allocsb61b51d4
	return refb61b51d4, allocsb61b51d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassSampleLocationsBeginInfoEXT) PassValue() (C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x.refb61b51d4 != nil {
		return *x.refb61b51d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassSampleLocationsBeginInfoEXT) Deref() {
	if x.refb61b51d4 == nil {
		return
	}
	x.SType = (StructureType)(x.refb61b51d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb61b51d4.pNext))
	x.AttachmentInitialSampleLocationsCount = (uint32)(x.refb61b51d4.attachmentInitialSampleLocationsCount)
	packSAttachmentSampleLocationsEXT(x.PAttachmentInitialSampleLocations, x.refb61b51d4.pAttachmentInitialSampleLocations)
	x.PostSubpassSampleLocationsCount = (uint32)(x.refb61b51d4.postSubpassSampleLocationsCount)
	packSSubpassSampleLocationsEXT(x.PPostSubpassSampleLocations, x.refb61b51d4.pPostSubpassSampleLocations)
}

// allocPipelineSampleLocationsStateCreateInfoEXTMemory allocates memory for type C.VkPipelineSampleLocationsStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineSampleLocationsStateCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineSampleLocationsStateCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineSampleLocationsStateCreateInfoEXTValue = unsafe.Sizeof([1]C.VkPipelineSampleLocationsStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineSampleLocationsStateCreateInfoEXT) Ref() *C.VkPipelineSampleLocationsStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref93a2968f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineSampleLocationsStateCreateInfoEXT) Free() {
	if x != nil && x.allocs93a2968f != nil {
		x.allocs93a2968f.(*cgoAllocMap).Free()
		x.ref93a2968f = nil
	}
}

// NewPipelineSampleLocationsStateCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineSampleLocationsStateCreateInfoEXTRef(ref unsafe.Pointer) *PipelineSampleLocationsStateCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(PipelineSampleLocationsStateCreateInfoEXT)
	obj.ref93a2968f = (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineSampleLocationsStateCreateInfoEXT) PassRef() (*C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93a2968f != nil {
		return x.ref93a2968f, nil
	}
	mem93a2968f := allocPipelineSampleLocationsStateCreateInfoEXTMemory(1)
	ref93a2968f := (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(mem93a2968f)
	allocs93a2968f := new(cgoAllocMap)
	allocs93a2968f.Add(mem93a2968f)

	var csType_allocs *cgoAllocMap
	ref93a2968f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs93a2968f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref93a2968f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs93a2968f.Borrow(cpNext_allocs)

	var csampleLocationsEnable_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsEnable, csampleLocationsEnable_allocs = (C.VkBool32)(x.SampleLocationsEnable), cgoAllocsUnknown
	allocs93a2968f.Borrow(csampleLocationsEnable_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs93a2968f.Borrow(csampleLocationsInfo_allocs)

	x.ref93a2968f = ref93a2968f
	x.allocs93a2968f = allocs93a2968f
	return ref93a2968f, allocs93a2968f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineSampleLocationsStateCreateInfoEXT) PassValue() (C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref93a2968f != nil {
		return *x.ref93a2968f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineSampleLocationsStateCreateInfoEXT) Deref() {
	if x.ref93a2968f == nil {
		return
	}
	x.SType = (StructureType)(x.ref93a2968f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref93a2968f.pNext))
	x.SampleLocationsEnable = (Bool32)(x.ref93a2968f.sampleLocationsEnable)
	x.SampleLocationsInfo = *NewSampleLocationsInfoEXTRef(unsafe.Pointer(&x.ref93a2968f.sampleLocationsInfo))
}

// allocPhysicalDeviceSampleLocationsPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceSampleLocationsPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSampleLocationsPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSampleLocationsPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSampleLocationsPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSampleLocationsPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSampleLocationsPropertiesEXT) Ref() *C.VkPhysicalDeviceSampleLocationsPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refaf801323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSampleLocationsPropertiesEXT) Free() {
	if x != nil && x.allocsaf801323 != nil {
		x.allocsaf801323.(*cgoAllocMap).Free()
		x.refaf801323 = nil
	}
}

// NewPhysicalDeviceSampleLocationsPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSampleLocationsPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceSampleLocationsPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSampleLocationsPropertiesEXT)
	obj.refaf801323 = (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSampleLocationsPropertiesEXT) PassRef() (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf801323 != nil {
		return x.refaf801323, nil
	}
	memaf801323 := allocPhysicalDeviceSampleLocationsPropertiesEXTMemory(1)
	refaf801323 := (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(memaf801323)
	allocsaf801323 := new(cgoAllocMap)
	allocsaf801323.Add(memaf801323)

	var csType_allocs *cgoAllocMap
	refaf801323.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaf801323.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaf801323.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaf801323.Borrow(cpNext_allocs)

	var csampleLocationSampleCounts_allocs *cgoAllocMap
	refaf801323.sampleLocationSampleCounts, csampleLocationSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleLocationSampleCounts), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSampleCounts_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	refaf801323.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocsaf801323.Borrow(cmaxSampleLocationGridSize_allocs)

	var csampleLocationCoordinateRange_allocs *cgoAllocMap
	refaf801323.sampleLocationCoordinateRange, csampleLocationCoordinateRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.SampleLocationCoordinateRange)), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationCoordinateRange_allocs)

	var csampleLocationSubPixelBits_allocs *cgoAllocMap
	refaf801323.sampleLocationSubPixelBits, csampleLocationSubPixelBits_allocs = (C.uint32_t)(x.SampleLocationSubPixelBits), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSubPixelBits_allocs)

	var cvariableSampleLocations_allocs *cgoAllocMap
	refaf801323.variableSampleLocations, cvariableSampleLocations_allocs = (C.VkBool32)(x.VariableSampleLocations), cgoAllocsUnknown
	allocsaf801323.Borrow(cvariableSampleLocations_allocs)

	x.refaf801323 = refaf801323
	x.allocsaf801323 = allocsaf801323
	return refaf801323, allocsaf801323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSampleLocationsPropertiesEXT) PassValue() (C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x.refaf801323 != nil {
		return *x.refaf801323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSampleLocationsPropertiesEXT) Deref() {
	if x.refaf801323 == nil {
		return
	}
	x.SType = (StructureType)(x.refaf801323.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaf801323.pNext))
	x.SampleLocationSampleCounts = (SampleCountFlags)(x.refaf801323.sampleLocationSampleCounts)
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refaf801323.maxSampleLocationGridSize))
	x.SampleLocationCoordinateRange = *(*[2]float32)(unsafe.Pointer(&x.refaf801323.sampleLocationCoordinateRange))
	x.SampleLocationSubPixelBits = (uint32)(x.refaf801323.sampleLocationSubPixelBits)
	x.VariableSampleLocations = (Bool32)(x.refaf801323.variableSampleLocations)
}

// allocMultisamplePropertiesEXTMemory allocates memory for type C.VkMultisamplePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultisamplePropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultisamplePropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMultisamplePropertiesEXTValue = unsafe.Sizeof([1]C.VkMultisamplePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MultisamplePropertiesEXT) Ref() *C.VkMultisamplePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref3e47f337
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MultisamplePropertiesEXT) Free() {
	if x != nil && x.allocs3e47f337 != nil {
		x.allocs3e47f337.(*cgoAllocMap).Free()
		x.ref3e47f337 = nil
	}
}

// NewMultisamplePropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMultisamplePropertiesEXTRef(ref unsafe.Pointer) *MultisamplePropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(MultisamplePropertiesEXT)
	obj.ref3e47f337 = (*C.VkMultisamplePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MultisamplePropertiesEXT) PassRef() (*C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e47f337 != nil {
		return x.ref3e47f337, nil
	}
	mem3e47f337 := allocMultisamplePropertiesEXTMemory(1)
	ref3e47f337 := (*C.VkMultisamplePropertiesEXT)(mem3e47f337)
	allocs3e47f337 := new(cgoAllocMap)
	allocs3e47f337.Add(mem3e47f337)

	var csType_allocs *cgoAllocMap
	ref3e47f337.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e47f337.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e47f337.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e47f337.Borrow(cpNext_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	ref3e47f337.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocs3e47f337.Borrow(cmaxSampleLocationGridSize_allocs)

	x.ref3e47f337 = ref3e47f337
	x.allocs3e47f337 = allocs3e47f337
	return ref3e47f337, allocs3e47f337

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MultisamplePropertiesEXT) PassValue() (C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x.ref3e47f337 != nil {
		return *x.ref3e47f337, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MultisamplePropertiesEXT) Deref() {
	if x.ref3e47f337 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e47f337.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e47f337.pNext))
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.ref3e47f337.maxSampleLocationGridSize))
}

// allocPhysicalDeviceBlendOperationAdvancedFeaturesEXTMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedFeaturesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedFeaturesEXT) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref8514bc93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeaturesEXT) Free() {
	if x != nil && x.allocs8514bc93 != nil {
		x.allocs8514bc93.(*cgoAllocMap).Free()
		x.ref8514bc93 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedFeaturesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedFeaturesEXTRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedFeaturesEXT)
	obj.ref8514bc93 = (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeaturesEXT) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8514bc93 != nil {
		return x.ref8514bc93, nil
	}
	mem8514bc93 := allocPhysicalDeviceBlendOperationAdvancedFeaturesEXTMemory(1)
	ref8514bc93 := (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(mem8514bc93)
	allocs8514bc93 := new(cgoAllocMap)
	allocs8514bc93.Add(mem8514bc93)

	var csType_allocs *cgoAllocMap
	ref8514bc93.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8514bc93.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8514bc93.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8514bc93.Borrow(cpNext_allocs)

	var cadvancedBlendCoherentOperations_allocs *cgoAllocMap
	ref8514bc93.advancedBlendCoherentOperations, cadvancedBlendCoherentOperations_allocs = (C.VkBool32)(x.AdvancedBlendCoherentOperations), cgoAllocsUnknown
	allocs8514bc93.Borrow(cadvancedBlendCoherentOperations_allocs)

	x.ref8514bc93 = ref8514bc93
	x.allocs8514bc93 = allocs8514bc93
	return ref8514bc93, allocs8514bc93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedFeaturesEXT) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x.ref8514bc93 != nil {
		return *x.ref8514bc93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedFeaturesEXT) Deref() {
	if x.ref8514bc93 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8514bc93.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8514bc93.pNext))
	x.AdvancedBlendCoherentOperations = (Bool32)(x.ref8514bc93.advancedBlendCoherentOperations)
}

// allocPhysicalDeviceBlendOperationAdvancedPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedPropertiesEXT) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref94cb3fa6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedPropertiesEXT) Free() {
	if x != nil && x.allocs94cb3fa6 != nil {
		x.allocs94cb3fa6.(*cgoAllocMap).Free()
		x.ref94cb3fa6 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedPropertiesEXT)
	obj.ref94cb3fa6 = (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedPropertiesEXT) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94cb3fa6 != nil {
		return x.ref94cb3fa6, nil
	}
	mem94cb3fa6 := allocPhysicalDeviceBlendOperationAdvancedPropertiesEXTMemory(1)
	ref94cb3fa6 := (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(mem94cb3fa6)
	allocs94cb3fa6 := new(cgoAllocMap)
	allocs94cb3fa6.Add(mem94cb3fa6)

	var csType_allocs *cgoAllocMap
	ref94cb3fa6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref94cb3fa6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cpNext_allocs)

	var cadvancedBlendMaxColorAttachments_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendMaxColorAttachments, cadvancedBlendMaxColorAttachments_allocs = (C.uint32_t)(x.AdvancedBlendMaxColorAttachments), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendMaxColorAttachments_allocs)

	var cadvancedBlendIndependentBlend_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendIndependentBlend, cadvancedBlendIndependentBlend_allocs = (C.VkBool32)(x.AdvancedBlendIndependentBlend), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendIndependentBlend_allocs)

	var cadvancedBlendNonPremultipliedSrcColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedSrcColor, cadvancedBlendNonPremultipliedSrcColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedSrcColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedSrcColor_allocs)

	var cadvancedBlendNonPremultipliedDstColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedDstColor, cadvancedBlendNonPremultipliedDstColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedDstColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedDstColor_allocs)

	var cadvancedBlendCorrelatedOverlap_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendCorrelatedOverlap, cadvancedBlendCorrelatedOverlap_allocs = (C.VkBool32)(x.AdvancedBlendCorrelatedOverlap), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendCorrelatedOverlap_allocs)

	var cadvancedBlendAllOperations_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendAllOperations, cadvancedBlendAllOperations_allocs = (C.VkBool32)(x.AdvancedBlendAllOperations), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendAllOperations_allocs)

	x.ref94cb3fa6 = ref94cb3fa6
	x.allocs94cb3fa6 = allocs94cb3fa6
	return ref94cb3fa6, allocs94cb3fa6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedPropertiesEXT) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x.ref94cb3fa6 != nil {
		return *x.ref94cb3fa6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedPropertiesEXT) Deref() {
	if x.ref94cb3fa6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref94cb3fa6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref94cb3fa6.pNext))
	x.AdvancedBlendMaxColorAttachments = (uint32)(x.ref94cb3fa6.advancedBlendMaxColorAttachments)
	x.AdvancedBlendIndependentBlend = (Bool32)(x.ref94cb3fa6.advancedBlendIndependentBlend)
	x.AdvancedBlendNonPremultipliedSrcColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedSrcColor)
	x.AdvancedBlendNonPremultipliedDstColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedDstColor)
	x.AdvancedBlendCorrelatedOverlap = (Bool32)(x.ref94cb3fa6.advancedBlendCorrelatedOverlap)
	x.AdvancedBlendAllOperations = (Bool32)(x.ref94cb3fa6.advancedBlendAllOperations)
}

// allocPipelineColorBlendAdvancedStateCreateInfoEXTMemory allocates memory for type C.VkPipelineColorBlendAdvancedStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAdvancedStateCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAdvancedStateCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAdvancedStateCreateInfoEXTValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAdvancedStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAdvancedStateCreateInfoEXT) Ref() *C.VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcd374989
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfoEXT) Free() {
	if x != nil && x.allocscd374989 != nil {
		x.allocscd374989.(*cgoAllocMap).Free()
		x.refcd374989 = nil
	}
}

// NewPipelineColorBlendAdvancedStateCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAdvancedStateCreateInfoEXTRef(ref unsafe.Pointer) *PipelineColorBlendAdvancedStateCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAdvancedStateCreateInfoEXT)
	obj.refcd374989 = (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfoEXT) PassRef() (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd374989 != nil {
		return x.refcd374989, nil
	}
	memcd374989 := allocPipelineColorBlendAdvancedStateCreateInfoEXTMemory(1)
	refcd374989 := (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(memcd374989)
	allocscd374989 := new(cgoAllocMap)
	allocscd374989.Add(memcd374989)

	var csType_allocs *cgoAllocMap
	refcd374989.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd374989.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd374989.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd374989.Borrow(cpNext_allocs)

	var csrcPremultiplied_allocs *cgoAllocMap
	refcd374989.srcPremultiplied, csrcPremultiplied_allocs = (C.VkBool32)(x.SrcPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(csrcPremultiplied_allocs)

	var cdstPremultiplied_allocs *cgoAllocMap
	refcd374989.dstPremultiplied, cdstPremultiplied_allocs = (C.VkBool32)(x.DstPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(cdstPremultiplied_allocs)

	var cblendOverlap_allocs *cgoAllocMap
	refcd374989.blendOverlap, cblendOverlap_allocs = (C.VkBlendOverlapEXT)(x.BlendOverlap), cgoAllocsUnknown
	allocscd374989.Borrow(cblendOverlap_allocs)

	x.refcd374989 = refcd374989
	x.allocscd374989 = allocscd374989
	return refcd374989, allocscd374989

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAdvancedStateCreateInfoEXT) PassValue() (C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcd374989 != nil {
		return *x.refcd374989, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAdvancedStateCreateInfoEXT) Deref() {
	if x.refcd374989 == nil {
		return
	}
	x.SType = (StructureType)(x.refcd374989.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd374989.pNext))
	x.SrcPremultiplied = (Bool32)(x.refcd374989.srcPremultiplied)
	x.DstPremultiplied = (Bool32)(x.refcd374989.dstPremultiplied)
	x.BlendOverlap = (BlendOverlapEXT)(x.refcd374989.blendOverlap)
}

// allocPipelineCoverageToColorStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageToColorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageToColorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageToColorStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCoverageToColorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageToColorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageToColorStateCreateInfoNV) Ref() *C.VkPipelineCoverageToColorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refcc6b7b68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) Free() {
	if x != nil && x.allocscc6b7b68 != nil {
		x.allocscc6b7b68.(*cgoAllocMap).Free()
		x.refcc6b7b68 = nil
	}
}

// NewPipelineCoverageToColorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageToColorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageToColorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageToColorStateCreateInfoNV)
	obj.refcc6b7b68 = (*C.VkPipelineCoverageToColorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc6b7b68 != nil {
		return x.refcc6b7b68, nil
	}
	memcc6b7b68 := allocPipelineCoverageToColorStateCreateInfoNVMemory(1)
	refcc6b7b68 := (*C.VkPipelineCoverageToColorStateCreateInfoNV)(memcc6b7b68)
	allocscc6b7b68 := new(cgoAllocMap)
	allocscc6b7b68.Add(memcc6b7b68)

	var csType_allocs *cgoAllocMap
	refcc6b7b68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc6b7b68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc6b7b68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcc6b7b68.flags, cflags_allocs = (C.VkPipelineCoverageToColorStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cflags_allocs)

	var ccoverageToColorEnable_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorEnable, ccoverageToColorEnable_allocs = (C.VkBool32)(x.CoverageToColorEnable), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorEnable_allocs)

	var ccoverageToColorLocation_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorLocation, ccoverageToColorLocation_allocs = (C.uint32_t)(x.CoverageToColorLocation), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorLocation_allocs)

	x.refcc6b7b68 = refcc6b7b68
	x.allocscc6b7b68 = allocscc6b7b68
	return refcc6b7b68, allocscc6b7b68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageToColorStateCreateInfoNV) PassValue() (C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x.refcc6b7b68 != nil {
		return *x.refcc6b7b68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageToColorStateCreateInfoNV) Deref() {
	if x.refcc6b7b68 == nil {
		return
	}
	x.SType = (StructureType)(x.refcc6b7b68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc6b7b68.pNext))
	x.Flags = (PipelineCoverageToColorStateCreateFlagsNV)(x.refcc6b7b68.flags)
	x.CoverageToColorEnable = (Bool32)(x.refcc6b7b68.coverageToColorEnable)
	x.CoverageToColorLocation = (uint32)(x.refcc6b7b68.coverageToColorLocation)
}

// allocPipelineCoverageModulationStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageModulationStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageModulationStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageModulationStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCoverageModulationStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageModulationStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageModulationStateCreateInfoNV) Ref() *C.VkPipelineCoverageModulationStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa081b0ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) Free() {
	if x != nil && x.allocsa081b0ea != nil {
		x.allocsa081b0ea.(*cgoAllocMap).Free()
		x.refa081b0ea = nil
	}
}

// NewPipelineCoverageModulationStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageModulationStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageModulationStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageModulationStateCreateInfoNV)
	obj.refa081b0ea = (*C.VkPipelineCoverageModulationStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa081b0ea != nil {
		return x.refa081b0ea, nil
	}
	mema081b0ea := allocPipelineCoverageModulationStateCreateInfoNVMemory(1)
	refa081b0ea := (*C.VkPipelineCoverageModulationStateCreateInfoNV)(mema081b0ea)
	allocsa081b0ea := new(cgoAllocMap)
	allocsa081b0ea.Add(mema081b0ea)

	var csType_allocs *cgoAllocMap
	refa081b0ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa081b0ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa081b0ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa081b0ea.flags, cflags_allocs = (C.VkPipelineCoverageModulationStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cflags_allocs)

	var ccoverageModulationMode_allocs *cgoAllocMap
	refa081b0ea.coverageModulationMode, ccoverageModulationMode_allocs = (C.VkCoverageModulationModeNV)(x.CoverageModulationMode), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationMode_allocs)

	var ccoverageModulationTableEnable_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableEnable, ccoverageModulationTableEnable_allocs = (C.VkBool32)(x.CoverageModulationTableEnable), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableEnable_allocs)

	var ccoverageModulationTableCount_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableCount, ccoverageModulationTableCount_allocs = (C.uint32_t)(x.CoverageModulationTableCount), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableCount_allocs)

	var cpCoverageModulationTable_allocs *cgoAllocMap
	refa081b0ea.pCoverageModulationTable, cpCoverageModulationTable_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable)).Data)), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cpCoverageModulationTable_allocs)

	x.refa081b0ea = refa081b0ea
	x.allocsa081b0ea = allocsa081b0ea
	return refa081b0ea, allocsa081b0ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageModulationStateCreateInfoNV) PassValue() (C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x.refa081b0ea != nil {
		return *x.refa081b0ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageModulationStateCreateInfoNV) Deref() {
	if x.refa081b0ea == nil {
		return
	}
	x.SType = (StructureType)(x.refa081b0ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa081b0ea.pNext))
	x.Flags = (PipelineCoverageModulationStateCreateFlagsNV)(x.refa081b0ea.flags)
	x.CoverageModulationMode = (CoverageModulationModeNV)(x.refa081b0ea.coverageModulationMode)
	x.CoverageModulationTableEnable = (Bool32)(x.refa081b0ea.coverageModulationTableEnable)
	x.CoverageModulationTableCount = (uint32)(x.refa081b0ea.coverageModulationTableCount)
	hxfb029a7 := (*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable))
	hxfb029a7.Data = unsafe.Pointer(x.refa081b0ea.pCoverageModulationTable)
	hxfb029a7.Cap = 0x7fffffff
	// hxfb029a7.Len = ?

}

// allocValidationCacheCreateInfoEXTMemory allocates memory for type C.VkValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationCacheCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationCacheCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValidationCacheCreateInfoEXTValue = unsafe.Sizeof([1]C.VkValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationCacheCreateInfoEXT) Ref() *C.VkValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref3d8ac8aa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationCacheCreateInfoEXT) Free() {
	if x != nil && x.allocs3d8ac8aa != nil {
		x.allocs3d8ac8aa.(*cgoAllocMap).Free()
		x.ref3d8ac8aa = nil
	}
}

// NewValidationCacheCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationCacheCreateInfoEXTRef(ref unsafe.Pointer) *ValidationCacheCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(ValidationCacheCreateInfoEXT)
	obj.ref3d8ac8aa = (*C.VkValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationCacheCreateInfoEXT) PassRef() (*C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d8ac8aa != nil {
		return x.ref3d8ac8aa, nil
	}
	mem3d8ac8aa := allocValidationCacheCreateInfoEXTMemory(1)
	ref3d8ac8aa := (*C.VkValidationCacheCreateInfoEXT)(mem3d8ac8aa)
	allocs3d8ac8aa := new(cgoAllocMap)
	allocs3d8ac8aa.Add(mem3d8ac8aa)

	var csType_allocs *cgoAllocMap
	ref3d8ac8aa.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3d8ac8aa.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref3d8ac8aa.flags, cflags_allocs = (C.VkValidationCacheCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	ref3d8ac8aa.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	ref3d8ac8aa.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpInitialData_allocs)

	x.ref3d8ac8aa = ref3d8ac8aa
	x.allocs3d8ac8aa = allocs3d8ac8aa
	return ref3d8ac8aa, allocs3d8ac8aa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationCacheCreateInfoEXT) PassValue() (C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref3d8ac8aa != nil {
		return *x.ref3d8ac8aa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationCacheCreateInfoEXT) Deref() {
	if x.ref3d8ac8aa == nil {
		return
	}
	x.SType = (StructureType)(x.ref3d8ac8aa.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pNext))
	x.Flags = (ValidationCacheCreateFlagsEXT)(x.ref3d8ac8aa.flags)
	x.InitialDataSize = (uint)(x.ref3d8ac8aa.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pInitialData))
}

// allocShaderModuleValidationCacheCreateInfoEXTMemory allocates memory for type C.VkShaderModuleValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleValidationCacheCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleValidationCacheCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleValidationCacheCreateInfoEXTValue = unsafe.Sizeof([1]C.VkShaderModuleValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleValidationCacheCreateInfoEXT) Ref() *C.VkShaderModuleValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref37065f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleValidationCacheCreateInfoEXT) Free() {
	if x != nil && x.allocs37065f24 != nil {
		x.allocs37065f24.(*cgoAllocMap).Free()
		x.ref37065f24 = nil
	}
}

// NewShaderModuleValidationCacheCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleValidationCacheCreateInfoEXTRef(ref unsafe.Pointer) *ShaderModuleValidationCacheCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleValidationCacheCreateInfoEXT)
	obj.ref37065f24 = (*C.VkShaderModuleValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleValidationCacheCreateInfoEXT) PassRef() (*C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37065f24 != nil {
		return x.ref37065f24, nil
	}
	mem37065f24 := allocShaderModuleValidationCacheCreateInfoEXTMemory(1)
	ref37065f24 := (*C.VkShaderModuleValidationCacheCreateInfoEXT)(mem37065f24)
	allocs37065f24 := new(cgoAllocMap)
	allocs37065f24.Add(mem37065f24)

	var csType_allocs *cgoAllocMap
	ref37065f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs37065f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref37065f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs37065f24.Borrow(cpNext_allocs)

	var cvalidationCache_allocs *cgoAllocMap
	ref37065f24.validationCache, cvalidationCache_allocs = *(*C.VkValidationCacheEXT)(unsafe.Pointer(&x.ValidationCache)), cgoAllocsUnknown
	allocs37065f24.Borrow(cvalidationCache_allocs)

	x.ref37065f24 = ref37065f24
	x.allocs37065f24 = allocs37065f24
	return ref37065f24, allocs37065f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleValidationCacheCreateInfoEXT) PassValue() (C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref37065f24 != nil {
		return *x.ref37065f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleValidationCacheCreateInfoEXT) Deref() {
	if x.ref37065f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref37065f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref37065f24.pNext))
	x.ValidationCache = *(*ValidationCacheEXT)(unsafe.Pointer(&x.ref37065f24.validationCache))
}

// allocDescriptorSetLayoutBindingFlagsCreateInfoEXTMemory allocates memory for type C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingFlagsCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingFlagsCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingFlagsCreateInfoEXTValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBindingFlagsCreateInfoEXT) Ref() *C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcb1cf42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfoEXT) Free() {
	if x != nil && x.allocscb1cf42 != nil {
		x.allocscb1cf42.(*cgoAllocMap).Free()
		x.refcb1cf42 = nil
	}
}

// NewDescriptorSetLayoutBindingFlagsCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingFlagsCreateInfoEXTRef(ref unsafe.Pointer) *DescriptorSetLayoutBindingFlagsCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBindingFlagsCreateInfoEXT)
	obj.refcb1cf42 = (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfoEXT) PassRef() (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcb1cf42 != nil {
		return x.refcb1cf42, nil
	}
	memcb1cf42 := allocDescriptorSetLayoutBindingFlagsCreateInfoEXTMemory(1)
	refcb1cf42 := (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT)(memcb1cf42)
	allocscb1cf42 := new(cgoAllocMap)
	allocscb1cf42.Add(memcb1cf42)

	var csType_allocs *cgoAllocMap
	refcb1cf42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscb1cf42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcb1cf42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscb1cf42.Borrow(cpNext_allocs)

	var cbindingCount_allocs *cgoAllocMap
	refcb1cf42.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocscb1cf42.Borrow(cbindingCount_allocs)

	var cpBindingFlags_allocs *cgoAllocMap
	refcb1cf42.pBindingFlags, cpBindingFlags_allocs = (*C.VkDescriptorBindingFlagsEXT)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PBindingFlags)).Data)), cgoAllocsUnknown
	allocscb1cf42.Borrow(cpBindingFlags_allocs)

	x.refcb1cf42 = refcb1cf42
	x.allocscb1cf42 = allocscb1cf42
	return refcb1cf42, allocscb1cf42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfoEXT) PassValue() (C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, *cgoAllocMap) {
	if x.refcb1cf42 != nil {
		return *x.refcb1cf42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBindingFlagsCreateInfoEXT) Deref() {
	if x.refcb1cf42 == nil {
		return
	}
	x.SType = (StructureType)(x.refcb1cf42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcb1cf42.pNext))
	x.BindingCount = (uint32)(x.refcb1cf42.bindingCount)
	hxf7d15a2 := (*sliceHeader)(unsafe.Pointer(&x.PBindingFlags))
	hxf7d15a2.Data = unsafe.Pointer(x.refcb1cf42.pBindingFlags)
	hxf7d15a2.Cap = 0x7fffffff
	// hxf7d15a2.Len = ?

}

// allocPhysicalDeviceDescriptorIndexingFeaturesEXTMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingFeaturesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingFeaturesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingFeaturesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingFeaturesEXT) Ref() *C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref76ca48bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeaturesEXT) Free() {
	if x != nil && x.allocs76ca48bc != nil {
		x.allocs76ca48bc.(*cgoAllocMap).Free()
		x.ref76ca48bc = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingFeaturesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingFeaturesEXTRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingFeaturesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingFeaturesEXT)
	obj.ref76ca48bc = (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeaturesEXT) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76ca48bc != nil {
		return x.ref76ca48bc, nil
	}
	mem76ca48bc := allocPhysicalDeviceDescriptorIndexingFeaturesEXTMemory(1)
	ref76ca48bc := (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT)(mem76ca48bc)
	allocs76ca48bc := new(cgoAllocMap)
	allocs76ca48bc.Add(mem76ca48bc)

	var csType_allocs *cgoAllocMap
	ref76ca48bc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76ca48bc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76ca48bc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cpNext_allocs)

	var cshaderInputAttachmentArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderInputAttachmentArrayDynamicIndexing, cshaderInputAttachmentArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderInputAttachmentArrayDynamicIndexing_allocs)

	var cshaderUniformTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformTexelBufferArrayDynamicIndexing, cshaderUniformTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformTexelBufferArrayDynamicIndexing_allocs)

	var cshaderStorageTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageTexelBufferArrayDynamicIndexing, cshaderStorageTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageTexelBufferArrayDynamicIndexing_allocs)

	var cshaderUniformBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformBufferArrayNonUniformIndexing, cshaderUniformBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformBufferArrayNonUniformIndexing_allocs)

	var cshaderSampledImageArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderSampledImageArrayNonUniformIndexing, cshaderSampledImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderSampledImageArrayNonUniformIndexing_allocs)

	var cshaderStorageBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageBufferArrayNonUniformIndexing, cshaderStorageBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageImageArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageImageArrayNonUniformIndexing, cshaderStorageImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageImageArrayNonUniformIndexing_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderInputAttachmentArrayNonUniformIndexing, cshaderInputAttachmentArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderInputAttachmentArrayNonUniformIndexing_allocs)

	var cshaderUniformTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformTexelBufferArrayNonUniformIndexing, cshaderUniformTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformTexelBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageTexelBufferArrayNonUniformIndexing, cshaderStorageTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageTexelBufferArrayNonUniformIndexing_allocs)

	var cdescriptorBindingUniformBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUniformBufferUpdateAfterBind, cdescriptorBindingUniformBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUniformBufferUpdateAfterBind_allocs)

	var cdescriptorBindingSampledImageUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingSampledImageUpdateAfterBind, cdescriptorBindingSampledImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingSampledImageUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingSampledImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageImageUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageImageUpdateAfterBind, cdescriptorBindingStorageImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageImageUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageBufferUpdateAfterBind, cdescriptorBindingStorageBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUniformTexelBufferUpdateAfterBind, cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageTexelBufferUpdateAfterBind, cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUpdateUnusedWhilePending_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUpdateUnusedWhilePending, cdescriptorBindingUpdateUnusedWhilePending_allocs = (C.VkBool32)(x.DescriptorBindingUpdateUnusedWhilePending), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUpdateUnusedWhilePending_allocs)

	var cdescriptorBindingPartiallyBound_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingPartiallyBound, cdescriptorBindingPartiallyBound_allocs = (C.VkBool32)(x.DescriptorBindingPartiallyBound), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingPartiallyBound_allocs)

	var cdescriptorBindingVariableDescriptorCount_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingVariableDescriptorCount, cdescriptorBindingVariableDescriptorCount_allocs = (C.VkBool32)(x.DescriptorBindingVariableDescriptorCount), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingVariableDescriptorCount_allocs)

	var cruntimeDescriptorArray_allocs *cgoAllocMap
	ref76ca48bc.runtimeDescriptorArray, cruntimeDescriptorArray_allocs = (C.VkBool32)(x.RuntimeDescriptorArray), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cruntimeDescriptorArray_allocs)

	x.ref76ca48bc = ref76ca48bc
	x.allocs76ca48bc = allocs76ca48bc
	return ref76ca48bc, allocs76ca48bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeaturesEXT) PassValue() (C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, *cgoAllocMap) {
	if x.ref76ca48bc != nil {
		return *x.ref76ca48bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingFeaturesEXT) Deref() {
	if x.ref76ca48bc == nil {
		return
	}
	x.SType = (StructureType)(x.ref76ca48bc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76ca48bc.pNext))
	x.ShaderInputAttachmentArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderInputAttachmentArrayDynamicIndexing)
	x.ShaderUniformTexelBufferArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderUniformTexelBufferArrayDynamicIndexing)
	x.ShaderStorageTexelBufferArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderStorageTexelBufferArrayDynamicIndexing)
	x.ShaderUniformBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderUniformBufferArrayNonUniformIndexing)
	x.ShaderSampledImageArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderSampledImageArrayNonUniformIndexing)
	x.ShaderStorageBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageBufferArrayNonUniformIndexing)
	x.ShaderStorageImageArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageImageArrayNonUniformIndexing)
	x.ShaderInputAttachmentArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderInputAttachmentArrayNonUniformIndexing)
	x.ShaderUniformTexelBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderUniformTexelBufferArrayNonUniformIndexing)
	x.ShaderStorageTexelBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageTexelBufferArrayNonUniformIndexing)
	x.DescriptorBindingUniformBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingUniformBufferUpdateAfterBind)
	x.DescriptorBindingSampledImageUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingSampledImageUpdateAfterBind)
	x.DescriptorBindingStorageImageUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageImageUpdateAfterBind)
	x.DescriptorBindingStorageBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageBufferUpdateAfterBind)
	x.DescriptorBindingUniformTexelBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingUniformTexelBufferUpdateAfterBind)
	x.DescriptorBindingStorageTexelBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageTexelBufferUpdateAfterBind)
	x.DescriptorBindingUpdateUnusedWhilePending = (Bool32)(x.ref76ca48bc.descriptorBindingUpdateUnusedWhilePending)
	x.DescriptorBindingPartiallyBound = (Bool32)(x.ref76ca48bc.descriptorBindingPartiallyBound)
	x.DescriptorBindingVariableDescriptorCount = (Bool32)(x.ref76ca48bc.descriptorBindingVariableDescriptorCount)
	x.RuntimeDescriptorArray = (Bool32)(x.ref76ca48bc.runtimeDescriptorArray)
}

// allocPhysicalDeviceDescriptorIndexingPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingPropertiesEXT) Ref() *C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref3c07c210
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingPropertiesEXT) Free() {
	if x != nil && x.allocs3c07c210 != nil {
		x.allocs3c07c210.(*cgoAllocMap).Free()
		x.ref3c07c210 = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingPropertiesEXT)
	obj.ref3c07c210 = (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingPropertiesEXT) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c07c210 != nil {
		return x.ref3c07c210, nil
	}
	mem3c07c210 := allocPhysicalDeviceDescriptorIndexingPropertiesEXTMemory(1)
	ref3c07c210 := (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT)(mem3c07c210)
	allocs3c07c210 := new(cgoAllocMap)
	allocs3c07c210.Add(mem3c07c210)

	var csType_allocs *cgoAllocMap
	ref3c07c210.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c07c210.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c07c210.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c07c210.Borrow(cpNext_allocs)

	var cmaxUpdateAfterBindDescriptorsInAllPools_allocs *cgoAllocMap
	ref3c07c210.maxUpdateAfterBindDescriptorsInAllPools, cmaxUpdateAfterBindDescriptorsInAllPools_allocs = (C.uint32_t)(x.MaxUpdateAfterBindDescriptorsInAllPools), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxUpdateAfterBindDescriptorsInAllPools_allocs)

	var cshaderUniformBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderUniformBufferArrayNonUniformIndexingNative, cshaderUniformBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderUniformBufferArrayNonUniformIndexingNative_allocs)

	var cshaderSampledImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderSampledImageArrayNonUniformIndexingNative, cshaderSampledImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderSampledImageArrayNonUniformIndexingNative_allocs)

	var cshaderStorageBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderStorageBufferArrayNonUniformIndexingNative, cshaderStorageBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderStorageBufferArrayNonUniformIndexingNative_allocs)

	var cshaderStorageImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderStorageImageArrayNonUniformIndexingNative, cshaderStorageImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderStorageImageArrayNonUniformIndexingNative_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderInputAttachmentArrayNonUniformIndexingNative, cshaderInputAttachmentArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderInputAttachmentArrayNonUniformIndexingNative_allocs)

	var crobustBufferAccessUpdateAfterBind_allocs *cgoAllocMap
	ref3c07c210.robustBufferAccessUpdateAfterBind, crobustBufferAccessUpdateAfterBind_allocs = (C.VkBool32)(x.RobustBufferAccessUpdateAfterBind), cgoAllocsUnknown
	allocs3c07c210.Borrow(crobustBufferAccessUpdateAfterBind_allocs)

	var cquadDivergentImplicitLod_allocs *cgoAllocMap
	ref3c07c210.quadDivergentImplicitLod, cquadDivergentImplicitLod_allocs = (C.VkBool32)(x.QuadDivergentImplicitLod), cgoAllocsUnknown
	allocs3c07c210.Borrow(cquadDivergentImplicitLod_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindSamplers, cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindUniformBuffers, cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageBuffers, cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindSampledImages, cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageImages, cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindInputAttachments, cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs)

	var cmaxPerStageUpdateAfterBindResources_allocs *cgoAllocMap
	ref3c07c210.maxPerStageUpdateAfterBindResources, cmaxPerStageUpdateAfterBindResources_allocs = (C.uint32_t)(x.MaxPerStageUpdateAfterBindResources), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageUpdateAfterBindResources_allocs)

	var cmaxDescriptorSetUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindSamplers, cmaxDescriptorSetUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindSamplers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffers, cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffers, cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindSampledImages, cmaxDescriptorSetUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindSampledImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageImages, cmaxDescriptorSetUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindInputAttachments, cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs)

	x.ref3c07c210 = ref3c07c210
	x.allocs3c07c210 = allocs3c07c210
	return ref3c07c210, allocs3c07c210

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingPropertiesEXT) PassValue() (C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, *cgoAllocMap) {
	if x.ref3c07c210 != nil {
		return *x.ref3c07c210, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingPropertiesEXT) Deref() {
	if x.ref3c07c210 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c07c210.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c07c210.pNext))
	x.MaxUpdateAfterBindDescriptorsInAllPools = (uint32)(x.ref3c07c210.maxUpdateAfterBindDescriptorsInAllPools)
	x.ShaderUniformBufferArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderUniformBufferArrayNonUniformIndexingNative)
	x.ShaderSampledImageArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderSampledImageArrayNonUniformIndexingNative)
	x.ShaderStorageBufferArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderStorageBufferArrayNonUniformIndexingNative)
	x.ShaderStorageImageArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderStorageImageArrayNonUniformIndexingNative)
	x.ShaderInputAttachmentArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderInputAttachmentArrayNonUniformIndexingNative)
	x.RobustBufferAccessUpdateAfterBind = (Bool32)(x.ref3c07c210.robustBufferAccessUpdateAfterBind)
	x.QuadDivergentImplicitLod = (Bool32)(x.ref3c07c210.quadDivergentImplicitLod)
	x.MaxPerStageDescriptorUpdateAfterBindSamplers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindSamplers)
	x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindSampledImages = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindSampledImages)
	x.MaxPerStageDescriptorUpdateAfterBindStorageImages = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageImages)
	x.MaxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	x.MaxPerStageUpdateAfterBindResources = (uint32)(x.ref3c07c210.maxPerStageUpdateAfterBindResources)
	x.MaxDescriptorSetUpdateAfterBindSamplers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindSamplers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffers)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindSampledImages = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindSampledImages)
	x.MaxDescriptorSetUpdateAfterBindStorageImages = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageImages)
	x.MaxDescriptorSetUpdateAfterBindInputAttachments = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindInputAttachments)
}

// allocDescriptorSetVariableDescriptorCountAllocateInfoEXTMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountAllocateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountAllocateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountAllocateInfoEXTValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountAllocateInfoEXT) Ref() *C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref65152aef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfoEXT) Free() {
	if x != nil && x.allocs65152aef != nil {
		x.allocs65152aef.(*cgoAllocMap).Free()
		x.ref65152aef = nil
	}
}

// NewDescriptorSetVariableDescriptorCountAllocateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountAllocateInfoEXTRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountAllocateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountAllocateInfoEXT)
	obj.ref65152aef = (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfoEXT) PassRef() (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref65152aef != nil {
		return x.ref65152aef, nil
	}
	mem65152aef := allocDescriptorSetVariableDescriptorCountAllocateInfoEXTMemory(1)
	ref65152aef := (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT)(mem65152aef)
	allocs65152aef := new(cgoAllocMap)
	allocs65152aef.Add(mem65152aef)

	var csType_allocs *cgoAllocMap
	ref65152aef.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs65152aef.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref65152aef.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs65152aef.Borrow(cpNext_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref65152aef.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs65152aef.Borrow(cdescriptorSetCount_allocs)

	var cpDescriptorCounts_allocs *cgoAllocMap
	ref65152aef.pDescriptorCounts, cpDescriptorCounts_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts)).Data)), cgoAllocsUnknown
	allocs65152aef.Borrow(cpDescriptorCounts_allocs)

	x.ref65152aef = ref65152aef
	x.allocs65152aef = allocs65152aef
	return ref65152aef, allocs65152aef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfoEXT) PassValue() (C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, *cgoAllocMap) {
	if x.ref65152aef != nil {
		return *x.ref65152aef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountAllocateInfoEXT) Deref() {
	if x.ref65152aef == nil {
		return
	}
	x.SType = (StructureType)(x.ref65152aef.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref65152aef.pNext))
	x.DescriptorSetCount = (uint32)(x.ref65152aef.descriptorSetCount)
	hxf8dbbe5 := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts))
	hxf8dbbe5.Data = unsafe.Pointer(x.ref65152aef.pDescriptorCounts)
	hxf8dbbe5.Cap = 0x7fffffff
	// hxf8dbbe5.Len = ?

}

// allocDescriptorSetVariableDescriptorCountLayoutSupportEXTMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountLayoutSupportEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountLayoutSupportEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountLayoutSupportEXTValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountLayoutSupportEXT) Ref() *C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
	if x == nil {
		return nil
	}
	return x.ref4684c56f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupportEXT) Free() {
	if x != nil && x.allocs4684c56f != nil {
		x.allocs4684c56f.(*cgoAllocMap).Free()
		x.ref4684c56f = nil
	}
}

// NewDescriptorSetVariableDescriptorCountLayoutSupportEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountLayoutSupportEXTRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountLayoutSupportEXT {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountLayoutSupportEXT)
	obj.ref4684c56f = (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupportEXT) PassRef() (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4684c56f != nil {
		return x.ref4684c56f, nil
	}
	mem4684c56f := allocDescriptorSetVariableDescriptorCountLayoutSupportEXTMemory(1)
	ref4684c56f := (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT)(mem4684c56f)
	allocs4684c56f := new(cgoAllocMap)
	allocs4684c56f.Add(mem4684c56f)

	var csType_allocs *cgoAllocMap
	ref4684c56f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4684c56f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4684c56f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4684c56f.Borrow(cpNext_allocs)

	var cmaxVariableDescriptorCount_allocs *cgoAllocMap
	ref4684c56f.maxVariableDescriptorCount, cmaxVariableDescriptorCount_allocs = (C.uint32_t)(x.MaxVariableDescriptorCount), cgoAllocsUnknown
	allocs4684c56f.Borrow(cmaxVariableDescriptorCount_allocs)

	x.ref4684c56f = ref4684c56f
	x.allocs4684c56f = allocs4684c56f
	return ref4684c56f, allocs4684c56f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupportEXT) PassValue() (C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, *cgoAllocMap) {
	if x.ref4684c56f != nil {
		return *x.ref4684c56f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountLayoutSupportEXT) Deref() {
	if x.ref4684c56f == nil {
		return
	}
	x.SType = (StructureType)(x.ref4684c56f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4684c56f.pNext))
	x.MaxVariableDescriptorCount = (uint32)(x.ref4684c56f.maxVariableDescriptorCount)
}

// allocDeviceQueueGlobalPriorityCreateInfoEXTMemory allocates memory for type C.VkDeviceQueueGlobalPriorityCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueGlobalPriorityCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueGlobalPriorityCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueGlobalPriorityCreateInfoEXTValue = unsafe.Sizeof([1]C.VkDeviceQueueGlobalPriorityCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueGlobalPriorityCreateInfoEXT) Ref() *C.VkDeviceQueueGlobalPriorityCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref76356646
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfoEXT) Free() {
	if x != nil && x.allocs76356646 != nil {
		x.allocs76356646.(*cgoAllocMap).Free()
		x.ref76356646 = nil
	}
}

// NewDeviceQueueGlobalPriorityCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueGlobalPriorityCreateInfoEXTRef(ref unsafe.Pointer) *DeviceQueueGlobalPriorityCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueGlobalPriorityCreateInfoEXT)
	obj.ref76356646 = (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfoEXT) PassRef() (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76356646 != nil {
		return x.ref76356646, nil
	}
	mem76356646 := allocDeviceQueueGlobalPriorityCreateInfoEXTMemory(1)
	ref76356646 := (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(mem76356646)
	allocs76356646 := new(cgoAllocMap)
	allocs76356646.Add(mem76356646)

	var csType_allocs *cgoAllocMap
	ref76356646.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76356646.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76356646.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76356646.Borrow(cpNext_allocs)

	var cglobalPriority_allocs *cgoAllocMap
	ref76356646.globalPriority, cglobalPriority_allocs = (C.VkQueueGlobalPriorityEXT)(x.GlobalPriority), cgoAllocsUnknown
	allocs76356646.Borrow(cglobalPriority_allocs)

	x.ref76356646 = ref76356646
	x.allocs76356646 = allocs76356646
	return ref76356646, allocs76356646

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueGlobalPriorityCreateInfoEXT) PassValue() (C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x.ref76356646 != nil {
		return *x.ref76356646, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueGlobalPriorityCreateInfoEXT) Deref() {
	if x.ref76356646 == nil {
		return
	}
	x.SType = (StructureType)(x.ref76356646.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76356646.pNext))
	x.GlobalPriority = (QueueGlobalPriorityEXT)(x.ref76356646.globalPriority)
}

// allocImportMemoryHostPointerInfoEXTMemory allocates memory for type C.VkImportMemoryHostPointerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryHostPointerInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryHostPointerInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportMemoryHostPointerInfoEXTValue = unsafe.Sizeof([1]C.VkImportMemoryHostPointerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryHostPointerInfoEXT) Ref() *C.VkImportMemoryHostPointerInfoEXT {
	if x == nil {
		return nil
	}
	return x.reffe09253e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryHostPointerInfoEXT) Free() {
	if x != nil && x.allocsfe09253e != nil {
		x.allocsfe09253e.(*cgoAllocMap).Free()
		x.reffe09253e = nil
	}
}

// NewImportMemoryHostPointerInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryHostPointerInfoEXTRef(ref unsafe.Pointer) *ImportMemoryHostPointerInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryHostPointerInfoEXT)
	obj.reffe09253e = (*C.VkImportMemoryHostPointerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryHostPointerInfoEXT) PassRef() (*C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe09253e != nil {
		return x.reffe09253e, nil
	}
	memfe09253e := allocImportMemoryHostPointerInfoEXTMemory(1)
	reffe09253e := (*C.VkImportMemoryHostPointerInfoEXT)(memfe09253e)
	allocsfe09253e := new(cgoAllocMap)
	allocsfe09253e.Add(memfe09253e)

	var csType_allocs *cgoAllocMap
	reffe09253e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe09253e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe09253e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	reffe09253e.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsfe09253e.Borrow(chandleType_allocs)

	var cpHostPointer_allocs *cgoAllocMap
	reffe09253e.pHostPointer, cpHostPointer_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PHostPointer)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpHostPointer_allocs)

	x.reffe09253e = reffe09253e
	x.allocsfe09253e = allocsfe09253e
	return reffe09253e, allocsfe09253e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryHostPointerInfoEXT) PassValue() (C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x.reffe09253e != nil {
		return *x.reffe09253e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryHostPointerInfoEXT) Deref() {
	if x.reffe09253e == nil {
		return
	}
	x.SType = (StructureType)(x.reffe09253e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.reffe09253e.handleType)
	x.PHostPointer = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pHostPointer))
}

// allocMemoryHostPointerPropertiesEXTMemory allocates memory for type C.VkMemoryHostPointerPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHostPointerPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHostPointerPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHostPointerPropertiesEXTValue = unsafe.Sizeof([1]C.VkMemoryHostPointerPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHostPointerPropertiesEXT) Ref() *C.VkMemoryHostPointerPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refebf46a84
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHostPointerPropertiesEXT) Free() {
	if x != nil && x.allocsebf46a84 != nil {
		x.allocsebf46a84.(*cgoAllocMap).Free()
		x.refebf46a84 = nil
	}
}

// NewMemoryHostPointerPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHostPointerPropertiesEXTRef(ref unsafe.Pointer) *MemoryHostPointerPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHostPointerPropertiesEXT)
	obj.refebf46a84 = (*C.VkMemoryHostPointerPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHostPointerPropertiesEXT) PassRef() (*C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebf46a84 != nil {
		return x.refebf46a84, nil
	}
	memebf46a84 := allocMemoryHostPointerPropertiesEXTMemory(1)
	refebf46a84 := (*C.VkMemoryHostPointerPropertiesEXT)(memebf46a84)
	allocsebf46a84 := new(cgoAllocMap)
	allocsebf46a84.Add(memebf46a84)

	var csType_allocs *cgoAllocMap
	refebf46a84.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsebf46a84.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refebf46a84.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsebf46a84.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	refebf46a84.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocsebf46a84.Borrow(cmemoryTypeBits_allocs)

	x.refebf46a84 = refebf46a84
	x.allocsebf46a84 = allocsebf46a84
	return refebf46a84, allocsebf46a84

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHostPointerPropertiesEXT) PassValue() (C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x.refebf46a84 != nil {
		return *x.refebf46a84, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHostPointerPropertiesEXT) Deref() {
	if x.refebf46a84 == nil {
		return
	}
	x.SType = (StructureType)(x.refebf46a84.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refebf46a84.pNext))
	x.MemoryTypeBits = (uint32)(x.refebf46a84.memoryTypeBits)
}

// allocPhysicalDeviceExternalMemoryHostPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalMemoryHostPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalMemoryHostPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalMemoryHostPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalMemoryHostPropertiesEXT) Ref() *C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7f697d15
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalMemoryHostPropertiesEXT) Free() {
	if x != nil && x.allocs7f697d15 != nil {
		x.allocs7f697d15.(*cgoAllocMap).Free()
		x.ref7f697d15 = nil
	}
}

// NewPhysicalDeviceExternalMemoryHostPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalMemoryHostPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceExternalMemoryHostPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalMemoryHostPropertiesEXT)
	obj.ref7f697d15 = (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalMemoryHostPropertiesEXT) PassRef() (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f697d15 != nil {
		return x.ref7f697d15, nil
	}
	mem7f697d15 := allocPhysicalDeviceExternalMemoryHostPropertiesEXTMemory(1)
	ref7f697d15 := (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(mem7f697d15)
	allocs7f697d15 := new(cgoAllocMap)
	allocs7f697d15.Add(mem7f697d15)

	var csType_allocs *cgoAllocMap
	ref7f697d15.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7f697d15.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7f697d15.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7f697d15.Borrow(cpNext_allocs)

	var cminImportedHostPointerAlignment_allocs *cgoAllocMap
	ref7f697d15.minImportedHostPointerAlignment, cminImportedHostPointerAlignment_allocs = (C.VkDeviceSize)(x.MinImportedHostPointerAlignment), cgoAllocsUnknown
	allocs7f697d15.Borrow(cminImportedHostPointerAlignment_allocs)

	x.ref7f697d15 = ref7f697d15
	x.allocs7f697d15 = allocs7f697d15
	return ref7f697d15, allocs7f697d15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalMemoryHostPropertiesEXT) PassValue() (C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x.ref7f697d15 != nil {
		return *x.ref7f697d15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalMemoryHostPropertiesEXT) Deref() {
	if x.ref7f697d15 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7f697d15.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7f697d15.pNext))
	x.MinImportedHostPointerAlignment = (DeviceSize)(x.ref7f697d15.minImportedHostPointerAlignment)
}

// allocPhysicalDeviceShaderCorePropertiesAMDMemory allocates memory for type C.VkPhysicalDeviceShaderCorePropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderCorePropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderCorePropertiesAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderCorePropertiesAMDValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderCorePropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Ref() *C.VkPhysicalDeviceShaderCorePropertiesAMD {
	if x == nil {
		return nil
	}
	return x.refde4b3b09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Free() {
	if x != nil && x.allocsde4b3b09 != nil {
		x.allocsde4b3b09.(*cgoAllocMap).Free()
		x.refde4b3b09 = nil
	}
}

// NewPhysicalDeviceShaderCorePropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderCorePropertiesAMDRef(ref unsafe.Pointer) *PhysicalDeviceShaderCorePropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderCorePropertiesAMD)
	obj.refde4b3b09 = (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) PassRef() (*C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde4b3b09 != nil {
		return x.refde4b3b09, nil
	}
	memde4b3b09 := allocPhysicalDeviceShaderCorePropertiesAMDMemory(1)
	refde4b3b09 := (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(memde4b3b09)
	allocsde4b3b09 := new(cgoAllocMap)
	allocsde4b3b09.Add(memde4b3b09)

	var csType_allocs *cgoAllocMap
	refde4b3b09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refde4b3b09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cpNext_allocs)

	var cshaderEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderEngineCount, cshaderEngineCount_allocs = (C.uint32_t)(x.ShaderEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderEngineCount_allocs)

	var cshaderArraysPerEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderArraysPerEngineCount, cshaderArraysPerEngineCount_allocs = (C.uint32_t)(x.ShaderArraysPerEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderArraysPerEngineCount_allocs)

	var ccomputeUnitsPerShaderArray_allocs *cgoAllocMap
	refde4b3b09.computeUnitsPerShaderArray, ccomputeUnitsPerShaderArray_allocs = (C.uint32_t)(x.ComputeUnitsPerShaderArray), cgoAllocsUnknown
	allocsde4b3b09.Borrow(ccomputeUnitsPerShaderArray_allocs)

	var csimdPerComputeUnit_allocs *cgoAllocMap
	refde4b3b09.simdPerComputeUnit, csimdPerComputeUnit_allocs = (C.uint32_t)(x.SimdPerComputeUnit), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csimdPerComputeUnit_allocs)

	var cwavefrontsPerSimd_allocs *cgoAllocMap
	refde4b3b09.wavefrontsPerSimd, cwavefrontsPerSimd_allocs = (C.uint32_t)(x.WavefrontsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontsPerSimd_allocs)

	var cwavefrontSize_allocs *cgoAllocMap
	refde4b3b09.wavefrontSize, cwavefrontSize_allocs = (C.uint32_t)(x.WavefrontSize), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontSize_allocs)

	var csgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.sgprsPerSimd, csgprsPerSimd_allocs = (C.uint32_t)(x.SgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprsPerSimd_allocs)

	var cminSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minSgprAllocation, cminSgprAllocation_allocs = (C.uint32_t)(x.MinSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminSgprAllocation_allocs)

	var cmaxSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxSgprAllocation, cmaxSgprAllocation_allocs = (C.uint32_t)(x.MaxSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxSgprAllocation_allocs)

	var csgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.sgprAllocationGranularity, csgprAllocationGranularity_allocs = (C.uint32_t)(x.SgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprAllocationGranularity_allocs)

	var cvgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.vgprsPerSimd, cvgprsPerSimd_allocs = (C.uint32_t)(x.VgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprsPerSimd_allocs)

	var cminVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minVgprAllocation, cminVgprAllocation_allocs = (C.uint32_t)(x.MinVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminVgprAllocation_allocs)

	var cmaxVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxVgprAllocation, cmaxVgprAllocation_allocs = (C.uint32_t)(x.MaxVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxVgprAllocation_allocs)

	var cvgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.vgprAllocationGranularity, cvgprAllocationGranularity_allocs = (C.uint32_t)(x.VgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprAllocationGranularity_allocs)

	x.refde4b3b09 = refde4b3b09
	x.allocsde4b3b09 = allocsde4b3b09
	return refde4b3b09, allocsde4b3b09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderCorePropertiesAMD) PassValue() (C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x.refde4b3b09 != nil {
		return *x.refde4b3b09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Deref() {
	if x.refde4b3b09 == nil {
		return
	}
	x.SType = (StructureType)(x.refde4b3b09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refde4b3b09.pNext))
	x.ShaderEngineCount = (uint32)(x.refde4b3b09.shaderEngineCount)
	x.ShaderArraysPerEngineCount = (uint32)(x.refde4b3b09.shaderArraysPerEngineCount)
	x.ComputeUnitsPerShaderArray = (uint32)(x.refde4b3b09.computeUnitsPerShaderArray)
	x.SimdPerComputeUnit = (uint32)(x.refde4b3b09.simdPerComputeUnit)
	x.WavefrontsPerSimd = (uint32)(x.refde4b3b09.wavefrontsPerSimd)
	x.WavefrontSize = (uint32)(x.refde4b3b09.wavefrontSize)
	x.SgprsPerSimd = (uint32)(x.refde4b3b09.sgprsPerSimd)
	x.MinSgprAllocation = (uint32)(x.refde4b3b09.minSgprAllocation)
	x.MaxSgprAllocation = (uint32)(x.refde4b3b09.maxSgprAllocation)
	x.SgprAllocationGranularity = (uint32)(x.refde4b3b09.sgprAllocationGranularity)
	x.VgprsPerSimd = (uint32)(x.refde4b3b09.vgprsPerSimd)
	x.MinVgprAllocation = (uint32)(x.refde4b3b09.minVgprAllocation)
	x.MaxVgprAllocation = (uint32)(x.refde4b3b09.maxVgprAllocation)
	x.VgprAllocationGranularity = (uint32)(x.refde4b3b09.vgprAllocationGranularity)
}

// allocPhysicalDeviceVertexAttributeDivisorPropertiesEXTMemory allocates memory for type C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexAttributeDivisorPropertiesEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesEXTValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexAttributeDivisorPropertiesEXT) Ref() *C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refbd6b5075
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorPropertiesEXT) Free() {
	if x != nil && x.allocsbd6b5075 != nil {
		x.allocsbd6b5075.(*cgoAllocMap).Free()
		x.refbd6b5075 = nil
	}
}

// NewPhysicalDeviceVertexAttributeDivisorPropertiesEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexAttributeDivisorPropertiesEXTRef(ref unsafe.Pointer) *PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexAttributeDivisorPropertiesEXT)
	obj.refbd6b5075 = (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorPropertiesEXT) PassRef() (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd6b5075 != nil {
		return x.refbd6b5075, nil
	}
	membd6b5075 := allocPhysicalDeviceVertexAttributeDivisorPropertiesEXTMemory(1)
	refbd6b5075 := (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(membd6b5075)
	allocsbd6b5075 := new(cgoAllocMap)
	allocsbd6b5075.Add(membd6b5075)

	var csType_allocs *cgoAllocMap
	refbd6b5075.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbd6b5075.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbd6b5075.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cpNext_allocs)

	var cmaxVertexAttribDivisor_allocs *cgoAllocMap
	refbd6b5075.maxVertexAttribDivisor, cmaxVertexAttribDivisor_allocs = (C.uint32_t)(x.MaxVertexAttribDivisor), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cmaxVertexAttribDivisor_allocs)

	x.refbd6b5075 = refbd6b5075
	x.allocsbd6b5075 = allocsbd6b5075
	return refbd6b5075, allocsbd6b5075

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexAttributeDivisorPropertiesEXT) PassValue() (C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x.refbd6b5075 != nil {
		return *x.refbd6b5075, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexAttributeDivisorPropertiesEXT) Deref() {
	if x.refbd6b5075 == nil {
		return
	}
	x.SType = (StructureType)(x.refbd6b5075.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbd6b5075.pNext))
	x.MaxVertexAttribDivisor = (uint32)(x.refbd6b5075.maxVertexAttribDivisor)
}

// allocVertexInputBindingDivisorDescriptionEXTMemory allocates memory for type C.VkVertexInputBindingDivisorDescriptionEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDivisorDescriptionEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDivisorDescriptionEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDivisorDescriptionEXTValue = unsafe.Sizeof([1]C.VkVertexInputBindingDivisorDescriptionEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDivisorDescriptionEXT) Ref() *C.VkVertexInputBindingDivisorDescriptionEXT {
	if x == nil {
		return nil
	}
	return x.refd64d4396
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDivisorDescriptionEXT) Free() {
	if x != nil && x.allocsd64d4396 != nil {
		x.allocsd64d4396.(*cgoAllocMap).Free()
		x.refd64d4396 = nil
	}
}

// NewVertexInputBindingDivisorDescriptionEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDivisorDescriptionEXTRef(ref unsafe.Pointer) *VertexInputBindingDivisorDescriptionEXT {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDivisorDescriptionEXT)
	obj.refd64d4396 = (*C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDivisorDescriptionEXT) PassRef() (*C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd64d4396 != nil {
		return x.refd64d4396, nil
	}
	memd64d4396 := allocVertexInputBindingDivisorDescriptionEXTMemory(1)
	refd64d4396 := (*C.VkVertexInputBindingDivisorDescriptionEXT)(memd64d4396)
	allocsd64d4396 := new(cgoAllocMap)
	allocsd64d4396.Add(memd64d4396)

	var cbinding_allocs *cgoAllocMap
	refd64d4396.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsd64d4396.Borrow(cbinding_allocs)

	var cdivisor_allocs *cgoAllocMap
	refd64d4396.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocsd64d4396.Borrow(cdivisor_allocs)

	x.refd64d4396 = refd64d4396
	x.allocsd64d4396 = allocsd64d4396
	return refd64d4396, allocsd64d4396

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDivisorDescriptionEXT) PassValue() (C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x.refd64d4396 != nil {
		return *x.refd64d4396, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDivisorDescriptionEXT) Deref() {
	if x.refd64d4396 == nil {
		return
	}
	x.Binding = (uint32)(x.refd64d4396.binding)
	x.Divisor = (uint32)(x.refd64d4396.divisor)
}

// allocPipelineVertexInputDivisorStateCreateInfoEXTMemory allocates memory for type C.VkPipelineVertexInputDivisorStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputDivisorStateCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputDivisorStateCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputDivisorStateCreateInfoEXTValue = unsafe.Sizeof([1]C.VkPipelineVertexInputDivisorStateCreateInfoEXT{})

// unpackSVertexInputBindingDivisorDescriptionEXT transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDivisorDescriptionEXT(x []VertexInputBindingDivisorDescriptionEXT) (unpacked *C.VkVertexInputBindingDivisorDescriptionEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDivisorDescriptionEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDivisorDescriptionEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDivisorDescriptionEXT)(h.Data)
	return
}

// packSVertexInputBindingDivisorDescriptionEXT reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDivisorDescriptionEXT(v []VertexInputBindingDivisorDescriptionEXT, ptr0 *C.VkVertexInputBindingDivisorDescriptionEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDivisorDescriptionEXTValue]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDivisorDescriptionEXTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputDivisorStateCreateInfoEXT) Ref() *C.VkPipelineVertexInputDivisorStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref86096bfd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfoEXT) Free() {
	if x != nil && x.allocs86096bfd != nil {
		x.allocs86096bfd.(*cgoAllocMap).Free()
		x.ref86096bfd = nil
	}
}

// NewPipelineVertexInputDivisorStateCreateInfoEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputDivisorStateCreateInfoEXTRef(ref unsafe.Pointer) *PipelineVertexInputDivisorStateCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputDivisorStateCreateInfoEXT)
	obj.ref86096bfd = (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfoEXT) PassRef() (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86096bfd != nil {
		return x.ref86096bfd, nil
	}
	mem86096bfd := allocPipelineVertexInputDivisorStateCreateInfoEXTMemory(1)
	ref86096bfd := (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(mem86096bfd)
	allocs86096bfd := new(cgoAllocMap)
	allocs86096bfd.Add(mem86096bfd)

	var csType_allocs *cgoAllocMap
	ref86096bfd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86096bfd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86096bfd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86096bfd.Borrow(cpNext_allocs)

	var cvertexBindingDivisorCount_allocs *cgoAllocMap
	ref86096bfd.vertexBindingDivisorCount, cvertexBindingDivisorCount_allocs = (C.uint32_t)(x.VertexBindingDivisorCount), cgoAllocsUnknown
	allocs86096bfd.Borrow(cvertexBindingDivisorCount_allocs)

	var cpVertexBindingDivisors_allocs *cgoAllocMap
	ref86096bfd.pVertexBindingDivisors, cpVertexBindingDivisors_allocs = unpackSVertexInputBindingDivisorDescriptionEXT(x.PVertexBindingDivisors)
	allocs86096bfd.Borrow(cpVertexBindingDivisors_allocs)

	x.ref86096bfd = ref86096bfd
	x.allocs86096bfd = allocs86096bfd
	return ref86096bfd, allocs86096bfd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputDivisorStateCreateInfoEXT) PassValue() (C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref86096bfd != nil {
		return *x.ref86096bfd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputDivisorStateCreateInfoEXT) Deref() {
	if x.ref86096bfd == nil {
		return
	}
	x.SType = (StructureType)(x.ref86096bfd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86096bfd.pNext))
	x.VertexBindingDivisorCount = (uint32)(x.ref86096bfd.vertexBindingDivisorCount)
	packSVertexInputBindingDivisorDescriptionEXT(x.PVertexBindingDivisors, x.ref86096bfd.pVertexBindingDivisors)
}

// allocQueueFamilyCheckpointPropertiesNVMemory allocates memory for type C.VkQueueFamilyCheckpointPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyCheckpointPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyCheckpointPropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyCheckpointPropertiesNVValue = unsafe.Sizeof([1]C.VkQueueFamilyCheckpointPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyCheckpointPropertiesNV) Ref() *C.VkQueueFamilyCheckpointPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref351f58c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) Free() {
	if x != nil && x.allocs351f58c6 != nil {
		x.allocs351f58c6.(*cgoAllocMap).Free()
		x.ref351f58c6 = nil
	}
}

// NewQueueFamilyCheckpointPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyCheckpointPropertiesNVRef(ref unsafe.Pointer) *QueueFamilyCheckpointPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyCheckpointPropertiesNV)
	obj.ref351f58c6 = (*C.VkQueueFamilyCheckpointPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) PassRef() (*C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref351f58c6 != nil {
		return x.ref351f58c6, nil
	}
	mem351f58c6 := allocQueueFamilyCheckpointPropertiesNVMemory(1)
	ref351f58c6 := (*C.VkQueueFamilyCheckpointPropertiesNV)(mem351f58c6)
	allocs351f58c6 := new(cgoAllocMap)
	allocs351f58c6.Add(mem351f58c6)

	var csType_allocs *cgoAllocMap
	ref351f58c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs351f58c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref351f58c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs351f58c6.Borrow(cpNext_allocs)

	var ccheckpointExecutionStageMask_allocs *cgoAllocMap
	ref351f58c6.checkpointExecutionStageMask, ccheckpointExecutionStageMask_allocs = (C.VkPipelineStageFlags)(x.CheckpointExecutionStageMask), cgoAllocsUnknown
	allocs351f58c6.Borrow(ccheckpointExecutionStageMask_allocs)

	x.ref351f58c6 = ref351f58c6
	x.allocs351f58c6 = allocs351f58c6
	return ref351f58c6, allocs351f58c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyCheckpointPropertiesNV) PassValue() (C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x.ref351f58c6 != nil {
		return *x.ref351f58c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyCheckpointPropertiesNV) Deref() {
	if x.ref351f58c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref351f58c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref351f58c6.pNext))
	x.CheckpointExecutionStageMask = (PipelineStageFlags)(x.ref351f58c6.checkpointExecutionStageMask)
}

// allocCheckpointDataNVMemory allocates memory for type C.VkCheckpointDataNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCheckpointDataNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCheckpointDataNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCheckpointDataNVValue = unsafe.Sizeof([1]C.VkCheckpointDataNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CheckpointDataNV) Ref() *C.VkCheckpointDataNV {
	if x == nil {
		return nil
	}
	return x.refd1c9224b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CheckpointDataNV) Free() {
	if x != nil && x.allocsd1c9224b != nil {
		x.allocsd1c9224b.(*cgoAllocMap).Free()
		x.refd1c9224b = nil
	}
}

// NewCheckpointDataNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCheckpointDataNVRef(ref unsafe.Pointer) *CheckpointDataNV {
	if ref == nil {
		return nil
	}
	obj := new(CheckpointDataNV)
	obj.refd1c9224b = (*C.VkCheckpointDataNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CheckpointDataNV) PassRef() (*C.VkCheckpointDataNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1c9224b != nil {
		return x.refd1c9224b, nil
	}
	memd1c9224b := allocCheckpointDataNVMemory(1)
	refd1c9224b := (*C.VkCheckpointDataNV)(memd1c9224b)
	allocsd1c9224b := new(cgoAllocMap)
	allocsd1c9224b.Add(memd1c9224b)

	var csType_allocs *cgoAllocMap
	refd1c9224b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1c9224b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1c9224b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpNext_allocs)

	var cstage_allocs *cgoAllocMap
	refd1c9224b.stage, cstage_allocs = (C.VkPipelineStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cstage_allocs)

	var cpCheckpointMarker_allocs *cgoAllocMap
	refd1c9224b.pCheckpointMarker, cpCheckpointMarker_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PCheckpointMarker)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpCheckpointMarker_allocs)

	x.refd1c9224b = refd1c9224b
	x.allocsd1c9224b = allocsd1c9224b
	return refd1c9224b, allocsd1c9224b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CheckpointDataNV) PassValue() (C.VkCheckpointDataNV, *cgoAllocMap) {
	if x.refd1c9224b != nil {
		return *x.refd1c9224b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CheckpointDataNV) Deref() {
	if x.refd1c9224b == nil {
		return
	}
	x.SType = (StructureType)(x.refd1c9224b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pNext))
	x.Stage = (PipelineStageFlagBits)(x.refd1c9224b.stage)
	x.PCheckpointMarker = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pCheckpointMarker))
}

// unpackArgSInstanceCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSInstanceCreateInfo(x []InstanceCreateInfo) (unpacked *C.VkInstanceCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkInstanceCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocInstanceCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkInstanceCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkInstanceCreateInfo)(h.Data)
	return
}

// packSInstanceCreateInfo reads sliced Go data structure out from plain C format.
func packSInstanceCreateInfo(v []InstanceCreateInfo, ptr0 *C.VkInstanceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInstanceCreateInfoValue]C.VkInstanceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInstanceCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSAllocationCallbacks transforms a sliced Go data structure into plain C format.
func unpackArgSAllocationCallbacks(x []AllocationCallbacks) (unpacked *C.VkAllocationCallbacks, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAllocationCallbacks) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAllocationCallbacksMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAllocationCallbacks)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAllocationCallbacks)(h.Data)
	return
}

// packSAllocationCallbacks reads sliced Go data structure out from plain C format.
func packSAllocationCallbacks(v []AllocationCallbacks, ptr0 *C.VkAllocationCallbacks) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAllocationCallbacksValue]C.VkAllocationCallbacks)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAllocationCallbacksRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(h.Data)
	return
}

// unpackArgSFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSFormatProperties(x []FormatProperties) (unpacked *C.VkFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkFormatProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFormatProperties)(h.Data)
	return
}

// packSFormatProperties reads sliced Go data structure out from plain C format.
func packSFormatProperties(v []FormatProperties, ptr0 *C.VkFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFormatPropertiesValue]C.VkFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSImageFormatProperties(x []ImageFormatProperties) (unpacked *C.VkImageFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageFormatProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageFormatProperties)(h.Data)
	return
}

// packSImageFormatProperties reads sliced Go data structure out from plain C format.
func packSImageFormatProperties(v []ImageFormatProperties, ptr0 *C.VkImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageFormatPropertiesValue]C.VkImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceProperties transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceProperties(x []PhysicalDeviceProperties) (unpacked *C.VkPhysicalDeviceProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDevicePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceProperties)(h.Data)
	return
}

// packSPhysicalDeviceProperties reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceProperties(v []PhysicalDeviceProperties, ptr0 *C.VkPhysicalDeviceProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDevicePropertiesValue]C.VkPhysicalDeviceProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSQueueFamilyProperties transforms a sliced Go data structure into plain C format.
func unpackArgSQueueFamilyProperties(x []QueueFamilyProperties) (unpacked *C.VkQueueFamilyProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkQueueFamilyProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocQueueFamilyPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueueFamilyProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueueFamilyProperties)(h.Data)
	return
}

// packSQueueFamilyProperties reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties(v []QueueFamilyProperties, ptr0 *C.VkQueueFamilyProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyPropertiesValue]C.VkQueueFamilyProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceMemoryProperties transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceMemoryProperties(x []PhysicalDeviceMemoryProperties) (unpacked *C.VkPhysicalDeviceMemoryProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceMemoryProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceMemoryPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceMemoryProperties)(h.Data)
	return
}

// packSPhysicalDeviceMemoryProperties reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceMemoryProperties(v []PhysicalDeviceMemoryProperties, ptr0 *C.VkPhysicalDeviceMemoryProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceMemoryPropertiesValue]C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceMemoryPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDeviceCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceCreateInfo(x []DeviceCreateInfo) (unpacked *C.VkDeviceCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceCreateInfo)(h.Data)
	return
}

// packSDeviceCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceCreateInfo(v []DeviceCreateInfo, ptr0 *C.VkDeviceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceCreateInfoValue]C.VkDeviceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExtensionProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(h.Data)
	return
}

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLayerProperties transforms a sliced Go data structure into plain C format.
func unpackArgSLayerProperties(x []LayerProperties) (unpacked *C.VkLayerProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkLayerProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLayerPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkLayerProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkLayerProperties)(h.Data)
	return
}

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSubmitInfo(x []SubmitInfo) (unpacked *C.VkSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubmitInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubmitInfo)(h.Data)
	return
}

// packSSubmitInfo reads sliced Go data structure out from plain C format.
func packSSubmitInfo(v []SubmitInfo, ptr0 *C.VkSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubmitInfoValue]C.VkSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryAllocateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryAllocateInfo(x []MemoryAllocateInfo) (unpacked *C.VkMemoryAllocateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryAllocateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryAllocateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryAllocateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryAllocateInfo)(h.Data)
	return
}

// packSMemoryAllocateInfo reads sliced Go data structure out from plain C format.
func packSMemoryAllocateInfo(v []MemoryAllocateInfo, ptr0 *C.VkMemoryAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryAllocateInfoValue]C.VkMemoryAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryAllocateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMappedMemoryRange transforms a sliced Go data structure into plain C format.
func unpackArgSMappedMemoryRange(x []MappedMemoryRange) (unpacked *C.VkMappedMemoryRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMappedMemoryRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMappedMemoryRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMappedMemoryRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMappedMemoryRange)(h.Data)
	return
}

// packSMappedMemoryRange reads sliced Go data structure out from plain C format.
func packSMappedMemoryRange(v []MappedMemoryRange, ptr0 *C.VkMappedMemoryRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappedMemoryRangeValue]C.VkMappedMemoryRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappedMemoryRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryRequirements transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryRequirements(x []MemoryRequirements) (unpacked *C.VkMemoryRequirements, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryRequirements) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryRequirementsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryRequirements)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryRequirements)(h.Data)
	return
}

// packSMemoryRequirements reads sliced Go data structure out from plain C format.
func packSMemoryRequirements(v []MemoryRequirements, ptr0 *C.VkMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryRequirementsValue]C.VkMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryRequirementsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageMemoryRequirements transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageMemoryRequirements(x []SparseImageMemoryRequirements) (unpacked *C.VkSparseImageMemoryRequirements, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryRequirements) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryRequirementsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryRequirements)(h.Data)
	return
}

// packSSparseImageMemoryRequirements reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements(v []SparseImageMemoryRequirements, ptr0 *C.VkSparseImageMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirementsValue]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageFormatProperties(x []SparseImageFormatProperties) (unpacked *C.VkSparseImageFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageFormatProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageFormatProperties)(h.Data)
	return
}

// packSSparseImageFormatProperties reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties(v []SparseImageFormatProperties, ptr0 *C.VkSparseImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatPropertiesValue]C.VkSparseImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindSparseInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindSparseInfo(x []BindSparseInfo) (unpacked *C.VkBindSparseInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBindSparseInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBindSparseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindSparseInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindSparseInfo)(h.Data)
	return
}

// packSBindSparseInfo reads sliced Go data structure out from plain C format.
func packSBindSparseInfo(v []BindSparseInfo, ptr0 *C.VkBindSparseInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindSparseInfoValue]C.VkBindSparseInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindSparseInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFenceCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFenceCreateInfo(x []FenceCreateInfo) (unpacked *C.VkFenceCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkFenceCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFenceCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFenceCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFenceCreateInfo)(h.Data)
	return
}

// packSFenceCreateInfo reads sliced Go data structure out from plain C format.
func packSFenceCreateInfo(v []FenceCreateInfo, ptr0 *C.VkFenceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFenceCreateInfoValue]C.VkFenceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFenceCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSemaphoreCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSemaphoreCreateInfo(x []SemaphoreCreateInfo) (unpacked *C.VkSemaphoreCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSemaphoreCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSemaphoreCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSemaphoreCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSemaphoreCreateInfo)(h.Data)
	return
}

// packSSemaphoreCreateInfo reads sliced Go data structure out from plain C format.
func packSSemaphoreCreateInfo(v []SemaphoreCreateInfo, ptr0 *C.VkSemaphoreCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSemaphoreCreateInfoValue]C.VkSemaphoreCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSemaphoreCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSEventCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSEventCreateInfo(x []EventCreateInfo) (unpacked *C.VkEventCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkEventCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocEventCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkEventCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkEventCreateInfo)(h.Data)
	return
}

// packSEventCreateInfo reads sliced Go data structure out from plain C format.
func packSEventCreateInfo(v []EventCreateInfo, ptr0 *C.VkEventCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfEventCreateInfoValue]C.VkEventCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewEventCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSQueryPoolCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSQueryPoolCreateInfo(x []QueryPoolCreateInfo) (unpacked *C.VkQueryPoolCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkQueryPoolCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocQueryPoolCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueryPoolCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueryPoolCreateInfo)(h.Data)
	return
}

// packSQueryPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSQueryPoolCreateInfo(v []QueryPoolCreateInfo, ptr0 *C.VkQueryPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueryPoolCreateInfoValue]C.VkQueryPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueryPoolCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBufferCreateInfo(x []BufferCreateInfo) (unpacked *C.VkBufferCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCreateInfo)(h.Data)
	return
}

// packSBufferCreateInfo reads sliced Go data structure out from plain C format.
func packSBufferCreateInfo(v []BufferCreateInfo, ptr0 *C.VkBufferCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCreateInfoValue]C.VkBufferCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferViewCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBufferViewCreateInfo(x []BufferViewCreateInfo) (unpacked *C.VkBufferViewCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferViewCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferViewCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferViewCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferViewCreateInfo)(h.Data)
	return
}

// packSBufferViewCreateInfo reads sliced Go data structure out from plain C format.
func packSBufferViewCreateInfo(v []BufferViewCreateInfo, ptr0 *C.VkBufferViewCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferViewCreateInfoValue]C.VkBufferViewCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferViewCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSImageCreateInfo(x []ImageCreateInfo) (unpacked *C.VkImageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCreateInfo)(h.Data)
	return
}

// packSImageCreateInfo reads sliced Go data structure out from plain C format.
func packSImageCreateInfo(v []ImageCreateInfo, ptr0 *C.VkImageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCreateInfoValue]C.VkImageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSubresource transforms a sliced Go data structure into plain C format.
func unpackArgSImageSubresource(x []ImageSubresource) (unpacked *C.VkImageSubresource, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageSubresource) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageSubresourceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSubresource)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSubresource)(h.Data)
	return
}

// packSImageSubresource reads sliced Go data structure out from plain C format.
func packSImageSubresource(v []ImageSubresource, ptr0 *C.VkImageSubresource) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceValue]C.VkImageSubresource)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubresourceLayout transforms a sliced Go data structure into plain C format.
func unpackArgSSubresourceLayout(x []SubresourceLayout) (unpacked *C.VkSubresourceLayout, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubresourceLayout) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubresourceLayoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubresourceLayout)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubresourceLayout)(h.Data)
	return
}

// packSSubresourceLayout reads sliced Go data structure out from plain C format.
func packSSubresourceLayout(v []SubresourceLayout, ptr0 *C.VkSubresourceLayout) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubresourceLayoutValue]C.VkSubresourceLayout)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubresourceLayoutRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageViewCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSImageViewCreateInfo(x []ImageViewCreateInfo) (unpacked *C.VkImageViewCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageViewCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageViewCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageViewCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageViewCreateInfo)(h.Data)
	return
}

// packSImageViewCreateInfo reads sliced Go data structure out from plain C format.
func packSImageViewCreateInfo(v []ImageViewCreateInfo, ptr0 *C.VkImageViewCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageViewCreateInfoValue]C.VkImageViewCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageViewCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSShaderModuleCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSShaderModuleCreateInfo(x []ShaderModuleCreateInfo) (unpacked *C.VkShaderModuleCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkShaderModuleCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocShaderModuleCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkShaderModuleCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkShaderModuleCreateInfo)(h.Data)
	return
}

// packSShaderModuleCreateInfo reads sliced Go data structure out from plain C format.
func packSShaderModuleCreateInfo(v []ShaderModuleCreateInfo, ptr0 *C.VkShaderModuleCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShaderModuleCreateInfoValue]C.VkShaderModuleCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShaderModuleCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPipelineCacheCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSPipelineCacheCreateInfo(x []PipelineCacheCreateInfo) (unpacked *C.VkPipelineCacheCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineCacheCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineCacheCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineCacheCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineCacheCreateInfo)(h.Data)
	return
}

// packSPipelineCacheCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineCacheCreateInfo(v []PipelineCacheCreateInfo, ptr0 *C.VkPipelineCacheCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineCacheCreateInfoValue]C.VkPipelineCacheCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineCacheCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSGraphicsPipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSGraphicsPipelineCreateInfo(x []GraphicsPipelineCreateInfo) (unpacked *C.VkGraphicsPipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkGraphicsPipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsPipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsPipelineCreateInfo)(h.Data)
	return
}

// packSGraphicsPipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSGraphicsPipelineCreateInfo(v []GraphicsPipelineCreateInfo, ptr0 *C.VkGraphicsPipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsPipelineCreateInfoValue]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsPipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSComputePipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSComputePipelineCreateInfo(x []ComputePipelineCreateInfo) (unpacked *C.VkComputePipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkComputePipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocComputePipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkComputePipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkComputePipelineCreateInfo)(h.Data)
	return
}

// packSComputePipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSComputePipelineCreateInfo(v []ComputePipelineCreateInfo, ptr0 *C.VkComputePipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfComputePipelineCreateInfoValue]C.VkComputePipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewComputePipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPipelineLayoutCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSPipelineLayoutCreateInfo(x []PipelineLayoutCreateInfo) (unpacked *C.VkPipelineLayoutCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineLayoutCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineLayoutCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineLayoutCreateInfo)(h.Data)
	return
}

// packSPipelineLayoutCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineLayoutCreateInfo(v []PipelineLayoutCreateInfo, ptr0 *C.VkPipelineLayoutCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineLayoutCreateInfoValue]C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineLayoutCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSamplerCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSamplerCreateInfo(x []SamplerCreateInfo) (unpacked *C.VkSamplerCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSamplerCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSamplerCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSamplerCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSamplerCreateInfo)(h.Data)
	return
}

// packSSamplerCreateInfo reads sliced Go data structure out from plain C format.
func packSSamplerCreateInfo(v []SamplerCreateInfo, ptr0 *C.VkSamplerCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSamplerCreateInfoValue]C.VkSamplerCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSamplerCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDescriptorSetLayoutCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorSetLayoutCreateInfo(x []DescriptorSetLayoutCreateInfo) (unpacked *C.VkDescriptorSetLayoutCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutCreateInfo)(h.Data)
	return
}

// packSDescriptorSetLayoutCreateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutCreateInfo(v []DescriptorSetLayoutCreateInfo, ptr0 *C.VkDescriptorSetLayoutCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutCreateInfoValue]C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDescriptorPoolCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorPoolCreateInfo(x []DescriptorPoolCreateInfo) (unpacked *C.VkDescriptorPoolCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorPoolCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolCreateInfo)(h.Data)
	return
}

// packSDescriptorPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorPoolCreateInfo(v []DescriptorPoolCreateInfo, ptr0 *C.VkDescriptorPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolCreateInfoValue]C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDescriptorSetAllocateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorSetAllocateInfo(x []DescriptorSetAllocateInfo) (unpacked *C.VkDescriptorSetAllocateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetAllocateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetAllocateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetAllocateInfo)(h.Data)
	return
}

// packSDescriptorSetAllocateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorSetAllocateInfo(v []DescriptorSetAllocateInfo, ptr0 *C.VkDescriptorSetAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetAllocateInfoValue]C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetAllocateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSWriteDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSWriteDescriptorSet(x []WriteDescriptorSet) (unpacked *C.VkWriteDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkWriteDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWriteDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkWriteDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkWriteDescriptorSet)(h.Data)
	return
}

// packSWriteDescriptorSet reads sliced Go data structure out from plain C format.
func packSWriteDescriptorSet(v []WriteDescriptorSet, ptr0 *C.VkWriteDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteDescriptorSetValue]C.VkWriteDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCopyDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSCopyDescriptorSet(x []CopyDescriptorSet) (unpacked *C.VkCopyDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCopyDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCopyDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCopyDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCopyDescriptorSet)(h.Data)
	return
}

// packSCopyDescriptorSet reads sliced Go data structure out from plain C format.
func packSCopyDescriptorSet(v []CopyDescriptorSet, ptr0 *C.VkCopyDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCopyDescriptorSetValue]C.VkCopyDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCopyDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFramebufferCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFramebufferCreateInfo(x []FramebufferCreateInfo) (unpacked *C.VkFramebufferCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkFramebufferCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFramebufferCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFramebufferCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFramebufferCreateInfo)(h.Data)
	return
}

// packSFramebufferCreateInfo reads sliced Go data structure out from plain C format.
func packSFramebufferCreateInfo(v []FramebufferCreateInfo, ptr0 *C.VkFramebufferCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFramebufferCreateInfoValue]C.VkFramebufferCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFramebufferCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRenderPassCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSRenderPassCreateInfo(x []RenderPassCreateInfo) (unpacked *C.VkRenderPassCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRenderPassCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRenderPassCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRenderPassCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRenderPassCreateInfo)(h.Data)
	return
}

// packSRenderPassCreateInfo reads sliced Go data structure out from plain C format.
func packSRenderPassCreateInfo(v []RenderPassCreateInfo, ptr0 *C.VkRenderPassCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderPassCreateInfoValue]C.VkRenderPassCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderPassCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExtent2D transforms a sliced Go data structure into plain C format.
func unpackArgSExtent2D(x []Extent2D) (unpacked *C.VkExtent2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExtent2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExtent2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtent2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtent2D)(h.Data)
	return
}

// packSExtent2D reads sliced Go data structure out from plain C format.
func packSExtent2D(v []Extent2D, ptr0 *C.VkExtent2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtent2DValue]C.VkExtent2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtent2DRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCommandPoolCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCommandPoolCreateInfo(x []CommandPoolCreateInfo) (unpacked *C.VkCommandPoolCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandPoolCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandPoolCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandPoolCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandPoolCreateInfo)(h.Data)
	return
}

// packSCommandPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSCommandPoolCreateInfo(v []CommandPoolCreateInfo, ptr0 *C.VkCommandPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandPoolCreateInfoValue]C.VkCommandPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandPoolCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCommandBufferAllocateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCommandBufferAllocateInfo(x []CommandBufferAllocateInfo) (unpacked *C.VkCommandBufferAllocateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferAllocateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferAllocateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferAllocateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferAllocateInfo)(h.Data)
	return
}

// packSCommandBufferAllocateInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferAllocateInfo(v []CommandBufferAllocateInfo, ptr0 *C.VkCommandBufferAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferAllocateInfoValue]C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferAllocateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCommandBufferBeginInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCommandBufferBeginInfo(x []CommandBufferBeginInfo) (unpacked *C.VkCommandBufferBeginInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferBeginInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferBeginInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferBeginInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferBeginInfo)(h.Data)
	return
}

// packSCommandBufferBeginInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferBeginInfo(v []CommandBufferBeginInfo, ptr0 *C.VkCommandBufferBeginInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferBeginInfoValue]C.VkCommandBufferBeginInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferBeginInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSViewport transforms a sliced Go data structure into plain C format.
func unpackArgSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackArgSRect2D transforms a sliced Go data structure into plain C format.
func unpackArgSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// unpackArgSBufferCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferCopy(x []BufferCopy) (unpacked *C.VkBufferCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCopy)(h.Data)
	return
}

// packSBufferCopy reads sliced Go data structure out from plain C format.
func packSBufferCopy(v []BufferCopy, ptr0 *C.VkBufferCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopyValue]C.VkBufferCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSImageCopy(x []ImageCopy) (unpacked *C.VkImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCopy)(h.Data)
	return
}

// packSImageCopy reads sliced Go data structure out from plain C format.
func packSImageCopy(v []ImageCopy, ptr0 *C.VkImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopyValue]C.VkImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageBlit transforms a sliced Go data structure into plain C format.
func unpackArgSImageBlit(x []ImageBlit) (unpacked *C.VkImageBlit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageBlit) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageBlitMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageBlit)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageBlit)(h.Data)
	return
}

// packSImageBlit reads sliced Go data structure out from plain C format.
func packSImageBlit(v []ImageBlit, ptr0 *C.VkImageBlit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlitValue]C.VkImageBlit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlitRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferImageCopy(x []BufferImageCopy) (unpacked *C.VkBufferImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferImageCopy)(h.Data)
	return
}

// packSBufferImageCopy reads sliced Go data structure out from plain C format.
func packSBufferImageCopy(v []BufferImageCopy, ptr0 *C.VkBufferImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopyValue]C.VkBufferImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSubresourceRange transforms a sliced Go data structure into plain C format.
func unpackArgSImageSubresourceRange(x []ImageSubresourceRange) (unpacked *C.VkImageSubresourceRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageSubresourceRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageSubresourceRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSubresourceRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSubresourceRange)(h.Data)
	return
}

// packSImageSubresourceRange reads sliced Go data structure out from plain C format.
func packSImageSubresourceRange(v []ImageSubresourceRange, ptr0 *C.VkImageSubresourceRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceRangeValue]C.VkImageSubresourceRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearDepthStencilValue transforms a sliced Go data structure into plain C format.
func unpackArgSClearDepthStencilValue(x []ClearDepthStencilValue) (unpacked *C.VkClearDepthStencilValue, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearDepthStencilValue) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearDepthStencilValueMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearDepthStencilValue)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearDepthStencilValue)(h.Data)
	return
}

// packSClearDepthStencilValue reads sliced Go data structure out from plain C format.
func packSClearDepthStencilValue(v []ClearDepthStencilValue, ptr0 *C.VkClearDepthStencilValue) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearDepthStencilValueValue]C.VkClearDepthStencilValue)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearDepthStencilValueRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearAttachment transforms a sliced Go data structure into plain C format.
func unpackArgSClearAttachment(x []ClearAttachment) (unpacked *C.VkClearAttachment, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearAttachment) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearAttachmentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearAttachment)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearAttachment)(h.Data)
	return
}

// packSClearAttachment reads sliced Go data structure out from plain C format.
func packSClearAttachment(v []ClearAttachment, ptr0 *C.VkClearAttachment) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearAttachmentValue]C.VkClearAttachment)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearAttachmentRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearRect transforms a sliced Go data structure into plain C format.
func unpackArgSClearRect(x []ClearRect) (unpacked *C.VkClearRect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearRect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearRect)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearRect)(h.Data)
	return
}

// packSClearRect reads sliced Go data structure out from plain C format.
func packSClearRect(v []ClearRect, ptr0 *C.VkClearRect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearRectValue]C.VkClearRect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageResolve transforms a sliced Go data structure into plain C format.
func unpackArgSImageResolve(x []ImageResolve) (unpacked *C.VkImageResolve, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageResolve) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageResolveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageResolve)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageResolve)(h.Data)
	return
}

// packSImageResolve reads sliced Go data structure out from plain C format.
func packSImageResolve(v []ImageResolve, ptr0 *C.VkImageResolve) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolveValue]C.VkImageResolve)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryBarrier(x []MemoryBarrier) (unpacked *C.VkMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryBarrier)(h.Data)
	return
}

// packSMemoryBarrier reads sliced Go data structure out from plain C format.
func packSMemoryBarrier(v []MemoryBarrier, ptr0 *C.VkMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrierValue]C.VkMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryBarrier(x []BufferMemoryBarrier) (unpacked *C.VkBufferMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier)(h.Data)
	return
}

// packSBufferMemoryBarrier reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier(v []BufferMemoryBarrier, ptr0 *C.VkBufferMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrierValue]C.VkBufferMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryBarrier(x []ImageMemoryBarrier) (unpacked *C.VkImageMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier)(h.Data)
	return
}

// packSImageMemoryBarrier reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier(v []ImageMemoryBarrier, ptr0 *C.VkImageMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrierValue]C.VkImageMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRenderPassBeginInfo transforms a sliced Go data structure into plain C format.
func unpackArgSRenderPassBeginInfo(x []RenderPassBeginInfo) (unpacked *C.VkRenderPassBeginInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRenderPassBeginInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRenderPassBeginInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRenderPassBeginInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRenderPassBeginInfo)(h.Data)
	return
}

// packSRenderPassBeginInfo reads sliced Go data structure out from plain C format.
func packSRenderPassBeginInfo(v []RenderPassBeginInfo, ptr0 *C.VkRenderPassBeginInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderPassBeginInfoValue]C.VkRenderPassBeginInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderPassBeginInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindBufferMemoryInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindBufferMemoryInfo(x []BindBufferMemoryInfo) (unpacked *C.VkBindBufferMemoryInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBindBufferMemoryInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBindBufferMemoryInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindBufferMemoryInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindBufferMemoryInfo)(h.Data)
	return
}

// packSBindBufferMemoryInfo reads sliced Go data structure out from plain C format.
func packSBindBufferMemoryInfo(v []BindBufferMemoryInfo, ptr0 *C.VkBindBufferMemoryInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindBufferMemoryInfoValue]C.VkBindBufferMemoryInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindBufferMemoryInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindImageMemoryInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindImageMemoryInfo(x []BindImageMemoryInfo) (unpacked *C.VkBindImageMemoryInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBindImageMemoryInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBindImageMemoryInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindImageMemoryInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindImageMemoryInfo)(h.Data)
	return
}

// packSBindImageMemoryInfo reads sliced Go data structure out from plain C format.
func packSBindImageMemoryInfo(v []BindImageMemoryInfo, ptr0 *C.VkBindImageMemoryInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindImageMemoryInfoValue]C.VkBindImageMemoryInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindImageMemoryInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceGroupProperties transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceGroupProperties(x []PhysicalDeviceGroupProperties) (unpacked *C.VkPhysicalDeviceGroupProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceGroupProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceGroupPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceGroupProperties)(h.Data)
	return
}

// packSPhysicalDeviceGroupProperties reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceGroupProperties(v []PhysicalDeviceGroupProperties, ptr0 *C.VkPhysicalDeviceGroupProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceGroupPropertiesValue]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceGroupPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageMemoryRequirementsInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryRequirementsInfo2(x []ImageMemoryRequirementsInfo2) (unpacked *C.VkImageMemoryRequirementsInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageMemoryRequirementsInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryRequirementsInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryRequirementsInfo2)(h.Data)
	return
}

// packSImageMemoryRequirementsInfo2 reads sliced Go data structure out from plain C format.
func packSImageMemoryRequirementsInfo2(v []ImageMemoryRequirementsInfo2, ptr0 *C.VkImageMemoryRequirementsInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryRequirementsInfo2Value]C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryRequirementsInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryRequirements2 transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryRequirements2(x []MemoryRequirements2) (unpacked *C.VkMemoryRequirements2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryRequirements2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryRequirements2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryRequirements2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryRequirements2)(h.Data)
	return
}

// packSMemoryRequirements2 reads sliced Go data structure out from plain C format.
func packSMemoryRequirements2(v []MemoryRequirements2, ptr0 *C.VkMemoryRequirements2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryRequirements2Value]C.VkMemoryRequirements2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryRequirements2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferMemoryRequirementsInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryRequirementsInfo2(x []BufferMemoryRequirementsInfo2) (unpacked *C.VkBufferMemoryRequirementsInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferMemoryRequirementsInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryRequirementsInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryRequirementsInfo2)(h.Data)
	return
}

// packSBufferMemoryRequirementsInfo2 reads sliced Go data structure out from plain C format.
func packSBufferMemoryRequirementsInfo2(v []BufferMemoryRequirementsInfo2, ptr0 *C.VkBufferMemoryRequirementsInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryRequirementsInfo2Value]C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryRequirementsInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSparseMemoryRequirementsInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSImageSparseMemoryRequirementsInfo2(x []ImageSparseMemoryRequirementsInfo2) (unpacked *C.VkImageSparseMemoryRequirementsInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageSparseMemoryRequirementsInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageSparseMemoryRequirementsInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSparseMemoryRequirementsInfo2)(h.Data)
	return
}

// packSImageSparseMemoryRequirementsInfo2 reads sliced Go data structure out from plain C format.
func packSImageSparseMemoryRequirementsInfo2(v []ImageSparseMemoryRequirementsInfo2, ptr0 *C.VkImageSparseMemoryRequirementsInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSparseMemoryRequirementsInfo2Value]C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSparseMemoryRequirementsInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageMemoryRequirements2 transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageMemoryRequirements2(x []SparseImageMemoryRequirements2) (unpacked *C.VkSparseImageMemoryRequirements2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryRequirements2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryRequirements2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryRequirements2)(h.Data)
	return
}

// packSSparseImageMemoryRequirements2 reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements2(v []SparseImageMemoryRequirements2, ptr0 *C.VkSparseImageMemoryRequirements2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirements2Value]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirements2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceFeatures2 transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceFeatures2(x []PhysicalDeviceFeatures2) (unpacked *C.VkPhysicalDeviceFeatures2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeatures2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures2)(h.Data)
	return
}

// packSPhysicalDeviceFeatures2 reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures2(v []PhysicalDeviceFeatures2, ptr0 *C.VkPhysicalDeviceFeatures2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeatures2Value]C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeatures2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceProperties2(x []PhysicalDeviceProperties2) (unpacked *C.VkPhysicalDeviceProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceProperties2)(h.Data)
	return
}

// packSPhysicalDeviceProperties2 reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceProperties2(v []PhysicalDeviceProperties2, ptr0 *C.VkPhysicalDeviceProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceProperties2Value]C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFormatProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSFormatProperties2(x []FormatProperties2) (unpacked *C.VkFormatProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkFormatProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFormatProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFormatProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFormatProperties2)(h.Data)
	return
}

// packSFormatProperties2 reads sliced Go data structure out from plain C format.
func packSFormatProperties2(v []FormatProperties2, ptr0 *C.VkFormatProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFormatProperties2Value]C.VkFormatProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFormatProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceImageFormatInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceImageFormatInfo2(x []PhysicalDeviceImageFormatInfo2) (unpacked *C.VkPhysicalDeviceImageFormatInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceImageFormatInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceImageFormatInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceImageFormatInfo2)(h.Data)
	return
}

// packSPhysicalDeviceImageFormatInfo2 reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceImageFormatInfo2(v []PhysicalDeviceImageFormatInfo2, ptr0 *C.VkPhysicalDeviceImageFormatInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceImageFormatInfo2Value]C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceImageFormatInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageFormatProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSImageFormatProperties2(x []ImageFormatProperties2) (unpacked *C.VkImageFormatProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageFormatProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageFormatProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageFormatProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageFormatProperties2)(h.Data)
	return
}

// packSImageFormatProperties2 reads sliced Go data structure out from plain C format.
func packSImageFormatProperties2(v []ImageFormatProperties2, ptr0 *C.VkImageFormatProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageFormatProperties2Value]C.VkImageFormatProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageFormatProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSQueueFamilyProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSQueueFamilyProperties2(x []QueueFamilyProperties2) (unpacked *C.VkQueueFamilyProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkQueueFamilyProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocQueueFamilyProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueueFamilyProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueueFamilyProperties2)(h.Data)
	return
}

// packSQueueFamilyProperties2 reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties2(v []QueueFamilyProperties2, ptr0 *C.VkQueueFamilyProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyProperties2Value]C.VkQueueFamilyProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceMemoryProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceMemoryProperties2(x []PhysicalDeviceMemoryProperties2) (unpacked *C.VkPhysicalDeviceMemoryProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceMemoryProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceMemoryProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceMemoryProperties2)(h.Data)
	return
}

// packSPhysicalDeviceMemoryProperties2 reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceMemoryProperties2(v []PhysicalDeviceMemoryProperties2, ptr0 *C.VkPhysicalDeviceMemoryProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceMemoryProperties2Value]C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceMemoryProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceSparseImageFormatInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceSparseImageFormatInfo2(x []PhysicalDeviceSparseImageFormatInfo2) (unpacked *C.VkPhysicalDeviceSparseImageFormatInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceSparseImageFormatInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceSparseImageFormatInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(h.Data)
	return
}

// packSPhysicalDeviceSparseImageFormatInfo2 reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceSparseImageFormatInfo2(v []PhysicalDeviceSparseImageFormatInfo2, ptr0 *C.VkPhysicalDeviceSparseImageFormatInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceSparseImageFormatInfo2Value]C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceSparseImageFormatInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageFormatProperties2 transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageFormatProperties2(x []SparseImageFormatProperties2) (unpacked *C.VkSparseImageFormatProperties2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageFormatProperties2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageFormatProperties2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageFormatProperties2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageFormatProperties2)(h.Data)
	return
}

// packSSparseImageFormatProperties2 reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties2(v []SparseImageFormatProperties2, ptr0 *C.VkSparseImageFormatProperties2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatProperties2Value]C.VkSparseImageFormatProperties2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatProperties2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDeviceQueueInfo2 transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceQueueInfo2(x []DeviceQueueInfo2) (unpacked *C.VkDeviceQueueInfo2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceQueueInfo2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueInfo2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueInfo2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueInfo2)(h.Data)
	return
}

// packSDeviceQueueInfo2 reads sliced Go data structure out from plain C format.
func packSDeviceQueueInfo2(v []DeviceQueueInfo2, ptr0 *C.VkDeviceQueueInfo2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueInfo2Value]C.VkDeviceQueueInfo2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueInfo2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSamplerYcbcrConversionCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSamplerYcbcrConversionCreateInfo(x []SamplerYcbcrConversionCreateInfo) (unpacked *C.VkSamplerYcbcrConversionCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSamplerYcbcrConversionCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSamplerYcbcrConversionCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSamplerYcbcrConversionCreateInfo)(h.Data)
	return
}

// packSSamplerYcbcrConversionCreateInfo reads sliced Go data structure out from plain C format.
func packSSamplerYcbcrConversionCreateInfo(v []SamplerYcbcrConversionCreateInfo, ptr0 *C.VkSamplerYcbcrConversionCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSamplerYcbcrConversionCreateInfoValue]C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSamplerYcbcrConversionCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDescriptorUpdateTemplateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorUpdateTemplateCreateInfo(x []DescriptorUpdateTemplateCreateInfo) (unpacked *C.VkDescriptorUpdateTemplateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorUpdateTemplateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorUpdateTemplateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorUpdateTemplateCreateInfo)(h.Data)
	return
}

// packSDescriptorUpdateTemplateCreateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorUpdateTemplateCreateInfo(v []DescriptorUpdateTemplateCreateInfo, ptr0 *C.VkDescriptorUpdateTemplateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorUpdateTemplateCreateInfoValue]C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorUpdateTemplateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceExternalBufferInfo transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceExternalBufferInfo(x []PhysicalDeviceExternalBufferInfo) (unpacked *C.VkPhysicalDeviceExternalBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceExternalBufferInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceExternalBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceExternalBufferInfo)(h.Data)
	return
}

// packSPhysicalDeviceExternalBufferInfo reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceExternalBufferInfo(v []PhysicalDeviceExternalBufferInfo, ptr0 *C.VkPhysicalDeviceExternalBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceExternalBufferInfoValue]C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceExternalBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExternalBufferProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExternalBufferProperties(x []ExternalBufferProperties) (unpacked *C.VkExternalBufferProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExternalBufferProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExternalBufferPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExternalBufferProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExternalBufferProperties)(h.Data)
	return
}

// packSExternalBufferProperties reads sliced Go data structure out from plain C format.
func packSExternalBufferProperties(v []ExternalBufferProperties, ptr0 *C.VkExternalBufferProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExternalBufferPropertiesValue]C.VkExternalBufferProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExternalBufferPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceExternalFenceInfo transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceExternalFenceInfo(x []PhysicalDeviceExternalFenceInfo) (unpacked *C.VkPhysicalDeviceExternalFenceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceExternalFenceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceExternalFenceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceExternalFenceInfo)(h.Data)
	return
}

// packSPhysicalDeviceExternalFenceInfo reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceExternalFenceInfo(v []PhysicalDeviceExternalFenceInfo, ptr0 *C.VkPhysicalDeviceExternalFenceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceExternalFenceInfoValue]C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceExternalFenceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExternalFenceProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExternalFenceProperties(x []ExternalFenceProperties) (unpacked *C.VkExternalFenceProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExternalFenceProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExternalFencePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExternalFenceProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExternalFenceProperties)(h.Data)
	return
}

// packSExternalFenceProperties reads sliced Go data structure out from plain C format.
func packSExternalFenceProperties(v []ExternalFenceProperties, ptr0 *C.VkExternalFenceProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExternalFencePropertiesValue]C.VkExternalFenceProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExternalFencePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceExternalSemaphoreInfo transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceExternalSemaphoreInfo(x []PhysicalDeviceExternalSemaphoreInfo) (unpacked *C.VkPhysicalDeviceExternalSemaphoreInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceExternalSemaphoreInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceExternalSemaphoreInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(h.Data)
	return
}

// packSPhysicalDeviceExternalSemaphoreInfo reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceExternalSemaphoreInfo(v []PhysicalDeviceExternalSemaphoreInfo, ptr0 *C.VkPhysicalDeviceExternalSemaphoreInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceExternalSemaphoreInfoValue]C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceExternalSemaphoreInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExternalSemaphoreProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExternalSemaphoreProperties(x []ExternalSemaphoreProperties) (unpacked *C.VkExternalSemaphoreProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExternalSemaphoreProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExternalSemaphorePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExternalSemaphoreProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExternalSemaphoreProperties)(h.Data)
	return
}

// packSExternalSemaphoreProperties reads sliced Go data structure out from plain C format.
func packSExternalSemaphoreProperties(v []ExternalSemaphoreProperties, ptr0 *C.VkExternalSemaphoreProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExternalSemaphorePropertiesValue]C.VkExternalSemaphoreProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExternalSemaphorePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDescriptorSetLayoutSupport transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorSetLayoutSupport(x []DescriptorSetLayoutSupport) (unpacked *C.VkDescriptorSetLayoutSupport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutSupport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutSupportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutSupport)(h.Data)
	return
}

// packSDescriptorSetLayoutSupport reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutSupport(v []DescriptorSetLayoutSupport, ptr0 *C.VkDescriptorSetLayoutSupport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutSupportValue]C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutSupportRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceCapabilitiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceCapabilitiesKHR(x []SurfaceCapabilitiesKHR) (unpacked *C.VkSurfaceCapabilitiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceCapabilitiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceCapabilitiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceCapabilitiesKHR)(h.Data)
	return
}

// packSSurfaceCapabilitiesKHR reads sliced Go data structure out from plain C format.
func packSSurfaceCapabilitiesKHR(v []SurfaceCapabilitiesKHR, ptr0 *C.VkSurfaceCapabilitiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceCapabilitiesKHRValue]C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceCapabilitiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceFormatKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceFormatKHR(x []SurfaceFormatKHR) (unpacked *C.VkSurfaceFormatKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceFormatKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceFormatKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceFormatKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceFormatKHR)(h.Data)
	return
}

// packSSurfaceFormatKHR reads sliced Go data structure out from plain C format.
func packSSurfaceFormatKHR(v []SurfaceFormatKHR, ptr0 *C.VkSurfaceFormatKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormatKHRValue]C.VkSurfaceFormatKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormatKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSwapchainCreateInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSwapchainCreateInfoKHR(x []SwapchainCreateInfoKHR) (unpacked *C.VkSwapchainCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSwapchainCreateInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSwapchainCreateInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSwapchainCreateInfoKHR)(h.Data)
	return
}

// packSSwapchainCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSSwapchainCreateInfoKHR(v []SwapchainCreateInfoKHR, ptr0 *C.VkSwapchainCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSwapchainCreateInfoKHRValue]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSwapchainCreateInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPresentInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSPresentInfoKHR(x []PresentInfoKHR) (unpacked *C.VkPresentInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPresentInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPresentInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentInfoKHR)(h.Data)
	return
}

// packSPresentInfoKHR reads sliced Go data structure out from plain C format.
func packSPresentInfoKHR(v []PresentInfoKHR, ptr0 *C.VkPresentInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentInfoKHRValue]C.VkPresentInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDeviceGroupPresentCapabilitiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceGroupPresentCapabilitiesKHR(x []DeviceGroupPresentCapabilitiesKHR) (unpacked *C.VkDeviceGroupPresentCapabilitiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceGroupPresentCapabilitiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceGroupPresentCapabilitiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceGroupPresentCapabilitiesKHR)(h.Data)
	return
}

// packSDeviceGroupPresentCapabilitiesKHR reads sliced Go data structure out from plain C format.
func packSDeviceGroupPresentCapabilitiesKHR(v []DeviceGroupPresentCapabilitiesKHR, ptr0 *C.VkDeviceGroupPresentCapabilitiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceGroupPresentCapabilitiesKHRValue]C.VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceGroupPresentCapabilitiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSAcquireNextImageInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSAcquireNextImageInfoKHR(x []AcquireNextImageInfoKHR) (unpacked *C.VkAcquireNextImageInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAcquireNextImageInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAcquireNextImageInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAcquireNextImageInfoKHR)(h.Data)
	return
}

// packSAcquireNextImageInfoKHR reads sliced Go data structure out from plain C format.
func packSAcquireNextImageInfoKHR(v []AcquireNextImageInfoKHR, ptr0 *C.VkAcquireNextImageInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAcquireNextImageInfoKHRValue]C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAcquireNextImageInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPropertiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPropertiesKHR(x []DisplayPropertiesKHR) (unpacked *C.VkDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPropertiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPropertiesKHR)(h.Data)
	return
}

// packSDisplayPropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPropertiesKHR(v []DisplayPropertiesKHR, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesKHRValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlanePropertiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlanePropertiesKHR(x []DisplayPlanePropertiesKHR) (unpacked *C.VkDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlanePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlanePropertiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlanePropertiesKHR)(h.Data)
	return
}

// packSDisplayPlanePropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPlanePropertiesKHR(v []DisplayPlanePropertiesKHR, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesKHRValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayModePropertiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModePropertiesKHR(x []DisplayModePropertiesKHR) (unpacked *C.VkDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayModePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModePropertiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModePropertiesKHR)(h.Data)
	return
}

// packSDisplayModePropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayModePropertiesKHR(v []DisplayModePropertiesKHR, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesKHRValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayModeCreateInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeCreateInfoKHR(x []DisplayModeCreateInfoKHR) (unpacked *C.VkDisplayModeCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayModeCreateInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModeCreateInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModeCreateInfoKHR)(h.Data)
	return
}

// packSDisplayModeCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSDisplayModeCreateInfoKHR(v []DisplayModeCreateInfoKHR, ptr0 *C.VkDisplayModeCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModeCreateInfoKHRValue]C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModeCreateInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneCapabilitiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneCapabilitiesKHR(x []DisplayPlaneCapabilitiesKHR) (unpacked *C.VkDisplayPlaneCapabilitiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlaneCapabilitiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlaneCapabilitiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlaneCapabilitiesKHR)(h.Data)
	return
}

// packSDisplayPlaneCapabilitiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPlaneCapabilitiesKHR(v []DisplayPlaneCapabilitiesKHR, ptr0 *C.VkDisplayPlaneCapabilitiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlaneCapabilitiesKHRValue]C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlaneCapabilitiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplaySurfaceCreateInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplaySurfaceCreateInfoKHR(x []DisplaySurfaceCreateInfoKHR) (unpacked *C.VkDisplaySurfaceCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplaySurfaceCreateInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplaySurfaceCreateInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplaySurfaceCreateInfoKHR)(h.Data)
	return
}

// packSDisplaySurfaceCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSDisplaySurfaceCreateInfoKHR(v []DisplaySurfaceCreateInfoKHR, ptr0 *C.VkDisplaySurfaceCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplaySurfaceCreateInfoKHRValue]C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplaySurfaceCreateInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryGetFdInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryGetFdInfoKHR(x []MemoryGetFdInfoKHR) (unpacked *C.VkMemoryGetFdInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryGetFdInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryGetFdInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryGetFdInfoKHR)(h.Data)
	return
}

// packSMemoryGetFdInfoKHR reads sliced Go data structure out from plain C format.
func packSMemoryGetFdInfoKHR(v []MemoryGetFdInfoKHR, ptr0 *C.VkMemoryGetFdInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryGetFdInfoKHRValue]C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryGetFdInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryFdPropertiesKHR transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryFdPropertiesKHR(x []MemoryFdPropertiesKHR) (unpacked *C.VkMemoryFdPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryFdPropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryFdPropertiesKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryFdPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryFdPropertiesKHR)(h.Data)
	return
}

// packSMemoryFdPropertiesKHR reads sliced Go data structure out from plain C format.
func packSMemoryFdPropertiesKHR(v []MemoryFdPropertiesKHR, ptr0 *C.VkMemoryFdPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryFdPropertiesKHRValue]C.VkMemoryFdPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryFdPropertiesKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImportSemaphoreFdInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSImportSemaphoreFdInfoKHR(x []ImportSemaphoreFdInfoKHR) (unpacked *C.VkImportSemaphoreFdInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImportSemaphoreFdInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImportSemaphoreFdInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImportSemaphoreFdInfoKHR)(h.Data)
	return
}

// packSImportSemaphoreFdInfoKHR reads sliced Go data structure out from plain C format.
func packSImportSemaphoreFdInfoKHR(v []ImportSemaphoreFdInfoKHR, ptr0 *C.VkImportSemaphoreFdInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImportSemaphoreFdInfoKHRValue]C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImportSemaphoreFdInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSemaphoreGetFdInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSemaphoreGetFdInfoKHR(x []SemaphoreGetFdInfoKHR) (unpacked *C.VkSemaphoreGetFdInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSemaphoreGetFdInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSemaphoreGetFdInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSemaphoreGetFdInfoKHR)(h.Data)
	return
}

// packSSemaphoreGetFdInfoKHR reads sliced Go data structure out from plain C format.
func packSSemaphoreGetFdInfoKHR(v []SemaphoreGetFdInfoKHR, ptr0 *C.VkSemaphoreGetFdInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSemaphoreGetFdInfoKHRValue]C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSemaphoreGetFdInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRenderPassCreateInfo2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSRenderPassCreateInfo2KHR(x []RenderPassCreateInfo2KHR) (unpacked *C.VkRenderPassCreateInfo2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRenderPassCreateInfo2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRenderPassCreateInfo2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRenderPassCreateInfo2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRenderPassCreateInfo2KHR)(h.Data)
	return
}

// packSRenderPassCreateInfo2KHR reads sliced Go data structure out from plain C format.
func packSRenderPassCreateInfo2KHR(v []RenderPassCreateInfo2KHR, ptr0 *C.VkRenderPassCreateInfo2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderPassCreateInfo2KHRValue]C.VkRenderPassCreateInfo2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderPassCreateInfo2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubpassBeginInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSubpassBeginInfoKHR(x []SubpassBeginInfoKHR) (unpacked *C.VkSubpassBeginInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassBeginInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassBeginInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassBeginInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassBeginInfoKHR)(h.Data)
	return
}

// packSSubpassBeginInfoKHR reads sliced Go data structure out from plain C format.
func packSSubpassBeginInfoKHR(v []SubpassBeginInfoKHR, ptr0 *C.VkSubpassBeginInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassBeginInfoKHRValue]C.VkSubpassBeginInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassBeginInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubpassEndInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSSubpassEndInfoKHR(x []SubpassEndInfoKHR) (unpacked *C.VkSubpassEndInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassEndInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassEndInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassEndInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassEndInfoKHR)(h.Data)
	return
}

// packSSubpassEndInfoKHR reads sliced Go data structure out from plain C format.
func packSSubpassEndInfoKHR(v []SubpassEndInfoKHR, ptr0 *C.VkSubpassEndInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassEndInfoKHRValue]C.VkSubpassEndInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassEndInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImportFenceFdInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSImportFenceFdInfoKHR(x []ImportFenceFdInfoKHR) (unpacked *C.VkImportFenceFdInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImportFenceFdInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImportFenceFdInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImportFenceFdInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImportFenceFdInfoKHR)(h.Data)
	return
}

// packSImportFenceFdInfoKHR reads sliced Go data structure out from plain C format.
func packSImportFenceFdInfoKHR(v []ImportFenceFdInfoKHR, ptr0 *C.VkImportFenceFdInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImportFenceFdInfoKHRValue]C.VkImportFenceFdInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImportFenceFdInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFenceGetFdInfoKHR transforms a sliced Go data structure into plain C format.
func unpackArgSFenceGetFdInfoKHR(x []FenceGetFdInfoKHR) (unpacked *C.VkFenceGetFdInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkFenceGetFdInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFenceGetFdInfoKHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFenceGetFdInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFenceGetFdInfoKHR)(h.Data)
	return
}

// packSFenceGetFdInfoKHR reads sliced Go data structure out from plain C format.
func packSFenceGetFdInfoKHR(v []FenceGetFdInfoKHR, ptr0 *C.VkFenceGetFdInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFenceGetFdInfoKHRValue]C.VkFenceGetFdInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFenceGetFdInfoKHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPhysicalDeviceSurfaceInfo2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSPhysicalDeviceSurfaceInfo2KHR(x []PhysicalDeviceSurfaceInfo2KHR) (unpacked *C.VkPhysicalDeviceSurfaceInfo2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceSurfaceInfo2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceSurfaceInfo2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(h.Data)
	return
}

// packSPhysicalDeviceSurfaceInfo2KHR reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceSurfaceInfo2KHR(v []PhysicalDeviceSurfaceInfo2KHR, ptr0 *C.VkPhysicalDeviceSurfaceInfo2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceSurfaceInfo2KHRValue]C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceSurfaceInfo2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceCapabilities2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceCapabilities2KHR(x []SurfaceCapabilities2KHR) (unpacked *C.VkSurfaceCapabilities2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceCapabilities2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceCapabilities2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceCapabilities2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceCapabilities2KHR)(h.Data)
	return
}

// packSSurfaceCapabilities2KHR reads sliced Go data structure out from plain C format.
func packSSurfaceCapabilities2KHR(v []SurfaceCapabilities2KHR, ptr0 *C.VkSurfaceCapabilities2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceCapabilities2KHRValue]C.VkSurfaceCapabilities2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceCapabilities2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceFormat2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceFormat2KHR(x []SurfaceFormat2KHR) (unpacked *C.VkSurfaceFormat2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceFormat2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceFormat2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceFormat2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceFormat2KHR)(h.Data)
	return
}

// packSSurfaceFormat2KHR reads sliced Go data structure out from plain C format.
func packSSurfaceFormat2KHR(v []SurfaceFormat2KHR, ptr0 *C.VkSurfaceFormat2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormat2KHRValue]C.VkSurfaceFormat2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormat2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayProperties2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayProperties2KHR(x []DisplayProperties2KHR) (unpacked *C.VkDisplayProperties2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayProperties2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayProperties2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayProperties2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayProperties2KHR)(h.Data)
	return
}

// packSDisplayProperties2KHR reads sliced Go data structure out from plain C format.
func packSDisplayProperties2KHR(v []DisplayProperties2KHR, ptr0 *C.VkDisplayProperties2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayProperties2KHRValue]C.VkDisplayProperties2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayProperties2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneProperties2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneProperties2KHR(x []DisplayPlaneProperties2KHR) (unpacked *C.VkDisplayPlaneProperties2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlaneProperties2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlaneProperties2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlaneProperties2KHR)(h.Data)
	return
}

// packSDisplayPlaneProperties2KHR reads sliced Go data structure out from plain C format.
func packSDisplayPlaneProperties2KHR(v []DisplayPlaneProperties2KHR, ptr0 *C.VkDisplayPlaneProperties2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlaneProperties2KHRValue]C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlaneProperties2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayModeProperties2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeProperties2KHR(x []DisplayModeProperties2KHR) (unpacked *C.VkDisplayModeProperties2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayModeProperties2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModeProperties2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModeProperties2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModeProperties2KHR)(h.Data)
	return
}

// packSDisplayModeProperties2KHR reads sliced Go data structure out from plain C format.
func packSDisplayModeProperties2KHR(v []DisplayModeProperties2KHR, ptr0 *C.VkDisplayModeProperties2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModeProperties2KHRValue]C.VkDisplayModeProperties2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModeProperties2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneInfo2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneInfo2KHR(x []DisplayPlaneInfo2KHR) (unpacked *C.VkDisplayPlaneInfo2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlaneInfo2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlaneInfo2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlaneInfo2KHR)(h.Data)
	return
}

// packSDisplayPlaneInfo2KHR reads sliced Go data structure out from plain C format.
func packSDisplayPlaneInfo2KHR(v []DisplayPlaneInfo2KHR, ptr0 *C.VkDisplayPlaneInfo2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlaneInfo2KHRValue]C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlaneInfo2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneCapabilities2KHR transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneCapabilities2KHR(x []DisplayPlaneCapabilities2KHR) (unpacked *C.VkDisplayPlaneCapabilities2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlaneCapabilities2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlaneCapabilities2KHRMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlaneCapabilities2KHR)(h.Data)
	return
}

// packSDisplayPlaneCapabilities2KHR reads sliced Go data structure out from plain C format.
func packSDisplayPlaneCapabilities2KHR(v []DisplayPlaneCapabilities2KHR, ptr0 *C.VkDisplayPlaneCapabilities2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlaneCapabilities2KHRValue]C.VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlaneCapabilities2KHRRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugReportCallbackCreateInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugReportCallbackCreateInfoEXT(x []DebugReportCallbackCreateInfoEXT) (unpacked *C.VkDebugReportCallbackCreateInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugReportCallbackCreateInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugReportCallbackCreateInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugReportCallbackCreateInfoEXT)(h.Data)
	return
}

// packSDebugReportCallbackCreateInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugReportCallbackCreateInfoEXT(v []DebugReportCallbackCreateInfoEXT, ptr0 *C.VkDebugReportCallbackCreateInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugReportCallbackCreateInfoEXTValue]C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugReportCallbackCreateInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugMarkerObjectTagInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugMarkerObjectTagInfoEXT(x []DebugMarkerObjectTagInfoEXT) (unpacked *C.VkDebugMarkerObjectTagInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugMarkerObjectTagInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugMarkerObjectTagInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugMarkerObjectTagInfoEXT)(h.Data)
	return
}

// packSDebugMarkerObjectTagInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerObjectTagInfoEXT(v []DebugMarkerObjectTagInfoEXT, ptr0 *C.VkDebugMarkerObjectTagInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerObjectTagInfoEXTValue]C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerObjectTagInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugMarkerObjectNameInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugMarkerObjectNameInfoEXT(x []DebugMarkerObjectNameInfoEXT) (unpacked *C.VkDebugMarkerObjectNameInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugMarkerObjectNameInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugMarkerObjectNameInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugMarkerObjectNameInfoEXT)(h.Data)
	return
}

// packSDebugMarkerObjectNameInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerObjectNameInfoEXT(v []DebugMarkerObjectNameInfoEXT, ptr0 *C.VkDebugMarkerObjectNameInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerObjectNameInfoEXTValue]C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerObjectNameInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugMarkerMarkerInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugMarkerMarkerInfoEXT(x []DebugMarkerMarkerInfoEXT) (unpacked *C.VkDebugMarkerMarkerInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugMarkerMarkerInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugMarkerMarkerInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugMarkerMarkerInfoEXT)(h.Data)
	return
}

// packSDebugMarkerMarkerInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerMarkerInfoEXT(v []DebugMarkerMarkerInfoEXT, ptr0 *C.VkDebugMarkerMarkerInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerMarkerInfoEXTValue]C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerMarkerInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExternalImageFormatPropertiesNV transforms a sliced Go data structure into plain C format.
func unpackArgSExternalImageFormatPropertiesNV(x []ExternalImageFormatPropertiesNV) (unpacked *C.VkExternalImageFormatPropertiesNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExternalImageFormatPropertiesNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExternalImageFormatPropertiesNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExternalImageFormatPropertiesNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExternalImageFormatPropertiesNV)(h.Data)
	return
}

// packSExternalImageFormatPropertiesNV reads sliced Go data structure out from plain C format.
func packSExternalImageFormatPropertiesNV(v []ExternalImageFormatPropertiesNV, ptr0 *C.VkExternalImageFormatPropertiesNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExternalImageFormatPropertiesNVValue]C.VkExternalImageFormatPropertiesNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExternalImageFormatPropertiesNVRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSConditionalRenderingBeginInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSConditionalRenderingBeginInfoEXT(x []ConditionalRenderingBeginInfoEXT) (unpacked *C.VkConditionalRenderingBeginInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkConditionalRenderingBeginInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocConditionalRenderingBeginInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkConditionalRenderingBeginInfoEXT)(h.Data)
	return
}

// packSConditionalRenderingBeginInfoEXT reads sliced Go data structure out from plain C format.
func packSConditionalRenderingBeginInfoEXT(v []ConditionalRenderingBeginInfoEXT, ptr0 *C.VkConditionalRenderingBeginInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfConditionalRenderingBeginInfoEXTValue]C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewConditionalRenderingBeginInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCmdProcessCommandsInfoNVX transforms a sliced Go data structure into plain C format.
func unpackArgSCmdProcessCommandsInfoNVX(x []CmdProcessCommandsInfoNVX) (unpacked *C.VkCmdProcessCommandsInfoNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCmdProcessCommandsInfoNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCmdProcessCommandsInfoNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCmdProcessCommandsInfoNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCmdProcessCommandsInfoNVX)(h.Data)
	return
}

// packSCmdProcessCommandsInfoNVX reads sliced Go data structure out from plain C format.
func packSCmdProcessCommandsInfoNVX(v []CmdProcessCommandsInfoNVX, ptr0 *C.VkCmdProcessCommandsInfoNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCmdProcessCommandsInfoNVXValue]C.VkCmdProcessCommandsInfoNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCmdProcessCommandsInfoNVXRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCmdReserveSpaceForCommandsInfoNVX transforms a sliced Go data structure into plain C format.
func unpackArgSCmdReserveSpaceForCommandsInfoNVX(x []CmdReserveSpaceForCommandsInfoNVX) (unpacked *C.VkCmdReserveSpaceForCommandsInfoNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCmdReserveSpaceForCommandsInfoNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCmdReserveSpaceForCommandsInfoNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCmdReserveSpaceForCommandsInfoNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCmdReserveSpaceForCommandsInfoNVX)(h.Data)
	return
}

// packSCmdReserveSpaceForCommandsInfoNVX reads sliced Go data structure out from plain C format.
func packSCmdReserveSpaceForCommandsInfoNVX(v []CmdReserveSpaceForCommandsInfoNVX, ptr0 *C.VkCmdReserveSpaceForCommandsInfoNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCmdReserveSpaceForCommandsInfoNVXValue]C.VkCmdReserveSpaceForCommandsInfoNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCmdReserveSpaceForCommandsInfoNVXRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSIndirectCommandsLayoutCreateInfoNVX transforms a sliced Go data structure into plain C format.
func unpackArgSIndirectCommandsLayoutCreateInfoNVX(x []IndirectCommandsLayoutCreateInfoNVX) (unpacked *C.VkIndirectCommandsLayoutCreateInfoNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkIndirectCommandsLayoutCreateInfoNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsLayoutCreateInfoNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsLayoutCreateInfoNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsLayoutCreateInfoNVX)(h.Data)
	return
}

// packSIndirectCommandsLayoutCreateInfoNVX reads sliced Go data structure out from plain C format.
func packSIndirectCommandsLayoutCreateInfoNVX(v []IndirectCommandsLayoutCreateInfoNVX, ptr0 *C.VkIndirectCommandsLayoutCreateInfoNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsLayoutCreateInfoNVXValue]C.VkIndirectCommandsLayoutCreateInfoNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsLayoutCreateInfoNVXRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSObjectTableCreateInfoNVX transforms a sliced Go data structure into plain C format.
func unpackArgSObjectTableCreateInfoNVX(x []ObjectTableCreateInfoNVX) (unpacked *C.VkObjectTableCreateInfoNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkObjectTableCreateInfoNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocObjectTableCreateInfoNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkObjectTableCreateInfoNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkObjectTableCreateInfoNVX)(h.Data)
	return
}

// packSObjectTableCreateInfoNVX reads sliced Go data structure out from plain C format.
func packSObjectTableCreateInfoNVX(v []ObjectTableCreateInfoNVX, ptr0 *C.VkObjectTableCreateInfoNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfObjectTableCreateInfoNVXValue]C.VkObjectTableCreateInfoNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewObjectTableCreateInfoNVXRef(unsafe.Pointer(&ptr1))
	}
}

// allocPObjectTableEntryNVXMemory allocates memory for type *C.VkObjectTableEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPObjectTableEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPObjectTableEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPObjectTableEntryNVXValue = unsafe.Sizeof([1]*C.VkObjectTableEntryNVX{})

// unpackArgSSObjectTableEntryNVX transforms a sliced Go data structure into plain C format.
func unpackArgSSObjectTableEntryNVX(x [][]ObjectTableEntryNVX) (unpacked **C.VkObjectTableEntryNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.VkObjectTableEntryNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPObjectTableEntryNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.VkObjectTableEntryNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocObjectTableEntryNVXMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.VkObjectTableEntryNVX)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.VkObjectTableEntryNVX)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.VkObjectTableEntryNVX)(h.Data)
	return
}

// packSSObjectTableEntryNVX reads sliced Go data structure out from plain C format.
func packSSObjectTableEntryNVX(v [][]ObjectTableEntryNVX, ptr0 **C.VkObjectTableEntryNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.VkObjectTableEntryNVX)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfObjectTableEntryNVXValue]C.VkObjectTableEntryNVX)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewObjectTableEntryNVXRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSDeviceGeneratedCommandsFeaturesNVX transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceGeneratedCommandsFeaturesNVX(x []DeviceGeneratedCommandsFeaturesNVX) (unpacked *C.VkDeviceGeneratedCommandsFeaturesNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceGeneratedCommandsFeaturesNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceGeneratedCommandsFeaturesNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceGeneratedCommandsFeaturesNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceGeneratedCommandsFeaturesNVX)(h.Data)
	return
}

// packSDeviceGeneratedCommandsFeaturesNVX reads sliced Go data structure out from plain C format.
func packSDeviceGeneratedCommandsFeaturesNVX(v []DeviceGeneratedCommandsFeaturesNVX, ptr0 *C.VkDeviceGeneratedCommandsFeaturesNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceGeneratedCommandsFeaturesNVXValue]C.VkDeviceGeneratedCommandsFeaturesNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceGeneratedCommandsFeaturesNVXRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDeviceGeneratedCommandsLimitsNVX transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceGeneratedCommandsLimitsNVX(x []DeviceGeneratedCommandsLimitsNVX) (unpacked *C.VkDeviceGeneratedCommandsLimitsNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceGeneratedCommandsLimitsNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceGeneratedCommandsLimitsNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceGeneratedCommandsLimitsNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceGeneratedCommandsLimitsNVX)(h.Data)
	return
}

// packSDeviceGeneratedCommandsLimitsNVX reads sliced Go data structure out from plain C format.
func packSDeviceGeneratedCommandsLimitsNVX(v []DeviceGeneratedCommandsLimitsNVX, ptr0 *C.VkDeviceGeneratedCommandsLimitsNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceGeneratedCommandsLimitsNVXValue]C.VkDeviceGeneratedCommandsLimitsNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceGeneratedCommandsLimitsNVXRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSViewportWScalingNV transforms a sliced Go data structure into plain C format.
func unpackArgSViewportWScalingNV(x []ViewportWScalingNV) (unpacked *C.VkViewportWScalingNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewportWScalingNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportWScalingNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportWScalingNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportWScalingNV)(h.Data)
	return
}

// unpackArgSSurfaceCapabilities2EXT transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceCapabilities2EXT(x []SurfaceCapabilities2EXT) (unpacked *C.VkSurfaceCapabilities2EXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceCapabilities2EXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceCapabilities2EXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceCapabilities2EXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceCapabilities2EXT)(h.Data)
	return
}

// packSSurfaceCapabilities2EXT reads sliced Go data structure out from plain C format.
func packSSurfaceCapabilities2EXT(v []SurfaceCapabilities2EXT, ptr0 *C.VkSurfaceCapabilities2EXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceCapabilities2EXTValue]C.VkSurfaceCapabilities2EXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceCapabilities2EXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPowerInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPowerInfoEXT(x []DisplayPowerInfoEXT) (unpacked *C.VkDisplayPowerInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPowerInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPowerInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPowerInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPowerInfoEXT)(h.Data)
	return
}

// packSDisplayPowerInfoEXT reads sliced Go data structure out from plain C format.
func packSDisplayPowerInfoEXT(v []DisplayPowerInfoEXT, ptr0 *C.VkDisplayPowerInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPowerInfoEXTValue]C.VkDisplayPowerInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPowerInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDeviceEventInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceEventInfoEXT(x []DeviceEventInfoEXT) (unpacked *C.VkDeviceEventInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceEventInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceEventInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceEventInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceEventInfoEXT)(h.Data)
	return
}

// packSDeviceEventInfoEXT reads sliced Go data structure out from plain C format.
func packSDeviceEventInfoEXT(v []DeviceEventInfoEXT, ptr0 *C.VkDeviceEventInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceEventInfoEXTValue]C.VkDeviceEventInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceEventInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayEventInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayEventInfoEXT(x []DisplayEventInfoEXT) (unpacked *C.VkDisplayEventInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayEventInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayEventInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayEventInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayEventInfoEXT)(h.Data)
	return
}

// packSDisplayEventInfoEXT reads sliced Go data structure out from plain C format.
func packSDisplayEventInfoEXT(v []DisplayEventInfoEXT, ptr0 *C.VkDisplayEventInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayEventInfoEXTValue]C.VkDisplayEventInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayEventInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRefreshCycleDurationGOOGLE transforms a sliced Go data structure into plain C format.
func unpackArgSRefreshCycleDurationGOOGLE(x []RefreshCycleDurationGOOGLE) (unpacked *C.VkRefreshCycleDurationGOOGLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRefreshCycleDurationGOOGLE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRefreshCycleDurationGOOGLEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRefreshCycleDurationGOOGLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRefreshCycleDurationGOOGLE)(h.Data)
	return
}

// packSRefreshCycleDurationGOOGLE reads sliced Go data structure out from plain C format.
func packSRefreshCycleDurationGOOGLE(v []RefreshCycleDurationGOOGLE, ptr0 *C.VkRefreshCycleDurationGOOGLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRefreshCycleDurationGOOGLEValue]C.VkRefreshCycleDurationGOOGLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRefreshCycleDurationGOOGLERef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPastPresentationTimingGOOGLE transforms a sliced Go data structure into plain C format.
func unpackArgSPastPresentationTimingGOOGLE(x []PastPresentationTimingGOOGLE) (unpacked *C.VkPastPresentationTimingGOOGLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPastPresentationTimingGOOGLE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPastPresentationTimingGOOGLEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPastPresentationTimingGOOGLE)(h.Data)
	return
}

// packSPastPresentationTimingGOOGLE reads sliced Go data structure out from plain C format.
func packSPastPresentationTimingGOOGLE(v []PastPresentationTimingGOOGLE, ptr0 *C.VkPastPresentationTimingGOOGLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPastPresentationTimingGOOGLEValue]C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPastPresentationTimingGOOGLERef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSHdrMetadataEXT transforms a sliced Go data structure into plain C format.
func unpackArgSHdrMetadataEXT(x []HdrMetadataEXT) (unpacked *C.VkHdrMetadataEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkHdrMetadataEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocHdrMetadataEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkHdrMetadataEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkHdrMetadataEXT)(h.Data)
	return
}

// packSHdrMetadataEXT reads sliced Go data structure out from plain C format.
func packSHdrMetadataEXT(v []HdrMetadataEXT, ptr0 *C.VkHdrMetadataEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfHdrMetadataEXTValue]C.VkHdrMetadataEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewHdrMetadataEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugUtilsObjectNameInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugUtilsObjectNameInfoEXT(x []DebugUtilsObjectNameInfoEXT) (unpacked *C.VkDebugUtilsObjectNameInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsObjectNameInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsObjectNameInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsObjectNameInfoEXT)(h.Data)
	return
}

// unpackArgSDebugUtilsObjectTagInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugUtilsObjectTagInfoEXT(x []DebugUtilsObjectTagInfoEXT) (unpacked *C.VkDebugUtilsObjectTagInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsObjectTagInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsObjectTagInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsObjectTagInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsObjectTagInfoEXT)(h.Data)
	return
}

// packSDebugUtilsObjectTagInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugUtilsObjectTagInfoEXT(v []DebugUtilsObjectTagInfoEXT, ptr0 *C.VkDebugUtilsObjectTagInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugUtilsObjectTagInfoEXTValue]C.VkDebugUtilsObjectTagInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugUtilsObjectTagInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugUtilsLabelEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugUtilsLabelEXT(x []DebugUtilsLabelEXT) (unpacked *C.VkDebugUtilsLabelEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsLabelEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsLabelEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsLabelEXT)(h.Data)
	return
}

// unpackArgSDebugUtilsMessengerCreateInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugUtilsMessengerCreateInfoEXT(x []DebugUtilsMessengerCreateInfoEXT) (unpacked *C.VkDebugUtilsMessengerCreateInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsMessengerCreateInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsMessengerCreateInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsMessengerCreateInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsMessengerCreateInfoEXT)(h.Data)
	return
}

// packSDebugUtilsMessengerCreateInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugUtilsMessengerCreateInfoEXT(v []DebugUtilsMessengerCreateInfoEXT, ptr0 *C.VkDebugUtilsMessengerCreateInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugUtilsMessengerCreateInfoEXTValue]C.VkDebugUtilsMessengerCreateInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugUtilsMessengerCreateInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDebugUtilsMessengerCallbackDataEXT transforms a sliced Go data structure into plain C format.
func unpackArgSDebugUtilsMessengerCallbackDataEXT(x []DebugUtilsMessengerCallbackDataEXT) (unpacked *C.VkDebugUtilsMessengerCallbackDataEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDebugUtilsMessengerCallbackDataEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDebugUtilsMessengerCallbackDataEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDebugUtilsMessengerCallbackDataEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDebugUtilsMessengerCallbackDataEXT)(h.Data)
	return
}

// packSDebugUtilsMessengerCallbackDataEXT reads sliced Go data structure out from plain C format.
func packSDebugUtilsMessengerCallbackDataEXT(v []DebugUtilsMessengerCallbackDataEXT, ptr0 *C.VkDebugUtilsMessengerCallbackDataEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugUtilsMessengerCallbackDataEXTValue]C.VkDebugUtilsMessengerCallbackDataEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugUtilsMessengerCallbackDataEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSampleLocationsInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSSampleLocationsInfoEXT(x []SampleLocationsInfoEXT) (unpacked *C.VkSampleLocationsInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSampleLocationsInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSampleLocationsInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSampleLocationsInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSampleLocationsInfoEXT)(h.Data)
	return
}

// packSSampleLocationsInfoEXT reads sliced Go data structure out from plain C format.
func packSSampleLocationsInfoEXT(v []SampleLocationsInfoEXT, ptr0 *C.VkSampleLocationsInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSampleLocationsInfoEXTValue]C.VkSampleLocationsInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSampleLocationsInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMultisamplePropertiesEXT transforms a sliced Go data structure into plain C format.
func unpackArgSMultisamplePropertiesEXT(x []MultisamplePropertiesEXT) (unpacked *C.VkMultisamplePropertiesEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMultisamplePropertiesEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMultisamplePropertiesEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMultisamplePropertiesEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMultisamplePropertiesEXT)(h.Data)
	return
}

// packSMultisamplePropertiesEXT reads sliced Go data structure out from plain C format.
func packSMultisamplePropertiesEXT(v []MultisamplePropertiesEXT, ptr0 *C.VkMultisamplePropertiesEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMultisamplePropertiesEXTValue]C.VkMultisamplePropertiesEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMultisamplePropertiesEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSValidationCacheCreateInfoEXT transforms a sliced Go data structure into plain C format.
func unpackArgSValidationCacheCreateInfoEXT(x []ValidationCacheCreateInfoEXT) (unpacked *C.VkValidationCacheCreateInfoEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkValidationCacheCreateInfoEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocValidationCacheCreateInfoEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkValidationCacheCreateInfoEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkValidationCacheCreateInfoEXT)(h.Data)
	return
}

// packSValidationCacheCreateInfoEXT reads sliced Go data structure out from plain C format.
func packSValidationCacheCreateInfoEXT(v []ValidationCacheCreateInfoEXT, ptr0 *C.VkValidationCacheCreateInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfValidationCacheCreateInfoEXTValue]C.VkValidationCacheCreateInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewValidationCacheCreateInfoEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryHostPointerPropertiesEXT transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryHostPointerPropertiesEXT(x []MemoryHostPointerPropertiesEXT) (unpacked *C.VkMemoryHostPointerPropertiesEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryHostPointerPropertiesEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryHostPointerPropertiesEXTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryHostPointerPropertiesEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryHostPointerPropertiesEXT)(h.Data)
	return
}

// packSMemoryHostPointerPropertiesEXT reads sliced Go data structure out from plain C format.
func packSMemoryHostPointerPropertiesEXT(v []MemoryHostPointerPropertiesEXT, ptr0 *C.VkMemoryHostPointerPropertiesEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryHostPointerPropertiesEXTValue]C.VkMemoryHostPointerPropertiesEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryHostPointerPropertiesEXTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCheckpointDataNV transforms a sliced Go data structure into plain C format.
func unpackArgSCheckpointDataNV(x []CheckpointDataNV) (unpacked *C.VkCheckpointDataNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCheckpointDataNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCheckpointDataNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCheckpointDataNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCheckpointDataNV)(h.Data)
	return
}

// packSCheckpointDataNV reads sliced Go data structure out from plain C format.
func packSCheckpointDataNV(v []CheckpointDataNV, ptr0 *C.VkCheckpointDataNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCheckpointDataNVValue]C.VkCheckpointDataNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCheckpointDataNVRef(unsafe.Pointer(&ptr1))
	}
}
