package vk
//#include "vulkan/vulkan.h"
//#include "bridges.auto.h"
//typedef void * void_pointer;
import "C"
import "unsafe"

type PipelineCacheHeaderVersion int

const (
	PIPELINE_CACHE_HEADER_VERSION_ONE         PipelineCacheHeaderVersion = 1
	PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE PipelineCacheHeaderVersion = PIPELINE_CACHE_HEADER_VERSION_ONE
	PIPELINE_CACHE_HEADER_VERSION_END_RANGE   PipelineCacheHeaderVersion = PIPELINE_CACHE_HEADER_VERSION_ONE
	PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE  PipelineCacheHeaderVersion = (PIPELINE_CACHE_HEADER_VERSION_ONE - PIPELINE_CACHE_HEADER_VERSION_ONE + 1)
	PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM    PipelineCacheHeaderVersion = 2147483647
)

type Result int

const (
	SUCCESS                           Result = 0
	NOT_READY                         Result = 1
	TIMEOUT                           Result = 2
	EVENT_SET                         Result = 3
	EVENT_RESET                       Result = 4
	INCOMPLETE                        Result = 5
	ERROR_OUT_OF_HOST_MEMORY          Result = -1
	ERROR_OUT_OF_DEVICE_MEMORY        Result = -2
	ERROR_INITIALIZATION_FAILED       Result = -3
	ERROR_DEVICE_LOST                 Result = -4
	ERROR_MEMORY_MAP_FAILED           Result = -5
	ERROR_LAYER_NOT_PRESENT           Result = -6
	ERROR_EXTENSION_NOT_PRESENT       Result = -7
	ERROR_FEATURE_NOT_PRESENT         Result = -8
	ERROR_INCOMPATIBLE_DRIVER         Result = -9
	ERROR_TOO_MANY_OBJECTS            Result = -10
	ERROR_FORMAT_NOT_SUPPORTED        Result = -11
	ERROR_FRAGMENTED_POOL             Result = -12
	ERROR_OUT_OF_POOL_MEMORY          Result = -1000069000
	ERROR_INVALID_EXTERNAL_HANDLE     Result = -1000072003
	ERROR_SURFACE_LOST_KHR            Result = -1000000000
	ERROR_NATIVE_WINDOW_IN_USE_KHR    Result = -1000000001
	SUBOPTIMAL_KHR                    Result = 1000001003
	ERROR_OUT_OF_DATE_KHR             Result = -1000001004
	ERROR_INCOMPATIBLE_DISPLAY_KHR    Result = -1000003001
	ERROR_VALIDATION_FAILED_EXT       Result = -1000011001
	ERROR_INVALID_SHADER_NV           Result = -1000012000
	ERROR_FRAGMENTATION_EXT           Result = -1000161000
	ERROR_NOT_PERMITTED_EXT           Result = -1000174001
	ERROR_OUT_OF_POOL_MEMORY_KHR      Result = ERROR_OUT_OF_POOL_MEMORY
	ERROR_INVALID_EXTERNAL_HANDLE_KHR Result = ERROR_INVALID_EXTERNAL_HANDLE
	RESULT_BEGIN_RANGE                Result = ERROR_FRAGMENTED_POOL
	RESULT_END_RANGE                  Result = INCOMPLETE
	RESULT_RANGE_SIZE                 Result = (INCOMPLETE - ERROR_FRAGMENTED_POOL + 1)
	RESULT_MAX_ENUM                   Result = 2147483647
)

type StructureType int

const (
	STRUCTURE_TYPE_APPLICATION_INFO                                             StructureType = 0
	STRUCTURE_TYPE_INSTANCE_CREATE_INFO                                         StructureType = 1
	STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                                     StructureType = 2
	STRUCTURE_TYPE_DEVICE_CREATE_INFO                                           StructureType = 3
	STRUCTURE_TYPE_SUBMIT_INFO                                                  StructureType = 4
	STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                                         StructureType = 5
	STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                                          StructureType = 6
	STRUCTURE_TYPE_BIND_SPARSE_INFO                                             StructureType = 7
	STRUCTURE_TYPE_FENCE_CREATE_INFO                                            StructureType = 8
	STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                                        StructureType = 9
	STRUCTURE_TYPE_EVENT_CREATE_INFO                                            StructureType = 10
	STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                                       StructureType = 11
	STRUCTURE_TYPE_BUFFER_CREATE_INFO                                           StructureType = 12
	STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                                      StructureType = 13
	STRUCTURE_TYPE_IMAGE_CREATE_INFO                                            StructureType = 14
	STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                                       StructureType = 15
	STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                                    StructureType = 16
	STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                                   StructureType = 17
	STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO                            StructureType = 18
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                      StructureType = 19
	STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO                    StructureType = 20
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO                      StructureType = 21
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO                          StructureType = 22
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO                     StructureType = 23
	STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                       StructureType = 24
	STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                     StructureType = 25
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                       StructureType = 26
	STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO                           StructureType = 27
	STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO                                StructureType = 28
	STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO                                 StructureType = 29
	STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                                  StructureType = 30
	STRUCTURE_TYPE_SAMPLER_CREATE_INFO                                          StructureType = 31
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO                            StructureType = 32
	STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                                  StructureType = 33
	STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO                                 StructureType = 34
	STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                                         StructureType = 35
	STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                                          StructureType = 36
	STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                                      StructureType = 37
	STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                                      StructureType = 38
	STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                                     StructureType = 39
	STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO                                 StructureType = 40
	STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO                              StructureType = 41
	STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                                    StructureType = 42
	STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                                       StructureType = 43
	STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                                        StructureType = 44
	STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                                         StructureType = 45
	STRUCTURE_TYPE_MEMORY_BARRIER                                               StructureType = 46
	STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                                  StructureType = 47
	STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                                    StructureType = 48
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                          StructureType = 1000094000
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                                      StructureType = 1000157000
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                                       StructureType = 1000157001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                       StructureType = 1000083000
	STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS                                StructureType = 1000127000
	STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO                               StructureType = 1000127001
	STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                                   StructureType = 1000060000
	STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                          StructureType = 1000060003
	STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                       StructureType = 1000060004
	STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                                     StructureType = 1000060005
	STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO                                StructureType = 1000060006
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                         StructureType = 1000060013
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                          StructureType = 1000060014
	STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES                             StructureType = 1000070000
	STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO                              StructureType = 1000070001
	STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2                            StructureType = 1000146000
	STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2                             StructureType = 1000146001
	STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                      StructureType = 1000146002
	STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                                        StructureType = 1000146003
	STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                           StructureType = 1000146004
	STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                                   StructureType = 1000059000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2                                 StructureType = 1000059001
	STRUCTURE_TYPE_FORMAT_PROPERTIES_2                                          StructureType = 1000059002
	STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                                    StructureType = 1000059003
	STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                          StructureType = 1000059004
	STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                                    StructureType = 1000059005
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                          StructureType = 1000059006
	STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2                             StructureType = 1000059007
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2                   StructureType = 1000059008
	STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES                    StructureType = 1000117000
	STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO              StructureType = 1000117001
	STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                                 StructureType = 1000117002
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO        StructureType = 1000117003
	STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                            StructureType = 1000053000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                           StructureType = 1000053001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                         StructureType = 1000053002
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES                    StructureType = 1000120000
	STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                                        StructureType = 1000145000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES                    StructureType = 1000145001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES                  StructureType = 1000145002
	STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                                          StructureType = 1000145003
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO                         StructureType = 1000156000
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                                StructureType = 1000156001
	STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                                 StructureType = 1000156002
	STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                         StructureType = 1000156003
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES            StructureType = 1000156004
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES             StructureType = 1000156005
	STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                       StructureType = 1000085000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO                   StructureType = 1000071000
	STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                             StructureType = 1000071001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                         StructureType = 1000071002
	STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                                   StructureType = 1000071003
	STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                                StructureType = 1000071004
	STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                           StructureType = 1000072000
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                            StructureType = 1000072001
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                                  StructureType = 1000072002
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                          StructureType = 1000112000
	STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                                    StructureType = 1000112001
	STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                                     StructureType = 1000113000
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                                 StructureType = 1000077000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                      StructureType = 1000076000
	STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                                StructureType = 1000076001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                     StructureType = 1000168000
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                                StructureType = 1000168001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES               StructureType = 1000063000
	STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                                    StructureType = 1000001000
	STRUCTURE_TYPE_PRESENT_INFO_KHR                                             StructureType = 1000001001
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                        StructureType = 1000060007
	STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR                              StructureType = 1000060008
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                         StructureType = 1000060009
	STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR                                  StructureType = 1000060010
	STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR                                StructureType = 1000060011
	STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                       StructureType = 1000060012
	STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR                                 StructureType = 1000002000
	STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR                              StructureType = 1000002001
	STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                                     StructureType = 1000003000
	STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR                                 StructureType = 1000004000
	STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR                                  StructureType = 1000005000
	STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR                              StructureType = 1000006000
	STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR                                  StructureType = 1000007000
	STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR                              StructureType = 1000008000
	STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR                                StructureType = 1000009000
	STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT                        StructureType = 1000011000
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD         StructureType = 1000018000
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT                            StructureType = 1000022000
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT                             StructureType = 1000022001
	STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT                                 StructureType = 1000022002
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV                    StructureType = 1000026000
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV                   StructureType = 1000026001
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV                 StructureType = 1000026002
	STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD                     StructureType = 1000041000
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV                         StructureType = 1000056000
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV                               StructureType = 1000056001
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV                           StructureType = 1000057000
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV                           StructureType = 1000057001
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV                    StructureType = 1000058000
	STRUCTURE_TYPE_VALIDATION_FLAGS_EXT                                         StructureType = 1000061000
	STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN                                    StructureType = 1000062000
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR                          StructureType = 1000073000
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR                          StructureType = 1000073001
	STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR                           StructureType = 1000073002
	STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR                             StructureType = 1000073003
	STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR                                    StructureType = 1000074000
	STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR                                     StructureType = 1000074001
	STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR                                       StructureType = 1000074002
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR                   StructureType = 1000075000
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                       StructureType = 1000078000
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                       StructureType = 1000078001
	STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR                                  StructureType = 1000078002
	STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR                          StructureType = 1000078003
	STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR                                 StructureType = 1000079000
	STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR                                    StructureType = 1000079001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR               StructureType = 1000080000
	STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT    StructureType = 1000081000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT           StructureType = 1000081001
	STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT                         StructureType = 1000081002
	STRUCTURE_TYPE_PRESENT_REGIONS_KHR                                          StructureType = 1000084000
	STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX                                 StructureType = 1000086000
	STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX                     StructureType = 1000086001
	STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX                                StructureType = 1000086002
	STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX                      StructureType = 1000086003
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX                         StructureType = 1000086004
	STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX                       StructureType = 1000086005
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV             StructureType = 1000087000
	STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT                                   StructureType = 1000090000
	STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT                                       StructureType = 1000091000
	STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT                                        StructureType = 1000091001
	STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT                                       StructureType = 1000091002
	STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT                            StructureType = 1000091003
	STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE                                    StructureType = 1000092000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX StructureType = 1000097000
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV               StructureType = 1000098000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT             StructureType = 1000099000
	STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT             StructureType = 1000099001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT    StructureType = 1000101000
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT    StructureType = 1000101001
	STRUCTURE_TYPE_HDR_METADATA_EXT                                             StructureType = 1000105000
	STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR                                 StructureType = 1000109000
	STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR                                   StructureType = 1000109001
	STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR                                    StructureType = 1000109002
	STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR                                     StructureType = 1000109003
	STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR                                StructureType = 1000109004
	STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR                                       StructureType = 1000109005
	STRUCTURE_TYPE_SUBPASS_END_INFO_KHR                                         StructureType = 1000109006
	STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR                      StructureType = 1000111000
	STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR                           StructureType = 1000114000
	STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR                           StructureType = 1000114001
	STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR                              StructureType = 1000114002
	STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR                                     StructureType = 1000115000
	STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR                                        StructureType = 1000115001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                           StructureType = 1000119000
	STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                                   StructureType = 1000119001
	STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                                         StructureType = 1000119002
	STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR                                     StructureType = 1000121000
	STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR                               StructureType = 1000121001
	STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR                                StructureType = 1000121002
	STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR                                     StructureType = 1000121003
	STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR                             StructureType = 1000121004
	STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK                                  StructureType = 1000122000
	STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK                                StructureType = 1000123000
	STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT                             StructureType = 1000128000
	STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT                              StructureType = 1000128001
	STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT                                        StructureType = 1000128002
	STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT                      StructureType = 1000128003
	STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT                        StructureType = 1000128004
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID                        StructureType = 1000129000
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID                   StructureType = 1000129001
	STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID            StructureType = 1000129002
	STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                  StructureType = 1000129003
	STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID              StructureType = 1000129004
	STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID                                      StructureType = 1000129005
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT         StructureType = 1000130000
	STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT                       StructureType = 1000130001
	STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT                                    StructureType = 1000143000
	STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT                  StructureType = 1000143001
	STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT              StructureType = 1000143002
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT              StructureType = 1000143003
	STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT                                   StructureType = 1000143004
	STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR                            StructureType = 1000147000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT        StructureType = 1000148000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT      StructureType = 1000148001
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT          StructureType = 1000148002
	STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV              StructureType = 1000149000
	STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV            StructureType = 1000152000
	STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT                             StructureType = 1000160000
	STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT               StructureType = 1000160001
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT          StructureType = 1000161000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT             StructureType = 1000161001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT           StructureType = 1000161002
	STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT   StructureType = 1000161003
	STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT  StructureType = 1000161004
	STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT                 StructureType = 1000174000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR                    StructureType = 1000177000
	STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT                          StructureType = 1000178000
	STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT                           StructureType = 1000178001
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT          StructureType = 1000178002
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD                   StructureType = 1000185000
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT      StructureType = 1000190000
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT          StructureType = 1000190001
	STRUCTURE_TYPE_CHECKPOINT_DATA_NV                                           StructureType = 1000206000
	STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV                        StructureType = 1000206001
	STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR                        StructureType = STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR                       StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR                     StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
	STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR                               StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
	STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR                             StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
	STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                                      StructureType = STRUCTURE_TYPE_FORMAT_PROPERTIES_2
	STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR                                StructureType = STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
	STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR                      StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
	STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR                                StructureType = STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR                      StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
	STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR                         StructureType = STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR               StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
	STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR                               StructureType = STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
	STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR                      StructureType = STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
	STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR                   StructureType = STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
	STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR                                 StructureType = STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
	STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR                            StructureType = STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR                     StructureType = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR                      StructureType = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR                         StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
	STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR                          StructureType = STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR               StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
	STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR                         StructureType = STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR                     StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
	STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR                               StructureType = STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
	STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR                            StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
	STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR                       StructureType = STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR                        StructureType = STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR                              StructureType = STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR                  StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
	STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR                            StructureType = STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
	STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR                             StructureType = STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR                   StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
	STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR                   StructureType = STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR                      StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
	STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR                                StructureType = STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
	STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR                                 StructureType = STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR                StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
	STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR          StructureType = STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
	STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR                             StructureType = STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR    StructureType = STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR                StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES
	STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR                            StructureType = STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
	STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR                           StructureType = STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
	STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR                        StructureType = STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
	STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR                         StructureType = STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
	STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR                  StructureType = STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
	STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR                                    StructureType = STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
	STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR                       StructureType = STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR                     StructureType = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR                            StructureType = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
	STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR                             StructureType = STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
	STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR                     StructureType = STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR        StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
	STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR         StructureType = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
	STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR                                  StructureType = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
	STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR                                   StructureType = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
	STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR                 StructureType = STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR                            StructureType = STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
	STRUCTURE_TYPE_BEGIN_RANGE                                                  StructureType = STRUCTURE_TYPE_APPLICATION_INFO
	STRUCTURE_TYPE_END_RANGE                                                    StructureType = STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO
	STRUCTURE_TYPE_RANGE_SIZE                                                   StructureType = (STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - STRUCTURE_TYPE_APPLICATION_INFO + 1)
	STRUCTURE_TYPE_MAX_ENUM                                                     StructureType = 2147483647
)

type SystemAllocationScope int

const (
	SYSTEM_ALLOCATION_SCOPE_COMMAND     SystemAllocationScope = 0
	SYSTEM_ALLOCATION_SCOPE_OBJECT      SystemAllocationScope = 1
	SYSTEM_ALLOCATION_SCOPE_CACHE       SystemAllocationScope = 2
	SYSTEM_ALLOCATION_SCOPE_DEVICE      SystemAllocationScope = 3
	SYSTEM_ALLOCATION_SCOPE_INSTANCE    SystemAllocationScope = 4
	SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE SystemAllocationScope = SYSTEM_ALLOCATION_SCOPE_COMMAND
	SYSTEM_ALLOCATION_SCOPE_END_RANGE   SystemAllocationScope = SYSTEM_ALLOCATION_SCOPE_INSTANCE
	SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE  SystemAllocationScope = (SYSTEM_ALLOCATION_SCOPE_INSTANCE - SYSTEM_ALLOCATION_SCOPE_COMMAND + 1)
	SYSTEM_ALLOCATION_SCOPE_MAX_ENUM    SystemAllocationScope = 2147483647
)

type InternalAllocationType int

const (
	INTERNAL_ALLOCATION_TYPE_EXECUTABLE  InternalAllocationType = 0
	INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE InternalAllocationType = INTERNAL_ALLOCATION_TYPE_EXECUTABLE
	INTERNAL_ALLOCATION_TYPE_END_RANGE   InternalAllocationType = INTERNAL_ALLOCATION_TYPE_EXECUTABLE
	INTERNAL_ALLOCATION_TYPE_RANGE_SIZE  InternalAllocationType = (INTERNAL_ALLOCATION_TYPE_EXECUTABLE - INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1)
	INTERNAL_ALLOCATION_TYPE_MAX_ENUM    InternalAllocationType = 2147483647
)

type Format int

const (
	FORMAT_UNDEFINED                                      Format = 0
	FORMAT_R4G4_UNORM_PACK8                               Format = 1
	FORMAT_R4G4B4A4_UNORM_PACK16                          Format = 2
	FORMAT_B4G4R4A4_UNORM_PACK16                          Format = 3
	FORMAT_R5G6B5_UNORM_PACK16                            Format = 4
	FORMAT_B5G6R5_UNORM_PACK16                            Format = 5
	FORMAT_R5G5B5A1_UNORM_PACK16                          Format = 6
	FORMAT_B5G5R5A1_UNORM_PACK16                          Format = 7
	FORMAT_A1R5G5B5_UNORM_PACK16                          Format = 8
	FORMAT_R8_UNORM                                       Format = 9
	FORMAT_R8_SNORM                                       Format = 10
	FORMAT_R8_USCALED                                     Format = 11
	FORMAT_R8_SSCALED                                     Format = 12
	FORMAT_R8_UINT                                        Format = 13
	FORMAT_R8_SINT                                        Format = 14
	FORMAT_R8_SRGB                                        Format = 15
	FORMAT_R8G8_UNORM                                     Format = 16
	FORMAT_R8G8_SNORM                                     Format = 17
	FORMAT_R8G8_USCALED                                   Format = 18
	FORMAT_R8G8_SSCALED                                   Format = 19
	FORMAT_R8G8_UINT                                      Format = 20
	FORMAT_R8G8_SINT                                      Format = 21
	FORMAT_R8G8_SRGB                                      Format = 22
	FORMAT_R8G8B8_UNORM                                   Format = 23
	FORMAT_R8G8B8_SNORM                                   Format = 24
	FORMAT_R8G8B8_USCALED                                 Format = 25
	FORMAT_R8G8B8_SSCALED                                 Format = 26
	FORMAT_R8G8B8_UINT                                    Format = 27
	FORMAT_R8G8B8_SINT                                    Format = 28
	FORMAT_R8G8B8_SRGB                                    Format = 29
	FORMAT_B8G8R8_UNORM                                   Format = 30
	FORMAT_B8G8R8_SNORM                                   Format = 31
	FORMAT_B8G8R8_USCALED                                 Format = 32
	FORMAT_B8G8R8_SSCALED                                 Format = 33
	FORMAT_B8G8R8_UINT                                    Format = 34
	FORMAT_B8G8R8_SINT                                    Format = 35
	FORMAT_B8G8R8_SRGB                                    Format = 36
	FORMAT_R8G8B8A8_UNORM                                 Format = 37
	FORMAT_R8G8B8A8_SNORM                                 Format = 38
	FORMAT_R8G8B8A8_USCALED                               Format = 39
	FORMAT_R8G8B8A8_SSCALED                               Format = 40
	FORMAT_R8G8B8A8_UINT                                  Format = 41
	FORMAT_R8G8B8A8_SINT                                  Format = 42
	FORMAT_R8G8B8A8_SRGB                                  Format = 43
	FORMAT_B8G8R8A8_UNORM                                 Format = 44
	FORMAT_B8G8R8A8_SNORM                                 Format = 45
	FORMAT_B8G8R8A8_USCALED                               Format = 46
	FORMAT_B8G8R8A8_SSCALED                               Format = 47
	FORMAT_B8G8R8A8_UINT                                  Format = 48
	FORMAT_B8G8R8A8_SINT                                  Format = 49
	FORMAT_B8G8R8A8_SRGB                                  Format = 50
	FORMAT_A8B8G8R8_UNORM_PACK32                          Format = 51
	FORMAT_A8B8G8R8_SNORM_PACK32                          Format = 52
	FORMAT_A8B8G8R8_USCALED_PACK32                        Format = 53
	FORMAT_A8B8G8R8_SSCALED_PACK32                        Format = 54
	FORMAT_A8B8G8R8_UINT_PACK32                           Format = 55
	FORMAT_A8B8G8R8_SINT_PACK32                           Format = 56
	FORMAT_A8B8G8R8_SRGB_PACK32                           Format = 57
	FORMAT_A2R10G10B10_UNORM_PACK32                       Format = 58
	FORMAT_A2R10G10B10_SNORM_PACK32                       Format = 59
	FORMAT_A2R10G10B10_USCALED_PACK32                     Format = 60
	FORMAT_A2R10G10B10_SSCALED_PACK32                     Format = 61
	FORMAT_A2R10G10B10_UINT_PACK32                        Format = 62
	FORMAT_A2R10G10B10_SINT_PACK32                        Format = 63
	FORMAT_A2B10G10R10_UNORM_PACK32                       Format = 64
	FORMAT_A2B10G10R10_SNORM_PACK32                       Format = 65
	FORMAT_A2B10G10R10_USCALED_PACK32                     Format = 66
	FORMAT_A2B10G10R10_SSCALED_PACK32                     Format = 67
	FORMAT_A2B10G10R10_UINT_PACK32                        Format = 68
	FORMAT_A2B10G10R10_SINT_PACK32                        Format = 69
	FORMAT_R16_UNORM                                      Format = 70
	FORMAT_R16_SNORM                                      Format = 71
	FORMAT_R16_USCALED                                    Format = 72
	FORMAT_R16_SSCALED                                    Format = 73
	FORMAT_R16_UINT                                       Format = 74
	FORMAT_R16_SINT                                       Format = 75
	FORMAT_R16_SFLOAT                                     Format = 76
	FORMAT_R16G16_UNORM                                   Format = 77
	FORMAT_R16G16_SNORM                                   Format = 78
	FORMAT_R16G16_USCALED                                 Format = 79
	FORMAT_R16G16_SSCALED                                 Format = 80
	FORMAT_R16G16_UINT                                    Format = 81
	FORMAT_R16G16_SINT                                    Format = 82
	FORMAT_R16G16_SFLOAT                                  Format = 83
	FORMAT_R16G16B16_UNORM                                Format = 84
	FORMAT_R16G16B16_SNORM                                Format = 85
	FORMAT_R16G16B16_USCALED                              Format = 86
	FORMAT_R16G16B16_SSCALED                              Format = 87
	FORMAT_R16G16B16_UINT                                 Format = 88
	FORMAT_R16G16B16_SINT                                 Format = 89
	FORMAT_R16G16B16_SFLOAT                               Format = 90
	FORMAT_R16G16B16A16_UNORM                             Format = 91
	FORMAT_R16G16B16A16_SNORM                             Format = 92
	FORMAT_R16G16B16A16_USCALED                           Format = 93
	FORMAT_R16G16B16A16_SSCALED                           Format = 94
	FORMAT_R16G16B16A16_UINT                              Format = 95
	FORMAT_R16G16B16A16_SINT                              Format = 96
	FORMAT_R16G16B16A16_SFLOAT                            Format = 97
	FORMAT_R32_UINT                                       Format = 98
	FORMAT_R32_SINT                                       Format = 99
	FORMAT_R32_SFLOAT                                     Format = 100
	FORMAT_R32G32_UINT                                    Format = 101
	FORMAT_R32G32_SINT                                    Format = 102
	FORMAT_R32G32_SFLOAT                                  Format = 103
	FORMAT_R32G32B32_UINT                                 Format = 104
	FORMAT_R32G32B32_SINT                                 Format = 105
	FORMAT_R32G32B32_SFLOAT                               Format = 106
	FORMAT_R32G32B32A32_UINT                              Format = 107
	FORMAT_R32G32B32A32_SINT                              Format = 108
	FORMAT_R32G32B32A32_SFLOAT                            Format = 109
	FORMAT_R64_UINT                                       Format = 110
	FORMAT_R64_SINT                                       Format = 111
	FORMAT_R64_SFLOAT                                     Format = 112
	FORMAT_R64G64_UINT                                    Format = 113
	FORMAT_R64G64_SINT                                    Format = 114
	FORMAT_R64G64_SFLOAT                                  Format = 115
	FORMAT_R64G64B64_UINT                                 Format = 116
	FORMAT_R64G64B64_SINT                                 Format = 117
	FORMAT_R64G64B64_SFLOAT                               Format = 118
	FORMAT_R64G64B64A64_UINT                              Format = 119
	FORMAT_R64G64B64A64_SINT                              Format = 120
	FORMAT_R64G64B64A64_SFLOAT                            Format = 121
	FORMAT_B10G11R11_UFLOAT_PACK32                        Format = 122
	FORMAT_E5B9G9R9_UFLOAT_PACK32                         Format = 123
	FORMAT_D16_UNORM                                      Format = 124
	FORMAT_X8_D24_UNORM_PACK32                            Format = 125
	FORMAT_D32_SFLOAT                                     Format = 126
	FORMAT_S8_UINT                                        Format = 127
	FORMAT_D16_UNORM_S8_UINT                              Format = 128
	FORMAT_D24_UNORM_S8_UINT                              Format = 129
	FORMAT_D32_SFLOAT_S8_UINT                             Format = 130
	FORMAT_BC1_RGB_UNORM_BLOCK                            Format = 131
	FORMAT_BC1_RGB_SRGB_BLOCK                             Format = 132
	FORMAT_BC1_RGBA_UNORM_BLOCK                           Format = 133
	FORMAT_BC1_RGBA_SRGB_BLOCK                            Format = 134
	FORMAT_BC2_UNORM_BLOCK                                Format = 135
	FORMAT_BC2_SRGB_BLOCK                                 Format = 136
	FORMAT_BC3_UNORM_BLOCK                                Format = 137
	FORMAT_BC3_SRGB_BLOCK                                 Format = 138
	FORMAT_BC4_UNORM_BLOCK                                Format = 139
	FORMAT_BC4_SNORM_BLOCK                                Format = 140
	FORMAT_BC5_UNORM_BLOCK                                Format = 141
	FORMAT_BC5_SNORM_BLOCK                                Format = 142
	FORMAT_BC6H_UFLOAT_BLOCK                              Format = 143
	FORMAT_BC6H_SFLOAT_BLOCK                              Format = 144
	FORMAT_BC7_UNORM_BLOCK                                Format = 145
	FORMAT_BC7_SRGB_BLOCK                                 Format = 146
	FORMAT_ETC2_R8G8B8_UNORM_BLOCK                        Format = 147
	FORMAT_ETC2_R8G8B8_SRGB_BLOCK                         Format = 148
	FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                      Format = 149
	FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                       Format = 150
	FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                      Format = 151
	FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                       Format = 152
	FORMAT_EAC_R11_UNORM_BLOCK                            Format = 153
	FORMAT_EAC_R11_SNORM_BLOCK                            Format = 154
	FORMAT_EAC_R11G11_UNORM_BLOCK                         Format = 155
	FORMAT_EAC_R11G11_SNORM_BLOCK                         Format = 156
	FORMAT_ASTC_4x4_UNORM_BLOCK                           Format = 157
	FORMAT_ASTC_4x4_SRGB_BLOCK                            Format = 158
	FORMAT_ASTC_5x4_UNORM_BLOCK                           Format = 159
	FORMAT_ASTC_5x4_SRGB_BLOCK                            Format = 160
	FORMAT_ASTC_5x5_UNORM_BLOCK                           Format = 161
	FORMAT_ASTC_5x5_SRGB_BLOCK                            Format = 162
	FORMAT_ASTC_6x5_UNORM_BLOCK                           Format = 163
	FORMAT_ASTC_6x5_SRGB_BLOCK                            Format = 164
	FORMAT_ASTC_6x6_UNORM_BLOCK                           Format = 165
	FORMAT_ASTC_6x6_SRGB_BLOCK                            Format = 166
	FORMAT_ASTC_8x5_UNORM_BLOCK                           Format = 167
	FORMAT_ASTC_8x5_SRGB_BLOCK                            Format = 168
	FORMAT_ASTC_8x6_UNORM_BLOCK                           Format = 169
	FORMAT_ASTC_8x6_SRGB_BLOCK                            Format = 170
	FORMAT_ASTC_8x8_UNORM_BLOCK                           Format = 171
	FORMAT_ASTC_8x8_SRGB_BLOCK                            Format = 172
	FORMAT_ASTC_10x5_UNORM_BLOCK                          Format = 173
	FORMAT_ASTC_10x5_SRGB_BLOCK                           Format = 174
	FORMAT_ASTC_10x6_UNORM_BLOCK                          Format = 175
	FORMAT_ASTC_10x6_SRGB_BLOCK                           Format = 176
	FORMAT_ASTC_10x8_UNORM_BLOCK                          Format = 177
	FORMAT_ASTC_10x8_SRGB_BLOCK                           Format = 178
	FORMAT_ASTC_10x10_UNORM_BLOCK                         Format = 179
	FORMAT_ASTC_10x10_SRGB_BLOCK                          Format = 180
	FORMAT_ASTC_12x10_UNORM_BLOCK                         Format = 181
	FORMAT_ASTC_12x10_SRGB_BLOCK                          Format = 182
	FORMAT_ASTC_12x12_UNORM_BLOCK                         Format = 183
	FORMAT_ASTC_12x12_SRGB_BLOCK                          Format = 184
	FORMAT_G8B8G8R8_422_UNORM                             Format = 1000156000
	FORMAT_B8G8R8G8_422_UNORM                             Format = 1000156001
	FORMAT_G8_B8_R8_3PLANE_420_UNORM                      Format = 1000156002
	FORMAT_G8_B8R8_2PLANE_420_UNORM                       Format = 1000156003
	FORMAT_G8_B8_R8_3PLANE_422_UNORM                      Format = 1000156004
	FORMAT_G8_B8R8_2PLANE_422_UNORM                       Format = 1000156005
	FORMAT_G8_B8_R8_3PLANE_444_UNORM                      Format = 1000156006
	FORMAT_R10X6_UNORM_PACK16                             Format = 1000156007
	FORMAT_R10X6G10X6_UNORM_2PACK16                       Format = 1000156008
	FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16             Format = 1000156009
	FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16         Format = 1000156010
	FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16         Format = 1000156011
	FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16     Format = 1000156012
	FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16      Format = 1000156013
	FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16     Format = 1000156014
	FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16      Format = 1000156015
	FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16     Format = 1000156016
	FORMAT_R12X4_UNORM_PACK16                             Format = 1000156017
	FORMAT_R12X4G12X4_UNORM_2PACK16                       Format = 1000156018
	FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16             Format = 1000156019
	FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16         Format = 1000156020
	FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16         Format = 1000156021
	FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16     Format = 1000156022
	FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16      Format = 1000156023
	FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16     Format = 1000156024
	FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16      Format = 1000156025
	FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16     Format = 1000156026
	FORMAT_G16B16G16R16_422_UNORM                         Format = 1000156027
	FORMAT_B16G16R16G16_422_UNORM                         Format = 1000156028
	FORMAT_G16_B16_R16_3PLANE_420_UNORM                   Format = 1000156029
	FORMAT_G16_B16R16_2PLANE_420_UNORM                    Format = 1000156030
	FORMAT_G16_B16_R16_3PLANE_422_UNORM                   Format = 1000156031
	FORMAT_G16_B16R16_2PLANE_422_UNORM                    Format = 1000156032
	FORMAT_G16_B16_R16_3PLANE_444_UNORM                   Format = 1000156033
	FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG                    Format = 1000054000
	FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG                    Format = 1000054001
	FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG                    Format = 1000054002
	FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG                    Format = 1000054003
	FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG                     Format = 1000054004
	FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG                     Format = 1000054005
	FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG                     Format = 1000054006
	FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG                     Format = 1000054007
	FORMAT_G8B8G8R8_422_UNORM_KHR                         Format = FORMAT_G8B8G8R8_422_UNORM
	FORMAT_B8G8R8G8_422_UNORM_KHR                         Format = FORMAT_B8G8R8G8_422_UNORM
	FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR                  Format = FORMAT_G8_B8_R8_3PLANE_420_UNORM
	FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR                   Format = FORMAT_G8_B8R8_2PLANE_420_UNORM
	FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR                  Format = FORMAT_G8_B8_R8_3PLANE_422_UNORM
	FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR                   Format = FORMAT_G8_B8R8_2PLANE_422_UNORM
	FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR                  Format = FORMAT_G8_B8_R8_3PLANE_444_UNORM
	FORMAT_R10X6_UNORM_PACK16_KHR                         Format = FORMAT_R10X6_UNORM_PACK16
	FORMAT_R10X6G10X6_UNORM_2PACK16_KHR                   Format = FORMAT_R10X6G10X6_UNORM_2PACK16
	FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR         Format = FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
	FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR     Format = FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
	FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR     Format = FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
	FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR Format = FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
	FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR  Format = FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
	FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR Format = FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
	FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR  Format = FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
	FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR Format = FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
	FORMAT_R12X4_UNORM_PACK16_KHR                         Format = FORMAT_R12X4_UNORM_PACK16
	FORMAT_R12X4G12X4_UNORM_2PACK16_KHR                   Format = FORMAT_R12X4G12X4_UNORM_2PACK16
	FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR         Format = FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
	FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR     Format = FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
	FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR     Format = FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
	FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR Format = FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
	FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR  Format = FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
	FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR Format = FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
	FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR  Format = FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
	FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR Format = FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
	FORMAT_G16B16G16R16_422_UNORM_KHR                     Format = FORMAT_G16B16G16R16_422_UNORM
	FORMAT_B16G16R16G16_422_UNORM_KHR                     Format = FORMAT_B16G16R16G16_422_UNORM
	FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR               Format = FORMAT_G16_B16_R16_3PLANE_420_UNORM
	FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR                Format = FORMAT_G16_B16R16_2PLANE_420_UNORM
	FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR               Format = FORMAT_G16_B16_R16_3PLANE_422_UNORM
	FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR                Format = FORMAT_G16_B16R16_2PLANE_422_UNORM
	FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR               Format = FORMAT_G16_B16_R16_3PLANE_444_UNORM
	FORMAT_BEGIN_RANGE                                    Format = FORMAT_UNDEFINED
	FORMAT_END_RANGE                                      Format = FORMAT_ASTC_12x12_SRGB_BLOCK
	FORMAT_RANGE_SIZE                                     Format = (FORMAT_ASTC_12x12_SRGB_BLOCK - FORMAT_UNDEFINED + 1)
	FORMAT_MAX_ENUM                                       Format = 2147483647
)

type ImageType int

const (
	IMAGE_TYPE_1D          ImageType = 0
	IMAGE_TYPE_2D          ImageType = 1
	IMAGE_TYPE_3D          ImageType = 2
	IMAGE_TYPE_BEGIN_RANGE ImageType = IMAGE_TYPE_1D
	IMAGE_TYPE_END_RANGE   ImageType = IMAGE_TYPE_3D
	IMAGE_TYPE_RANGE_SIZE  ImageType = (IMAGE_TYPE_3D - IMAGE_TYPE_1D + 1)
	IMAGE_TYPE_MAX_ENUM    ImageType = 2147483647
)

type ImageTiling int

const (
	IMAGE_TILING_OPTIMAL     ImageTiling = 0
	IMAGE_TILING_LINEAR      ImageTiling = 1
	IMAGE_TILING_BEGIN_RANGE ImageTiling = IMAGE_TILING_OPTIMAL
	IMAGE_TILING_END_RANGE   ImageTiling = IMAGE_TILING_LINEAR
	IMAGE_TILING_RANGE_SIZE  ImageTiling = (IMAGE_TILING_LINEAR - IMAGE_TILING_OPTIMAL + 1)
	IMAGE_TILING_MAX_ENUM    ImageTiling = 2147483647
)

type PhysicalDeviceType int

const (
	PHYSICAL_DEVICE_TYPE_OTHER          PhysicalDeviceType = 0
	PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU PhysicalDeviceType = 1
	PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   PhysicalDeviceType = 2
	PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    PhysicalDeviceType = 3
	PHYSICAL_DEVICE_TYPE_CPU            PhysicalDeviceType = 4
	PHYSICAL_DEVICE_TYPE_BEGIN_RANGE    PhysicalDeviceType = PHYSICAL_DEVICE_TYPE_OTHER
	PHYSICAL_DEVICE_TYPE_END_RANGE      PhysicalDeviceType = PHYSICAL_DEVICE_TYPE_CPU
	PHYSICAL_DEVICE_TYPE_RANGE_SIZE     PhysicalDeviceType = (PHYSICAL_DEVICE_TYPE_CPU - PHYSICAL_DEVICE_TYPE_OTHER + 1)
	PHYSICAL_DEVICE_TYPE_MAX_ENUM       PhysicalDeviceType = 2147483647
)

type QueryType int

const (
	QUERY_TYPE_OCCLUSION           QueryType = 0
	QUERY_TYPE_PIPELINE_STATISTICS QueryType = 1
	QUERY_TYPE_TIMESTAMP           QueryType = 2
	QUERY_TYPE_BEGIN_RANGE         QueryType = QUERY_TYPE_OCCLUSION
	QUERY_TYPE_END_RANGE           QueryType = QUERY_TYPE_TIMESTAMP
	QUERY_TYPE_RANGE_SIZE          QueryType = (QUERY_TYPE_TIMESTAMP - QUERY_TYPE_OCCLUSION + 1)
	QUERY_TYPE_MAX_ENUM            QueryType = 2147483647
)

type SharingMode int

const (
	SHARING_MODE_EXCLUSIVE   SharingMode = 0
	SHARING_MODE_CONCURRENT  SharingMode = 1
	SHARING_MODE_BEGIN_RANGE SharingMode = SHARING_MODE_EXCLUSIVE
	SHARING_MODE_END_RANGE   SharingMode = SHARING_MODE_CONCURRENT
	SHARING_MODE_RANGE_SIZE  SharingMode = (SHARING_MODE_CONCURRENT - SHARING_MODE_EXCLUSIVE + 1)
	SHARING_MODE_MAX_ENUM    SharingMode = 2147483647
)

type ImageLayout int

const (
	IMAGE_LAYOUT_UNDEFINED                                      ImageLayout = 0
	IMAGE_LAYOUT_GENERAL                                        ImageLayout = 1
	IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                       ImageLayout = 2
	IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL               ImageLayout = 3
	IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL                ImageLayout = 4
	IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                       ImageLayout = 5
	IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                           ImageLayout = 6
	IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                           ImageLayout = 7
	IMAGE_LAYOUT_PREINITIALIZED                                 ImageLayout = 8
	IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL     ImageLayout = 1000117000
	IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL     ImageLayout = 1000117001
	IMAGE_LAYOUT_PRESENT_SRC_KHR                                ImageLayout = 1000001002
	IMAGE_LAYOUT_SHARED_PRESENT_KHR                             ImageLayout = 1000111000
	IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR ImageLayout = IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
	IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR ImageLayout = IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
	IMAGE_LAYOUT_BEGIN_RANGE                                    ImageLayout = IMAGE_LAYOUT_UNDEFINED
	IMAGE_LAYOUT_END_RANGE                                      ImageLayout = IMAGE_LAYOUT_PREINITIALIZED
	IMAGE_LAYOUT_RANGE_SIZE                                     ImageLayout = (IMAGE_LAYOUT_PREINITIALIZED - IMAGE_LAYOUT_UNDEFINED + 1)
	IMAGE_LAYOUT_MAX_ENUM                                       ImageLayout = 2147483647
)

type ImageViewType int

const (
	IMAGE_VIEW_TYPE_1D          ImageViewType = 0
	IMAGE_VIEW_TYPE_2D          ImageViewType = 1
	IMAGE_VIEW_TYPE_3D          ImageViewType = 2
	IMAGE_VIEW_TYPE_CUBE        ImageViewType = 3
	IMAGE_VIEW_TYPE_1D_ARRAY    ImageViewType = 4
	IMAGE_VIEW_TYPE_2D_ARRAY    ImageViewType = 5
	IMAGE_VIEW_TYPE_CUBE_ARRAY  ImageViewType = 6
	IMAGE_VIEW_TYPE_BEGIN_RANGE ImageViewType = IMAGE_VIEW_TYPE_1D
	IMAGE_VIEW_TYPE_END_RANGE   ImageViewType = IMAGE_VIEW_TYPE_CUBE_ARRAY
	IMAGE_VIEW_TYPE_RANGE_SIZE  ImageViewType = (IMAGE_VIEW_TYPE_CUBE_ARRAY - IMAGE_VIEW_TYPE_1D + 1)
	IMAGE_VIEW_TYPE_MAX_ENUM    ImageViewType = 2147483647
)

type ComponentSwizzle int

const (
	COMPONENT_SWIZZLE_IDENTITY    ComponentSwizzle = 0
	COMPONENT_SWIZZLE_ZERO        ComponentSwizzle = 1
	COMPONENT_SWIZZLE_ONE         ComponentSwizzle = 2
	COMPONENT_SWIZZLE_R           ComponentSwizzle = 3
	COMPONENT_SWIZZLE_G           ComponentSwizzle = 4
	COMPONENT_SWIZZLE_B           ComponentSwizzle = 5
	COMPONENT_SWIZZLE_A           ComponentSwizzle = 6
	COMPONENT_SWIZZLE_BEGIN_RANGE ComponentSwizzle = COMPONENT_SWIZZLE_IDENTITY
	COMPONENT_SWIZZLE_END_RANGE   ComponentSwizzle = COMPONENT_SWIZZLE_A
	COMPONENT_SWIZZLE_RANGE_SIZE  ComponentSwizzle = (COMPONENT_SWIZZLE_A - COMPONENT_SWIZZLE_IDENTITY + 1)
	COMPONENT_SWIZZLE_MAX_ENUM    ComponentSwizzle = 2147483647
)

type VertexInputRate int

const (
	VERTEX_INPUT_RATE_VERTEX      VertexInputRate = 0
	VERTEX_INPUT_RATE_INSTANCE    VertexInputRate = 1
	VERTEX_INPUT_RATE_BEGIN_RANGE VertexInputRate = VERTEX_INPUT_RATE_VERTEX
	VERTEX_INPUT_RATE_END_RANGE   VertexInputRate = VERTEX_INPUT_RATE_INSTANCE
	VERTEX_INPUT_RATE_RANGE_SIZE  VertexInputRate = (VERTEX_INPUT_RATE_INSTANCE - VERTEX_INPUT_RATE_VERTEX + 1)
	VERTEX_INPUT_RATE_MAX_ENUM    VertexInputRate = 2147483647
)

type PrimitiveTopology int

const (
	PRIMITIVE_TOPOLOGY_POINT_LIST                    PrimitiveTopology = 0
	PRIMITIVE_TOPOLOGY_LINE_LIST                     PrimitiveTopology = 1
	PRIMITIVE_TOPOLOGY_LINE_STRIP                    PrimitiveTopology = 2
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 PrimitiveTopology = 3
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                PrimitiveTopology = 4
	PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  PrimitiveTopology = 5
	PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      PrimitiveTopology = 6
	PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     PrimitiveTopology = 7
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  PrimitiveTopology = 8
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY PrimitiveTopology = 9
	PRIMITIVE_TOPOLOGY_PATCH_LIST                    PrimitiveTopology = 10
	PRIMITIVE_TOPOLOGY_BEGIN_RANGE                   PrimitiveTopology = PRIMITIVE_TOPOLOGY_POINT_LIST
	PRIMITIVE_TOPOLOGY_END_RANGE                     PrimitiveTopology = PRIMITIVE_TOPOLOGY_PATCH_LIST
	PRIMITIVE_TOPOLOGY_RANGE_SIZE                    PrimitiveTopology = (PRIMITIVE_TOPOLOGY_PATCH_LIST - PRIMITIVE_TOPOLOGY_POINT_LIST + 1)
	PRIMITIVE_TOPOLOGY_MAX_ENUM                      PrimitiveTopology = 2147483647
)

type PolygonMode int

const (
	POLYGON_MODE_FILL              PolygonMode = 0
	POLYGON_MODE_LINE              PolygonMode = 1
	POLYGON_MODE_POINT             PolygonMode = 2
	POLYGON_MODE_FILL_RECTANGLE_NV PolygonMode = 1000153000
	POLYGON_MODE_BEGIN_RANGE       PolygonMode = POLYGON_MODE_FILL
	POLYGON_MODE_END_RANGE         PolygonMode = POLYGON_MODE_POINT
	POLYGON_MODE_RANGE_SIZE        PolygonMode = (POLYGON_MODE_POINT - POLYGON_MODE_FILL + 1)
	POLYGON_MODE_MAX_ENUM          PolygonMode = 2147483647
)

type FrontFace int

const (
	FRONT_FACE_COUNTER_CLOCKWISE FrontFace = 0
	FRONT_FACE_CLOCKWISE         FrontFace = 1
	FRONT_FACE_BEGIN_RANGE       FrontFace = FRONT_FACE_COUNTER_CLOCKWISE
	FRONT_FACE_END_RANGE         FrontFace = FRONT_FACE_CLOCKWISE
	FRONT_FACE_RANGE_SIZE        FrontFace = (FRONT_FACE_CLOCKWISE - FRONT_FACE_COUNTER_CLOCKWISE + 1)
	FRONT_FACE_MAX_ENUM          FrontFace = 2147483647
)

type CompareOp int

const (
	COMPARE_OP_NEVER            CompareOp = 0
	COMPARE_OP_LESS             CompareOp = 1
	COMPARE_OP_EQUAL            CompareOp = 2
	COMPARE_OP_LESS_OR_EQUAL    CompareOp = 3
	COMPARE_OP_GREATER          CompareOp = 4
	COMPARE_OP_NOT_EQUAL        CompareOp = 5
	COMPARE_OP_GREATER_OR_EQUAL CompareOp = 6
	COMPARE_OP_ALWAYS           CompareOp = 7
	COMPARE_OP_BEGIN_RANGE      CompareOp = COMPARE_OP_NEVER
	COMPARE_OP_END_RANGE        CompareOp = COMPARE_OP_ALWAYS
	COMPARE_OP_RANGE_SIZE       CompareOp = (COMPARE_OP_ALWAYS - COMPARE_OP_NEVER + 1)
	COMPARE_OP_MAX_ENUM         CompareOp = 2147483647
)

type StencilOp int

const (
	STENCIL_OP_KEEP                StencilOp = 0
	STENCIL_OP_ZERO                StencilOp = 1
	STENCIL_OP_REPLACE             StencilOp = 2
	STENCIL_OP_INCREMENT_AND_CLAMP StencilOp = 3
	STENCIL_OP_DECREMENT_AND_CLAMP StencilOp = 4
	STENCIL_OP_INVERT              StencilOp = 5
	STENCIL_OP_INCREMENT_AND_WRAP  StencilOp = 6
	STENCIL_OP_DECREMENT_AND_WRAP  StencilOp = 7
	STENCIL_OP_BEGIN_RANGE         StencilOp = STENCIL_OP_KEEP
	STENCIL_OP_END_RANGE           StencilOp = STENCIL_OP_DECREMENT_AND_WRAP
	STENCIL_OP_RANGE_SIZE          StencilOp = (STENCIL_OP_DECREMENT_AND_WRAP - STENCIL_OP_KEEP + 1)
	STENCIL_OP_MAX_ENUM            StencilOp = 2147483647
)

type LogicOp int

const (
	LOGIC_OP_CLEAR         LogicOp = 0
	LOGIC_OP_AND           LogicOp = 1
	LOGIC_OP_AND_REVERSE   LogicOp = 2
	LOGIC_OP_COPY          LogicOp = 3
	LOGIC_OP_AND_INVERTED  LogicOp = 4
	LOGIC_OP_NO_OP         LogicOp = 5
	LOGIC_OP_XOR           LogicOp = 6
	LOGIC_OP_OR            LogicOp = 7
	LOGIC_OP_NOR           LogicOp = 8
	LOGIC_OP_EQUIVALENT    LogicOp = 9
	LOGIC_OP_INVERT        LogicOp = 10
	LOGIC_OP_OR_REVERSE    LogicOp = 11
	LOGIC_OP_COPY_INVERTED LogicOp = 12
	LOGIC_OP_OR_INVERTED   LogicOp = 13
	LOGIC_OP_NAND          LogicOp = 14
	LOGIC_OP_SET           LogicOp = 15
	LOGIC_OP_BEGIN_RANGE   LogicOp = LOGIC_OP_CLEAR
	LOGIC_OP_END_RANGE     LogicOp = LOGIC_OP_SET
	LOGIC_OP_RANGE_SIZE    LogicOp = (LOGIC_OP_SET - LOGIC_OP_CLEAR + 1)
	LOGIC_OP_MAX_ENUM      LogicOp = 2147483647
)

type BlendFactor int

const (
	BLEND_FACTOR_ZERO                     BlendFactor = 0
	BLEND_FACTOR_ONE                      BlendFactor = 1
	BLEND_FACTOR_SRC_COLOR                BlendFactor = 2
	BLEND_FACTOR_ONE_MINUS_SRC_COLOR      BlendFactor = 3
	BLEND_FACTOR_DST_COLOR                BlendFactor = 4
	BLEND_FACTOR_ONE_MINUS_DST_COLOR      BlendFactor = 5
	BLEND_FACTOR_SRC_ALPHA                BlendFactor = 6
	BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      BlendFactor = 7
	BLEND_FACTOR_DST_ALPHA                BlendFactor = 8
	BLEND_FACTOR_ONE_MINUS_DST_ALPHA      BlendFactor = 9
	BLEND_FACTOR_CONSTANT_COLOR           BlendFactor = 10
	BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR BlendFactor = 11
	BLEND_FACTOR_CONSTANT_ALPHA           BlendFactor = 12
	BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA BlendFactor = 13
	BLEND_FACTOR_SRC_ALPHA_SATURATE       BlendFactor = 14
	BLEND_FACTOR_SRC1_COLOR               BlendFactor = 15
	BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     BlendFactor = 16
	BLEND_FACTOR_SRC1_ALPHA               BlendFactor = 17
	BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     BlendFactor = 18
	BLEND_FACTOR_BEGIN_RANGE              BlendFactor = BLEND_FACTOR_ZERO
	BLEND_FACTOR_END_RANGE                BlendFactor = BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
	BLEND_FACTOR_RANGE_SIZE               BlendFactor = (BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - BLEND_FACTOR_ZERO + 1)
	BLEND_FACTOR_MAX_ENUM                 BlendFactor = 2147483647
)

type BlendOp int

const (
	BLEND_OP_ADD                    BlendOp = 0
	BLEND_OP_SUBTRACT               BlendOp = 1
	BLEND_OP_REVERSE_SUBTRACT       BlendOp = 2
	BLEND_OP_MIN                    BlendOp = 3
	BLEND_OP_MAX                    BlendOp = 4
	BLEND_OP_ZERO_EXT               BlendOp = 1000148000
	BLEND_OP_SRC_EXT                BlendOp = 1000148001
	BLEND_OP_DST_EXT                BlendOp = 1000148002
	BLEND_OP_SRC_OVER_EXT           BlendOp = 1000148003
	BLEND_OP_DST_OVER_EXT           BlendOp = 1000148004
	BLEND_OP_SRC_IN_EXT             BlendOp = 1000148005
	BLEND_OP_DST_IN_EXT             BlendOp = 1000148006
	BLEND_OP_SRC_OUT_EXT            BlendOp = 1000148007
	BLEND_OP_DST_OUT_EXT            BlendOp = 1000148008
	BLEND_OP_SRC_ATOP_EXT           BlendOp = 1000148009
	BLEND_OP_DST_ATOP_EXT           BlendOp = 1000148010
	BLEND_OP_XOR_EXT                BlendOp = 1000148011
	BLEND_OP_MULTIPLY_EXT           BlendOp = 1000148012
	BLEND_OP_SCREEN_EXT             BlendOp = 1000148013
	BLEND_OP_OVERLAY_EXT            BlendOp = 1000148014
	BLEND_OP_DARKEN_EXT             BlendOp = 1000148015
	BLEND_OP_LIGHTEN_EXT            BlendOp = 1000148016
	BLEND_OP_COLORDODGE_EXT         BlendOp = 1000148017
	BLEND_OP_COLORBURN_EXT          BlendOp = 1000148018
	BLEND_OP_HARDLIGHT_EXT          BlendOp = 1000148019
	BLEND_OP_SOFTLIGHT_EXT          BlendOp = 1000148020
	BLEND_OP_DIFFERENCE_EXT         BlendOp = 1000148021
	BLEND_OP_EXCLUSION_EXT          BlendOp = 1000148022
	BLEND_OP_INVERT_EXT             BlendOp = 1000148023
	BLEND_OP_INVERT_RGB_EXT         BlendOp = 1000148024
	BLEND_OP_LINEARDODGE_EXT        BlendOp = 1000148025
	BLEND_OP_LINEARBURN_EXT         BlendOp = 1000148026
	BLEND_OP_VIVIDLIGHT_EXT         BlendOp = 1000148027
	BLEND_OP_LINEARLIGHT_EXT        BlendOp = 1000148028
	BLEND_OP_PINLIGHT_EXT           BlendOp = 1000148029
	BLEND_OP_HARDMIX_EXT            BlendOp = 1000148030
	BLEND_OP_HSL_HUE_EXT            BlendOp = 1000148031
	BLEND_OP_HSL_SATURATION_EXT     BlendOp = 1000148032
	BLEND_OP_HSL_COLOR_EXT          BlendOp = 1000148033
	BLEND_OP_HSL_LUMINOSITY_EXT     BlendOp = 1000148034
	BLEND_OP_PLUS_EXT               BlendOp = 1000148035
	BLEND_OP_PLUS_CLAMPED_EXT       BlendOp = 1000148036
	BLEND_OP_PLUS_CLAMPED_ALPHA_EXT BlendOp = 1000148037
	BLEND_OP_PLUS_DARKER_EXT        BlendOp = 1000148038
	BLEND_OP_MINUS_EXT              BlendOp = 1000148039
	BLEND_OP_MINUS_CLAMPED_EXT      BlendOp = 1000148040
	BLEND_OP_CONTRAST_EXT           BlendOp = 1000148041
	BLEND_OP_INVERT_OVG_EXT         BlendOp = 1000148042
	BLEND_OP_RED_EXT                BlendOp = 1000148043
	BLEND_OP_GREEN_EXT              BlendOp = 1000148044
	BLEND_OP_BLUE_EXT               BlendOp = 1000148045
	BLEND_OP_BEGIN_RANGE            BlendOp = BLEND_OP_ADD
	BLEND_OP_END_RANGE              BlendOp = BLEND_OP_MAX
	BLEND_OP_RANGE_SIZE             BlendOp = (BLEND_OP_MAX - BLEND_OP_ADD + 1)
	BLEND_OP_MAX_ENUM               BlendOp = 2147483647
)

type DynamicState int

const (
	DYNAMIC_STATE_VIEWPORT              DynamicState = 0
	DYNAMIC_STATE_SCISSOR               DynamicState = 1
	DYNAMIC_STATE_LINE_WIDTH            DynamicState = 2
	DYNAMIC_STATE_DEPTH_BIAS            DynamicState = 3
	DYNAMIC_STATE_BLEND_CONSTANTS       DynamicState = 4
	DYNAMIC_STATE_DEPTH_BOUNDS          DynamicState = 5
	DYNAMIC_STATE_STENCIL_COMPARE_MASK  DynamicState = 6
	DYNAMIC_STATE_STENCIL_WRITE_MASK    DynamicState = 7
	DYNAMIC_STATE_STENCIL_REFERENCE     DynamicState = 8
	DYNAMIC_STATE_VIEWPORT_W_SCALING_NV DynamicState = 1000087000
	DYNAMIC_STATE_DISCARD_RECTANGLE_EXT DynamicState = 1000099000
	DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT  DynamicState = 1000143000
	DYNAMIC_STATE_BEGIN_RANGE           DynamicState = DYNAMIC_STATE_VIEWPORT
	DYNAMIC_STATE_END_RANGE             DynamicState = DYNAMIC_STATE_STENCIL_REFERENCE
	DYNAMIC_STATE_RANGE_SIZE            DynamicState = (DYNAMIC_STATE_STENCIL_REFERENCE - DYNAMIC_STATE_VIEWPORT + 1)
	DYNAMIC_STATE_MAX_ENUM              DynamicState = 2147483647
)

type Filter int

const (
	FILTER_NEAREST     Filter = 0
	FILTER_LINEAR      Filter = 1
	FILTER_CUBIC_IMG   Filter = 1000015000
	FILTER_BEGIN_RANGE Filter = FILTER_NEAREST
	FILTER_END_RANGE   Filter = FILTER_LINEAR
	FILTER_RANGE_SIZE  Filter = (FILTER_LINEAR - FILTER_NEAREST + 1)
	FILTER_MAX_ENUM    Filter = 2147483647
)

type SamplerMipmapMode int

const (
	SAMPLER_MIPMAP_MODE_NEAREST     SamplerMipmapMode = 0
	SAMPLER_MIPMAP_MODE_LINEAR      SamplerMipmapMode = 1
	SAMPLER_MIPMAP_MODE_BEGIN_RANGE SamplerMipmapMode = SAMPLER_MIPMAP_MODE_NEAREST
	SAMPLER_MIPMAP_MODE_END_RANGE   SamplerMipmapMode = SAMPLER_MIPMAP_MODE_LINEAR
	SAMPLER_MIPMAP_MODE_RANGE_SIZE  SamplerMipmapMode = (SAMPLER_MIPMAP_MODE_LINEAR - SAMPLER_MIPMAP_MODE_NEAREST + 1)
	SAMPLER_MIPMAP_MODE_MAX_ENUM    SamplerMipmapMode = 2147483647
)

type SamplerAddressMode int

const (
	SAMPLER_ADDRESS_MODE_REPEAT               SamplerAddressMode = 0
	SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      SamplerAddressMode = 1
	SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        SamplerAddressMode = 2
	SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      SamplerAddressMode = 3
	SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE SamplerAddressMode = 4
	SAMPLER_ADDRESS_MODE_BEGIN_RANGE          SamplerAddressMode = SAMPLER_ADDRESS_MODE_REPEAT
	SAMPLER_ADDRESS_MODE_END_RANGE            SamplerAddressMode = SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER
	SAMPLER_ADDRESS_MODE_RANGE_SIZE           SamplerAddressMode = (SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - SAMPLER_ADDRESS_MODE_REPEAT + 1)
	SAMPLER_ADDRESS_MODE_MAX_ENUM             SamplerAddressMode = 2147483647
)

type BorderColor int

const (
	BORDER_COLOR_FLOAT_TRANSPARENT_BLACK BorderColor = 0
	BORDER_COLOR_INT_TRANSPARENT_BLACK   BorderColor = 1
	BORDER_COLOR_FLOAT_OPAQUE_BLACK      BorderColor = 2
	BORDER_COLOR_INT_OPAQUE_BLACK        BorderColor = 3
	BORDER_COLOR_FLOAT_OPAQUE_WHITE      BorderColor = 4
	BORDER_COLOR_INT_OPAQUE_WHITE        BorderColor = 5
	BORDER_COLOR_BEGIN_RANGE             BorderColor = BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
	BORDER_COLOR_END_RANGE               BorderColor = BORDER_COLOR_INT_OPAQUE_WHITE
	BORDER_COLOR_RANGE_SIZE              BorderColor = (BORDER_COLOR_INT_OPAQUE_WHITE - BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1)
	BORDER_COLOR_MAX_ENUM                BorderColor = 2147483647
)

type DescriptorType int

const (
	DESCRIPTOR_TYPE_SAMPLER                DescriptorType = 0
	DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DescriptorType = 1
	DESCRIPTOR_TYPE_SAMPLED_IMAGE          DescriptorType = 2
	DESCRIPTOR_TYPE_STORAGE_IMAGE          DescriptorType = 3
	DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   DescriptorType = 4
	DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   DescriptorType = 5
	DESCRIPTOR_TYPE_UNIFORM_BUFFER         DescriptorType = 6
	DESCRIPTOR_TYPE_STORAGE_BUFFER         DescriptorType = 7
	DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC DescriptorType = 8
	DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC DescriptorType = 9
	DESCRIPTOR_TYPE_INPUT_ATTACHMENT       DescriptorType = 10
	DESCRIPTOR_TYPE_BEGIN_RANGE            DescriptorType = DESCRIPTOR_TYPE_SAMPLER
	DESCRIPTOR_TYPE_END_RANGE              DescriptorType = DESCRIPTOR_TYPE_INPUT_ATTACHMENT
	DESCRIPTOR_TYPE_RANGE_SIZE             DescriptorType = (DESCRIPTOR_TYPE_INPUT_ATTACHMENT - DESCRIPTOR_TYPE_SAMPLER + 1)
	DESCRIPTOR_TYPE_MAX_ENUM               DescriptorType = 2147483647
)

type AttachmentLoadOp int

const (
	ATTACHMENT_LOAD_OP_LOAD        AttachmentLoadOp = 0
	ATTACHMENT_LOAD_OP_CLEAR       AttachmentLoadOp = 1
	ATTACHMENT_LOAD_OP_DONT_CARE   AttachmentLoadOp = 2
	ATTACHMENT_LOAD_OP_BEGIN_RANGE AttachmentLoadOp = ATTACHMENT_LOAD_OP_LOAD
	ATTACHMENT_LOAD_OP_END_RANGE   AttachmentLoadOp = ATTACHMENT_LOAD_OP_DONT_CARE
	ATTACHMENT_LOAD_OP_RANGE_SIZE  AttachmentLoadOp = (ATTACHMENT_LOAD_OP_DONT_CARE - ATTACHMENT_LOAD_OP_LOAD + 1)
	ATTACHMENT_LOAD_OP_MAX_ENUM    AttachmentLoadOp = 2147483647
)

type AttachmentStoreOp int

const (
	ATTACHMENT_STORE_OP_STORE       AttachmentStoreOp = 0
	ATTACHMENT_STORE_OP_DONT_CARE   AttachmentStoreOp = 1
	ATTACHMENT_STORE_OP_BEGIN_RANGE AttachmentStoreOp = ATTACHMENT_STORE_OP_STORE
	ATTACHMENT_STORE_OP_END_RANGE   AttachmentStoreOp = ATTACHMENT_STORE_OP_DONT_CARE
	ATTACHMENT_STORE_OP_RANGE_SIZE  AttachmentStoreOp = (ATTACHMENT_STORE_OP_DONT_CARE - ATTACHMENT_STORE_OP_STORE + 1)
	ATTACHMENT_STORE_OP_MAX_ENUM    AttachmentStoreOp = 2147483647
)

type PipelineBindPoint int

const (
	PIPELINE_BIND_POINT_GRAPHICS    PipelineBindPoint = 0
	PIPELINE_BIND_POINT_COMPUTE     PipelineBindPoint = 1
	PIPELINE_BIND_POINT_BEGIN_RANGE PipelineBindPoint = PIPELINE_BIND_POINT_GRAPHICS
	PIPELINE_BIND_POINT_END_RANGE   PipelineBindPoint = PIPELINE_BIND_POINT_COMPUTE
	PIPELINE_BIND_POINT_RANGE_SIZE  PipelineBindPoint = (PIPELINE_BIND_POINT_COMPUTE - PIPELINE_BIND_POINT_GRAPHICS + 1)
	PIPELINE_BIND_POINT_MAX_ENUM    PipelineBindPoint = 2147483647
)

type CommandBufferLevel int

const (
	COMMAND_BUFFER_LEVEL_PRIMARY     CommandBufferLevel = 0
	COMMAND_BUFFER_LEVEL_SECONDARY   CommandBufferLevel = 1
	COMMAND_BUFFER_LEVEL_BEGIN_RANGE CommandBufferLevel = COMMAND_BUFFER_LEVEL_PRIMARY
	COMMAND_BUFFER_LEVEL_END_RANGE   CommandBufferLevel = COMMAND_BUFFER_LEVEL_SECONDARY
	COMMAND_BUFFER_LEVEL_RANGE_SIZE  CommandBufferLevel = (COMMAND_BUFFER_LEVEL_SECONDARY - COMMAND_BUFFER_LEVEL_PRIMARY + 1)
	COMMAND_BUFFER_LEVEL_MAX_ENUM    CommandBufferLevel = 2147483647
)

type IndexType int

const (
	INDEX_TYPE_UINT16      IndexType = 0
	INDEX_TYPE_UINT32      IndexType = 1
	INDEX_TYPE_BEGIN_RANGE IndexType = INDEX_TYPE_UINT16
	INDEX_TYPE_END_RANGE   IndexType = INDEX_TYPE_UINT32
	INDEX_TYPE_RANGE_SIZE  IndexType = (INDEX_TYPE_UINT32 - INDEX_TYPE_UINT16 + 1)
	INDEX_TYPE_MAX_ENUM    IndexType = 2147483647
)

type SubpassContents int

const (
	SUBPASS_CONTENTS_INLINE                    SubpassContents = 0
	SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS SubpassContents = 1
	SUBPASS_CONTENTS_BEGIN_RANGE               SubpassContents = SUBPASS_CONTENTS_INLINE
	SUBPASS_CONTENTS_END_RANGE                 SubpassContents = SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
	SUBPASS_CONTENTS_RANGE_SIZE                SubpassContents = (SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - SUBPASS_CONTENTS_INLINE + 1)
	SUBPASS_CONTENTS_MAX_ENUM                  SubpassContents = 2147483647
)

type ObjectType int

const (
	OBJECT_TYPE_UNKNOWN                        ObjectType = 0
	OBJECT_TYPE_INSTANCE                       ObjectType = 1
	OBJECT_TYPE_PHYSICAL_DEVICE                ObjectType = 2
	OBJECT_TYPE_DEVICE                         ObjectType = 3
	OBJECT_TYPE_QUEUE                          ObjectType = 4
	OBJECT_TYPE_SEMAPHORE                      ObjectType = 5
	OBJECT_TYPE_COMMAND_BUFFER                 ObjectType = 6
	OBJECT_TYPE_FENCE                          ObjectType = 7
	OBJECT_TYPE_DEVICE_MEMORY                  ObjectType = 8
	OBJECT_TYPE_BUFFER                         ObjectType = 9
	OBJECT_TYPE_IMAGE                          ObjectType = 10
	OBJECT_TYPE_EVENT                          ObjectType = 11
	OBJECT_TYPE_QUERY_POOL                     ObjectType = 12
	OBJECT_TYPE_BUFFER_VIEW                    ObjectType = 13
	OBJECT_TYPE_IMAGE_VIEW                     ObjectType = 14
	OBJECT_TYPE_SHADER_MODULE                  ObjectType = 15
	OBJECT_TYPE_PIPELINE_CACHE                 ObjectType = 16
	OBJECT_TYPE_PIPELINE_LAYOUT                ObjectType = 17
	OBJECT_TYPE_RENDER_PASS                    ObjectType = 18
	OBJECT_TYPE_PIPELINE                       ObjectType = 19
	OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT          ObjectType = 20
	OBJECT_TYPE_SAMPLER                        ObjectType = 21
	OBJECT_TYPE_DESCRIPTOR_POOL                ObjectType = 22
	OBJECT_TYPE_DESCRIPTOR_SET                 ObjectType = 23
	OBJECT_TYPE_FRAMEBUFFER                    ObjectType = 24
	OBJECT_TYPE_COMMAND_POOL                   ObjectType = 25
	OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION       ObjectType = 1000156000
	OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE     ObjectType = 1000085000
	OBJECT_TYPE_SURFACE_KHR                    ObjectType = 1000000000
	OBJECT_TYPE_SWAPCHAIN_KHR                  ObjectType = 1000001000
	OBJECT_TYPE_DISPLAY_KHR                    ObjectType = 1000002000
	OBJECT_TYPE_DISPLAY_MODE_KHR               ObjectType = 1000002001
	OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT      ObjectType = 1000011000
	OBJECT_TYPE_OBJECT_TABLE_NVX               ObjectType = 1000086000
	OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX   ObjectType = 1000086001
	OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT      ObjectType = 1000128000
	OBJECT_TYPE_VALIDATION_CACHE_EXT           ObjectType = 1000160000
	OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR ObjectType = OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
	OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR   ObjectType = OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
	OBJECT_TYPE_BEGIN_RANGE                    ObjectType = OBJECT_TYPE_UNKNOWN
	OBJECT_TYPE_END_RANGE                      ObjectType = OBJECT_TYPE_COMMAND_POOL
	OBJECT_TYPE_RANGE_SIZE                     ObjectType = (OBJECT_TYPE_COMMAND_POOL - OBJECT_TYPE_UNKNOWN + 1)
	OBJECT_TYPE_MAX_ENUM                       ObjectType = 2147483647
)

type VendorId int

const (
	VENDOR_ID_VIV         VendorId = 65537
	VENDOR_ID_VSI         VendorId = 65538
	VENDOR_ID_KAZAN       VendorId = 65539
	VENDOR_ID_BEGIN_RANGE VendorId = VENDOR_ID_VIV
	VENDOR_ID_END_RANGE   VendorId = VENDOR_ID_KAZAN
	VENDOR_ID_RANGE_SIZE  VendorId = (VENDOR_ID_KAZAN - VENDOR_ID_VIV + 1)
	VENDOR_ID_MAX_ENUM    VendorId = 2147483647
)

type FormatFeatureFlagBits int

const (
	FORMAT_FEATURE_SAMPLED_IMAGE_BIT                                                               FormatFeatureFlagBits = 1
	FORMAT_FEATURE_STORAGE_IMAGE_BIT                                                               FormatFeatureFlagBits = 2
	FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT                                                        FormatFeatureFlagBits = 4
	FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT                                                        FormatFeatureFlagBits = 8
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT                                                        FormatFeatureFlagBits = 16
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                                 FormatFeatureFlagBits = 32
	FORMAT_FEATURE_VERTEX_BUFFER_BIT                                                               FormatFeatureFlagBits = 64
	FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                                                            FormatFeatureFlagBits = 128
	FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT                                                      FormatFeatureFlagBits = 256
	FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT                                                    FormatFeatureFlagBits = 512
	FORMAT_FEATURE_BLIT_SRC_BIT                                                                    FormatFeatureFlagBits = 1024
	FORMAT_FEATURE_BLIT_DST_BIT                                                                    FormatFeatureFlagBits = 2048
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT                                                 FormatFeatureFlagBits = 4096
	FORMAT_FEATURE_TRANSFER_SRC_BIT                                                                FormatFeatureFlagBits = 16384
	FORMAT_FEATURE_TRANSFER_DST_BIT                                                                FormatFeatureFlagBits = 32768
	FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                                     FormatFeatureFlagBits = 131072
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                                FormatFeatureFlagBits = 262144
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT               FormatFeatureFlagBits = 524288
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT               FormatFeatureFlagBits = 1048576
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT     FormatFeatureFlagBits = 2097152
	FORMAT_FEATURE_DISJOINT_BIT                                                                    FormatFeatureFlagBits = 4194304
	FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                                      FormatFeatureFlagBits = 8388608
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG                                              FormatFeatureFlagBits = 8192
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT                                             FormatFeatureFlagBits = 65536
	FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR                                                            FormatFeatureFlagBits = FORMAT_FEATURE_TRANSFER_SRC_BIT
	FORMAT_FEATURE_TRANSFER_DST_BIT_KHR                                                            FormatFeatureFlagBits = FORMAT_FEATURE_TRANSFER_DST_BIT
	FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                 FormatFeatureFlagBits = FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                            FormatFeatureFlagBits = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR           FormatFeatureFlagBits = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR           FormatFeatureFlagBits = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
	FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR FormatFeatureFlagBits = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
	FORMAT_FEATURE_DISJOINT_BIT_KHR                                                                FormatFeatureFlagBits = FORMAT_FEATURE_DISJOINT_BIT
	FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR                                                  FormatFeatureFlagBits = FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
	FORMAT_FEATURE_FLAG_BITS_MAX_ENUM                                                              FormatFeatureFlagBits = 2147483647
)

type ImageUsageFlagBits int

const (
	IMAGE_USAGE_TRANSFER_SRC_BIT             ImageUsageFlagBits = 1
	IMAGE_USAGE_TRANSFER_DST_BIT             ImageUsageFlagBits = 2
	IMAGE_USAGE_SAMPLED_BIT                  ImageUsageFlagBits = 4
	IMAGE_USAGE_STORAGE_BIT                  ImageUsageFlagBits = 8
	IMAGE_USAGE_COLOR_ATTACHMENT_BIT         ImageUsageFlagBits = 16
	IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ImageUsageFlagBits = 32
	IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     ImageUsageFlagBits = 64
	IMAGE_USAGE_INPUT_ATTACHMENT_BIT         ImageUsageFlagBits = 128
	IMAGE_USAGE_FLAG_BITS_MAX_ENUM           ImageUsageFlagBits = 2147483647
)

type ImageCreateFlagBits int

const (
	IMAGE_CREATE_SPARSE_BINDING_BIT                        ImageCreateFlagBits = 1
	IMAGE_CREATE_SPARSE_RESIDENCY_BIT                      ImageCreateFlagBits = 2
	IMAGE_CREATE_SPARSE_ALIASED_BIT                        ImageCreateFlagBits = 4
	IMAGE_CREATE_MUTABLE_FORMAT_BIT                        ImageCreateFlagBits = 8
	IMAGE_CREATE_CUBE_COMPATIBLE_BIT                       ImageCreateFlagBits = 16
	IMAGE_CREATE_ALIAS_BIT                                 ImageCreateFlagBits = 1024
	IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT           ImageCreateFlagBits = 64
	IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT                   ImageCreateFlagBits = 32
	IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT           ImageCreateFlagBits = 128
	IMAGE_CREATE_EXTENDED_USAGE_BIT                        ImageCreateFlagBits = 256
	IMAGE_CREATE_PROTECTED_BIT                             ImageCreateFlagBits = 2048
	IMAGE_CREATE_DISJOINT_BIT                              ImageCreateFlagBits = 512
	IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT ImageCreateFlagBits = 4096
	IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR       ImageCreateFlagBits = IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
	IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR               ImageCreateFlagBits = IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
	IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR       ImageCreateFlagBits = IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
	IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR                    ImageCreateFlagBits = IMAGE_CREATE_EXTENDED_USAGE_BIT
	IMAGE_CREATE_DISJOINT_BIT_KHR                          ImageCreateFlagBits = IMAGE_CREATE_DISJOINT_BIT
	IMAGE_CREATE_ALIAS_BIT_KHR                             ImageCreateFlagBits = IMAGE_CREATE_ALIAS_BIT
	IMAGE_CREATE_FLAG_BITS_MAX_ENUM                        ImageCreateFlagBits = 2147483647
)

type SampleCountFlagBits int

const (
	SAMPLE_COUNT_1_BIT              SampleCountFlagBits = 1
	SAMPLE_COUNT_2_BIT              SampleCountFlagBits = 2
	SAMPLE_COUNT_4_BIT              SampleCountFlagBits = 4
	SAMPLE_COUNT_8_BIT              SampleCountFlagBits = 8
	SAMPLE_COUNT_16_BIT             SampleCountFlagBits = 16
	SAMPLE_COUNT_32_BIT             SampleCountFlagBits = 32
	SAMPLE_COUNT_64_BIT             SampleCountFlagBits = 64
	SAMPLE_COUNT_FLAG_BITS_MAX_ENUM SampleCountFlagBits = 2147483647
)

type QueueFlagBits int

const (
	QUEUE_GRAPHICS_BIT       QueueFlagBits = 1
	QUEUE_COMPUTE_BIT        QueueFlagBits = 2
	QUEUE_TRANSFER_BIT       QueueFlagBits = 4
	QUEUE_SPARSE_BINDING_BIT QueueFlagBits = 8
	QUEUE_PROTECTED_BIT      QueueFlagBits = 16
	QUEUE_FLAG_BITS_MAX_ENUM QueueFlagBits = 2147483647
)

type MemoryPropertyFlagBits int

const (
	MEMORY_PROPERTY_DEVICE_LOCAL_BIT     MemoryPropertyFlagBits = 1
	MEMORY_PROPERTY_HOST_VISIBLE_BIT     MemoryPropertyFlagBits = 2
	MEMORY_PROPERTY_HOST_COHERENT_BIT    MemoryPropertyFlagBits = 4
	MEMORY_PROPERTY_HOST_CACHED_BIT      MemoryPropertyFlagBits = 8
	MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT MemoryPropertyFlagBits = 16
	MEMORY_PROPERTY_PROTECTED_BIT        MemoryPropertyFlagBits = 32
	MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM   MemoryPropertyFlagBits = 2147483647
)

type MemoryHeapFlagBits int

const (
	MEMORY_HEAP_DEVICE_LOCAL_BIT       MemoryHeapFlagBits = 1
	MEMORY_HEAP_MULTI_INSTANCE_BIT     MemoryHeapFlagBits = 2
	MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR MemoryHeapFlagBits = MEMORY_HEAP_MULTI_INSTANCE_BIT
	MEMORY_HEAP_FLAG_BITS_MAX_ENUM     MemoryHeapFlagBits = 2147483647
)

type DeviceQueueCreateFlagBits int

const (
	DEVICE_QUEUE_CREATE_PROTECTED_BIT      DeviceQueueCreateFlagBits = 1
	DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM DeviceQueueCreateFlagBits = 2147483647
)

type PipelineStageFlagBits int

const (
	PIPELINE_STAGE_TOP_OF_PIPE_BIT                    PipelineStageFlagBits = 1
	PIPELINE_STAGE_DRAW_INDIRECT_BIT                  PipelineStageFlagBits = 2
	PIPELINE_STAGE_VERTEX_INPUT_BIT                   PipelineStageFlagBits = 4
	PIPELINE_STAGE_VERTEX_SHADER_BIT                  PipelineStageFlagBits = 8
	PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    PipelineStageFlagBits = 16
	PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT PipelineStageFlagBits = 32
	PIPELINE_STAGE_GEOMETRY_SHADER_BIT                PipelineStageFlagBits = 64
	PIPELINE_STAGE_FRAGMENT_SHADER_BIT                PipelineStageFlagBits = 128
	PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           PipelineStageFlagBits = 256
	PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            PipelineStageFlagBits = 512
	PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        PipelineStageFlagBits = 1024
	PIPELINE_STAGE_COMPUTE_SHADER_BIT                 PipelineStageFlagBits = 2048
	PIPELINE_STAGE_TRANSFER_BIT                       PipelineStageFlagBits = 4096
	PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 PipelineStageFlagBits = 8192
	PIPELINE_STAGE_HOST_BIT                           PipelineStageFlagBits = 16384
	PIPELINE_STAGE_ALL_GRAPHICS_BIT                   PipelineStageFlagBits = 32768
	PIPELINE_STAGE_ALL_COMMANDS_BIT                   PipelineStageFlagBits = 65536
	PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT      PipelineStageFlagBits = 262144
	PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX            PipelineStageFlagBits = 131072
	PIPELINE_STAGE_FLAG_BITS_MAX_ENUM                 PipelineStageFlagBits = 2147483647
)

type ImageAspectFlagBits int

const (
	IMAGE_ASPECT_COLOR_BIT          ImageAspectFlagBits = 1
	IMAGE_ASPECT_DEPTH_BIT          ImageAspectFlagBits = 2
	IMAGE_ASPECT_STENCIL_BIT        ImageAspectFlagBits = 4
	IMAGE_ASPECT_METADATA_BIT       ImageAspectFlagBits = 8
	IMAGE_ASPECT_PLANE_0_BIT        ImageAspectFlagBits = 16
	IMAGE_ASPECT_PLANE_1_BIT        ImageAspectFlagBits = 32
	IMAGE_ASPECT_PLANE_2_BIT        ImageAspectFlagBits = 64
	IMAGE_ASPECT_PLANE_0_BIT_KHR    ImageAspectFlagBits = IMAGE_ASPECT_PLANE_0_BIT
	IMAGE_ASPECT_PLANE_1_BIT_KHR    ImageAspectFlagBits = IMAGE_ASPECT_PLANE_1_BIT
	IMAGE_ASPECT_PLANE_2_BIT_KHR    ImageAspectFlagBits = IMAGE_ASPECT_PLANE_2_BIT
	IMAGE_ASPECT_FLAG_BITS_MAX_ENUM ImageAspectFlagBits = 2147483647
)

type SparseImageFormatFlagBits int

const (
	SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         SparseImageFormatFlagBits = 1
	SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       SparseImageFormatFlagBits = 2
	SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT SparseImageFormatFlagBits = 4
	SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM         SparseImageFormatFlagBits = 2147483647
)

type SparseMemoryBindFlagBits int

const (
	SPARSE_MEMORY_BIND_METADATA_BIT       SparseMemoryBindFlagBits = 1
	SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM SparseMemoryBindFlagBits = 2147483647
)

type FenceCreateFlagBits int

const (
	FENCE_CREATE_SIGNALED_BIT       FenceCreateFlagBits = 1
	FENCE_CREATE_FLAG_BITS_MAX_ENUM FenceCreateFlagBits = 2147483647
)

type QueryPipelineStatisticFlagBits int

const (
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    QueryPipelineStatisticFlagBits = 1
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  QueryPipelineStatisticFlagBits = 2
	QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  QueryPipelineStatisticFlagBits = 4
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = 8
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 QueryPipelineStatisticFlagBits = 16
	QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       QueryPipelineStatisticFlagBits = 32
	QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        QueryPipelineStatisticFlagBits = 64
	QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = 128
	QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        QueryPipelineStatisticFlagBits = 256
	QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = 512
	QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 QueryPipelineStatisticFlagBits = 1024
	QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM                             QueryPipelineStatisticFlagBits = 2147483647
)

type QueryResultFlagBits int

const (
	QUERY_RESULT_64_BIT                QueryResultFlagBits = 1
	QUERY_RESULT_WAIT_BIT              QueryResultFlagBits = 2
	QUERY_RESULT_WITH_AVAILABILITY_BIT QueryResultFlagBits = 4
	QUERY_RESULT_PARTIAL_BIT           QueryResultFlagBits = 8
	QUERY_RESULT_FLAG_BITS_MAX_ENUM    QueryResultFlagBits = 2147483647
)

type BufferCreateFlagBits int

const (
	BUFFER_CREATE_SPARSE_BINDING_BIT   BufferCreateFlagBits = 1
	BUFFER_CREATE_SPARSE_RESIDENCY_BIT BufferCreateFlagBits = 2
	BUFFER_CREATE_SPARSE_ALIASED_BIT   BufferCreateFlagBits = 4
	BUFFER_CREATE_PROTECTED_BIT        BufferCreateFlagBits = 8
	BUFFER_CREATE_FLAG_BITS_MAX_ENUM   BufferCreateFlagBits = 2147483647
)

type BufferUsageFlagBits int

const (
	BUFFER_USAGE_TRANSFER_SRC_BIT              BufferUsageFlagBits = 1
	BUFFER_USAGE_TRANSFER_DST_BIT              BufferUsageFlagBits = 2
	BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT      BufferUsageFlagBits = 4
	BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT      BufferUsageFlagBits = 8
	BUFFER_USAGE_UNIFORM_BUFFER_BIT            BufferUsageFlagBits = 16
	BUFFER_USAGE_STORAGE_BUFFER_BIT            BufferUsageFlagBits = 32
	BUFFER_USAGE_INDEX_BUFFER_BIT              BufferUsageFlagBits = 64
	BUFFER_USAGE_VERTEX_BUFFER_BIT             BufferUsageFlagBits = 128
	BUFFER_USAGE_INDIRECT_BUFFER_BIT           BufferUsageFlagBits = 256
	BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT BufferUsageFlagBits = 512
	BUFFER_USAGE_FLAG_BITS_MAX_ENUM            BufferUsageFlagBits = 2147483647
)

type PipelineCreateFlagBits int

const (
	PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT             PipelineCreateFlagBits = 1
	PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                PipelineCreateFlagBits = 2
	PIPELINE_CREATE_DERIVATIVE_BIT                       PipelineCreateFlagBits = 4
	PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT     PipelineCreateFlagBits = 8
	PIPELINE_CREATE_DISPATCH_BASE                        PipelineCreateFlagBits = 16
	PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR PipelineCreateFlagBits = PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT
	PIPELINE_CREATE_DISPATCH_BASE_KHR                    PipelineCreateFlagBits = PIPELINE_CREATE_DISPATCH_BASE
	PIPELINE_CREATE_FLAG_BITS_MAX_ENUM                   PipelineCreateFlagBits = 2147483647
)

type ShaderStageFlagBits int

const (
	SHADER_STAGE_VERTEX_BIT                  ShaderStageFlagBits = 1
	SHADER_STAGE_TESSELLATION_CONTROL_BIT    ShaderStageFlagBits = 2
	SHADER_STAGE_TESSELLATION_EVALUATION_BIT ShaderStageFlagBits = 4
	SHADER_STAGE_GEOMETRY_BIT                ShaderStageFlagBits = 8
	SHADER_STAGE_FRAGMENT_BIT                ShaderStageFlagBits = 16
	SHADER_STAGE_COMPUTE_BIT                 ShaderStageFlagBits = 32
	SHADER_STAGE_ALL_GRAPHICS                ShaderStageFlagBits = 31
	SHADER_STAGE_ALL                         ShaderStageFlagBits = 2147483647
	SHADER_STAGE_FLAG_BITS_MAX_ENUM          ShaderStageFlagBits = 2147483647
)

type CullModeFlagBits int

const (
	CULL_MODE_NONE               CullModeFlagBits = 0
	CULL_MODE_FRONT_BIT          CullModeFlagBits = 1
	CULL_MODE_BACK_BIT           CullModeFlagBits = 2
	CULL_MODE_FRONT_AND_BACK     CullModeFlagBits = 3
	CULL_MODE_FLAG_BITS_MAX_ENUM CullModeFlagBits = 2147483647
)

type ColorComponentFlagBits int

const (
	COLOR_COMPONENT_R_BIT              ColorComponentFlagBits = 1
	COLOR_COMPONENT_G_BIT              ColorComponentFlagBits = 2
	COLOR_COMPONENT_B_BIT              ColorComponentFlagBits = 4
	COLOR_COMPONENT_A_BIT              ColorComponentFlagBits = 8
	COLOR_COMPONENT_FLAG_BITS_MAX_ENUM ColorComponentFlagBits = 2147483647
)

type DescriptorSetLayoutCreateFlagBits int

const (
	DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR        DescriptorSetLayoutCreateFlagBits = 1
	DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT DescriptorSetLayoutCreateFlagBits = 2
	DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM             DescriptorSetLayoutCreateFlagBits = 2147483647
)

type DescriptorPoolCreateFlagBits int

const (
	DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT   DescriptorPoolCreateFlagBits = 1
	DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT DescriptorPoolCreateFlagBits = 2
	DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM        DescriptorPoolCreateFlagBits = 2147483647
)

type AttachmentDescriptionFlagBits int

const (
	ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT      AttachmentDescriptionFlagBits = 1
	ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM AttachmentDescriptionFlagBits = 2147483647
)

type SubpassDescriptionFlagBits int

const (
	SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX      SubpassDescriptionFlagBits = 1
	SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX SubpassDescriptionFlagBits = 2
	SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM               SubpassDescriptionFlagBits = 2147483647
)

type AccessFlagBits int

const (
	ACCESS_INDIRECT_COMMAND_READ_BIT                 AccessFlagBits = 1
	ACCESS_INDEX_READ_BIT                            AccessFlagBits = 2
	ACCESS_VERTEX_ATTRIBUTE_READ_BIT                 AccessFlagBits = 4
	ACCESS_UNIFORM_READ_BIT                          AccessFlagBits = 8
	ACCESS_INPUT_ATTACHMENT_READ_BIT                 AccessFlagBits = 16
	ACCESS_SHADER_READ_BIT                           AccessFlagBits = 32
	ACCESS_SHADER_WRITE_BIT                          AccessFlagBits = 64
	ACCESS_COLOR_ATTACHMENT_READ_BIT                 AccessFlagBits = 128
	ACCESS_COLOR_ATTACHMENT_WRITE_BIT                AccessFlagBits = 256
	ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT         AccessFlagBits = 512
	ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT        AccessFlagBits = 1024
	ACCESS_TRANSFER_READ_BIT                         AccessFlagBits = 2048
	ACCESS_TRANSFER_WRITE_BIT                        AccessFlagBits = 4096
	ACCESS_HOST_READ_BIT                             AccessFlagBits = 8192
	ACCESS_HOST_WRITE_BIT                            AccessFlagBits = 16384
	ACCESS_MEMORY_READ_BIT                           AccessFlagBits = 32768
	ACCESS_MEMORY_WRITE_BIT                          AccessFlagBits = 65536
	ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT        AccessFlagBits = 1048576
	ACCESS_COMMAND_PROCESS_READ_BIT_NVX              AccessFlagBits = 131072
	ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX             AccessFlagBits = 262144
	ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT AccessFlagBits = 524288
	ACCESS_FLAG_BITS_MAX_ENUM                        AccessFlagBits = 2147483647
)

type DependencyFlagBits int

const (
	DEPENDENCY_BY_REGION_BIT        DependencyFlagBits = 1
	DEPENDENCY_DEVICE_GROUP_BIT     DependencyFlagBits = 4
	DEPENDENCY_VIEW_LOCAL_BIT       DependencyFlagBits = 2
	DEPENDENCY_VIEW_LOCAL_BIT_KHR   DependencyFlagBits = DEPENDENCY_VIEW_LOCAL_BIT
	DEPENDENCY_DEVICE_GROUP_BIT_KHR DependencyFlagBits = DEPENDENCY_DEVICE_GROUP_BIT
	DEPENDENCY_FLAG_BITS_MAX_ENUM   DependencyFlagBits = 2147483647
)

type CommandPoolCreateFlagBits int

const (
	COMMAND_POOL_CREATE_TRANSIENT_BIT            CommandPoolCreateFlagBits = 1
	COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT CommandPoolCreateFlagBits = 2
	COMMAND_POOL_CREATE_PROTECTED_BIT            CommandPoolCreateFlagBits = 4
	COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM       CommandPoolCreateFlagBits = 2147483647
)

type CommandPoolResetFlagBits int

const (
	COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT CommandPoolResetFlagBits = 1
	COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM    CommandPoolResetFlagBits = 2147483647
)

type CommandBufferUsageFlagBits int

const (
	COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      CommandBufferUsageFlagBits = 1
	COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT CommandBufferUsageFlagBits = 2
	COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     CommandBufferUsageFlagBits = 4
	COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM       CommandBufferUsageFlagBits = 2147483647
)

type QueryControlFlagBits int

const (
	QUERY_CONTROL_PRECISE_BIT        QueryControlFlagBits = 1
	QUERY_CONTROL_FLAG_BITS_MAX_ENUM QueryControlFlagBits = 2147483647
)

type CommandBufferResetFlagBits int

const (
	COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT CommandBufferResetFlagBits = 1
	COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM    CommandBufferResetFlagBits = 2147483647
)

type StencilFaceFlagBits int

const (
	STENCIL_FACE_FRONT_BIT          StencilFaceFlagBits = 1
	STENCIL_FACE_BACK_BIT           StencilFaceFlagBits = 2
	STENCIL_FRONT_AND_BACK          StencilFaceFlagBits = 3
	STENCIL_FACE_FLAG_BITS_MAX_ENUM StencilFaceFlagBits = 2147483647
)

type PFNAllocationFunction C.PFN_vkAllocationFunction
type FuncAllocationFunction func(arg0 unsafe.Pointer, arg1 uint, arg2 uint, arg3 SystemAllocationScope) (_ret unsafe.Pointer)

func ToAllocationFunction(p PFNVoidFunction) (fn FuncAllocationFunction) {
	return func(arg0 unsafe.Pointer, arg1 uint, arg2 uint, arg3 SystemAllocationScope) (_ret unsafe.Pointer) {
		var c struct {
			arg0 unsafe.Pointer
			arg1 C.size_t
			arg2 C.size_t
			arg3 C.VkSystemAllocationScope
			_ret unsafe.Pointer
		}
		c.arg0 = arg0
		c.arg1 = C.size_t(arg1)
		c.arg2 = C.size_t(arg2)
		c.arg3 = C.VkSystemAllocationScope(arg3)
		c._ret = C.callPFN_vkAllocationFunction(C.PFN_vkAllocationFunction(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3)
		_ret = c._ret
		return
	}
}

type PFNReallocationFunction C.PFN_vkReallocationFunction
type FuncReallocationFunction func(arg0 unsafe.Pointer, arg1 unsafe.Pointer, arg2 uint, arg3 uint, arg4 SystemAllocationScope) (_ret unsafe.Pointer)

func ToReallocationFunction(p PFNVoidFunction) (fn FuncReallocationFunction) {
	return func(arg0 unsafe.Pointer, arg1 unsafe.Pointer, arg2 uint, arg3 uint, arg4 SystemAllocationScope) (_ret unsafe.Pointer) {
		var c struct {
			arg0 unsafe.Pointer
			arg1 unsafe.Pointer
			arg2 C.size_t
			arg3 C.size_t
			arg4 C.VkSystemAllocationScope
			_ret unsafe.Pointer
		}
		c.arg0 = arg0
		c.arg1 = arg1
		c.arg2 = C.size_t(arg2)
		c.arg3 = C.size_t(arg3)
		c.arg4 = C.VkSystemAllocationScope(arg4)
		c._ret = C.callPFN_vkReallocationFunction(C.PFN_vkReallocationFunction(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3, c.arg4)
		_ret = c._ret
		return
	}
}

type PFNFreeFunction C.PFN_vkFreeFunction
type FuncFreeFunction func(arg0 unsafe.Pointer, arg1 unsafe.Pointer)

func ToFreeFunction(p PFNVoidFunction) (fn FuncFreeFunction) {
	return func(arg0 unsafe.Pointer, arg1 unsafe.Pointer) {
		var c struct {
			arg0 unsafe.Pointer
			arg1 unsafe.Pointer
		}
		c.arg0 = arg0
		c.arg1 = arg1
		C.callPFN_vkFreeFunction(C.PFN_vkFreeFunction(unsafe.Pointer(p)), c.arg0, c.arg1)
	}
}

type PFNInternalAllocationNotification C.PFN_vkInternalAllocationNotification
type FuncInternalAllocationNotification func(arg0 unsafe.Pointer, arg1 uint, arg2 InternalAllocationType, arg3 SystemAllocationScope)

func ToInternalAllocationNotification(p PFNVoidFunction) (fn FuncInternalAllocationNotification) {
	return func(arg0 unsafe.Pointer, arg1 uint, arg2 InternalAllocationType, arg3 SystemAllocationScope) {
		var c struct {
			arg0 unsafe.Pointer
			arg1 C.size_t
			arg2 C.VkInternalAllocationType
			arg3 C.VkSystemAllocationScope
		}
		c.arg0 = arg0
		c.arg1 = C.size_t(arg1)
		c.arg2 = C.VkInternalAllocationType(arg2)
		c.arg3 = C.VkSystemAllocationScope(arg3)
		C.callPFN_vkInternalAllocationNotification(C.PFN_vkInternalAllocationNotification(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3)
	}
}

type PFNInternalFreeNotification C.PFN_vkInternalFreeNotification
type FuncInternalFreeNotification func(arg0 unsafe.Pointer, arg1 uint, arg2 InternalAllocationType, arg3 SystemAllocationScope)

func ToInternalFreeNotification(p PFNVoidFunction) (fn FuncInternalFreeNotification) {
	return func(arg0 unsafe.Pointer, arg1 uint, arg2 InternalAllocationType, arg3 SystemAllocationScope) {
		var c struct {
			arg0 unsafe.Pointer
			arg1 C.size_t
			arg2 C.VkInternalAllocationType
			arg3 C.VkSystemAllocationScope
		}
		c.arg0 = arg0
		c.arg1 = C.size_t(arg1)
		c.arg2 = C.VkInternalAllocationType(arg2)
		c.arg3 = C.VkSystemAllocationScope(arg3)
		C.callPFN_vkInternalFreeNotification(C.PFN_vkInternalFreeNotification(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3)
	}
}

type PFNVoidFunction C.PFN_vkVoidFunction
type FuncVoidFunction func()

func ToVoidFunction(p PFNVoidFunction) (fn FuncVoidFunction) {
	return func() {
		C.callPFN_vkVoidFunction(C.PFN_vkVoidFunction(unsafe.Pointer(p)))
	}
}

type PFNCreateInstance C.PFN_vkCreateInstance
type Flags uint32
type InstanceCreateFlags Flags
type ApplicationInfo struct {
	Next               Structure
	ApplicationName    string
	ApplicationVersion uint32
	EngineName         string
	EngineVersion      uint32
	ApiVersion         uint32
}

func (g *ApplicationInfo) toC(c *C.VkApplicationInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.pApplicationName = toCString(g.ApplicationName, m)
	c.applicationVersion = C.uint32_t(g.ApplicationVersion)
	c.pEngineName = toCString(g.EngineName, m)
	c.engineVersion = C.uint32_t(g.EngineVersion)
	c.apiVersion = C.uint32_t(g.ApiVersion)
}
func (g *ApplicationInfo) fromC(c *C.VkApplicationInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ApplicationName = toGoString(c.pApplicationName)
	g.ApplicationVersion = uint32(c.applicationVersion)
	g.EngineName = toGoString(c.pEngineName)
	g.EngineVersion = uint32(c.engineVersion)
	g.ApiVersion = uint32(c.apiVersion)
}
func (s *ApplicationInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_APPLICATION_INFO
}
func (s *ApplicationInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkApplicationInfo)(m.alloc(C.sizeof_VkApplicationInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ApplicationInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkApplicationInfo)(p)
	s.fromC(c)
}
func (s *ApplicationInfo) GetNext() Structure {
	return s.Next
}
func (s *ApplicationInfo) SetNext(n Structure) {
	s.Next = n
}

type InstanceCreateInfo struct {
	Next                  Structure
	Flags                 InstanceCreateFlags
	ApplicationInfo       *ApplicationInfo
	EnabledLayerNames     []string
	EnabledExtensionNames []string
}

func (g *InstanceCreateInfo) toC(c *C.VkInstanceCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkInstanceCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkInstanceCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkInstanceCreateFlags(temp_in_VkInstanceCreateFlags)
	}
	if g.ApplicationInfo != nil {
		c.pApplicationInfo = (*C.VkApplicationInfo)(m.alloc(C.sizeof_VkApplicationInfo))
		g.ApplicationInfo.toC(c.pApplicationInfo, m)
	} else {
		c.pApplicationInfo = nil
	}
	c.enabledLayerCount = C.uint32_t(len(g.EnabledLayerNames))
	if len(g.EnabledLayerNames) != 0 {
		c.ppEnabledLayerNames = (**C.char)(m.alloc(C.sizeof_void_pointer * uint(len(g.EnabledLayerNames))))
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledLayerNames))[:len(g.EnabledLayerNames):len(g.EnabledLayerNames)]
		for i1, _ := range g.EnabledLayerNames {
			slice1[i1] = toCString(g.EnabledLayerNames[i1], m)
		}
	} else {
		c.ppEnabledLayerNames = nil
	}
	c.enabledExtensionCount = C.uint32_t(len(g.EnabledExtensionNames))
	if len(g.EnabledExtensionNames) != 0 {
		c.ppEnabledExtensionNames = (**C.char)(m.alloc(C.sizeof_void_pointer * uint(len(g.EnabledExtensionNames))))
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledExtensionNames))[:len(g.EnabledExtensionNames):len(g.EnabledExtensionNames)]
		for i1, _ := range g.EnabledExtensionNames {
			slice1[i1] = toCString(g.EnabledExtensionNames[i1], m)
		}
	} else {
		c.ppEnabledExtensionNames = nil
	}
}
func (g *InstanceCreateInfo) fromC(c *C.VkInstanceCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkInstanceCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkInstanceCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = InstanceCreateFlags(temp_in_VkInstanceCreateFlags)
	}
	if g.ApplicationInfo != nil {
		g.ApplicationInfo.fromC(c.pApplicationInfo)
	}
	g.EnabledLayerNames = make([]string, int(c.enabledLayerCount))
	if len(g.EnabledLayerNames) != 0 {
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledLayerNames))[:len(g.EnabledLayerNames):len(g.EnabledLayerNames)]
		for i1, _ := range g.EnabledLayerNames {
			g.EnabledLayerNames[i1] = toGoString(slice1[i1])
		}
	}
	g.EnabledExtensionNames = make([]string, int(c.enabledExtensionCount))
	if len(g.EnabledExtensionNames) != 0 {
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledExtensionNames))[:len(g.EnabledExtensionNames):len(g.EnabledExtensionNames)]
		for i1, _ := range g.EnabledExtensionNames {
			g.EnabledExtensionNames[i1] = toGoString(slice1[i1])
		}
	}
}
func (s *InstanceCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
}
func (s *InstanceCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkInstanceCreateInfo)(m.alloc(C.sizeof_VkInstanceCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *InstanceCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkInstanceCreateInfo)(p)
	s.fromC(c)
}
func (s *InstanceCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *InstanceCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type AllocationCallbacks struct {
	UserData           unsafe.Pointer
	Allocation         PFNAllocationFunction
	Reallocation       PFNReallocationFunction
	Free               PFNFreeFunction
	InternalAllocation PFNInternalAllocationNotification
	InternalFree       PFNInternalFreeNotification
}

func (g *AllocationCallbacks) toC(c *C.VkAllocationCallbacks) {
	c.pUserData = g.UserData
	c.pfnAllocation = C.PFN_vkAllocationFunction(g.Allocation)
	c.pfnReallocation = C.PFN_vkReallocationFunction(g.Reallocation)
	c.pfnFree = C.PFN_vkFreeFunction(g.Free)
	c.pfnInternalAllocation = C.PFN_vkInternalAllocationNotification(g.InternalAllocation)
	c.pfnInternalFree = C.PFN_vkInternalFreeNotification(g.InternalFree)
}
func (g *AllocationCallbacks) fromC(c *C.VkAllocationCallbacks) {
	g.UserData = c.pUserData
	g.Allocation = PFNAllocationFunction(c.pfnAllocation)
	g.Reallocation = PFNReallocationFunction(c.pfnReallocation)
	g.Free = PFNFreeFunction(c.pfnFree)
	g.InternalAllocation = PFNInternalAllocationNotification(c.pfnInternalAllocation)
	g.InternalFree = PFNInternalFreeNotification(c.pfnInternalFree)
}

type Instance C.VkInstance
type FuncCreateInstance func(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks, instance *Instance) (_ret Result)

func ToCreateInstance(p PFNVoidFunction) (fn FuncCreateInstance) {
	return func(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks, instance *Instance) (_ret Result) {
		var c struct {
			pCreateInfo *C.VkInstanceCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pInstance   *C.VkInstance
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkInstanceCreateInfo)(m.alloc(C.sizeof_VkInstanceCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if instance != nil {
			c.pInstance = (*C.VkInstance)(m.alloc(C.sizeof_VkInstance))
			*c.pInstance = C.VkInstance(*instance)
		} else {
			c.pInstance = nil
		}
		c._ret = C.callPFN_vkCreateInstance(C.PFN_vkCreateInstance(unsafe.Pointer(p)), c.pCreateInfo, c.pAllocator, c.pInstance)
		_ret = Result(c._ret)
		if instance != nil {
			*instance = Instance(*c.pInstance)
		}
		return
	}
}

type PFNDestroyInstance C.PFN_vkDestroyInstance
type FuncDestroyInstance func(instance Instance, allocator *AllocationCallbacks)

func ToDestroyInstance(p PFNVoidFunction) (fn FuncDestroyInstance) {
	return func(instance Instance, allocator *AllocationCallbacks) {
		var c struct {
			instance   C.VkInstance
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyInstance(C.PFN_vkDestroyInstance(unsafe.Pointer(p)), c.instance, c.pAllocator)
	}
}

type PFNEnumeratePhysicalDevices C.PFN_vkEnumeratePhysicalDevices
type PhysicalDevice C.VkPhysicalDevice
type FuncEnumeratePhysicalDevices func(instance Instance, physicalDeviceCount *uint32, physicalDevices []PhysicalDevice) (_ret Result)

func ToEnumeratePhysicalDevices(p PFNVoidFunction) (fn FuncEnumeratePhysicalDevices) {
	return func(instance Instance, physicalDeviceCount *uint32, physicalDevices []PhysicalDevice) (_ret Result) {
		var c struct {
			instance             C.VkInstance
			pPhysicalDeviceCount *C.uint32_t
			pPhysicalDevices     *C.VkPhysicalDevice
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if physicalDeviceCount != nil {
			c.pPhysicalDeviceCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPhysicalDeviceCount = C.uint32_t(*physicalDeviceCount)
		} else {
			c.pPhysicalDeviceCount = nil
		}
		if len(physicalDevices) != 0 {
			c.pPhysicalDevices = (*C.VkPhysicalDevice)(m.alloc(C.sizeof_VkPhysicalDevice * uint(len(physicalDevices))))
			slice1 := (*[1 << 31]C.VkPhysicalDevice)(unsafe.Pointer(c.pPhysicalDevices))[:len(physicalDevices):len(physicalDevices)]
			for i1, _ := range physicalDevices {
				slice1[i1] = C.VkPhysicalDevice(physicalDevices[i1])
			}
		} else {
			c.pPhysicalDevices = nil
		}
		c._ret = C.callPFN_vkEnumeratePhysicalDevices(C.PFN_vkEnumeratePhysicalDevices(unsafe.Pointer(p)), c.instance, c.pPhysicalDeviceCount, c.pPhysicalDevices)
		_ret = Result(c._ret)
		if physicalDeviceCount != nil {
			*physicalDeviceCount = uint32(*c.pPhysicalDeviceCount)
		}
		if len(physicalDevices) != 0 {
			slice1 := (*[1 << 31]C.VkPhysicalDevice)(unsafe.Pointer(c.pPhysicalDevices))[:len(physicalDevices):len(physicalDevices)]
			for i1, _ := range physicalDevices {
				physicalDevices[i1] = PhysicalDevice(slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceFeatures C.PFN_vkGetPhysicalDeviceFeatures
type PhysicalDeviceFeatures struct {
	RobustBufferAccess                      bool
	FullDrawIndexUint32                     bool
	ImageCubeArray                          bool
	IndependentBlend                        bool
	GeometryShader                          bool
	TessellationShader                      bool
	SampleRateShading                       bool
	DualSrcBlend                            bool
	LogicOp                                 bool
	MultiDrawIndirect                       bool
	DrawIndirectFirstInstance               bool
	DepthClamp                              bool
	DepthBiasClamp                          bool
	FillModeNonSolid                        bool
	DepthBounds                             bool
	WideLines                               bool
	LargePoints                             bool
	AlphaToOne                              bool
	MultiViewport                           bool
	SamplerAnisotropy                       bool
	TextureCompressionETC2                  bool
	TextureCompressionASTC_LDR              bool
	TextureCompressionBC                    bool
	OcclusionQueryPrecise                   bool
	PipelineStatisticsQuery                 bool
	VertexPipelineStoresAndAtomics          bool
	FragmentStoresAndAtomics                bool
	ShaderTessellationAndGeometryPointSize  bool
	ShaderImageGatherExtended               bool
	ShaderStorageImageExtendedFormats       bool
	ShaderStorageImageMultisample           bool
	ShaderStorageImageReadWithoutFormat     bool
	ShaderStorageImageWriteWithoutFormat    bool
	ShaderUniformBufferArrayDynamicIndexing bool
	ShaderSampledImageArrayDynamicIndexing  bool
	ShaderStorageBufferArrayDynamicIndexing bool
	ShaderStorageImageArrayDynamicIndexing  bool
	ShaderClipDistance                      bool
	ShaderCullDistance                      bool
	ShaderFloat64                           bool
	ShaderInt64                             bool
	ShaderInt16                             bool
	ShaderResourceResidency                 bool
	ShaderResourceMinLod                    bool
	SparseBinding                           bool
	SparseResidencyBuffer                   bool
	SparseResidencyImage2D                  bool
	SparseResidencyImage3D                  bool
	SparseResidency2Samples                 bool
	SparseResidency4Samples                 bool
	SparseResidency8Samples                 bool
	SparseResidency16Samples                bool
	SparseResidencyAliased                  bool
	VariableMultisampleRate                 bool
	InheritedQueries                        bool
}

func (g *PhysicalDeviceFeatures) toC(c *C.VkPhysicalDeviceFeatures) {
	if g.RobustBufferAccess {
		c.robustBufferAccess = 1
	} else {
		c.robustBufferAccess = 0
	}
	if g.FullDrawIndexUint32 {
		c.fullDrawIndexUint32 = 1
	} else {
		c.fullDrawIndexUint32 = 0
	}
	if g.ImageCubeArray {
		c.imageCubeArray = 1
	} else {
		c.imageCubeArray = 0
	}
	if g.IndependentBlend {
		c.independentBlend = 1
	} else {
		c.independentBlend = 0
	}
	if g.GeometryShader {
		c.geometryShader = 1
	} else {
		c.geometryShader = 0
	}
	if g.TessellationShader {
		c.tessellationShader = 1
	} else {
		c.tessellationShader = 0
	}
	if g.SampleRateShading {
		c.sampleRateShading = 1
	} else {
		c.sampleRateShading = 0
	}
	if g.DualSrcBlend {
		c.dualSrcBlend = 1
	} else {
		c.dualSrcBlend = 0
	}
	if g.LogicOp {
		c.logicOp = 1
	} else {
		c.logicOp = 0
	}
	if g.MultiDrawIndirect {
		c.multiDrawIndirect = 1
	} else {
		c.multiDrawIndirect = 0
	}
	if g.DrawIndirectFirstInstance {
		c.drawIndirectFirstInstance = 1
	} else {
		c.drawIndirectFirstInstance = 0
	}
	if g.DepthClamp {
		c.depthClamp = 1
	} else {
		c.depthClamp = 0
	}
	if g.DepthBiasClamp {
		c.depthBiasClamp = 1
	} else {
		c.depthBiasClamp = 0
	}
	if g.FillModeNonSolid {
		c.fillModeNonSolid = 1
	} else {
		c.fillModeNonSolid = 0
	}
	if g.DepthBounds {
		c.depthBounds = 1
	} else {
		c.depthBounds = 0
	}
	if g.WideLines {
		c.wideLines = 1
	} else {
		c.wideLines = 0
	}
	if g.LargePoints {
		c.largePoints = 1
	} else {
		c.largePoints = 0
	}
	if g.AlphaToOne {
		c.alphaToOne = 1
	} else {
		c.alphaToOne = 0
	}
	if g.MultiViewport {
		c.multiViewport = 1
	} else {
		c.multiViewport = 0
	}
	if g.SamplerAnisotropy {
		c.samplerAnisotropy = 1
	} else {
		c.samplerAnisotropy = 0
	}
	if g.TextureCompressionETC2 {
		c.textureCompressionETC2 = 1
	} else {
		c.textureCompressionETC2 = 0
	}
	if g.TextureCompressionASTC_LDR {
		c.textureCompressionASTC_LDR = 1
	} else {
		c.textureCompressionASTC_LDR = 0
	}
	if g.TextureCompressionBC {
		c.textureCompressionBC = 1
	} else {
		c.textureCompressionBC = 0
	}
	if g.OcclusionQueryPrecise {
		c.occlusionQueryPrecise = 1
	} else {
		c.occlusionQueryPrecise = 0
	}
	if g.PipelineStatisticsQuery {
		c.pipelineStatisticsQuery = 1
	} else {
		c.pipelineStatisticsQuery = 0
	}
	if g.VertexPipelineStoresAndAtomics {
		c.vertexPipelineStoresAndAtomics = 1
	} else {
		c.vertexPipelineStoresAndAtomics = 0
	}
	if g.FragmentStoresAndAtomics {
		c.fragmentStoresAndAtomics = 1
	} else {
		c.fragmentStoresAndAtomics = 0
	}
	if g.ShaderTessellationAndGeometryPointSize {
		c.shaderTessellationAndGeometryPointSize = 1
	} else {
		c.shaderTessellationAndGeometryPointSize = 0
	}
	if g.ShaderImageGatherExtended {
		c.shaderImageGatherExtended = 1
	} else {
		c.shaderImageGatherExtended = 0
	}
	if g.ShaderStorageImageExtendedFormats {
		c.shaderStorageImageExtendedFormats = 1
	} else {
		c.shaderStorageImageExtendedFormats = 0
	}
	if g.ShaderStorageImageMultisample {
		c.shaderStorageImageMultisample = 1
	} else {
		c.shaderStorageImageMultisample = 0
	}
	if g.ShaderStorageImageReadWithoutFormat {
		c.shaderStorageImageReadWithoutFormat = 1
	} else {
		c.shaderStorageImageReadWithoutFormat = 0
	}
	if g.ShaderStorageImageWriteWithoutFormat {
		c.shaderStorageImageWriteWithoutFormat = 1
	} else {
		c.shaderStorageImageWriteWithoutFormat = 0
	}
	if g.ShaderUniformBufferArrayDynamicIndexing {
		c.shaderUniformBufferArrayDynamicIndexing = 1
	} else {
		c.shaderUniformBufferArrayDynamicIndexing = 0
	}
	if g.ShaderSampledImageArrayDynamicIndexing {
		c.shaderSampledImageArrayDynamicIndexing = 1
	} else {
		c.shaderSampledImageArrayDynamicIndexing = 0
	}
	if g.ShaderStorageBufferArrayDynamicIndexing {
		c.shaderStorageBufferArrayDynamicIndexing = 1
	} else {
		c.shaderStorageBufferArrayDynamicIndexing = 0
	}
	if g.ShaderStorageImageArrayDynamicIndexing {
		c.shaderStorageImageArrayDynamicIndexing = 1
	} else {
		c.shaderStorageImageArrayDynamicIndexing = 0
	}
	if g.ShaderClipDistance {
		c.shaderClipDistance = 1
	} else {
		c.shaderClipDistance = 0
	}
	if g.ShaderCullDistance {
		c.shaderCullDistance = 1
	} else {
		c.shaderCullDistance = 0
	}
	if g.ShaderFloat64 {
		c.shaderFloat64 = 1
	} else {
		c.shaderFloat64 = 0
	}
	if g.ShaderInt64 {
		c.shaderInt64 = 1
	} else {
		c.shaderInt64 = 0
	}
	if g.ShaderInt16 {
		c.shaderInt16 = 1
	} else {
		c.shaderInt16 = 0
	}
	if g.ShaderResourceResidency {
		c.shaderResourceResidency = 1
	} else {
		c.shaderResourceResidency = 0
	}
	if g.ShaderResourceMinLod {
		c.shaderResourceMinLod = 1
	} else {
		c.shaderResourceMinLod = 0
	}
	if g.SparseBinding {
		c.sparseBinding = 1
	} else {
		c.sparseBinding = 0
	}
	if g.SparseResidencyBuffer {
		c.sparseResidencyBuffer = 1
	} else {
		c.sparseResidencyBuffer = 0
	}
	if g.SparseResidencyImage2D {
		c.sparseResidencyImage2D = 1
	} else {
		c.sparseResidencyImage2D = 0
	}
	if g.SparseResidencyImage3D {
		c.sparseResidencyImage3D = 1
	} else {
		c.sparseResidencyImage3D = 0
	}
	if g.SparseResidency2Samples {
		c.sparseResidency2Samples = 1
	} else {
		c.sparseResidency2Samples = 0
	}
	if g.SparseResidency4Samples {
		c.sparseResidency4Samples = 1
	} else {
		c.sparseResidency4Samples = 0
	}
	if g.SparseResidency8Samples {
		c.sparseResidency8Samples = 1
	} else {
		c.sparseResidency8Samples = 0
	}
	if g.SparseResidency16Samples {
		c.sparseResidency16Samples = 1
	} else {
		c.sparseResidency16Samples = 0
	}
	if g.SparseResidencyAliased {
		c.sparseResidencyAliased = 1
	} else {
		c.sparseResidencyAliased = 0
	}
	if g.VariableMultisampleRate {
		c.variableMultisampleRate = 1
	} else {
		c.variableMultisampleRate = 0
	}
	if g.InheritedQueries {
		c.inheritedQueries = 1
	} else {
		c.inheritedQueries = 0
	}
}
func (g *PhysicalDeviceFeatures) fromC(c *C.VkPhysicalDeviceFeatures) {
	g.RobustBufferAccess = c.robustBufferAccess != 0
	g.FullDrawIndexUint32 = c.fullDrawIndexUint32 != 0
	g.ImageCubeArray = c.imageCubeArray != 0
	g.IndependentBlend = c.independentBlend != 0
	g.GeometryShader = c.geometryShader != 0
	g.TessellationShader = c.tessellationShader != 0
	g.SampleRateShading = c.sampleRateShading != 0
	g.DualSrcBlend = c.dualSrcBlend != 0
	g.LogicOp = c.logicOp != 0
	g.MultiDrawIndirect = c.multiDrawIndirect != 0
	g.DrawIndirectFirstInstance = c.drawIndirectFirstInstance != 0
	g.DepthClamp = c.depthClamp != 0
	g.DepthBiasClamp = c.depthBiasClamp != 0
	g.FillModeNonSolid = c.fillModeNonSolid != 0
	g.DepthBounds = c.depthBounds != 0
	g.WideLines = c.wideLines != 0
	g.LargePoints = c.largePoints != 0
	g.AlphaToOne = c.alphaToOne != 0
	g.MultiViewport = c.multiViewport != 0
	g.SamplerAnisotropy = c.samplerAnisotropy != 0
	g.TextureCompressionETC2 = c.textureCompressionETC2 != 0
	g.TextureCompressionASTC_LDR = c.textureCompressionASTC_LDR != 0
	g.TextureCompressionBC = c.textureCompressionBC != 0
	g.OcclusionQueryPrecise = c.occlusionQueryPrecise != 0
	g.PipelineStatisticsQuery = c.pipelineStatisticsQuery != 0
	g.VertexPipelineStoresAndAtomics = c.vertexPipelineStoresAndAtomics != 0
	g.FragmentStoresAndAtomics = c.fragmentStoresAndAtomics != 0
	g.ShaderTessellationAndGeometryPointSize = c.shaderTessellationAndGeometryPointSize != 0
	g.ShaderImageGatherExtended = c.shaderImageGatherExtended != 0
	g.ShaderStorageImageExtendedFormats = c.shaderStorageImageExtendedFormats != 0
	g.ShaderStorageImageMultisample = c.shaderStorageImageMultisample != 0
	g.ShaderStorageImageReadWithoutFormat = c.shaderStorageImageReadWithoutFormat != 0
	g.ShaderStorageImageWriteWithoutFormat = c.shaderStorageImageWriteWithoutFormat != 0
	g.ShaderUniformBufferArrayDynamicIndexing = c.shaderUniformBufferArrayDynamicIndexing != 0
	g.ShaderSampledImageArrayDynamicIndexing = c.shaderSampledImageArrayDynamicIndexing != 0
	g.ShaderStorageBufferArrayDynamicIndexing = c.shaderStorageBufferArrayDynamicIndexing != 0
	g.ShaderStorageImageArrayDynamicIndexing = c.shaderStorageImageArrayDynamicIndexing != 0
	g.ShaderClipDistance = c.shaderClipDistance != 0
	g.ShaderCullDistance = c.shaderCullDistance != 0
	g.ShaderFloat64 = c.shaderFloat64 != 0
	g.ShaderInt64 = c.shaderInt64 != 0
	g.ShaderInt16 = c.shaderInt16 != 0
	g.ShaderResourceResidency = c.shaderResourceResidency != 0
	g.ShaderResourceMinLod = c.shaderResourceMinLod != 0
	g.SparseBinding = c.sparseBinding != 0
	g.SparseResidencyBuffer = c.sparseResidencyBuffer != 0
	g.SparseResidencyImage2D = c.sparseResidencyImage2D != 0
	g.SparseResidencyImage3D = c.sparseResidencyImage3D != 0
	g.SparseResidency2Samples = c.sparseResidency2Samples != 0
	g.SparseResidency4Samples = c.sparseResidency4Samples != 0
	g.SparseResidency8Samples = c.sparseResidency8Samples != 0
	g.SparseResidency16Samples = c.sparseResidency16Samples != 0
	g.SparseResidencyAliased = c.sparseResidencyAliased != 0
	g.VariableMultisampleRate = c.variableMultisampleRate != 0
	g.InheritedQueries = c.inheritedQueries != 0
}

type FuncGetPhysicalDeviceFeatures func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures)

func ToGetPhysicalDeviceFeatures(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFeatures) {
	return func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFeatures      *C.VkPhysicalDeviceFeatures
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if features != nil {
			c.pFeatures = (*C.VkPhysicalDeviceFeatures)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures))
			features.toC(c.pFeatures)
		} else {
			c.pFeatures = nil
		}
		C.callPFN_vkGetPhysicalDeviceFeatures(C.PFN_vkGetPhysicalDeviceFeatures(unsafe.Pointer(p)), c.physicalDevice, c.pFeatures)
		if features != nil {
			features.fromC(c.pFeatures)
		}
	}
}

type PFNGetPhysicalDeviceFormatProperties C.PFN_vkGetPhysicalDeviceFormatProperties
type FormatFeatureFlags Flags
type FormatProperties struct {
	LinearTilingFeatures  FormatFeatureFlags
	OptimalTilingFeatures FormatFeatureFlags
	BufferFeatures        FormatFeatureFlags
}

func (g *FormatProperties) toC(c *C.VkFormatProperties) {
	{
		var temp_in_VkFormatFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.LinearTilingFeatures)))
			temp_in_VkFormatFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.linearTilingFeatures = C.VkFormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
	{
		var temp_in_VkFormatFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.OptimalTilingFeatures)))
			temp_in_VkFormatFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.optimalTilingFeatures = C.VkFormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
	{
		var temp_in_VkFormatFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.BufferFeatures)))
			temp_in_VkFormatFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.bufferFeatures = C.VkFormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
}
func (g *FormatProperties) fromC(c *C.VkFormatProperties) {
	{
		var temp_in_VkFormatFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.linearTilingFeatures)))
			temp_in_VkFormatFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.LinearTilingFeatures = FormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
	{
		var temp_in_VkFormatFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.optimalTilingFeatures)))
			temp_in_VkFormatFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.OptimalTilingFeatures = FormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
	{
		var temp_in_VkFormatFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.bufferFeatures)))
			temp_in_VkFormatFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.BufferFeatures = FormatFeatureFlags(temp_in_VkFormatFeatureFlags)
	}
}

type FuncGetPhysicalDeviceFormatProperties func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties)

func ToGetPhysicalDeviceFormatProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFormatProperties) {
	return func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			format            C.VkFormat
			pFormatProperties *C.VkFormatProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		if formatProperties != nil {
			c.pFormatProperties = (*C.VkFormatProperties)(m.alloc(C.sizeof_VkFormatProperties))
			formatProperties.toC(c.pFormatProperties)
		} else {
			c.pFormatProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceFormatProperties(C.PFN_vkGetPhysicalDeviceFormatProperties(unsafe.Pointer(p)), c.physicalDevice, c.format, c.pFormatProperties)
		if formatProperties != nil {
			formatProperties.fromC(c.pFormatProperties)
		}
	}
}

type PFNGetPhysicalDeviceImageFormatProperties C.PFN_vkGetPhysicalDeviceImageFormatProperties
type ImageUsageFlags Flags
type ImageCreateFlags Flags
type Extent3D struct {
	Width  uint32
	Height uint32
	Depth  uint32
}

func (g *Extent3D) toC(c *C.VkExtent3D) {
	c.width = C.uint32_t(g.Width)
	c.height = C.uint32_t(g.Height)
	c.depth = C.uint32_t(g.Depth)
}
func (g *Extent3D) fromC(c *C.VkExtent3D) {
	g.Width = uint32(c.width)
	g.Height = uint32(c.height)
	g.Depth = uint32(c.depth)
}

type SampleCountFlags Flags
type DeviceSize uint64
type ImageFormatProperties struct {
	MaxExtent       Extent3D
	MaxMipLevels    uint32
	MaxArrayLayers  uint32
	SampleCounts    SampleCountFlags
	MaxResourceSize DeviceSize
}

func (g *ImageFormatProperties) toC(c *C.VkImageFormatProperties) {
	g.MaxExtent.toC(&c.maxExtent)
	c.maxMipLevels = C.uint32_t(g.MaxMipLevels)
	c.maxArrayLayers = C.uint32_t(g.MaxArrayLayers)
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.sampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MaxResourceSize))
		c.maxResourceSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *ImageFormatProperties) fromC(c *C.VkImageFormatProperties) {
	g.MaxExtent.fromC(&c.maxExtent)
	g.MaxMipLevels = uint32(c.maxMipLevels)
	g.MaxArrayLayers = uint32(c.maxArrayLayers)
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.sampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.SampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.maxResourceSize))
		g.MaxResourceSize = DeviceSize(temp_in_VkDeviceSize)
	}
}

type FuncGetPhysicalDeviceImageFormatProperties func(physicalDevice PhysicalDevice, format Format, _type ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, imageFormatProperties *ImageFormatProperties) (_ret Result)

func ToGetPhysicalDeviceImageFormatProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceImageFormatProperties) {
	return func(physicalDevice PhysicalDevice, format Format, _type ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, imageFormatProperties *ImageFormatProperties) (_ret Result) {
		var c struct {
			physicalDevice         C.VkPhysicalDevice
			format                 C.VkFormat
			_type                  C.VkImageType
			tiling                 C.VkImageTiling
			usage                  C.VkImageUsageFlags
			flags                  C.VkImageCreateFlags
			pImageFormatProperties *C.VkImageFormatProperties
			_ret                   C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		c._type = C.VkImageType(_type)
		c.tiling = C.VkImageTiling(tiling)
		{
			var temp_in_VkImageUsageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(usage)))
				temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
		}
		{
			var temp_in_VkImageCreateFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkImageCreateFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkImageCreateFlags(temp_in_VkImageCreateFlags)
		}
		if imageFormatProperties != nil {
			c.pImageFormatProperties = (*C.VkImageFormatProperties)(m.alloc(C.sizeof_VkImageFormatProperties))
			imageFormatProperties.toC(c.pImageFormatProperties)
		} else {
			c.pImageFormatProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceImageFormatProperties(C.PFN_vkGetPhysicalDeviceImageFormatProperties(unsafe.Pointer(p)), c.physicalDevice, c.format, c._type, c.tiling, c.usage, c.flags, c.pImageFormatProperties)
		_ret = Result(c._ret)
		if imageFormatProperties != nil {
			imageFormatProperties.fromC(c.pImageFormatProperties)
		}
		return
	}
}

type PFNGetPhysicalDeviceProperties C.PFN_vkGetPhysicalDeviceProperties
type PhysicalDeviceLimits struct {
	MaxImageDimension1D                             uint32
	MaxImageDimension2D                             uint32
	MaxImageDimension3D                             uint32
	MaxImageDimensionCube                           uint32
	MaxImageArrayLayers                             uint32
	MaxTexelBufferElements                          uint32
	MaxUniformBufferRange                           uint32
	MaxStorageBufferRange                           uint32
	MaxPushConstantsSize                            uint32
	MaxMemoryAllocationCount                        uint32
	MaxSamplerAllocationCount                       uint32
	BufferImageGranularity                          DeviceSize
	SparseAddressSpaceSize                          DeviceSize
	MaxBoundDescriptorSets                          uint32
	MaxPerStageDescriptorSamplers                   uint32
	MaxPerStageDescriptorUniformBuffers             uint32
	MaxPerStageDescriptorStorageBuffers             uint32
	MaxPerStageDescriptorSampledImages              uint32
	MaxPerStageDescriptorStorageImages              uint32
	MaxPerStageDescriptorInputAttachments           uint32
	MaxPerStageResources                            uint32
	MaxDescriptorSetSamplers                        uint32
	MaxDescriptorSetUniformBuffers                  uint32
	MaxDescriptorSetUniformBuffersDynamic           uint32
	MaxDescriptorSetStorageBuffers                  uint32
	MaxDescriptorSetStorageBuffersDynamic           uint32
	MaxDescriptorSetSampledImages                   uint32
	MaxDescriptorSetStorageImages                   uint32
	MaxDescriptorSetInputAttachments                uint32
	MaxVertexInputAttributes                        uint32
	MaxVertexInputBindings                          uint32
	MaxVertexInputAttributeOffset                   uint32
	MaxVertexInputBindingStride                     uint32
	MaxVertexOutputComponents                       uint32
	MaxTessellationGenerationLevel                  uint32
	MaxTessellationPatchSize                        uint32
	MaxTessellationControlPerVertexInputComponents  uint32
	MaxTessellationControlPerVertexOutputComponents uint32
	MaxTessellationControlPerPatchOutputComponents  uint32
	MaxTessellationControlTotalOutputComponents     uint32
	MaxTessellationEvaluationInputComponents        uint32
	MaxTessellationEvaluationOutputComponents       uint32
	MaxGeometryShaderInvocations                    uint32
	MaxGeometryInputComponents                      uint32
	MaxGeometryOutputComponents                     uint32
	MaxGeometryOutputVertices                       uint32
	MaxGeometryTotalOutputComponents                uint32
	MaxFragmentInputComponents                      uint32
	MaxFragmentOutputAttachments                    uint32
	MaxFragmentDualSrcAttachments                   uint32
	MaxFragmentCombinedOutputResources              uint32
	MaxComputeSharedMemorySize                      uint32
	MaxComputeWorkGroupCount                        [3]uint32
	MaxComputeWorkGroupInvocations                  uint32
	MaxComputeWorkGroupSize                         [3]uint32
	SubPixelPrecisionBits                           uint32
	SubTexelPrecisionBits                           uint32
	MipmapPrecisionBits                             uint32
	MaxDrawIndexedIndexValue                        uint32
	MaxDrawIndirectCount                            uint32
	MaxSamplerLodBias                               float32
	MaxSamplerAnisotropy                            float32
	MaxViewports                                    uint32
	MaxViewportDimensions                           [2]uint32
	ViewportBoundsRange                             [2]float32
	ViewportSubPixelBits                            uint32
	MinMemoryMapAlignment                           uint
	MinTexelBufferOffsetAlignment                   DeviceSize
	MinUniformBufferOffsetAlignment                 DeviceSize
	MinStorageBufferOffsetAlignment                 DeviceSize
	MinTexelOffset                                  int32
	MaxTexelOffset                                  uint32
	MinTexelGatherOffset                            int32
	MaxTexelGatherOffset                            uint32
	MinInterpolationOffset                          float32
	MaxInterpolationOffset                          float32
	SubPixelInterpolationOffsetBits                 uint32
	MaxFramebufferWidth                             uint32
	MaxFramebufferHeight                            uint32
	MaxFramebufferLayers                            uint32
	FramebufferColorSampleCounts                    SampleCountFlags
	FramebufferDepthSampleCounts                    SampleCountFlags
	FramebufferStencilSampleCounts                  SampleCountFlags
	FramebufferNoAttachmentsSampleCounts            SampleCountFlags
	MaxColorAttachments                             uint32
	SampledImageColorSampleCounts                   SampleCountFlags
	SampledImageIntegerSampleCounts                 SampleCountFlags
	SampledImageDepthSampleCounts                   SampleCountFlags
	SampledImageStencilSampleCounts                 SampleCountFlags
	StorageImageSampleCounts                        SampleCountFlags
	MaxSampleMaskWords                              uint32
	TimestampComputeAndGraphics                     bool
	TimestampPeriod                                 float32
	MaxClipDistances                                uint32
	MaxCullDistances                                uint32
	MaxCombinedClipAndCullDistances                 uint32
	DiscreteQueuePriorities                         uint32
	PointSizeRange                                  [2]float32
	LineWidthRange                                  [2]float32
	PointSizeGranularity                            float32
	LineWidthGranularity                            float32
	StrictLines                                     bool
	StandardSampleLocations                         bool
	OptimalBufferCopyOffsetAlignment                DeviceSize
	OptimalBufferCopyRowPitchAlignment              DeviceSize
	NonCoherentAtomSize                             DeviceSize
}

func (g *PhysicalDeviceLimits) toC(c *C.VkPhysicalDeviceLimits) {
	c.maxImageDimension1D = C.uint32_t(g.MaxImageDimension1D)
	c.maxImageDimension2D = C.uint32_t(g.MaxImageDimension2D)
	c.maxImageDimension3D = C.uint32_t(g.MaxImageDimension3D)
	c.maxImageDimensionCube = C.uint32_t(g.MaxImageDimensionCube)
	c.maxImageArrayLayers = C.uint32_t(g.MaxImageArrayLayers)
	c.maxTexelBufferElements = C.uint32_t(g.MaxTexelBufferElements)
	c.maxUniformBufferRange = C.uint32_t(g.MaxUniformBufferRange)
	c.maxStorageBufferRange = C.uint32_t(g.MaxStorageBufferRange)
	c.maxPushConstantsSize = C.uint32_t(g.MaxPushConstantsSize)
	c.maxMemoryAllocationCount = C.uint32_t(g.MaxMemoryAllocationCount)
	c.maxSamplerAllocationCount = C.uint32_t(g.MaxSamplerAllocationCount)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.BufferImageGranularity))
		c.bufferImageGranularity = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.SparseAddressSpaceSize))
		c.sparseAddressSpaceSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.maxBoundDescriptorSets = C.uint32_t(g.MaxBoundDescriptorSets)
	c.maxPerStageDescriptorSamplers = C.uint32_t(g.MaxPerStageDescriptorSamplers)
	c.maxPerStageDescriptorUniformBuffers = C.uint32_t(g.MaxPerStageDescriptorUniformBuffers)
	c.maxPerStageDescriptorStorageBuffers = C.uint32_t(g.MaxPerStageDescriptorStorageBuffers)
	c.maxPerStageDescriptorSampledImages = C.uint32_t(g.MaxPerStageDescriptorSampledImages)
	c.maxPerStageDescriptorStorageImages = C.uint32_t(g.MaxPerStageDescriptorStorageImages)
	c.maxPerStageDescriptorInputAttachments = C.uint32_t(g.MaxPerStageDescriptorInputAttachments)
	c.maxPerStageResources = C.uint32_t(g.MaxPerStageResources)
	c.maxDescriptorSetSamplers = C.uint32_t(g.MaxDescriptorSetSamplers)
	c.maxDescriptorSetUniformBuffers = C.uint32_t(g.MaxDescriptorSetUniformBuffers)
	c.maxDescriptorSetUniformBuffersDynamic = C.uint32_t(g.MaxDescriptorSetUniformBuffersDynamic)
	c.maxDescriptorSetStorageBuffers = C.uint32_t(g.MaxDescriptorSetStorageBuffers)
	c.maxDescriptorSetStorageBuffersDynamic = C.uint32_t(g.MaxDescriptorSetStorageBuffersDynamic)
	c.maxDescriptorSetSampledImages = C.uint32_t(g.MaxDescriptorSetSampledImages)
	c.maxDescriptorSetStorageImages = C.uint32_t(g.MaxDescriptorSetStorageImages)
	c.maxDescriptorSetInputAttachments = C.uint32_t(g.MaxDescriptorSetInputAttachments)
	c.maxVertexInputAttributes = C.uint32_t(g.MaxVertexInputAttributes)
	c.maxVertexInputBindings = C.uint32_t(g.MaxVertexInputBindings)
	c.maxVertexInputAttributeOffset = C.uint32_t(g.MaxVertexInputAttributeOffset)
	c.maxVertexInputBindingStride = C.uint32_t(g.MaxVertexInputBindingStride)
	c.maxVertexOutputComponents = C.uint32_t(g.MaxVertexOutputComponents)
	c.maxTessellationGenerationLevel = C.uint32_t(g.MaxTessellationGenerationLevel)
	c.maxTessellationPatchSize = C.uint32_t(g.MaxTessellationPatchSize)
	c.maxTessellationControlPerVertexInputComponents = C.uint32_t(g.MaxTessellationControlPerVertexInputComponents)
	c.maxTessellationControlPerVertexOutputComponents = C.uint32_t(g.MaxTessellationControlPerVertexOutputComponents)
	c.maxTessellationControlPerPatchOutputComponents = C.uint32_t(g.MaxTessellationControlPerPatchOutputComponents)
	c.maxTessellationControlTotalOutputComponents = C.uint32_t(g.MaxTessellationControlTotalOutputComponents)
	c.maxTessellationEvaluationInputComponents = C.uint32_t(g.MaxTessellationEvaluationInputComponents)
	c.maxTessellationEvaluationOutputComponents = C.uint32_t(g.MaxTessellationEvaluationOutputComponents)
	c.maxGeometryShaderInvocations = C.uint32_t(g.MaxGeometryShaderInvocations)
	c.maxGeometryInputComponents = C.uint32_t(g.MaxGeometryInputComponents)
	c.maxGeometryOutputComponents = C.uint32_t(g.MaxGeometryOutputComponents)
	c.maxGeometryOutputVertices = C.uint32_t(g.MaxGeometryOutputVertices)
	c.maxGeometryTotalOutputComponents = C.uint32_t(g.MaxGeometryTotalOutputComponents)
	c.maxFragmentInputComponents = C.uint32_t(g.MaxFragmentInputComponents)
	c.maxFragmentOutputAttachments = C.uint32_t(g.MaxFragmentOutputAttachments)
	c.maxFragmentDualSrcAttachments = C.uint32_t(g.MaxFragmentDualSrcAttachments)
	c.maxFragmentCombinedOutputResources = C.uint32_t(g.MaxFragmentCombinedOutputResources)
	c.maxComputeSharedMemorySize = C.uint32_t(g.MaxComputeSharedMemorySize)
	for i, _ := range g.MaxComputeWorkGroupCount {
		c.maxComputeWorkGroupCount[i] = C.uint32_t(g.MaxComputeWorkGroupCount[i])
	}
	c.maxComputeWorkGroupInvocations = C.uint32_t(g.MaxComputeWorkGroupInvocations)
	for i, _ := range g.MaxComputeWorkGroupSize {
		c.maxComputeWorkGroupSize[i] = C.uint32_t(g.MaxComputeWorkGroupSize[i])
	}
	c.subPixelPrecisionBits = C.uint32_t(g.SubPixelPrecisionBits)
	c.subTexelPrecisionBits = C.uint32_t(g.SubTexelPrecisionBits)
	c.mipmapPrecisionBits = C.uint32_t(g.MipmapPrecisionBits)
	c.maxDrawIndexedIndexValue = C.uint32_t(g.MaxDrawIndexedIndexValue)
	c.maxDrawIndirectCount = C.uint32_t(g.MaxDrawIndirectCount)
	c.maxSamplerLodBias = C.float(g.MaxSamplerLodBias)
	c.maxSamplerAnisotropy = C.float(g.MaxSamplerAnisotropy)
	c.maxViewports = C.uint32_t(g.MaxViewports)
	for i, _ := range g.MaxViewportDimensions {
		c.maxViewportDimensions[i] = C.uint32_t(g.MaxViewportDimensions[i])
	}
	for i, _ := range g.ViewportBoundsRange {
		c.viewportBoundsRange[i] = C.float(g.ViewportBoundsRange[i])
	}
	c.viewportSubPixelBits = C.uint32_t(g.ViewportSubPixelBits)
	c.minMemoryMapAlignment = C.size_t(g.MinMemoryMapAlignment)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MinTexelBufferOffsetAlignment))
		c.minTexelBufferOffsetAlignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MinUniformBufferOffsetAlignment))
		c.minUniformBufferOffsetAlignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MinStorageBufferOffsetAlignment))
		c.minStorageBufferOffsetAlignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.minTexelOffset = C.int32_t(g.MinTexelOffset)
	c.maxTexelOffset = C.uint32_t(g.MaxTexelOffset)
	c.minTexelGatherOffset = C.int32_t(g.MinTexelGatherOffset)
	c.maxTexelGatherOffset = C.uint32_t(g.MaxTexelGatherOffset)
	c.minInterpolationOffset = C.float(g.MinInterpolationOffset)
	c.maxInterpolationOffset = C.float(g.MaxInterpolationOffset)
	c.subPixelInterpolationOffsetBits = C.uint32_t(g.SubPixelInterpolationOffsetBits)
	c.maxFramebufferWidth = C.uint32_t(g.MaxFramebufferWidth)
	c.maxFramebufferHeight = C.uint32_t(g.MaxFramebufferHeight)
	c.maxFramebufferLayers = C.uint32_t(g.MaxFramebufferLayers)
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.FramebufferColorSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.framebufferColorSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.FramebufferDepthSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.framebufferDepthSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.FramebufferStencilSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.framebufferStencilSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.FramebufferNoAttachmentsSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.framebufferNoAttachmentsSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	c.maxColorAttachments = C.uint32_t(g.MaxColorAttachments)
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SampledImageColorSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.sampledImageColorSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SampledImageIntegerSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.sampledImageIntegerSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SampledImageDepthSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.sampledImageDepthSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SampledImageStencilSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.sampledImageStencilSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.StorageImageSampleCounts)))
			temp_in_VkSampleCountFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.storageImageSampleCounts = C.VkSampleCountFlags(temp_in_VkSampleCountFlags)
	}
	c.maxSampleMaskWords = C.uint32_t(g.MaxSampleMaskWords)
	if g.TimestampComputeAndGraphics {
		c.timestampComputeAndGraphics = 1
	} else {
		c.timestampComputeAndGraphics = 0
	}
	c.timestampPeriod = C.float(g.TimestampPeriod)
	c.maxClipDistances = C.uint32_t(g.MaxClipDistances)
	c.maxCullDistances = C.uint32_t(g.MaxCullDistances)
	c.maxCombinedClipAndCullDistances = C.uint32_t(g.MaxCombinedClipAndCullDistances)
	c.discreteQueuePriorities = C.uint32_t(g.DiscreteQueuePriorities)
	for i, _ := range g.PointSizeRange {
		c.pointSizeRange[i] = C.float(g.PointSizeRange[i])
	}
	for i, _ := range g.LineWidthRange {
		c.lineWidthRange[i] = C.float(g.LineWidthRange[i])
	}
	c.pointSizeGranularity = C.float(g.PointSizeGranularity)
	c.lineWidthGranularity = C.float(g.LineWidthGranularity)
	if g.StrictLines {
		c.strictLines = 1
	} else {
		c.strictLines = 0
	}
	if g.StandardSampleLocations {
		c.standardSampleLocations = 1
	} else {
		c.standardSampleLocations = 0
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.OptimalBufferCopyOffsetAlignment))
		c.optimalBufferCopyOffsetAlignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.OptimalBufferCopyRowPitchAlignment))
		c.optimalBufferCopyRowPitchAlignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.NonCoherentAtomSize))
		c.nonCoherentAtomSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *PhysicalDeviceLimits) fromC(c *C.VkPhysicalDeviceLimits) {
	g.MaxImageDimension1D = uint32(c.maxImageDimension1D)
	g.MaxImageDimension2D = uint32(c.maxImageDimension2D)
	g.MaxImageDimension3D = uint32(c.maxImageDimension3D)
	g.MaxImageDimensionCube = uint32(c.maxImageDimensionCube)
	g.MaxImageArrayLayers = uint32(c.maxImageArrayLayers)
	g.MaxTexelBufferElements = uint32(c.maxTexelBufferElements)
	g.MaxUniformBufferRange = uint32(c.maxUniformBufferRange)
	g.MaxStorageBufferRange = uint32(c.maxStorageBufferRange)
	g.MaxPushConstantsSize = uint32(c.maxPushConstantsSize)
	g.MaxMemoryAllocationCount = uint32(c.maxMemoryAllocationCount)
	g.MaxSamplerAllocationCount = uint32(c.maxSamplerAllocationCount)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.bufferImageGranularity))
		g.BufferImageGranularity = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.sparseAddressSpaceSize))
		g.SparseAddressSpaceSize = DeviceSize(temp_in_VkDeviceSize)
	}
	g.MaxBoundDescriptorSets = uint32(c.maxBoundDescriptorSets)
	g.MaxPerStageDescriptorSamplers = uint32(c.maxPerStageDescriptorSamplers)
	g.MaxPerStageDescriptorUniformBuffers = uint32(c.maxPerStageDescriptorUniformBuffers)
	g.MaxPerStageDescriptorStorageBuffers = uint32(c.maxPerStageDescriptorStorageBuffers)
	g.MaxPerStageDescriptorSampledImages = uint32(c.maxPerStageDescriptorSampledImages)
	g.MaxPerStageDescriptorStorageImages = uint32(c.maxPerStageDescriptorStorageImages)
	g.MaxPerStageDescriptorInputAttachments = uint32(c.maxPerStageDescriptorInputAttachments)
	g.MaxPerStageResources = uint32(c.maxPerStageResources)
	g.MaxDescriptorSetSamplers = uint32(c.maxDescriptorSetSamplers)
	g.MaxDescriptorSetUniformBuffers = uint32(c.maxDescriptorSetUniformBuffers)
	g.MaxDescriptorSetUniformBuffersDynamic = uint32(c.maxDescriptorSetUniformBuffersDynamic)
	g.MaxDescriptorSetStorageBuffers = uint32(c.maxDescriptorSetStorageBuffers)
	g.MaxDescriptorSetStorageBuffersDynamic = uint32(c.maxDescriptorSetStorageBuffersDynamic)
	g.MaxDescriptorSetSampledImages = uint32(c.maxDescriptorSetSampledImages)
	g.MaxDescriptorSetStorageImages = uint32(c.maxDescriptorSetStorageImages)
	g.MaxDescriptorSetInputAttachments = uint32(c.maxDescriptorSetInputAttachments)
	g.MaxVertexInputAttributes = uint32(c.maxVertexInputAttributes)
	g.MaxVertexInputBindings = uint32(c.maxVertexInputBindings)
	g.MaxVertexInputAttributeOffset = uint32(c.maxVertexInputAttributeOffset)
	g.MaxVertexInputBindingStride = uint32(c.maxVertexInputBindingStride)
	g.MaxVertexOutputComponents = uint32(c.maxVertexOutputComponents)
	g.MaxTessellationGenerationLevel = uint32(c.maxTessellationGenerationLevel)
	g.MaxTessellationPatchSize = uint32(c.maxTessellationPatchSize)
	g.MaxTessellationControlPerVertexInputComponents = uint32(c.maxTessellationControlPerVertexInputComponents)
	g.MaxTessellationControlPerVertexOutputComponents = uint32(c.maxTessellationControlPerVertexOutputComponents)
	g.MaxTessellationControlPerPatchOutputComponents = uint32(c.maxTessellationControlPerPatchOutputComponents)
	g.MaxTessellationControlTotalOutputComponents = uint32(c.maxTessellationControlTotalOutputComponents)
	g.MaxTessellationEvaluationInputComponents = uint32(c.maxTessellationEvaluationInputComponents)
	g.MaxTessellationEvaluationOutputComponents = uint32(c.maxTessellationEvaluationOutputComponents)
	g.MaxGeometryShaderInvocations = uint32(c.maxGeometryShaderInvocations)
	g.MaxGeometryInputComponents = uint32(c.maxGeometryInputComponents)
	g.MaxGeometryOutputComponents = uint32(c.maxGeometryOutputComponents)
	g.MaxGeometryOutputVertices = uint32(c.maxGeometryOutputVertices)
	g.MaxGeometryTotalOutputComponents = uint32(c.maxGeometryTotalOutputComponents)
	g.MaxFragmentInputComponents = uint32(c.maxFragmentInputComponents)
	g.MaxFragmentOutputAttachments = uint32(c.maxFragmentOutputAttachments)
	g.MaxFragmentDualSrcAttachments = uint32(c.maxFragmentDualSrcAttachments)
	g.MaxFragmentCombinedOutputResources = uint32(c.maxFragmentCombinedOutputResources)
	g.MaxComputeSharedMemorySize = uint32(c.maxComputeSharedMemorySize)
	for i, _ := range g.MaxComputeWorkGroupCount {
		g.MaxComputeWorkGroupCount[i] = uint32(c.maxComputeWorkGroupCount[i])
	}
	g.MaxComputeWorkGroupInvocations = uint32(c.maxComputeWorkGroupInvocations)
	for i, _ := range g.MaxComputeWorkGroupSize {
		g.MaxComputeWorkGroupSize[i] = uint32(c.maxComputeWorkGroupSize[i])
	}
	g.SubPixelPrecisionBits = uint32(c.subPixelPrecisionBits)
	g.SubTexelPrecisionBits = uint32(c.subTexelPrecisionBits)
	g.MipmapPrecisionBits = uint32(c.mipmapPrecisionBits)
	g.MaxDrawIndexedIndexValue = uint32(c.maxDrawIndexedIndexValue)
	g.MaxDrawIndirectCount = uint32(c.maxDrawIndirectCount)
	g.MaxSamplerLodBias = float32(c.maxSamplerLodBias)
	g.MaxSamplerAnisotropy = float32(c.maxSamplerAnisotropy)
	g.MaxViewports = uint32(c.maxViewports)
	for i, _ := range g.MaxViewportDimensions {
		g.MaxViewportDimensions[i] = uint32(c.maxViewportDimensions[i])
	}
	for i, _ := range g.ViewportBoundsRange {
		g.ViewportBoundsRange[i] = float32(c.viewportBoundsRange[i])
	}
	g.ViewportSubPixelBits = uint32(c.viewportSubPixelBits)
	g.MinMemoryMapAlignment = uint(c.minMemoryMapAlignment)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.minTexelBufferOffsetAlignment))
		g.MinTexelBufferOffsetAlignment = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.minUniformBufferOffsetAlignment))
		g.MinUniformBufferOffsetAlignment = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.minStorageBufferOffsetAlignment))
		g.MinStorageBufferOffsetAlignment = DeviceSize(temp_in_VkDeviceSize)
	}
	g.MinTexelOffset = int32(c.minTexelOffset)
	g.MaxTexelOffset = uint32(c.maxTexelOffset)
	g.MinTexelGatherOffset = int32(c.minTexelGatherOffset)
	g.MaxTexelGatherOffset = uint32(c.maxTexelGatherOffset)
	g.MinInterpolationOffset = float32(c.minInterpolationOffset)
	g.MaxInterpolationOffset = float32(c.maxInterpolationOffset)
	g.SubPixelInterpolationOffsetBits = uint32(c.subPixelInterpolationOffsetBits)
	g.MaxFramebufferWidth = uint32(c.maxFramebufferWidth)
	g.MaxFramebufferHeight = uint32(c.maxFramebufferHeight)
	g.MaxFramebufferLayers = uint32(c.maxFramebufferLayers)
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.framebufferColorSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.FramebufferColorSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.framebufferDepthSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.FramebufferDepthSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.framebufferStencilSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.FramebufferStencilSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.framebufferNoAttachmentsSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.FramebufferNoAttachmentsSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	g.MaxColorAttachments = uint32(c.maxColorAttachments)
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.sampledImageColorSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.SampledImageColorSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.sampledImageIntegerSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.SampledImageIntegerSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.sampledImageDepthSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.SampledImageDepthSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.sampledImageStencilSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.SampledImageStencilSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	{
		var temp_in_VkSampleCountFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.storageImageSampleCounts)))
			temp_in_VkSampleCountFlags = Flags(temp_in_VkFlags)
		}
		g.StorageImageSampleCounts = SampleCountFlags(temp_in_VkSampleCountFlags)
	}
	g.MaxSampleMaskWords = uint32(c.maxSampleMaskWords)
	g.TimestampComputeAndGraphics = c.timestampComputeAndGraphics != 0
	g.TimestampPeriod = float32(c.timestampPeriod)
	g.MaxClipDistances = uint32(c.maxClipDistances)
	g.MaxCullDistances = uint32(c.maxCullDistances)
	g.MaxCombinedClipAndCullDistances = uint32(c.maxCombinedClipAndCullDistances)
	g.DiscreteQueuePriorities = uint32(c.discreteQueuePriorities)
	for i, _ := range g.PointSizeRange {
		g.PointSizeRange[i] = float32(c.pointSizeRange[i])
	}
	for i, _ := range g.LineWidthRange {
		g.LineWidthRange[i] = float32(c.lineWidthRange[i])
	}
	g.PointSizeGranularity = float32(c.pointSizeGranularity)
	g.LineWidthGranularity = float32(c.lineWidthGranularity)
	g.StrictLines = c.strictLines != 0
	g.StandardSampleLocations = c.standardSampleLocations != 0
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.optimalBufferCopyOffsetAlignment))
		g.OptimalBufferCopyOffsetAlignment = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.optimalBufferCopyRowPitchAlignment))
		g.OptimalBufferCopyRowPitchAlignment = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.nonCoherentAtomSize))
		g.NonCoherentAtomSize = DeviceSize(temp_in_VkDeviceSize)
	}
}

type PhysicalDeviceSparseProperties struct {
	ResidencyStandard2DBlockShape            bool
	ResidencyStandard2DMultisampleBlockShape bool
	ResidencyStandard3DBlockShape            bool
	ResidencyAlignedMipSize                  bool
	ResidencyNonResidentStrict               bool
}

func (g *PhysicalDeviceSparseProperties) toC(c *C.VkPhysicalDeviceSparseProperties) {
	if g.ResidencyStandard2DBlockShape {
		c.residencyStandard2DBlockShape = 1
	} else {
		c.residencyStandard2DBlockShape = 0
	}
	if g.ResidencyStandard2DMultisampleBlockShape {
		c.residencyStandard2DMultisampleBlockShape = 1
	} else {
		c.residencyStandard2DMultisampleBlockShape = 0
	}
	if g.ResidencyStandard3DBlockShape {
		c.residencyStandard3DBlockShape = 1
	} else {
		c.residencyStandard3DBlockShape = 0
	}
	if g.ResidencyAlignedMipSize {
		c.residencyAlignedMipSize = 1
	} else {
		c.residencyAlignedMipSize = 0
	}
	if g.ResidencyNonResidentStrict {
		c.residencyNonResidentStrict = 1
	} else {
		c.residencyNonResidentStrict = 0
	}
}
func (g *PhysicalDeviceSparseProperties) fromC(c *C.VkPhysicalDeviceSparseProperties) {
	g.ResidencyStandard2DBlockShape = c.residencyStandard2DBlockShape != 0
	g.ResidencyStandard2DMultisampleBlockShape = c.residencyStandard2DMultisampleBlockShape != 0
	g.ResidencyStandard3DBlockShape = c.residencyStandard3DBlockShape != 0
	g.ResidencyAlignedMipSize = c.residencyAlignedMipSize != 0
	g.ResidencyNonResidentStrict = c.residencyNonResidentStrict != 0
}

type PhysicalDeviceProperties struct {
	ApiVersion        uint32
	DriverVersion     uint32
	VendorID          uint32
	DeviceID          uint32
	DeviceType        PhysicalDeviceType
	DeviceName        [256]byte
	PipelineCacheUUID [16]uint8
	Limits            PhysicalDeviceLimits
	SparseProperties  PhysicalDeviceSparseProperties
}

func (g *PhysicalDeviceProperties) toC(c *C.VkPhysicalDeviceProperties) {
	c.apiVersion = C.uint32_t(g.ApiVersion)
	c.driverVersion = C.uint32_t(g.DriverVersion)
	c.vendorID = C.uint32_t(g.VendorID)
	c.deviceID = C.uint32_t(g.DeviceID)
	c.deviceType = C.VkPhysicalDeviceType(g.DeviceType)
	for i, _ := range g.DeviceName {
		c.deviceName[i] = C.char(g.DeviceName[i])
	}
	for i, _ := range g.PipelineCacheUUID {
		c.pipelineCacheUUID[i] = C.uint8_t(g.PipelineCacheUUID[i])
	}
	g.Limits.toC(&c.limits)
	g.SparseProperties.toC(&c.sparseProperties)
}
func (g *PhysicalDeviceProperties) fromC(c *C.VkPhysicalDeviceProperties) {
	g.ApiVersion = uint32(c.apiVersion)
	g.DriverVersion = uint32(c.driverVersion)
	g.VendorID = uint32(c.vendorID)
	g.DeviceID = uint32(c.deviceID)
	g.DeviceType = PhysicalDeviceType(c.deviceType)
	for i, _ := range g.DeviceName {
		g.DeviceName[i] = byte(c.deviceName[i])
	}
	for i, _ := range g.PipelineCacheUUID {
		g.PipelineCacheUUID[i] = uint8(c.pipelineCacheUUID[i])
	}
	g.Limits.fromC(&c.limits)
	g.SparseProperties.fromC(&c.sparseProperties)
}

type FuncGetPhysicalDeviceProperties func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties)

func ToGetPhysicalDeviceProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceProperties) {
	return func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pProperties    *C.VkPhysicalDeviceProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if properties != nil {
			c.pProperties = (*C.VkPhysicalDeviceProperties)(m.alloc(C.sizeof_VkPhysicalDeviceProperties))
			properties.toC(c.pProperties)
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceProperties(C.PFN_vkGetPhysicalDeviceProperties(unsafe.Pointer(p)), c.physicalDevice, c.pProperties)
		if properties != nil {
			properties.fromC(c.pProperties)
		}
	}
}

type PFNGetPhysicalDeviceQueueFamilyProperties C.PFN_vkGetPhysicalDeviceQueueFamilyProperties
type QueueFlags Flags
type QueueFamilyProperties struct {
	QueueFlags                  QueueFlags
	QueueCount                  uint32
	TimestampValidBits          uint32
	MinImageTransferGranularity Extent3D
}

func (g *QueueFamilyProperties) toC(c *C.VkQueueFamilyProperties) {
	{
		var temp_in_VkQueueFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.QueueFlags)))
			temp_in_VkQueueFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.queueFlags = C.VkQueueFlags(temp_in_VkQueueFlags)
	}
	c.queueCount = C.uint32_t(g.QueueCount)
	c.timestampValidBits = C.uint32_t(g.TimestampValidBits)
	g.MinImageTransferGranularity.toC(&c.minImageTransferGranularity)
}
func (g *QueueFamilyProperties) fromC(c *C.VkQueueFamilyProperties) {
	{
		var temp_in_VkQueueFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.queueFlags)))
			temp_in_VkQueueFlags = Flags(temp_in_VkFlags)
		}
		g.QueueFlags = QueueFlags(temp_in_VkQueueFlags)
	}
	g.QueueCount = uint32(c.queueCount)
	g.TimestampValidBits = uint32(c.timestampValidBits)
	g.MinImageTransferGranularity.fromC(&c.minImageTransferGranularity)
}

type FuncGetPhysicalDeviceQueueFamilyProperties func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties)

func ToGetPhysicalDeviceQueueFamilyProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceQueueFamilyProperties) {
	return func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties) {
		var c struct {
			physicalDevice            C.VkPhysicalDevice
			pQueueFamilyPropertyCount *C.uint32_t
			pQueueFamilyProperties    *C.VkQueueFamilyProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if queueFamilyPropertyCount != nil {
			c.pQueueFamilyPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pQueueFamilyPropertyCount = C.uint32_t(*queueFamilyPropertyCount)
		} else {
			c.pQueueFamilyPropertyCount = nil
		}
		if len(queueFamilyProperties) != 0 {
			c.pQueueFamilyProperties = (*C.VkQueueFamilyProperties)(m.alloc(C.sizeof_VkQueueFamilyProperties * uint(len(queueFamilyProperties))))
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].toC(&slice1[i1])
			}
		} else {
			c.pQueueFamilyProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceQueueFamilyProperties(C.PFN_vkGetPhysicalDeviceQueueFamilyProperties(unsafe.Pointer(p)), c.physicalDevice, c.pQueueFamilyPropertyCount, c.pQueueFamilyProperties)
		if queueFamilyPropertyCount != nil {
			*queueFamilyPropertyCount = uint32(*c.pQueueFamilyPropertyCount)
		}
		if len(queueFamilyProperties) != 0 {
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetPhysicalDeviceMemoryProperties C.PFN_vkGetPhysicalDeviceMemoryProperties
type MemoryPropertyFlags Flags
type MemoryType struct {
	PropertyFlags MemoryPropertyFlags
	HeapIndex     uint32
}

func (g *MemoryType) toC(c *C.VkMemoryType) {
	{
		var temp_in_VkMemoryPropertyFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.PropertyFlags)))
			temp_in_VkMemoryPropertyFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.propertyFlags = C.VkMemoryPropertyFlags(temp_in_VkMemoryPropertyFlags)
	}
	c.heapIndex = C.uint32_t(g.HeapIndex)
}
func (g *MemoryType) fromC(c *C.VkMemoryType) {
	{
		var temp_in_VkMemoryPropertyFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.propertyFlags)))
			temp_in_VkMemoryPropertyFlags = Flags(temp_in_VkFlags)
		}
		g.PropertyFlags = MemoryPropertyFlags(temp_in_VkMemoryPropertyFlags)
	}
	g.HeapIndex = uint32(c.heapIndex)
}

type MemoryHeapFlags Flags
type MemoryHeap struct {
	Size  DeviceSize
	Flags MemoryHeapFlags
}

func (g *MemoryHeap) toC(c *C.VkMemoryHeap) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkMemoryHeapFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkMemoryHeapFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkMemoryHeapFlags(temp_in_VkMemoryHeapFlags)
	}
}
func (g *MemoryHeap) fromC(c *C.VkMemoryHeap) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkMemoryHeapFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkMemoryHeapFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = MemoryHeapFlags(temp_in_VkMemoryHeapFlags)
	}
}

type PhysicalDeviceMemoryProperties struct {
	MemoryTypeCount uint32
	MemoryTypes     [32]MemoryType
	MemoryHeapCount uint32
	MemoryHeaps     [16]MemoryHeap
}

func (g *PhysicalDeviceMemoryProperties) toC(c *C.VkPhysicalDeviceMemoryProperties) {
	c.memoryTypeCount = C.uint32_t(g.MemoryTypeCount)
	for i, _ := range g.MemoryTypes {
		g.MemoryTypes[i].toC(&c.memoryTypes[i])
	}
	c.memoryHeapCount = C.uint32_t(g.MemoryHeapCount)
	for i, _ := range g.MemoryHeaps {
		g.MemoryHeaps[i].toC(&c.memoryHeaps[i])
	}
}
func (g *PhysicalDeviceMemoryProperties) fromC(c *C.VkPhysicalDeviceMemoryProperties) {
	g.MemoryTypeCount = uint32(c.memoryTypeCount)
	for i, _ := range g.MemoryTypes {
		g.MemoryTypes[i].fromC(&c.memoryTypes[i])
	}
	g.MemoryHeapCount = uint32(c.memoryHeapCount)
	for i, _ := range g.MemoryHeaps {
		g.MemoryHeaps[i].fromC(&c.memoryHeaps[i])
	}
}

type FuncGetPhysicalDeviceMemoryProperties func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties)

func ToGetPhysicalDeviceMemoryProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceMemoryProperties) {
	return func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			pMemoryProperties *C.VkPhysicalDeviceMemoryProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if memoryProperties != nil {
			c.pMemoryProperties = (*C.VkPhysicalDeviceMemoryProperties)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties))
			memoryProperties.toC(c.pMemoryProperties)
		} else {
			c.pMemoryProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceMemoryProperties(C.PFN_vkGetPhysicalDeviceMemoryProperties(unsafe.Pointer(p)), c.physicalDevice, c.pMemoryProperties)
		if memoryProperties != nil {
			memoryProperties.fromC(c.pMemoryProperties)
		}
	}
}

type PFNGetInstanceProcAddr C.PFN_vkGetInstanceProcAddr
type FuncGetInstanceProcAddr func(instance Instance, name string) (_ret PFNVoidFunction)

func ToGetInstanceProcAddr(p PFNVoidFunction) (fn FuncGetInstanceProcAddr) {
	return func(instance Instance, name string) (_ret PFNVoidFunction) {
		var c struct {
			instance C.VkInstance
			pName    *C.char
			_ret     C.PFN_vkVoidFunction
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		c.pName = toCString(name, m)
		c._ret = C.callPFN_vkGetInstanceProcAddr(C.PFN_vkGetInstanceProcAddr(unsafe.Pointer(p)), c.instance, c.pName)
		_ret = PFNVoidFunction(c._ret)
		return
	}
}

type PFNGetDeviceProcAddr C.PFN_vkGetDeviceProcAddr
type Device C.VkDevice
type FuncGetDeviceProcAddr func(device Device, name string) (_ret PFNVoidFunction)

func ToGetDeviceProcAddr(p PFNVoidFunction) (fn FuncGetDeviceProcAddr) {
	return func(device Device, name string) (_ret PFNVoidFunction) {
		var c struct {
			device C.VkDevice
			pName  *C.char
			_ret   C.PFN_vkVoidFunction
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pName = toCString(name, m)
		c._ret = C.callPFN_vkGetDeviceProcAddr(C.PFN_vkGetDeviceProcAddr(unsafe.Pointer(p)), c.device, c.pName)
		_ret = PFNVoidFunction(c._ret)
		return
	}
}

type PFNCreateDevice C.PFN_vkCreateDevice
type DeviceCreateFlags Flags
type DeviceQueueCreateFlags Flags
type DeviceQueueCreateInfo struct {
	Next             Structure
	Flags            DeviceQueueCreateFlags
	QueueFamilyIndex uint32
	QueuePriorities  []float32
}

func (g *DeviceQueueCreateInfo) toC(c *C.VkDeviceQueueCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDeviceQueueCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDeviceQueueCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDeviceQueueCreateFlags(temp_in_VkDeviceQueueCreateFlags)
	}
	c.queueFamilyIndex = C.uint32_t(g.QueueFamilyIndex)
	c.queueCount = C.uint32_t(len(g.QueuePriorities))
	if len(g.QueuePriorities) != 0 {
		c.pQueuePriorities = (*C.float)(m.alloc(C.sizeof_float * uint(len(g.QueuePriorities))))
		slice1 := (*[1 << 31]C.float)(unsafe.Pointer(c.pQueuePriorities))[:len(g.QueuePriorities):len(g.QueuePriorities)]
		for i1, _ := range g.QueuePriorities {
			slice1[i1] = C.float(g.QueuePriorities[i1])
		}
	} else {
		c.pQueuePriorities = nil
	}
}
func (g *DeviceQueueCreateInfo) fromC(c *C.VkDeviceQueueCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDeviceQueueCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDeviceQueueCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DeviceQueueCreateFlags(temp_in_VkDeviceQueueCreateFlags)
	}
	g.QueueFamilyIndex = uint32(c.queueFamilyIndex)
	g.QueuePriorities = make([]float32, int(c.queueCount))
	if len(g.QueuePriorities) != 0 {
		slice1 := (*[1 << 31]C.float)(unsafe.Pointer(c.pQueuePriorities))[:len(g.QueuePriorities):len(g.QueuePriorities)]
		for i1, _ := range g.QueuePriorities {
			g.QueuePriorities[i1] = float32(slice1[i1])
		}
	}
}
func (s *DeviceQueueCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
}
func (s *DeviceQueueCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceQueueCreateInfo)(m.alloc(C.sizeof_VkDeviceQueueCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceQueueCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceQueueCreateInfo)(p)
	s.fromC(c)
}
func (s *DeviceQueueCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *DeviceQueueCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type DeviceCreateInfo struct {
	Next                  Structure
	Flags                 DeviceCreateFlags
	QueueCreateInfos      []DeviceQueueCreateInfo
	EnabledLayerNames     []string
	EnabledExtensionNames []string
	EnabledFeatures       *PhysicalDeviceFeatures
}

func (g *DeviceCreateInfo) toC(c *C.VkDeviceCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDeviceCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDeviceCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDeviceCreateFlags(temp_in_VkDeviceCreateFlags)
	}
	c.queueCreateInfoCount = C.uint32_t(len(g.QueueCreateInfos))
	if len(g.QueueCreateInfos) != 0 {
		c.pQueueCreateInfos = (*C.VkDeviceQueueCreateInfo)(m.alloc(C.sizeof_VkDeviceQueueCreateInfo * uint(len(g.QueueCreateInfos))))
		slice1 := (*[1 << 31]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(c.pQueueCreateInfos))[:len(g.QueueCreateInfos):len(g.QueueCreateInfos)]
		for i1, _ := range g.QueueCreateInfos {
			g.QueueCreateInfos[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pQueueCreateInfos = nil
	}
	c.enabledLayerCount = C.uint32_t(len(g.EnabledLayerNames))
	if len(g.EnabledLayerNames) != 0 {
		c.ppEnabledLayerNames = (**C.char)(m.alloc(C.sizeof_void_pointer * uint(len(g.EnabledLayerNames))))
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledLayerNames))[:len(g.EnabledLayerNames):len(g.EnabledLayerNames)]
		for i1, _ := range g.EnabledLayerNames {
			slice1[i1] = toCString(g.EnabledLayerNames[i1], m)
		}
	} else {
		c.ppEnabledLayerNames = nil
	}
	c.enabledExtensionCount = C.uint32_t(len(g.EnabledExtensionNames))
	if len(g.EnabledExtensionNames) != 0 {
		c.ppEnabledExtensionNames = (**C.char)(m.alloc(C.sizeof_void_pointer * uint(len(g.EnabledExtensionNames))))
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledExtensionNames))[:len(g.EnabledExtensionNames):len(g.EnabledExtensionNames)]
		for i1, _ := range g.EnabledExtensionNames {
			slice1[i1] = toCString(g.EnabledExtensionNames[i1], m)
		}
	} else {
		c.ppEnabledExtensionNames = nil
	}
	if g.EnabledFeatures != nil {
		c.pEnabledFeatures = (*C.VkPhysicalDeviceFeatures)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures))
		g.EnabledFeatures.toC(c.pEnabledFeatures)
	} else {
		c.pEnabledFeatures = nil
	}
}
func (g *DeviceCreateInfo) fromC(c *C.VkDeviceCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDeviceCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDeviceCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DeviceCreateFlags(temp_in_VkDeviceCreateFlags)
	}
	g.QueueCreateInfos = make([]DeviceQueueCreateInfo, int(c.queueCreateInfoCount))
	if len(g.QueueCreateInfos) != 0 {
		slice1 := (*[1 << 31]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(c.pQueueCreateInfos))[:len(g.QueueCreateInfos):len(g.QueueCreateInfos)]
		for i1, _ := range g.QueueCreateInfos {
			g.QueueCreateInfos[i1].fromC(&slice1[i1])
		}
	}
	g.EnabledLayerNames = make([]string, int(c.enabledLayerCount))
	if len(g.EnabledLayerNames) != 0 {
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledLayerNames))[:len(g.EnabledLayerNames):len(g.EnabledLayerNames)]
		for i1, _ := range g.EnabledLayerNames {
			g.EnabledLayerNames[i1] = toGoString(slice1[i1])
		}
	}
	g.EnabledExtensionNames = make([]string, int(c.enabledExtensionCount))
	if len(g.EnabledExtensionNames) != 0 {
		slice1 := (*[1 << 31]*C.char)(unsafe.Pointer(c.ppEnabledExtensionNames))[:len(g.EnabledExtensionNames):len(g.EnabledExtensionNames)]
		for i1, _ := range g.EnabledExtensionNames {
			g.EnabledExtensionNames[i1] = toGoString(slice1[i1])
		}
	}
	if g.EnabledFeatures != nil {
		g.EnabledFeatures.fromC(c.pEnabledFeatures)
	}
}
func (s *DeviceCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
}
func (s *DeviceCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceCreateInfo)(m.alloc(C.sizeof_VkDeviceCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceCreateInfo)(p)
	s.fromC(c)
}
func (s *DeviceCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *DeviceCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateDevice func(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks, device *Device) (_ret Result)

func ToCreateDevice(p PFNVoidFunction) (fn FuncCreateDevice) {
	return func(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks, device *Device) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pCreateInfo    *C.VkDeviceCreateInfo
			pAllocator     *C.VkAllocationCallbacks
			pDevice        *C.VkDevice
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDeviceCreateInfo)(m.alloc(C.sizeof_VkDeviceCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if device != nil {
			c.pDevice = (*C.VkDevice)(m.alloc(C.sizeof_VkDevice))
			*c.pDevice = C.VkDevice(*device)
		} else {
			c.pDevice = nil
		}
		c._ret = C.callPFN_vkCreateDevice(C.PFN_vkCreateDevice(unsafe.Pointer(p)), c.physicalDevice, c.pCreateInfo, c.pAllocator, c.pDevice)
		_ret = Result(c._ret)
		if device != nil {
			*device = Device(*c.pDevice)
		}
		return
	}
}

type PFNDestroyDevice C.PFN_vkDestroyDevice
type FuncDestroyDevice func(device Device, allocator *AllocationCallbacks)

func ToDestroyDevice(p PFNVoidFunction) (fn FuncDestroyDevice) {
	return func(device Device, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDevice(C.PFN_vkDestroyDevice(unsafe.Pointer(p)), c.device, c.pAllocator)
	}
}

type PFNEnumerateInstanceExtensionProperties C.PFN_vkEnumerateInstanceExtensionProperties
type ExtensionProperties struct {
	ExtensionName [256]byte
	SpecVersion   uint32
}

func (g *ExtensionProperties) toC(c *C.VkExtensionProperties) {
	for i, _ := range g.ExtensionName {
		c.extensionName[i] = C.char(g.ExtensionName[i])
	}
	c.specVersion = C.uint32_t(g.SpecVersion)
}
func (g *ExtensionProperties) fromC(c *C.VkExtensionProperties) {
	for i, _ := range g.ExtensionName {
		g.ExtensionName[i] = byte(c.extensionName[i])
	}
	g.SpecVersion = uint32(c.specVersion)
}

type FuncEnumerateInstanceExtensionProperties func(layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result)

func ToEnumerateInstanceExtensionProperties(p PFNVoidFunction) (fn FuncEnumerateInstanceExtensionProperties) {
	return func(layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result) {
		var c struct {
			pLayerName     *C.char
			pPropertyCount *C.uint32_t
			pProperties    *C.VkExtensionProperties
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.pLayerName = toCString(layerName, m)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkExtensionProperties)(m.alloc(C.sizeof_VkExtensionProperties * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkEnumerateInstanceExtensionProperties(C.PFN_vkEnumerateInstanceExtensionProperties(unsafe.Pointer(p)), c.pLayerName, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNEnumerateDeviceExtensionProperties C.PFN_vkEnumerateDeviceExtensionProperties
type FuncEnumerateDeviceExtensionProperties func(physicalDevice PhysicalDevice, layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result)

func ToEnumerateDeviceExtensionProperties(p PFNVoidFunction) (fn FuncEnumerateDeviceExtensionProperties) {
	return func(physicalDevice PhysicalDevice, layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pLayerName     *C.char
			pPropertyCount *C.uint32_t
			pProperties    *C.VkExtensionProperties
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.pLayerName = toCString(layerName, m)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkExtensionProperties)(m.alloc(C.sizeof_VkExtensionProperties * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkEnumerateDeviceExtensionProperties(C.PFN_vkEnumerateDeviceExtensionProperties(unsafe.Pointer(p)), c.physicalDevice, c.pLayerName, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNEnumerateInstanceLayerProperties C.PFN_vkEnumerateInstanceLayerProperties
type LayerProperties struct {
	LayerName             [256]byte
	SpecVersion           uint32
	ImplementationVersion uint32
	Description           [256]byte
}

func (g *LayerProperties) toC(c *C.VkLayerProperties) {
	for i, _ := range g.LayerName {
		c.layerName[i] = C.char(g.LayerName[i])
	}
	c.specVersion = C.uint32_t(g.SpecVersion)
	c.implementationVersion = C.uint32_t(g.ImplementationVersion)
	for i, _ := range g.Description {
		c.description[i] = C.char(g.Description[i])
	}
}
func (g *LayerProperties) fromC(c *C.VkLayerProperties) {
	for i, _ := range g.LayerName {
		g.LayerName[i] = byte(c.layerName[i])
	}
	g.SpecVersion = uint32(c.specVersion)
	g.ImplementationVersion = uint32(c.implementationVersion)
	for i, _ := range g.Description {
		g.Description[i] = byte(c.description[i])
	}
}

type FuncEnumerateInstanceLayerProperties func(propertyCount *uint32, properties []LayerProperties) (_ret Result)

func ToEnumerateInstanceLayerProperties(p PFNVoidFunction) (fn FuncEnumerateInstanceLayerProperties) {
	return func(propertyCount *uint32, properties []LayerProperties) (_ret Result) {
		var c struct {
			pPropertyCount *C.uint32_t
			pProperties    *C.VkLayerProperties
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkLayerProperties)(m.alloc(C.sizeof_VkLayerProperties * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkEnumerateInstanceLayerProperties(C.PFN_vkEnumerateInstanceLayerProperties(unsafe.Pointer(p)), c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNEnumerateDeviceLayerProperties C.PFN_vkEnumerateDeviceLayerProperties
type FuncEnumerateDeviceLayerProperties func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []LayerProperties) (_ret Result)

func ToEnumerateDeviceLayerProperties(p PFNVoidFunction) (fn FuncEnumerateDeviceLayerProperties) {
	return func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []LayerProperties) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pPropertyCount *C.uint32_t
			pProperties    *C.VkLayerProperties
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkLayerProperties)(m.alloc(C.sizeof_VkLayerProperties * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkEnumerateDeviceLayerProperties(C.PFN_vkEnumerateDeviceLayerProperties(unsafe.Pointer(p)), c.physicalDevice, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetDeviceQueue C.PFN_vkGetDeviceQueue
type Queue C.VkQueue
type FuncGetDeviceQueue func(device Device, queueFamilyIndex uint32, queueIndex uint32, queue *Queue)

func ToGetDeviceQueue(p PFNVoidFunction) (fn FuncGetDeviceQueue) {
	return func(device Device, queueFamilyIndex uint32, queueIndex uint32, queue *Queue) {
		var c struct {
			device           C.VkDevice
			queueFamilyIndex C.uint32_t
			queueIndex       C.uint32_t
			pQueue           *C.VkQueue
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.queueFamilyIndex = C.uint32_t(queueFamilyIndex)
		c.queueIndex = C.uint32_t(queueIndex)
		if queue != nil {
			c.pQueue = (*C.VkQueue)(m.alloc(C.sizeof_VkQueue))
			*c.pQueue = C.VkQueue(*queue)
		} else {
			c.pQueue = nil
		}
		C.callPFN_vkGetDeviceQueue(C.PFN_vkGetDeviceQueue(unsafe.Pointer(p)), c.device, c.queueFamilyIndex, c.queueIndex, c.pQueue)
		if queue != nil {
			*queue = Queue(*c.pQueue)
		}
	}
}

type PFNQueueSubmit C.PFN_vkQueueSubmit
type Semaphore C.VkSemaphore
type PipelineStageFlags Flags
type CommandBuffer C.VkCommandBuffer
type SubmitInfo struct {
	Next             Structure
	WaitSemaphores   []Semaphore
	WaitDstStageMask *PipelineStageFlags
	CommandBuffers   []CommandBuffer
	SignalSemaphores []Semaphore
}

func (g *SubmitInfo) toC(c *C.VkSubmitInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.waitSemaphoreCount = C.uint32_t(len(g.WaitSemaphores))
	if len(g.WaitSemaphores) != 0 {
		c.pWaitSemaphores = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore * uint(len(g.WaitSemaphores))))
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			slice1[i1] = C.VkSemaphore(g.WaitSemaphores[i1])
		}
	} else {
		c.pWaitSemaphores = nil
	}
	if g.WaitDstStageMask != nil {
		c.pWaitDstStageMask = (*C.VkPipelineStageFlags)(m.alloc(C.sizeof_VkPipelineStageFlags))
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(*g.WaitDstStageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			*c.pWaitDstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
	} else {
		c.pWaitDstStageMask = nil
	}
	c.commandBufferCount = C.uint32_t(len(g.CommandBuffers))
	if len(g.CommandBuffers) != 0 {
		c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer * uint(len(g.CommandBuffers))))
		slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(g.CommandBuffers):len(g.CommandBuffers)]
		for i1, _ := range g.CommandBuffers {
			slice1[i1] = C.VkCommandBuffer(g.CommandBuffers[i1])
		}
	} else {
		c.pCommandBuffers = nil
	}
	c.signalSemaphoreCount = C.uint32_t(len(g.SignalSemaphores))
	if len(g.SignalSemaphores) != 0 {
		c.pSignalSemaphores = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore * uint(len(g.SignalSemaphores))))
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pSignalSemaphores))[:len(g.SignalSemaphores):len(g.SignalSemaphores)]
		for i1, _ := range g.SignalSemaphores {
			slice1[i1] = C.VkSemaphore(g.SignalSemaphores[i1])
		}
	} else {
		c.pSignalSemaphores = nil
	}
}
func (g *SubmitInfo) fromC(c *C.VkSubmitInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.WaitSemaphores = make([]Semaphore, int(c.waitSemaphoreCount))
	if len(g.WaitSemaphores) != 0 {
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			g.WaitSemaphores[i1] = Semaphore(slice1[i1])
		}
	}
	if g.WaitDstStageMask != nil {
		var temp_in_VkPipelineStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(*c.pWaitDstStageMask)))
			temp_in_VkPipelineStageFlags = Flags(temp_in_VkFlags)
		}
		*g.WaitDstStageMask = PipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	g.CommandBuffers = make([]CommandBuffer, int(c.commandBufferCount))
	if len(g.CommandBuffers) != 0 {
		slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(g.CommandBuffers):len(g.CommandBuffers)]
		for i1, _ := range g.CommandBuffers {
			g.CommandBuffers[i1] = CommandBuffer(slice1[i1])
		}
	}
	g.SignalSemaphores = make([]Semaphore, int(c.signalSemaphoreCount))
	if len(g.SignalSemaphores) != 0 {
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pSignalSemaphores))[:len(g.SignalSemaphores):len(g.SignalSemaphores)]
		for i1, _ := range g.SignalSemaphores {
			g.SignalSemaphores[i1] = Semaphore(slice1[i1])
		}
	}
}
func (s *SubmitInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SUBMIT_INFO
}
func (s *SubmitInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSubmitInfo)(m.alloc(C.sizeof_VkSubmitInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SubmitInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSubmitInfo)(p)
	s.fromC(c)
}
func (s *SubmitInfo) GetNext() Structure {
	return s.Next
}
func (s *SubmitInfo) SetNext(n Structure) {
	s.Next = n
}

type Fence C.VkFence
type FuncQueueSubmit func(queue Queue, submits []SubmitInfo, fence Fence) (_ret Result)

func ToQueueSubmit(p PFNVoidFunction) (fn FuncQueueSubmit) {
	return func(queue Queue, submits []SubmitInfo, fence Fence) (_ret Result) {
		var c struct {
			queue       C.VkQueue
			submitCount C.uint32_t
			pSubmits    *C.VkSubmitInfo
			fence       C.VkFence
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		c.submitCount = C.uint32_t(len(submits))
		if len(submits) != 0 {
			c.pSubmits = (*C.VkSubmitInfo)(m.alloc(C.sizeof_VkSubmitInfo * uint(len(submits))))
			slice1 := (*[1 << 31]C.VkSubmitInfo)(unsafe.Pointer(c.pSubmits))[:len(submits):len(submits)]
			for i1, _ := range submits {
				submits[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pSubmits = nil
		}
		c.fence = C.VkFence(fence)
		c._ret = C.callPFN_vkQueueSubmit(C.PFN_vkQueueSubmit(unsafe.Pointer(p)), c.queue, c.submitCount, c.pSubmits, c.fence)
		_ret = Result(c._ret)
		return
	}
}

type PFNQueueWaitIdle C.PFN_vkQueueWaitIdle
type FuncQueueWaitIdle func(queue Queue) (_ret Result)

func ToQueueWaitIdle(p PFNVoidFunction) (fn FuncQueueWaitIdle) {
	return func(queue Queue) (_ret Result) {
		var c struct {
			queue C.VkQueue
			_ret  C.VkResult
		}
		c.queue = C.VkQueue(queue)
		c._ret = C.callPFN_vkQueueWaitIdle(C.PFN_vkQueueWaitIdle(unsafe.Pointer(p)), c.queue)
		_ret = Result(c._ret)
		return
	}
}

type PFNDeviceWaitIdle C.PFN_vkDeviceWaitIdle
type FuncDeviceWaitIdle func(device Device) (_ret Result)

func ToDeviceWaitIdle(p PFNVoidFunction) (fn FuncDeviceWaitIdle) {
	return func(device Device) (_ret Result) {
		var c struct {
			device C.VkDevice
			_ret   C.VkResult
		}
		c.device = C.VkDevice(device)
		c._ret = C.callPFN_vkDeviceWaitIdle(C.PFN_vkDeviceWaitIdle(unsafe.Pointer(p)), c.device)
		_ret = Result(c._ret)
		return
	}
}

type PFNAllocateMemory C.PFN_vkAllocateMemory
type MemoryAllocateInfo struct {
	Next            Structure
	AllocationSize  DeviceSize
	MemoryTypeIndex uint32
}

func (g *MemoryAllocateInfo) toC(c *C.VkMemoryAllocateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.AllocationSize))
		c.allocationSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.memoryTypeIndex = C.uint32_t(g.MemoryTypeIndex)
}
func (g *MemoryAllocateInfo) fromC(c *C.VkMemoryAllocateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.allocationSize))
		g.AllocationSize = DeviceSize(temp_in_VkDeviceSize)
	}
	g.MemoryTypeIndex = uint32(c.memoryTypeIndex)
}
func (s *MemoryAllocateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
}
func (s *MemoryAllocateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryAllocateInfo)(m.alloc(C.sizeof_VkMemoryAllocateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryAllocateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryAllocateInfo)(p)
	s.fromC(c)
}
func (s *MemoryAllocateInfo) GetNext() Structure {
	return s.Next
}
func (s *MemoryAllocateInfo) SetNext(n Structure) {
	s.Next = n
}

type DeviceMemory C.VkDeviceMemory
type FuncAllocateMemory func(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks, memory *DeviceMemory) (_ret Result)

func ToAllocateMemory(p PFNVoidFunction) (fn FuncAllocateMemory) {
	return func(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks, memory *DeviceMemory) (_ret Result) {
		var c struct {
			device        C.VkDevice
			pAllocateInfo *C.VkMemoryAllocateInfo
			pAllocator    *C.VkAllocationCallbacks
			pMemory       *C.VkDeviceMemory
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if allocateInfo != nil {
			c.pAllocateInfo = (*C.VkMemoryAllocateInfo)(m.alloc(C.sizeof_VkMemoryAllocateInfo))
			allocateInfo.toC(c.pAllocateInfo, m)
		} else {
			c.pAllocateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if memory != nil {
			c.pMemory = (*C.VkDeviceMemory)(m.alloc(C.sizeof_VkDeviceMemory))
			*c.pMemory = C.VkDeviceMemory(*memory)
		} else {
			c.pMemory = nil
		}
		c._ret = C.callPFN_vkAllocateMemory(C.PFN_vkAllocateMemory(unsafe.Pointer(p)), c.device, c.pAllocateInfo, c.pAllocator, c.pMemory)
		_ret = Result(c._ret)
		if memory != nil {
			*memory = DeviceMemory(*c.pMemory)
		}
		return
	}
}

type PFNFreeMemory C.PFN_vkFreeMemory
type FuncFreeMemory func(device Device, memory DeviceMemory, allocator *AllocationCallbacks)

func ToFreeMemory(p PFNVoidFunction) (fn FuncFreeMemory) {
	return func(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			memory     C.VkDeviceMemory
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.memory = C.VkDeviceMemory(memory)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkFreeMemory(C.PFN_vkFreeMemory(unsafe.Pointer(p)), c.device, c.memory, c.pAllocator)
	}
}

type PFNMapMemory C.PFN_vkMapMemory
type MemoryMapFlags Flags
type FuncMapMemory func(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, data *unsafe.Pointer) (_ret Result)

func ToMapMemory(p PFNVoidFunction) (fn FuncMapMemory) {
	return func(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, data *unsafe.Pointer) (_ret Result) {
		var c struct {
			device C.VkDevice
			memory C.VkDeviceMemory
			offset C.VkDeviceSize
			size   C.VkDeviceSize
			flags  C.VkMemoryMapFlags
			ppData *unsafe.Pointer
			_ret   C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.memory = C.VkDeviceMemory(memory)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(size))
			c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkMemoryMapFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkMemoryMapFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkMemoryMapFlags(temp_in_VkMemoryMapFlags)
		}
		if data != nil {
			c.ppData = (*unsafe.Pointer)(m.alloc(C.sizeof_void_pointer))
			*c.ppData = *data
		} else {
			c.ppData = nil
		}
		c._ret = C.callPFN_vkMapMemory(C.PFN_vkMapMemory(unsafe.Pointer(p)), c.device, c.memory, c.offset, c.size, c.flags, c.ppData)
		_ret = Result(c._ret)
		if data != nil {
			*data = *c.ppData
		}
		return
	}
}

type PFNUnmapMemory C.PFN_vkUnmapMemory
type FuncUnmapMemory func(device Device, memory DeviceMemory)

func ToUnmapMemory(p PFNVoidFunction) (fn FuncUnmapMemory) {
	return func(device Device, memory DeviceMemory) {
		var c struct {
			device C.VkDevice
			memory C.VkDeviceMemory
		}
		c.device = C.VkDevice(device)
		c.memory = C.VkDeviceMemory(memory)
		C.callPFN_vkUnmapMemory(C.PFN_vkUnmapMemory(unsafe.Pointer(p)), c.device, c.memory)
	}
}

type PFNFlushMappedMemoryRanges C.PFN_vkFlushMappedMemoryRanges
type MappedMemoryRange struct {
	Next   Structure
	Memory DeviceMemory
	Offset DeviceSize
	Size   DeviceSize
}

func (g *MappedMemoryRange) toC(c *C.VkMappedMemoryRange, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.memory = C.VkDeviceMemory(g.Memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *MappedMemoryRange) fromC(c *C.VkMappedMemoryRange) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Memory = DeviceMemory(c.memory)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *MappedMemoryRange) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
}
func (s *MappedMemoryRange) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMappedMemoryRange)(m.alloc(C.sizeof_VkMappedMemoryRange))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MappedMemoryRange) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMappedMemoryRange)(p)
	s.fromC(c)
}
func (s *MappedMemoryRange) GetNext() Structure {
	return s.Next
}
func (s *MappedMemoryRange) SetNext(n Structure) {
	s.Next = n
}

type FuncFlushMappedMemoryRanges func(device Device, memoryRanges []MappedMemoryRange) (_ret Result)

func ToFlushMappedMemoryRanges(p PFNVoidFunction) (fn FuncFlushMappedMemoryRanges) {
	return func(device Device, memoryRanges []MappedMemoryRange) (_ret Result) {
		var c struct {
			device           C.VkDevice
			memoryRangeCount C.uint32_t
			pMemoryRanges    *C.VkMappedMemoryRange
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.memoryRangeCount = C.uint32_t(len(memoryRanges))
		if len(memoryRanges) != 0 {
			c.pMemoryRanges = (*C.VkMappedMemoryRange)(m.alloc(C.sizeof_VkMappedMemoryRange * uint(len(memoryRanges))))
			slice1 := (*[1 << 31]C.VkMappedMemoryRange)(unsafe.Pointer(c.pMemoryRanges))[:len(memoryRanges):len(memoryRanges)]
			for i1, _ := range memoryRanges {
				memoryRanges[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pMemoryRanges = nil
		}
		c._ret = C.callPFN_vkFlushMappedMemoryRanges(C.PFN_vkFlushMappedMemoryRanges(unsafe.Pointer(p)), c.device, c.memoryRangeCount, c.pMemoryRanges)
		_ret = Result(c._ret)
		return
	}
}

type PFNInvalidateMappedMemoryRanges C.PFN_vkInvalidateMappedMemoryRanges
type FuncInvalidateMappedMemoryRanges func(device Device, memoryRanges []MappedMemoryRange) (_ret Result)

func ToInvalidateMappedMemoryRanges(p PFNVoidFunction) (fn FuncInvalidateMappedMemoryRanges) {
	return func(device Device, memoryRanges []MappedMemoryRange) (_ret Result) {
		var c struct {
			device           C.VkDevice
			memoryRangeCount C.uint32_t
			pMemoryRanges    *C.VkMappedMemoryRange
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.memoryRangeCount = C.uint32_t(len(memoryRanges))
		if len(memoryRanges) != 0 {
			c.pMemoryRanges = (*C.VkMappedMemoryRange)(m.alloc(C.sizeof_VkMappedMemoryRange * uint(len(memoryRanges))))
			slice1 := (*[1 << 31]C.VkMappedMemoryRange)(unsafe.Pointer(c.pMemoryRanges))[:len(memoryRanges):len(memoryRanges)]
			for i1, _ := range memoryRanges {
				memoryRanges[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pMemoryRanges = nil
		}
		c._ret = C.callPFN_vkInvalidateMappedMemoryRanges(C.PFN_vkInvalidateMappedMemoryRanges(unsafe.Pointer(p)), c.device, c.memoryRangeCount, c.pMemoryRanges)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetDeviceMemoryCommitment C.PFN_vkGetDeviceMemoryCommitment
type FuncGetDeviceMemoryCommitment func(device Device, memory DeviceMemory, committedMemoryInBytes *DeviceSize)

func ToGetDeviceMemoryCommitment(p PFNVoidFunction) (fn FuncGetDeviceMemoryCommitment) {
	return func(device Device, memory DeviceMemory, committedMemoryInBytes *DeviceSize) {
		var c struct {
			device                  C.VkDevice
			memory                  C.VkDeviceMemory
			pCommittedMemoryInBytes *C.VkDeviceSize
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.memory = C.VkDeviceMemory(memory)
		if committedMemoryInBytes != nil {
			c.pCommittedMemoryInBytes = (*C.VkDeviceSize)(m.alloc(C.sizeof_VkDeviceSize))
			{
				var temp_in_VkDeviceSize C.uint64_t
				temp_in_VkDeviceSize = C.uint64_t((uint64)(*committedMemoryInBytes))
				*c.pCommittedMemoryInBytes = C.VkDeviceSize(temp_in_VkDeviceSize)
			}
		} else {
			c.pCommittedMemoryInBytes = nil
		}
		C.callPFN_vkGetDeviceMemoryCommitment(C.PFN_vkGetDeviceMemoryCommitment(unsafe.Pointer(p)), c.device, c.memory, c.pCommittedMemoryInBytes)
		if committedMemoryInBytes != nil {
			var temp_in_VkDeviceSize uint64
			temp_in_VkDeviceSize = uint64((C.uint64_t)(*c.pCommittedMemoryInBytes))
			*committedMemoryInBytes = DeviceSize(temp_in_VkDeviceSize)
		}
	}
}

type PFNBindBufferMemory C.PFN_vkBindBufferMemory
type Buffer C.VkBuffer
type FuncBindBufferMemory func(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result)

func ToBindBufferMemory(p PFNVoidFunction) (fn FuncBindBufferMemory) {
	return func(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result) {
		var c struct {
			device       C.VkDevice
			buffer       C.VkBuffer
			memory       C.VkDeviceMemory
			memoryOffset C.VkDeviceSize
			_ret         C.VkResult
		}
		c.device = C.VkDevice(device)
		c.buffer = C.VkBuffer(buffer)
		c.memory = C.VkDeviceMemory(memory)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(memoryOffset))
			c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c._ret = C.callPFN_vkBindBufferMemory(C.PFN_vkBindBufferMemory(unsafe.Pointer(p)), c.device, c.buffer, c.memory, c.memoryOffset)
		_ret = Result(c._ret)
		return
	}
}

type PFNBindImageMemory C.PFN_vkBindImageMemory
type Image C.VkImage
type FuncBindImageMemory func(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result)

func ToBindImageMemory(p PFNVoidFunction) (fn FuncBindImageMemory) {
	return func(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result) {
		var c struct {
			device       C.VkDevice
			image        C.VkImage
			memory       C.VkDeviceMemory
			memoryOffset C.VkDeviceSize
			_ret         C.VkResult
		}
		c.device = C.VkDevice(device)
		c.image = C.VkImage(image)
		c.memory = C.VkDeviceMemory(memory)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(memoryOffset))
			c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c._ret = C.callPFN_vkBindImageMemory(C.PFN_vkBindImageMemory(unsafe.Pointer(p)), c.device, c.image, c.memory, c.memoryOffset)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetBufferMemoryRequirements C.PFN_vkGetBufferMemoryRequirements
type MemoryRequirements struct {
	Size           DeviceSize
	Alignment      DeviceSize
	MemoryTypeBits uint32
}

func (g *MemoryRequirements) toC(c *C.VkMemoryRequirements) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Alignment))
		c.alignment = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.memoryTypeBits = C.uint32_t(g.MemoryTypeBits)
}
func (g *MemoryRequirements) fromC(c *C.VkMemoryRequirements) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.alignment))
		g.Alignment = DeviceSize(temp_in_VkDeviceSize)
	}
	g.MemoryTypeBits = uint32(c.memoryTypeBits)
}

type FuncGetBufferMemoryRequirements func(device Device, buffer Buffer, memoryRequirements *MemoryRequirements)

func ToGetBufferMemoryRequirements(p PFNVoidFunction) (fn FuncGetBufferMemoryRequirements) {
	return func(device Device, buffer Buffer, memoryRequirements *MemoryRequirements) {
		var c struct {
			device              C.VkDevice
			buffer              C.VkBuffer
			pMemoryRequirements *C.VkMemoryRequirements
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.buffer = C.VkBuffer(buffer)
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements)(m.alloc(C.sizeof_VkMemoryRequirements))
			memoryRequirements.toC(c.pMemoryRequirements)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetBufferMemoryRequirements(C.PFN_vkGetBufferMemoryRequirements(unsafe.Pointer(p)), c.device, c.buffer, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetImageMemoryRequirements C.PFN_vkGetImageMemoryRequirements
type FuncGetImageMemoryRequirements func(device Device, image Image, memoryRequirements *MemoryRequirements)

func ToGetImageMemoryRequirements(p PFNVoidFunction) (fn FuncGetImageMemoryRequirements) {
	return func(device Device, image Image, memoryRequirements *MemoryRequirements) {
		var c struct {
			device              C.VkDevice
			image               C.VkImage
			pMemoryRequirements *C.VkMemoryRequirements
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.image = C.VkImage(image)
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements)(m.alloc(C.sizeof_VkMemoryRequirements))
			memoryRequirements.toC(c.pMemoryRequirements)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetImageMemoryRequirements(C.PFN_vkGetImageMemoryRequirements(unsafe.Pointer(p)), c.device, c.image, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetImageSparseMemoryRequirements C.PFN_vkGetImageSparseMemoryRequirements
type ImageAspectFlags Flags
type SparseImageFormatFlags Flags
type SparseImageFormatProperties struct {
	AspectMask       ImageAspectFlags
	ImageGranularity Extent3D
	Flags            SparseImageFormatFlags
}

func (g *SparseImageFormatProperties) toC(c *C.VkSparseImageFormatProperties) {
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.ImageGranularity.toC(&c.imageGranularity)
	{
		var temp_in_VkSparseImageFormatFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSparseImageFormatFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSparseImageFormatFlags(temp_in_VkSparseImageFormatFlags)
	}
}
func (g *SparseImageFormatProperties) fromC(c *C.VkSparseImageFormatProperties) {
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.ImageGranularity.fromC(&c.imageGranularity)
	{
		var temp_in_VkSparseImageFormatFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSparseImageFormatFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SparseImageFormatFlags(temp_in_VkSparseImageFormatFlags)
	}
}

type SparseImageMemoryRequirements struct {
	FormatProperties     SparseImageFormatProperties
	ImageMipTailFirstLod uint32
	ImageMipTailSize     DeviceSize
	ImageMipTailOffset   DeviceSize
	ImageMipTailStride   DeviceSize
}

func (g *SparseImageMemoryRequirements) toC(c *C.VkSparseImageMemoryRequirements) {
	g.FormatProperties.toC(&c.formatProperties)
	c.imageMipTailFirstLod = C.uint32_t(g.ImageMipTailFirstLod)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.ImageMipTailSize))
		c.imageMipTailSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.ImageMipTailOffset))
		c.imageMipTailOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.ImageMipTailStride))
		c.imageMipTailStride = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *SparseImageMemoryRequirements) fromC(c *C.VkSparseImageMemoryRequirements) {
	g.FormatProperties.fromC(&c.formatProperties)
	g.ImageMipTailFirstLod = uint32(c.imageMipTailFirstLod)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.imageMipTailSize))
		g.ImageMipTailSize = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.imageMipTailOffset))
		g.ImageMipTailOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.imageMipTailStride))
		g.ImageMipTailStride = DeviceSize(temp_in_VkDeviceSize)
	}
}

type FuncGetImageSparseMemoryRequirements func(device Device, image Image, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements)

func ToGetImageSparseMemoryRequirements(p PFNVoidFunction) (fn FuncGetImageSparseMemoryRequirements) {
	return func(device Device, image Image, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements) {
		var c struct {
			device                        C.VkDevice
			image                         C.VkImage
			pSparseMemoryRequirementCount *C.uint32_t
			pSparseMemoryRequirements     *C.VkSparseImageMemoryRequirements
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.image = C.VkImage(image)
		if sparseMemoryRequirementCount != nil {
			c.pSparseMemoryRequirementCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSparseMemoryRequirementCount = C.uint32_t(*sparseMemoryRequirementCount)
		} else {
			c.pSparseMemoryRequirementCount = nil
		}
		if len(sparseMemoryRequirements) != 0 {
			c.pSparseMemoryRequirements = (*C.VkSparseImageMemoryRequirements)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements * uint(len(sparseMemoryRequirements))))
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].toC(&slice1[i1])
			}
		} else {
			c.pSparseMemoryRequirements = nil
		}
		C.callPFN_vkGetImageSparseMemoryRequirements(C.PFN_vkGetImageSparseMemoryRequirements(unsafe.Pointer(p)), c.device, c.image, c.pSparseMemoryRequirementCount, c.pSparseMemoryRequirements)
		if sparseMemoryRequirementCount != nil {
			*sparseMemoryRequirementCount = uint32(*c.pSparseMemoryRequirementCount)
		}
		if len(sparseMemoryRequirements) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetPhysicalDeviceSparseImageFormatProperties C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties
type FuncGetPhysicalDeviceSparseImageFormatProperties func(physicalDevice PhysicalDevice, format Format, _type ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, propertyCount *uint32, properties []SparseImageFormatProperties)

func ToGetPhysicalDeviceSparseImageFormatProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSparseImageFormatProperties) {
	return func(physicalDevice PhysicalDevice, format Format, _type ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, propertyCount *uint32, properties []SparseImageFormatProperties) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			format         C.VkFormat
			_type          C.VkImageType
			samples        C.VkSampleCountFlagBits
			usage          C.VkImageUsageFlags
			tiling         C.VkImageTiling
			pPropertyCount *C.uint32_t
			pProperties    *C.VkSparseImageFormatProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		c._type = C.VkImageType(_type)
		c.samples = C.VkSampleCountFlagBits(samples)
		{
			var temp_in_VkImageUsageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(usage)))
				temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
		}
		c.tiling = C.VkImageTiling(tiling)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkSparseImageFormatProperties)(m.alloc(C.sizeof_VkSparseImageFormatProperties * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceSparseImageFormatProperties(C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties(unsafe.Pointer(p)), c.physicalDevice, c.format, c._type, c.samples, c.usage, c.tiling, c.pPropertyCount, c.pProperties)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNQueueBindSparse C.PFN_vkQueueBindSparse
type SparseMemoryBindFlags Flags
type SparseMemoryBind struct {
	ResourceOffset DeviceSize
	Size           DeviceSize
	Memory         DeviceMemory
	MemoryOffset   DeviceSize
	Flags          SparseMemoryBindFlags
}

func (g *SparseMemoryBind) toC(c *C.VkSparseMemoryBind) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.ResourceOffset))
		c.resourceOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.memory = C.VkDeviceMemory(g.Memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MemoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkSparseMemoryBindFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSparseMemoryBindFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSparseMemoryBindFlags(temp_in_VkSparseMemoryBindFlags)
	}
}
func (g *SparseMemoryBind) fromC(c *C.VkSparseMemoryBind) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.resourceOffset))
		g.ResourceOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
	g.Memory = DeviceMemory(c.memory)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.memoryOffset))
		g.MemoryOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkSparseMemoryBindFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSparseMemoryBindFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SparseMemoryBindFlags(temp_in_VkSparseMemoryBindFlags)
	}
}

type SparseBufferMemoryBindInfo struct {
	Buffer Buffer
	Binds  []SparseMemoryBind
}

func (g *SparseBufferMemoryBindInfo) toC(c *C.VkSparseBufferMemoryBindInfo, m *cmemory) {
	c.buffer = C.VkBuffer(g.Buffer)
	c.bindCount = C.uint32_t(len(g.Binds))
	if len(g.Binds) != 0 {
		c.pBinds = (*C.VkSparseMemoryBind)(m.alloc(C.sizeof_VkSparseMemoryBind * uint(len(g.Binds))))
		slice1 := (*[1 << 31]C.VkSparseMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].toC(&slice1[i1])
		}
	} else {
		c.pBinds = nil
	}
}
func (g *SparseBufferMemoryBindInfo) fromC(c *C.VkSparseBufferMemoryBindInfo) {
	g.Buffer = Buffer(c.buffer)
	g.Binds = make([]SparseMemoryBind, int(c.bindCount))
	if len(g.Binds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].fromC(&slice1[i1])
		}
	}
}

type SparseImageOpaqueMemoryBindInfo struct {
	Image Image
	Binds []SparseMemoryBind
}

func (g *SparseImageOpaqueMemoryBindInfo) toC(c *C.VkSparseImageOpaqueMemoryBindInfo, m *cmemory) {
	c.image = C.VkImage(g.Image)
	c.bindCount = C.uint32_t(len(g.Binds))
	if len(g.Binds) != 0 {
		c.pBinds = (*C.VkSparseMemoryBind)(m.alloc(C.sizeof_VkSparseMemoryBind * uint(len(g.Binds))))
		slice1 := (*[1 << 31]C.VkSparseMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].toC(&slice1[i1])
		}
	} else {
		c.pBinds = nil
	}
}
func (g *SparseImageOpaqueMemoryBindInfo) fromC(c *C.VkSparseImageOpaqueMemoryBindInfo) {
	g.Image = Image(c.image)
	g.Binds = make([]SparseMemoryBind, int(c.bindCount))
	if len(g.Binds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].fromC(&slice1[i1])
		}
	}
}

type ImageSubresource struct {
	AspectMask ImageAspectFlags
	MipLevel   uint32
	ArrayLayer uint32
}

func (g *ImageSubresource) toC(c *C.VkImageSubresource) {
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	c.mipLevel = C.uint32_t(g.MipLevel)
	c.arrayLayer = C.uint32_t(g.ArrayLayer)
}
func (g *ImageSubresource) fromC(c *C.VkImageSubresource) {
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.MipLevel = uint32(c.mipLevel)
	g.ArrayLayer = uint32(c.arrayLayer)
}

type Offset3D struct {
	X int32
	Y int32
	Z int32
}

func (g *Offset3D) toC(c *C.VkOffset3D) {
	c.x = C.int32_t(g.X)
	c.y = C.int32_t(g.Y)
	c.z = C.int32_t(g.Z)
}
func (g *Offset3D) fromC(c *C.VkOffset3D) {
	g.X = int32(c.x)
	g.Y = int32(c.y)
	g.Z = int32(c.z)
}

type SparseImageMemoryBind struct {
	Subresource  ImageSubresource
	Offset       Offset3D
	Extent       Extent3D
	Memory       DeviceMemory
	MemoryOffset DeviceSize
	Flags        SparseMemoryBindFlags
}

func (g *SparseImageMemoryBind) toC(c *C.VkSparseImageMemoryBind) {
	g.Subresource.toC(&c.subresource)
	g.Offset.toC(&c.offset)
	g.Extent.toC(&c.extent)
	c.memory = C.VkDeviceMemory(g.Memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MemoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkSparseMemoryBindFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSparseMemoryBindFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSparseMemoryBindFlags(temp_in_VkSparseMemoryBindFlags)
	}
}
func (g *SparseImageMemoryBind) fromC(c *C.VkSparseImageMemoryBind) {
	g.Subresource.fromC(&c.subresource)
	g.Offset.fromC(&c.offset)
	g.Extent.fromC(&c.extent)
	g.Memory = DeviceMemory(c.memory)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.memoryOffset))
		g.MemoryOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkSparseMemoryBindFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSparseMemoryBindFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SparseMemoryBindFlags(temp_in_VkSparseMemoryBindFlags)
	}
}

type SparseImageMemoryBindInfo struct {
	Image Image
	Binds []SparseImageMemoryBind
}

func (g *SparseImageMemoryBindInfo) toC(c *C.VkSparseImageMemoryBindInfo, m *cmemory) {
	c.image = C.VkImage(g.Image)
	c.bindCount = C.uint32_t(len(g.Binds))
	if len(g.Binds) != 0 {
		c.pBinds = (*C.VkSparseImageMemoryBind)(m.alloc(C.sizeof_VkSparseImageMemoryBind * uint(len(g.Binds))))
		slice1 := (*[1 << 31]C.VkSparseImageMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].toC(&slice1[i1])
		}
	} else {
		c.pBinds = nil
	}
}
func (g *SparseImageMemoryBindInfo) fromC(c *C.VkSparseImageMemoryBindInfo) {
	g.Image = Image(c.image)
	g.Binds = make([]SparseImageMemoryBind, int(c.bindCount))
	if len(g.Binds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageMemoryBind)(unsafe.Pointer(c.pBinds))[:len(g.Binds):len(g.Binds)]
		for i1, _ := range g.Binds {
			g.Binds[i1].fromC(&slice1[i1])
		}
	}
}

type BindSparseInfo struct {
	Next             Structure
	WaitSemaphores   []Semaphore
	BufferBinds      []SparseBufferMemoryBindInfo
	ImageOpaqueBinds []SparseImageOpaqueMemoryBindInfo
	ImageBinds       []SparseImageMemoryBindInfo
	SignalSemaphores []Semaphore
}

func (g *BindSparseInfo) toC(c *C.VkBindSparseInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.waitSemaphoreCount = C.uint32_t(len(g.WaitSemaphores))
	if len(g.WaitSemaphores) != 0 {
		c.pWaitSemaphores = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore * uint(len(g.WaitSemaphores))))
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			slice1[i1] = C.VkSemaphore(g.WaitSemaphores[i1])
		}
	} else {
		c.pWaitSemaphores = nil
	}
	c.bufferBindCount = C.uint32_t(len(g.BufferBinds))
	if len(g.BufferBinds) != 0 {
		c.pBufferBinds = (*C.VkSparseBufferMemoryBindInfo)(m.alloc(C.sizeof_VkSparseBufferMemoryBindInfo * uint(len(g.BufferBinds))))
		slice1 := (*[1 << 31]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(c.pBufferBinds))[:len(g.BufferBinds):len(g.BufferBinds)]
		for i1, _ := range g.BufferBinds {
			g.BufferBinds[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBufferBinds = nil
	}
	c.imageOpaqueBindCount = C.uint32_t(len(g.ImageOpaqueBinds))
	if len(g.ImageOpaqueBinds) != 0 {
		c.pImageOpaqueBinds = (*C.VkSparseImageOpaqueMemoryBindInfo)(m.alloc(C.sizeof_VkSparseImageOpaqueMemoryBindInfo * uint(len(g.ImageOpaqueBinds))))
		slice1 := (*[1 << 31]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(c.pImageOpaqueBinds))[:len(g.ImageOpaqueBinds):len(g.ImageOpaqueBinds)]
		for i1, _ := range g.ImageOpaqueBinds {
			g.ImageOpaqueBinds[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pImageOpaqueBinds = nil
	}
	c.imageBindCount = C.uint32_t(len(g.ImageBinds))
	if len(g.ImageBinds) != 0 {
		c.pImageBinds = (*C.VkSparseImageMemoryBindInfo)(m.alloc(C.sizeof_VkSparseImageMemoryBindInfo * uint(len(g.ImageBinds))))
		slice1 := (*[1 << 31]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(c.pImageBinds))[:len(g.ImageBinds):len(g.ImageBinds)]
		for i1, _ := range g.ImageBinds {
			g.ImageBinds[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pImageBinds = nil
	}
	c.signalSemaphoreCount = C.uint32_t(len(g.SignalSemaphores))
	if len(g.SignalSemaphores) != 0 {
		c.pSignalSemaphores = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore * uint(len(g.SignalSemaphores))))
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pSignalSemaphores))[:len(g.SignalSemaphores):len(g.SignalSemaphores)]
		for i1, _ := range g.SignalSemaphores {
			slice1[i1] = C.VkSemaphore(g.SignalSemaphores[i1])
		}
	} else {
		c.pSignalSemaphores = nil
	}
}
func (g *BindSparseInfo) fromC(c *C.VkBindSparseInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.WaitSemaphores = make([]Semaphore, int(c.waitSemaphoreCount))
	if len(g.WaitSemaphores) != 0 {
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			g.WaitSemaphores[i1] = Semaphore(slice1[i1])
		}
	}
	g.BufferBinds = make([]SparseBufferMemoryBindInfo, int(c.bufferBindCount))
	if len(g.BufferBinds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(c.pBufferBinds))[:len(g.BufferBinds):len(g.BufferBinds)]
		for i1, _ := range g.BufferBinds {
			g.BufferBinds[i1].fromC(&slice1[i1])
		}
	}
	g.ImageOpaqueBinds = make([]SparseImageOpaqueMemoryBindInfo, int(c.imageOpaqueBindCount))
	if len(g.ImageOpaqueBinds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(c.pImageOpaqueBinds))[:len(g.ImageOpaqueBinds):len(g.ImageOpaqueBinds)]
		for i1, _ := range g.ImageOpaqueBinds {
			g.ImageOpaqueBinds[i1].fromC(&slice1[i1])
		}
	}
	g.ImageBinds = make([]SparseImageMemoryBindInfo, int(c.imageBindCount))
	if len(g.ImageBinds) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(c.pImageBinds))[:len(g.ImageBinds):len(g.ImageBinds)]
		for i1, _ := range g.ImageBinds {
			g.ImageBinds[i1].fromC(&slice1[i1])
		}
	}
	g.SignalSemaphores = make([]Semaphore, int(c.signalSemaphoreCount))
	if len(g.SignalSemaphores) != 0 {
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pSignalSemaphores))[:len(g.SignalSemaphores):len(g.SignalSemaphores)]
		for i1, _ := range g.SignalSemaphores {
			g.SignalSemaphores[i1] = Semaphore(slice1[i1])
		}
	}
}
func (s *BindSparseInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
}
func (s *BindSparseInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBindSparseInfo)(m.alloc(C.sizeof_VkBindSparseInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BindSparseInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBindSparseInfo)(p)
	s.fromC(c)
}
func (s *BindSparseInfo) GetNext() Structure {
	return s.Next
}
func (s *BindSparseInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncQueueBindSparse func(queue Queue, bindInfoCount uint32, bindInfo *BindSparseInfo, fence Fence) (_ret Result)

func ToQueueBindSparse(p PFNVoidFunction) (fn FuncQueueBindSparse) {
	return func(queue Queue, bindInfoCount uint32, bindInfo *BindSparseInfo, fence Fence) (_ret Result) {
		var c struct {
			queue         C.VkQueue
			bindInfoCount C.uint32_t
			pBindInfo     *C.VkBindSparseInfo
			fence         C.VkFence
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		c.bindInfoCount = C.uint32_t(bindInfoCount)
		if bindInfo != nil {
			c.pBindInfo = (*C.VkBindSparseInfo)(m.alloc(C.sizeof_VkBindSparseInfo))
			bindInfo.toC(c.pBindInfo, m)
		} else {
			c.pBindInfo = nil
		}
		c.fence = C.VkFence(fence)
		c._ret = C.callPFN_vkQueueBindSparse(C.PFN_vkQueueBindSparse(unsafe.Pointer(p)), c.queue, c.bindInfoCount, c.pBindInfo, c.fence)
		_ret = Result(c._ret)
		return
	}
}

type PFNCreateFence C.PFN_vkCreateFence
type FenceCreateFlags Flags
type FenceCreateInfo struct {
	Next  Structure
	Flags FenceCreateFlags
}

func (g *FenceCreateInfo) toC(c *C.VkFenceCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkFenceCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkFenceCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkFenceCreateFlags(temp_in_VkFenceCreateFlags)
	}
}
func (g *FenceCreateInfo) fromC(c *C.VkFenceCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkFenceCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkFenceCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = FenceCreateFlags(temp_in_VkFenceCreateFlags)
	}
}
func (s *FenceCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
}
func (s *FenceCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkFenceCreateInfo)(m.alloc(C.sizeof_VkFenceCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *FenceCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkFenceCreateInfo)(p)
	s.fromC(c)
}
func (s *FenceCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *FenceCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateFence func(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks, fence *Fence) (_ret Result)

func ToCreateFence(p PFNVoidFunction) (fn FuncCreateFence) {
	return func(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks, fence *Fence) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkFenceCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pFence      *C.VkFence
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkFenceCreateInfo)(m.alloc(C.sizeof_VkFenceCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if fence != nil {
			c.pFence = (*C.VkFence)(m.alloc(C.sizeof_VkFence))
			*c.pFence = C.VkFence(*fence)
		} else {
			c.pFence = nil
		}
		c._ret = C.callPFN_vkCreateFence(C.PFN_vkCreateFence(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pFence)
		_ret = Result(c._ret)
		if fence != nil {
			*fence = Fence(*c.pFence)
		}
		return
	}
}

type PFNDestroyFence C.PFN_vkDestroyFence
type FuncDestroyFence func(device Device, fence Fence, allocator *AllocationCallbacks)

func ToDestroyFence(p PFNVoidFunction) (fn FuncDestroyFence) {
	return func(device Device, fence Fence, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			fence      C.VkFence
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.fence = C.VkFence(fence)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyFence(C.PFN_vkDestroyFence(unsafe.Pointer(p)), c.device, c.fence, c.pAllocator)
	}
}

type PFNResetFences C.PFN_vkResetFences
type FuncResetFences func(device Device, fences []Fence) (_ret Result)

func ToResetFences(p PFNVoidFunction) (fn FuncResetFences) {
	return func(device Device, fences []Fence) (_ret Result) {
		var c struct {
			device     C.VkDevice
			fenceCount C.uint32_t
			pFences    *C.VkFence
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.fenceCount = C.uint32_t(len(fences))
		if len(fences) != 0 {
			c.pFences = (*C.VkFence)(m.alloc(C.sizeof_VkFence * uint(len(fences))))
			slice1 := (*[1 << 31]C.VkFence)(unsafe.Pointer(c.pFences))[:len(fences):len(fences)]
			for i1, _ := range fences {
				slice1[i1] = C.VkFence(fences[i1])
			}
		} else {
			c.pFences = nil
		}
		c._ret = C.callPFN_vkResetFences(C.PFN_vkResetFences(unsafe.Pointer(p)), c.device, c.fenceCount, c.pFences)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetFenceStatus C.PFN_vkGetFenceStatus
type FuncGetFenceStatus func(device Device, fence Fence) (_ret Result)

func ToGetFenceStatus(p PFNVoidFunction) (fn FuncGetFenceStatus) {
	return func(device Device, fence Fence) (_ret Result) {
		var c struct {
			device C.VkDevice
			fence  C.VkFence
			_ret   C.VkResult
		}
		c.device = C.VkDevice(device)
		c.fence = C.VkFence(fence)
		c._ret = C.callPFN_vkGetFenceStatus(C.PFN_vkGetFenceStatus(unsafe.Pointer(p)), c.device, c.fence)
		_ret = Result(c._ret)
		return
	}
}

type PFNWaitForFences C.PFN_vkWaitForFences
type FuncWaitForFences func(device Device, fences []Fence, waitAll bool, timeout uint64) (_ret Result)

func ToWaitForFences(p PFNVoidFunction) (fn FuncWaitForFences) {
	return func(device Device, fences []Fence, waitAll bool, timeout uint64) (_ret Result) {
		var c struct {
			device     C.VkDevice
			fenceCount C.uint32_t
			pFences    *C.VkFence
			waitAll    C.VkBool32
			timeout    C.uint64_t
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.fenceCount = C.uint32_t(len(fences))
		if len(fences) != 0 {
			c.pFences = (*C.VkFence)(m.alloc(C.sizeof_VkFence * uint(len(fences))))
			slice1 := (*[1 << 31]C.VkFence)(unsafe.Pointer(c.pFences))[:len(fences):len(fences)]
			for i1, _ := range fences {
				slice1[i1] = C.VkFence(fences[i1])
			}
		} else {
			c.pFences = nil
		}
		if waitAll {
			c.waitAll = 1
		} else {
			c.waitAll = 0
		}
		c.timeout = C.uint64_t(timeout)
		c._ret = C.callPFN_vkWaitForFences(C.PFN_vkWaitForFences(unsafe.Pointer(p)), c.device, c.fenceCount, c.pFences, c.waitAll, c.timeout)
		_ret = Result(c._ret)
		return
	}
}

type PFNCreateSemaphore C.PFN_vkCreateSemaphore
type SemaphoreCreateFlags Flags
type SemaphoreCreateInfo struct {
	Next  Structure
	Flags SemaphoreCreateFlags
}

func (g *SemaphoreCreateInfo) toC(c *C.VkSemaphoreCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkSemaphoreCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSemaphoreCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSemaphoreCreateFlags(temp_in_VkSemaphoreCreateFlags)
	}
}
func (g *SemaphoreCreateInfo) fromC(c *C.VkSemaphoreCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkSemaphoreCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSemaphoreCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SemaphoreCreateFlags(temp_in_VkSemaphoreCreateFlags)
	}
}
func (s *SemaphoreCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
}
func (s *SemaphoreCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSemaphoreCreateInfo)(m.alloc(C.sizeof_VkSemaphoreCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SemaphoreCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSemaphoreCreateInfo)(p)
	s.fromC(c)
}
func (s *SemaphoreCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *SemaphoreCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateSemaphore func(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks, semaphore *Semaphore) (_ret Result)

func ToCreateSemaphore(p PFNVoidFunction) (fn FuncCreateSemaphore) {
	return func(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks, semaphore *Semaphore) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkSemaphoreCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pSemaphore  *C.VkSemaphore
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkSemaphoreCreateInfo)(m.alloc(C.sizeof_VkSemaphoreCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if semaphore != nil {
			c.pSemaphore = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore))
			*c.pSemaphore = C.VkSemaphore(*semaphore)
		} else {
			c.pSemaphore = nil
		}
		c._ret = C.callPFN_vkCreateSemaphore(C.PFN_vkCreateSemaphore(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pSemaphore)
		_ret = Result(c._ret)
		if semaphore != nil {
			*semaphore = Semaphore(*c.pSemaphore)
		}
		return
	}
}

type PFNDestroySemaphore C.PFN_vkDestroySemaphore
type FuncDestroySemaphore func(device Device, semaphore Semaphore, allocator *AllocationCallbacks)

func ToDestroySemaphore(p PFNVoidFunction) (fn FuncDestroySemaphore) {
	return func(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			semaphore  C.VkSemaphore
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.semaphore = C.VkSemaphore(semaphore)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySemaphore(C.PFN_vkDestroySemaphore(unsafe.Pointer(p)), c.device, c.semaphore, c.pAllocator)
	}
}

type PFNCreateEvent C.PFN_vkCreateEvent
type EventCreateFlags Flags
type EventCreateInfo struct {
	Next  Structure
	Flags EventCreateFlags
}

func (g *EventCreateInfo) toC(c *C.VkEventCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkEventCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkEventCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkEventCreateFlags(temp_in_VkEventCreateFlags)
	}
}
func (g *EventCreateInfo) fromC(c *C.VkEventCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkEventCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkEventCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = EventCreateFlags(temp_in_VkEventCreateFlags)
	}
}
func (s *EventCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
}
func (s *EventCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkEventCreateInfo)(m.alloc(C.sizeof_VkEventCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *EventCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkEventCreateInfo)(p)
	s.fromC(c)
}
func (s *EventCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *EventCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type Event C.VkEvent
type FuncCreateEvent func(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks, event *Event) (_ret Result)

func ToCreateEvent(p PFNVoidFunction) (fn FuncCreateEvent) {
	return func(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks, event *Event) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkEventCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pEvent      *C.VkEvent
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkEventCreateInfo)(m.alloc(C.sizeof_VkEventCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if event != nil {
			c.pEvent = (*C.VkEvent)(m.alloc(C.sizeof_VkEvent))
			*c.pEvent = C.VkEvent(*event)
		} else {
			c.pEvent = nil
		}
		c._ret = C.callPFN_vkCreateEvent(C.PFN_vkCreateEvent(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pEvent)
		_ret = Result(c._ret)
		if event != nil {
			*event = Event(*c.pEvent)
		}
		return
	}
}

type PFNDestroyEvent C.PFN_vkDestroyEvent
type FuncDestroyEvent func(device Device, event Event, allocator *AllocationCallbacks)

func ToDestroyEvent(p PFNVoidFunction) (fn FuncDestroyEvent) {
	return func(device Device, event Event, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			event      C.VkEvent
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.event = C.VkEvent(event)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyEvent(C.PFN_vkDestroyEvent(unsafe.Pointer(p)), c.device, c.event, c.pAllocator)
	}
}

type PFNGetEventStatus C.PFN_vkGetEventStatus
type FuncGetEventStatus func(device Device, event Event) (_ret Result)

func ToGetEventStatus(p PFNVoidFunction) (fn FuncGetEventStatus) {
	return func(device Device, event Event) (_ret Result) {
		var c struct {
			device C.VkDevice
			event  C.VkEvent
			_ret   C.VkResult
		}
		c.device = C.VkDevice(device)
		c.event = C.VkEvent(event)
		c._ret = C.callPFN_vkGetEventStatus(C.PFN_vkGetEventStatus(unsafe.Pointer(p)), c.device, c.event)
		_ret = Result(c._ret)
		return
	}
}

type PFNSetEvent C.PFN_vkSetEvent
type FuncSetEvent func(device Device, event Event) (_ret Result)

func ToSetEvent(p PFNVoidFunction) (fn FuncSetEvent) {
	return func(device Device, event Event) (_ret Result) {
		var c struct {
			device C.VkDevice
			event  C.VkEvent
			_ret   C.VkResult
		}
		c.device = C.VkDevice(device)
		c.event = C.VkEvent(event)
		c._ret = C.callPFN_vkSetEvent(C.PFN_vkSetEvent(unsafe.Pointer(p)), c.device, c.event)
		_ret = Result(c._ret)
		return
	}
}

type PFNResetEvent C.PFN_vkResetEvent
type FuncResetEvent func(device Device, event Event) (_ret Result)

func ToResetEvent(p PFNVoidFunction) (fn FuncResetEvent) {
	return func(device Device, event Event) (_ret Result) {
		var c struct {
			device C.VkDevice
			event  C.VkEvent
			_ret   C.VkResult
		}
		c.device = C.VkDevice(device)
		c.event = C.VkEvent(event)
		c._ret = C.callPFN_vkResetEvent(C.PFN_vkResetEvent(unsafe.Pointer(p)), c.device, c.event)
		_ret = Result(c._ret)
		return
	}
}

type PFNCreateQueryPool C.PFN_vkCreateQueryPool
type QueryPoolCreateFlags Flags
type QueryPipelineStatisticFlags Flags
type QueryPoolCreateInfo struct {
	Next               Structure
	Flags              QueryPoolCreateFlags
	QueryType          QueryType
	QueryCount         uint32
	PipelineStatistics QueryPipelineStatisticFlags
}

func (g *QueryPoolCreateInfo) toC(c *C.VkQueryPoolCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkQueryPoolCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkQueryPoolCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkQueryPoolCreateFlags(temp_in_VkQueryPoolCreateFlags)
	}
	c.queryType = C.VkQueryType(g.QueryType)
	c.queryCount = C.uint32_t(g.QueryCount)
	{
		var temp_in_VkQueryPipelineStatisticFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.PipelineStatistics)))
			temp_in_VkQueryPipelineStatisticFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.pipelineStatistics = C.VkQueryPipelineStatisticFlags(temp_in_VkQueryPipelineStatisticFlags)
	}
}
func (g *QueryPoolCreateInfo) fromC(c *C.VkQueryPoolCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkQueryPoolCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkQueryPoolCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = QueryPoolCreateFlags(temp_in_VkQueryPoolCreateFlags)
	}
	g.QueryType = QueryType(c.queryType)
	g.QueryCount = uint32(c.queryCount)
	{
		var temp_in_VkQueryPipelineStatisticFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.pipelineStatistics)))
			temp_in_VkQueryPipelineStatisticFlags = Flags(temp_in_VkFlags)
		}
		g.PipelineStatistics = QueryPipelineStatisticFlags(temp_in_VkQueryPipelineStatisticFlags)
	}
}
func (s *QueryPoolCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
}
func (s *QueryPoolCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkQueryPoolCreateInfo)(m.alloc(C.sizeof_VkQueryPoolCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *QueryPoolCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkQueryPoolCreateInfo)(p)
	s.fromC(c)
}
func (s *QueryPoolCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *QueryPoolCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type QueryPool C.VkQueryPool
type FuncCreateQueryPool func(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks, queryPool *QueryPool) (_ret Result)

func ToCreateQueryPool(p PFNVoidFunction) (fn FuncCreateQueryPool) {
	return func(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks, queryPool *QueryPool) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkQueryPoolCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pQueryPool  *C.VkQueryPool
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkQueryPoolCreateInfo)(m.alloc(C.sizeof_VkQueryPoolCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if queryPool != nil {
			c.pQueryPool = (*C.VkQueryPool)(m.alloc(C.sizeof_VkQueryPool))
			*c.pQueryPool = C.VkQueryPool(*queryPool)
		} else {
			c.pQueryPool = nil
		}
		c._ret = C.callPFN_vkCreateQueryPool(C.PFN_vkCreateQueryPool(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pQueryPool)
		_ret = Result(c._ret)
		if queryPool != nil {
			*queryPool = QueryPool(*c.pQueryPool)
		}
		return
	}
}

type PFNDestroyQueryPool C.PFN_vkDestroyQueryPool
type FuncDestroyQueryPool func(device Device, queryPool QueryPool, allocator *AllocationCallbacks)

func ToDestroyQueryPool(p PFNVoidFunction) (fn FuncDestroyQueryPool) {
	return func(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			queryPool  C.VkQueryPool
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.queryPool = C.VkQueryPool(queryPool)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyQueryPool(C.PFN_vkDestroyQueryPool(unsafe.Pointer(p)), c.device, c.queryPool, c.pAllocator)
	}
}

type PFNGetQueryPoolResults C.PFN_vkGetQueryPoolResults
type QueryResultFlags Flags
type FuncGetQueryPoolResults func(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (_ret Result)

func ToGetQueryPoolResults(p PFNVoidFunction) (fn FuncGetQueryPoolResults) {
	return func(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (_ret Result) {
		var c struct {
			device     C.VkDevice
			queryPool  C.VkQueryPool
			firstQuery C.uint32_t
			queryCount C.uint32_t
			dataSize   C.size_t
			pData      unsafe.Pointer
			stride     C.VkDeviceSize
			flags      C.VkQueryResultFlags
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.queryPool = C.VkQueryPool(queryPool)
		c.firstQuery = C.uint32_t(firstQuery)
		c.queryCount = C.uint32_t(queryCount)
		c.dataSize = C.size_t(len(data))
		if len(data) != 0 {
			c.pData = m.alloc(C.sizeof_char * uint(len(data)))
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				slice1[i1] = data[i1]
			}
		} else {
			c.pData = nil
		}
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(stride))
			c.stride = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkQueryResultFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkQueryResultFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkQueryResultFlags(temp_in_VkQueryResultFlags)
		}
		c._ret = C.callPFN_vkGetQueryPoolResults(C.PFN_vkGetQueryPoolResults(unsafe.Pointer(p)), c.device, c.queryPool, c.firstQuery, c.queryCount, c.dataSize, c.pData, c.stride, c.flags)
		_ret = Result(c._ret)
		if len(data) != 0 {
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				data[i1] = slice1[i1]
			}
		}
		return
	}
}

type PFNCreateBuffer C.PFN_vkCreateBuffer
type BufferCreateFlags Flags
type BufferUsageFlags Flags
type BufferCreateInfo struct {
	Next               Structure
	Flags              BufferCreateFlags
	Size               DeviceSize
	Usage              BufferUsageFlags
	SharingMode        SharingMode
	QueueFamilyIndices []uint32
}

func (g *BufferCreateInfo) toC(c *C.VkBufferCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkBufferCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkBufferCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkBufferCreateFlags(temp_in_VkBufferCreateFlags)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkBufferUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Usage)))
			temp_in_VkBufferUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkBufferUsageFlags(temp_in_VkBufferUsageFlags)
	}
	c.sharingMode = C.VkSharingMode(g.SharingMode)
	c.queueFamilyIndexCount = C.uint32_t(len(g.QueueFamilyIndices))
	if len(g.QueueFamilyIndices) != 0 {
		c.pQueueFamilyIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.QueueFamilyIndices))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			slice1[i1] = C.uint32_t(g.QueueFamilyIndices[i1])
		}
	} else {
		c.pQueueFamilyIndices = nil
	}
}
func (g *BufferCreateInfo) fromC(c *C.VkBufferCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkBufferCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkBufferCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = BufferCreateFlags(temp_in_VkBufferCreateFlags)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkBufferUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.usage)))
			temp_in_VkBufferUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Usage = BufferUsageFlags(temp_in_VkBufferUsageFlags)
	}
	g.SharingMode = SharingMode(c.sharingMode)
	g.QueueFamilyIndices = make([]uint32, int(c.queueFamilyIndexCount))
	if len(g.QueueFamilyIndices) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			g.QueueFamilyIndices[i1] = uint32(slice1[i1])
		}
	}
}
func (s *BufferCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
}
func (s *BufferCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBufferCreateInfo)(m.alloc(C.sizeof_VkBufferCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BufferCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBufferCreateInfo)(p)
	s.fromC(c)
}
func (s *BufferCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *BufferCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateBuffer func(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks, buffer *Buffer) (_ret Result)

func ToCreateBuffer(p PFNVoidFunction) (fn FuncCreateBuffer) {
	return func(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks, buffer *Buffer) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkBufferCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pBuffer     *C.VkBuffer
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkBufferCreateInfo)(m.alloc(C.sizeof_VkBufferCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if buffer != nil {
			c.pBuffer = (*C.VkBuffer)(m.alloc(C.sizeof_VkBuffer))
			*c.pBuffer = C.VkBuffer(*buffer)
		} else {
			c.pBuffer = nil
		}
		c._ret = C.callPFN_vkCreateBuffer(C.PFN_vkCreateBuffer(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pBuffer)
		_ret = Result(c._ret)
		if buffer != nil {
			*buffer = Buffer(*c.pBuffer)
		}
		return
	}
}

type PFNDestroyBuffer C.PFN_vkDestroyBuffer
type FuncDestroyBuffer func(device Device, buffer Buffer, allocator *AllocationCallbacks)

func ToDestroyBuffer(p PFNVoidFunction) (fn FuncDestroyBuffer) {
	return func(device Device, buffer Buffer, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			buffer     C.VkBuffer
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.buffer = C.VkBuffer(buffer)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyBuffer(C.PFN_vkDestroyBuffer(unsafe.Pointer(p)), c.device, c.buffer, c.pAllocator)
	}
}

type PFNCreateBufferView C.PFN_vkCreateBufferView
type BufferViewCreateFlags Flags
type BufferViewCreateInfo struct {
	Next   Structure
	Flags  BufferViewCreateFlags
	Buffer Buffer
	Format Format
	Offset DeviceSize
	Range  DeviceSize
}

func (g *BufferViewCreateInfo) toC(c *C.VkBufferViewCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkBufferViewCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkBufferViewCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkBufferViewCreateFlags(temp_in_VkBufferViewCreateFlags)
	}
	c.buffer = C.VkBuffer(g.Buffer)
	c.format = C.VkFormat(g.Format)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Range))
		c._range = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *BufferViewCreateInfo) fromC(c *C.VkBufferViewCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkBufferViewCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkBufferViewCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = BufferViewCreateFlags(temp_in_VkBufferViewCreateFlags)
	}
	g.Buffer = Buffer(c.buffer)
	g.Format = Format(c.format)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c._range))
		g.Range = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *BufferViewCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
}
func (s *BufferViewCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBufferViewCreateInfo)(m.alloc(C.sizeof_VkBufferViewCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BufferViewCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBufferViewCreateInfo)(p)
	s.fromC(c)
}
func (s *BufferViewCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *BufferViewCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type BufferView C.VkBufferView
type FuncCreateBufferView func(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks, view *BufferView) (_ret Result)

func ToCreateBufferView(p PFNVoidFunction) (fn FuncCreateBufferView) {
	return func(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks, view *BufferView) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkBufferViewCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pView       *C.VkBufferView
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkBufferViewCreateInfo)(m.alloc(C.sizeof_VkBufferViewCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if view != nil {
			c.pView = (*C.VkBufferView)(m.alloc(C.sizeof_VkBufferView))
			*c.pView = C.VkBufferView(*view)
		} else {
			c.pView = nil
		}
		c._ret = C.callPFN_vkCreateBufferView(C.PFN_vkCreateBufferView(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pView)
		_ret = Result(c._ret)
		if view != nil {
			*view = BufferView(*c.pView)
		}
		return
	}
}

type PFNDestroyBufferView C.PFN_vkDestroyBufferView
type FuncDestroyBufferView func(device Device, bufferView BufferView, allocator *AllocationCallbacks)

func ToDestroyBufferView(p PFNVoidFunction) (fn FuncDestroyBufferView) {
	return func(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			bufferView C.VkBufferView
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.bufferView = C.VkBufferView(bufferView)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyBufferView(C.PFN_vkDestroyBufferView(unsafe.Pointer(p)), c.device, c.bufferView, c.pAllocator)
	}
}

type PFNCreateImage C.PFN_vkCreateImage
type ImageCreateInfo struct {
	Next               Structure
	Flags              ImageCreateFlags
	ImageType          ImageType
	Format             Format
	Extent             Extent3D
	MipLevels          uint32
	ArrayLayers        uint32
	Samples            SampleCountFlagBits
	Tiling             ImageTiling
	Usage              ImageUsageFlags
	SharingMode        SharingMode
	QueueFamilyIndices []uint32
	InitialLayout      ImageLayout
}

func (g *ImageCreateInfo) toC(c *C.VkImageCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkImageCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkImageCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkImageCreateFlags(temp_in_VkImageCreateFlags)
	}
	c.imageType = C.VkImageType(g.ImageType)
	c.format = C.VkFormat(g.Format)
	g.Extent.toC(&c.extent)
	c.mipLevels = C.uint32_t(g.MipLevels)
	c.arrayLayers = C.uint32_t(g.ArrayLayers)
	c.samples = C.VkSampleCountFlagBits(g.Samples)
	c.tiling = C.VkImageTiling(g.Tiling)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Usage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	c.sharingMode = C.VkSharingMode(g.SharingMode)
	c.queueFamilyIndexCount = C.uint32_t(len(g.QueueFamilyIndices))
	if len(g.QueueFamilyIndices) != 0 {
		c.pQueueFamilyIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.QueueFamilyIndices))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			slice1[i1] = C.uint32_t(g.QueueFamilyIndices[i1])
		}
	} else {
		c.pQueueFamilyIndices = nil
	}
	c.initialLayout = C.VkImageLayout(g.InitialLayout)
}
func (g *ImageCreateInfo) fromC(c *C.VkImageCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkImageCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkImageCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = ImageCreateFlags(temp_in_VkImageCreateFlags)
	}
	g.ImageType = ImageType(c.imageType)
	g.Format = Format(c.format)
	g.Extent.fromC(&c.extent)
	g.MipLevels = uint32(c.mipLevels)
	g.ArrayLayers = uint32(c.arrayLayers)
	g.Samples = SampleCountFlagBits(c.samples)
	g.Tiling = ImageTiling(c.tiling)
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.usage)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Usage = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	g.SharingMode = SharingMode(c.sharingMode)
	g.QueueFamilyIndices = make([]uint32, int(c.queueFamilyIndexCount))
	if len(g.QueueFamilyIndices) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			g.QueueFamilyIndices[i1] = uint32(slice1[i1])
		}
	}
	g.InitialLayout = ImageLayout(c.initialLayout)
}
func (s *ImageCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
}
func (s *ImageCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageCreateInfo)(m.alloc(C.sizeof_VkImageCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageCreateInfo)(p)
	s.fromC(c)
}
func (s *ImageCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *ImageCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateImage func(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks, image *Image) (_ret Result)

func ToCreateImage(p PFNVoidFunction) (fn FuncCreateImage) {
	return func(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks, image *Image) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkImageCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pImage      *C.VkImage
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkImageCreateInfo)(m.alloc(C.sizeof_VkImageCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if image != nil {
			c.pImage = (*C.VkImage)(m.alloc(C.sizeof_VkImage))
			*c.pImage = C.VkImage(*image)
		} else {
			c.pImage = nil
		}
		c._ret = C.callPFN_vkCreateImage(C.PFN_vkCreateImage(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pImage)
		_ret = Result(c._ret)
		if image != nil {
			*image = Image(*c.pImage)
		}
		return
	}
}

type PFNDestroyImage C.PFN_vkDestroyImage
type FuncDestroyImage func(device Device, image Image, allocator *AllocationCallbacks)

func ToDestroyImage(p PFNVoidFunction) (fn FuncDestroyImage) {
	return func(device Device, image Image, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			image      C.VkImage
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.image = C.VkImage(image)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyImage(C.PFN_vkDestroyImage(unsafe.Pointer(p)), c.device, c.image, c.pAllocator)
	}
}

type PFNGetImageSubresourceLayout C.PFN_vkGetImageSubresourceLayout
type SubresourceLayout struct {
	Offset     DeviceSize
	Size       DeviceSize
	RowPitch   DeviceSize
	ArrayPitch DeviceSize
	DepthPitch DeviceSize
}

func (g *SubresourceLayout) toC(c *C.VkSubresourceLayout) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.RowPitch))
		c.rowPitch = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.ArrayPitch))
		c.arrayPitch = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.DepthPitch))
		c.depthPitch = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *SubresourceLayout) fromC(c *C.VkSubresourceLayout) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.rowPitch))
		g.RowPitch = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.arrayPitch))
		g.ArrayPitch = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.depthPitch))
		g.DepthPitch = DeviceSize(temp_in_VkDeviceSize)
	}
}

type FuncGetImageSubresourceLayout func(device Device, image Image, subresource *ImageSubresource, layout *SubresourceLayout)

func ToGetImageSubresourceLayout(p PFNVoidFunction) (fn FuncGetImageSubresourceLayout) {
	return func(device Device, image Image, subresource *ImageSubresource, layout *SubresourceLayout) {
		var c struct {
			device       C.VkDevice
			image        C.VkImage
			pSubresource *C.VkImageSubresource
			pLayout      *C.VkSubresourceLayout
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.image = C.VkImage(image)
		if subresource != nil {
			c.pSubresource = (*C.VkImageSubresource)(m.alloc(C.sizeof_VkImageSubresource))
			subresource.toC(c.pSubresource)
		} else {
			c.pSubresource = nil
		}
		if layout != nil {
			c.pLayout = (*C.VkSubresourceLayout)(m.alloc(C.sizeof_VkSubresourceLayout))
			layout.toC(c.pLayout)
		} else {
			c.pLayout = nil
		}
		C.callPFN_vkGetImageSubresourceLayout(C.PFN_vkGetImageSubresourceLayout(unsafe.Pointer(p)), c.device, c.image, c.pSubresource, c.pLayout)
		if layout != nil {
			layout.fromC(c.pLayout)
		}
	}
}

type PFNCreateImageView C.PFN_vkCreateImageView
type ImageViewCreateFlags Flags
type ComponentMapping struct {
	R ComponentSwizzle
	G ComponentSwizzle
	B ComponentSwizzle
	A ComponentSwizzle
}

func (g *ComponentMapping) toC(c *C.VkComponentMapping) {
	c.r = C.VkComponentSwizzle(g.R)
	c.g = C.VkComponentSwizzle(g.G)
	c.b = C.VkComponentSwizzle(g.B)
	c.a = C.VkComponentSwizzle(g.A)
}
func (g *ComponentMapping) fromC(c *C.VkComponentMapping) {
	g.R = ComponentSwizzle(c.r)
	g.G = ComponentSwizzle(c.g)
	g.B = ComponentSwizzle(c.b)
	g.A = ComponentSwizzle(c.a)
}

type ImageSubresourceRange struct {
	AspectMask     ImageAspectFlags
	BaseMipLevel   uint32
	LevelCount     uint32
	BaseArrayLayer uint32
	LayerCount     uint32
}

func (g *ImageSubresourceRange) toC(c *C.VkImageSubresourceRange) {
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	c.baseMipLevel = C.uint32_t(g.BaseMipLevel)
	c.levelCount = C.uint32_t(g.LevelCount)
	c.baseArrayLayer = C.uint32_t(g.BaseArrayLayer)
	c.layerCount = C.uint32_t(g.LayerCount)
}
func (g *ImageSubresourceRange) fromC(c *C.VkImageSubresourceRange) {
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.BaseMipLevel = uint32(c.baseMipLevel)
	g.LevelCount = uint32(c.levelCount)
	g.BaseArrayLayer = uint32(c.baseArrayLayer)
	g.LayerCount = uint32(c.layerCount)
}

type ImageViewCreateInfo struct {
	Next             Structure
	Flags            ImageViewCreateFlags
	Image            Image
	ViewType         ImageViewType
	Format           Format
	Components       ComponentMapping
	SubresourceRange ImageSubresourceRange
}

func (g *ImageViewCreateInfo) toC(c *C.VkImageViewCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkImageViewCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkImageViewCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkImageViewCreateFlags(temp_in_VkImageViewCreateFlags)
	}
	c.image = C.VkImage(g.Image)
	c.viewType = C.VkImageViewType(g.ViewType)
	c.format = C.VkFormat(g.Format)
	g.Components.toC(&c.components)
	g.SubresourceRange.toC(&c.subresourceRange)
}
func (g *ImageViewCreateInfo) fromC(c *C.VkImageViewCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkImageViewCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkImageViewCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = ImageViewCreateFlags(temp_in_VkImageViewCreateFlags)
	}
	g.Image = Image(c.image)
	g.ViewType = ImageViewType(c.viewType)
	g.Format = Format(c.format)
	g.Components.fromC(&c.components)
	g.SubresourceRange.fromC(&c.subresourceRange)
}
func (s *ImageViewCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
}
func (s *ImageViewCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageViewCreateInfo)(m.alloc(C.sizeof_VkImageViewCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageViewCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageViewCreateInfo)(p)
	s.fromC(c)
}
func (s *ImageViewCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *ImageViewCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type ImageView C.VkImageView
type FuncCreateImageView func(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks, view *ImageView) (_ret Result)

func ToCreateImageView(p PFNVoidFunction) (fn FuncCreateImageView) {
	return func(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks, view *ImageView) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkImageViewCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pView       *C.VkImageView
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkImageViewCreateInfo)(m.alloc(C.sizeof_VkImageViewCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if view != nil {
			c.pView = (*C.VkImageView)(m.alloc(C.sizeof_VkImageView))
			*c.pView = C.VkImageView(*view)
		} else {
			c.pView = nil
		}
		c._ret = C.callPFN_vkCreateImageView(C.PFN_vkCreateImageView(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pView)
		_ret = Result(c._ret)
		if view != nil {
			*view = ImageView(*c.pView)
		}
		return
	}
}

type PFNDestroyImageView C.PFN_vkDestroyImageView
type FuncDestroyImageView func(device Device, imageView ImageView, allocator *AllocationCallbacks)

func ToDestroyImageView(p PFNVoidFunction) (fn FuncDestroyImageView) {
	return func(device Device, imageView ImageView, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			imageView  C.VkImageView
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.imageView = C.VkImageView(imageView)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyImageView(C.PFN_vkDestroyImageView(unsafe.Pointer(p)), c.device, c.imageView, c.pAllocator)
	}
}

type PFNCreateShaderModule C.PFN_vkCreateShaderModule
type ShaderModuleCreateFlags Flags
type ShaderModuleCreateInfo struct {
	Next  Structure
	Flags ShaderModuleCreateFlags
	Code  []uint32
}

func (g *ShaderModuleCreateInfo) toC(c *C.VkShaderModuleCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkShaderModuleCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkShaderModuleCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkShaderModuleCreateFlags(temp_in_VkShaderModuleCreateFlags)
	}
	c.codeSize = C.size_t(len(g.Code))
	if len(g.Code) != 0 {
		c.pCode = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.Code))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pCode))[:len(g.Code):len(g.Code)]
		for i1, _ := range g.Code {
			slice1[i1] = C.uint32_t(g.Code[i1])
		}
	} else {
		c.pCode = nil
	}
}
func (g *ShaderModuleCreateInfo) fromC(c *C.VkShaderModuleCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkShaderModuleCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkShaderModuleCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = ShaderModuleCreateFlags(temp_in_VkShaderModuleCreateFlags)
	}
	g.Code = make([]uint32, int(c.codeSize))
	if len(g.Code) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pCode))[:len(g.Code):len(g.Code)]
		for i1, _ := range g.Code {
			g.Code[i1] = uint32(slice1[i1])
		}
	}
}
func (s *ShaderModuleCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
}
func (s *ShaderModuleCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkShaderModuleCreateInfo)(m.alloc(C.sizeof_VkShaderModuleCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ShaderModuleCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkShaderModuleCreateInfo)(p)
	s.fromC(c)
}
func (s *ShaderModuleCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *ShaderModuleCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type ShaderModule C.VkShaderModule
type FuncCreateShaderModule func(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks, shaderModule *ShaderModule) (_ret Result)

func ToCreateShaderModule(p PFNVoidFunction) (fn FuncCreateShaderModule) {
	return func(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks, shaderModule *ShaderModule) (_ret Result) {
		var c struct {
			device        C.VkDevice
			pCreateInfo   *C.VkShaderModuleCreateInfo
			pAllocator    *C.VkAllocationCallbacks
			pShaderModule *C.VkShaderModule
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkShaderModuleCreateInfo)(m.alloc(C.sizeof_VkShaderModuleCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if shaderModule != nil {
			c.pShaderModule = (*C.VkShaderModule)(m.alloc(C.sizeof_VkShaderModule))
			*c.pShaderModule = C.VkShaderModule(*shaderModule)
		} else {
			c.pShaderModule = nil
		}
		c._ret = C.callPFN_vkCreateShaderModule(C.PFN_vkCreateShaderModule(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pShaderModule)
		_ret = Result(c._ret)
		if shaderModule != nil {
			*shaderModule = ShaderModule(*c.pShaderModule)
		}
		return
	}
}

type PFNDestroyShaderModule C.PFN_vkDestroyShaderModule
type FuncDestroyShaderModule func(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks)

func ToDestroyShaderModule(p PFNVoidFunction) (fn FuncDestroyShaderModule) {
	return func(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
		var c struct {
			device       C.VkDevice
			shaderModule C.VkShaderModule
			pAllocator   *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.shaderModule = C.VkShaderModule(shaderModule)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyShaderModule(C.PFN_vkDestroyShaderModule(unsafe.Pointer(p)), c.device, c.shaderModule, c.pAllocator)
	}
}

type PFNCreatePipelineCache C.PFN_vkCreatePipelineCache
type PipelineCacheCreateFlags Flags
type PipelineCacheCreateInfo struct {
	Next        Structure
	Flags       PipelineCacheCreateFlags
	InitialData []byte
}

func (g *PipelineCacheCreateInfo) toC(c *C.VkPipelineCacheCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineCacheCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineCacheCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineCacheCreateFlags(temp_in_VkPipelineCacheCreateFlags)
	}
	c.initialDataSize = C.size_t(len(g.InitialData))
	if len(g.InitialData) != 0 {
		c.pInitialData = m.alloc(C.sizeof_char * uint(len(g.InitialData)))
		slice1 := (*[1 << 31]byte)(c.pInitialData)[:len(g.InitialData):len(g.InitialData)]
		for i1, _ := range g.InitialData {
			slice1[i1] = g.InitialData[i1]
		}
	} else {
		c.pInitialData = nil
	}
}
func (g *PipelineCacheCreateInfo) fromC(c *C.VkPipelineCacheCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineCacheCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineCacheCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineCacheCreateFlags(temp_in_VkPipelineCacheCreateFlags)
	}
	g.InitialData = make([]byte, int(c.initialDataSize))
	if len(g.InitialData) != 0 {
		slice1 := (*[1 << 31]byte)(c.pInitialData)[:len(g.InitialData):len(g.InitialData)]
		for i1, _ := range g.InitialData {
			g.InitialData[i1] = slice1[i1]
		}
	}
}
func (s *PipelineCacheCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
}
func (s *PipelineCacheCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineCacheCreateInfo)(m.alloc(C.sizeof_VkPipelineCacheCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineCacheCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineCacheCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineCacheCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineCacheCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineCache C.VkPipelineCache
type FuncCreatePipelineCache func(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks, pipelineCache *PipelineCache) (_ret Result)

func ToCreatePipelineCache(p PFNVoidFunction) (fn FuncCreatePipelineCache) {
	return func(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks, pipelineCache *PipelineCache) (_ret Result) {
		var c struct {
			device         C.VkDevice
			pCreateInfo    *C.VkPipelineCacheCreateInfo
			pAllocator     *C.VkAllocationCallbacks
			pPipelineCache *C.VkPipelineCache
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkPipelineCacheCreateInfo)(m.alloc(C.sizeof_VkPipelineCacheCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if pipelineCache != nil {
			c.pPipelineCache = (*C.VkPipelineCache)(m.alloc(C.sizeof_VkPipelineCache))
			*c.pPipelineCache = C.VkPipelineCache(*pipelineCache)
		} else {
			c.pPipelineCache = nil
		}
		c._ret = C.callPFN_vkCreatePipelineCache(C.PFN_vkCreatePipelineCache(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pPipelineCache)
		_ret = Result(c._ret)
		if pipelineCache != nil {
			*pipelineCache = PipelineCache(*c.pPipelineCache)
		}
		return
	}
}

type PFNDestroyPipelineCache C.PFN_vkDestroyPipelineCache
type FuncDestroyPipelineCache func(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks)

func ToDestroyPipelineCache(p PFNVoidFunction) (fn FuncDestroyPipelineCache) {
	return func(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
		var c struct {
			device        C.VkDevice
			pipelineCache C.VkPipelineCache
			pAllocator    *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipelineCache = C.VkPipelineCache(pipelineCache)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyPipelineCache(C.PFN_vkDestroyPipelineCache(unsafe.Pointer(p)), c.device, c.pipelineCache, c.pAllocator)
	}
}

type PFNGetPipelineCacheData C.PFN_vkGetPipelineCacheData
type FuncGetPipelineCacheData func(device Device, pipelineCache PipelineCache, dataSize *uint, data []byte) (_ret Result)

func ToGetPipelineCacheData(p PFNVoidFunction) (fn FuncGetPipelineCacheData) {
	return func(device Device, pipelineCache PipelineCache, dataSize *uint, data []byte) (_ret Result) {
		var c struct {
			device        C.VkDevice
			pipelineCache C.VkPipelineCache
			pDataSize     *C.size_t
			pData         unsafe.Pointer
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipelineCache = C.VkPipelineCache(pipelineCache)
		if dataSize != nil {
			c.pDataSize = (*C.size_t)(m.alloc(C.sizeof_size_t))
			*c.pDataSize = C.size_t(*dataSize)
		} else {
			c.pDataSize = nil
		}
		if len(data) != 0 {
			c.pData = m.alloc(C.sizeof_char * uint(len(data)))
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				slice1[i1] = data[i1]
			}
		} else {
			c.pData = nil
		}
		c._ret = C.callPFN_vkGetPipelineCacheData(C.PFN_vkGetPipelineCacheData(unsafe.Pointer(p)), c.device, c.pipelineCache, c.pDataSize, c.pData)
		_ret = Result(c._ret)
		if dataSize != nil {
			*dataSize = uint(*c.pDataSize)
		}
		if len(data) != 0 {
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				data[i1] = slice1[i1]
			}
		}
		return
	}
}

type PFNMergePipelineCaches C.PFN_vkMergePipelineCaches
type FuncMergePipelineCaches func(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (_ret Result)

func ToMergePipelineCaches(p PFNVoidFunction) (fn FuncMergePipelineCaches) {
	return func(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (_ret Result) {
		var c struct {
			device        C.VkDevice
			dstCache      C.VkPipelineCache
			srcCacheCount C.uint32_t
			pSrcCaches    *C.VkPipelineCache
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.dstCache = C.VkPipelineCache(dstCache)
		c.srcCacheCount = C.uint32_t(len(srcCaches))
		if len(srcCaches) != 0 {
			c.pSrcCaches = (*C.VkPipelineCache)(m.alloc(C.sizeof_VkPipelineCache * uint(len(srcCaches))))
			slice1 := (*[1 << 31]C.VkPipelineCache)(unsafe.Pointer(c.pSrcCaches))[:len(srcCaches):len(srcCaches)]
			for i1, _ := range srcCaches {
				slice1[i1] = C.VkPipelineCache(srcCaches[i1])
			}
		} else {
			c.pSrcCaches = nil
		}
		c._ret = C.callPFN_vkMergePipelineCaches(C.PFN_vkMergePipelineCaches(unsafe.Pointer(p)), c.device, c.dstCache, c.srcCacheCount, c.pSrcCaches)
		_ret = Result(c._ret)
		return
	}
}

type PFNCreateGraphicsPipelines C.PFN_vkCreateGraphicsPipelines
type PipelineCreateFlags Flags
type PipelineShaderStageCreateFlags Flags
type SpecializationMapEntry struct {
	ConstantID uint32
	Offset     uint32
	Size       uint
}

func (g *SpecializationMapEntry) toC(c *C.VkSpecializationMapEntry) {
	c.constantID = C.uint32_t(g.ConstantID)
	c.offset = C.uint32_t(g.Offset)
	c.size = C.size_t(g.Size)
}
func (g *SpecializationMapEntry) fromC(c *C.VkSpecializationMapEntry) {
	g.ConstantID = uint32(c.constantID)
	g.Offset = uint32(c.offset)
	g.Size = uint(c.size)
}

type SpecializationInfo struct {
	MapEntries []SpecializationMapEntry
	Data       []byte
}

func (g *SpecializationInfo) toC(c *C.VkSpecializationInfo, m *cmemory) {
	c.mapEntryCount = C.uint32_t(len(g.MapEntries))
	if len(g.MapEntries) != 0 {
		c.pMapEntries = (*C.VkSpecializationMapEntry)(m.alloc(C.sizeof_VkSpecializationMapEntry * uint(len(g.MapEntries))))
		slice1 := (*[1 << 31]C.VkSpecializationMapEntry)(unsafe.Pointer(c.pMapEntries))[:len(g.MapEntries):len(g.MapEntries)]
		for i1, _ := range g.MapEntries {
			g.MapEntries[i1].toC(&slice1[i1])
		}
	} else {
		c.pMapEntries = nil
	}
	c.dataSize = C.size_t(len(g.Data))
	if len(g.Data) != 0 {
		c.pData = m.alloc(C.sizeof_char * uint(len(g.Data)))
		slice1 := (*[1 << 31]byte)(c.pData)[:len(g.Data):len(g.Data)]
		for i1, _ := range g.Data {
			slice1[i1] = g.Data[i1]
		}
	} else {
		c.pData = nil
	}
}
func (g *SpecializationInfo) fromC(c *C.VkSpecializationInfo) {
	g.MapEntries = make([]SpecializationMapEntry, int(c.mapEntryCount))
	if len(g.MapEntries) != 0 {
		slice1 := (*[1 << 31]C.VkSpecializationMapEntry)(unsafe.Pointer(c.pMapEntries))[:len(g.MapEntries):len(g.MapEntries)]
		for i1, _ := range g.MapEntries {
			g.MapEntries[i1].fromC(&slice1[i1])
		}
	}
	g.Data = make([]byte, int(c.dataSize))
	if len(g.Data) != 0 {
		slice1 := (*[1 << 31]byte)(c.pData)[:len(g.Data):len(g.Data)]
		for i1, _ := range g.Data {
			g.Data[i1] = slice1[i1]
		}
	}
}

type PipelineShaderStageCreateInfo struct {
	Next               Structure
	Flags              PipelineShaderStageCreateFlags
	Stage              ShaderStageFlagBits
	Module             ShaderModule
	Name               string
	SpecializationInfo *SpecializationInfo
}

func (g *PipelineShaderStageCreateInfo) toC(c *C.VkPipelineShaderStageCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineShaderStageCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineShaderStageCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineShaderStageCreateFlags(temp_in_VkPipelineShaderStageCreateFlags)
	}
	c.stage = C.VkShaderStageFlagBits(g.Stage)
	c.module = C.VkShaderModule(g.Module)
	c.pName = toCString(g.Name, m)
	if g.SpecializationInfo != nil {
		c.pSpecializationInfo = (*C.VkSpecializationInfo)(m.alloc(C.sizeof_VkSpecializationInfo))
		g.SpecializationInfo.toC(c.pSpecializationInfo, m)
	} else {
		c.pSpecializationInfo = nil
	}
}
func (g *PipelineShaderStageCreateInfo) fromC(c *C.VkPipelineShaderStageCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineShaderStageCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineShaderStageCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineShaderStageCreateFlags(temp_in_VkPipelineShaderStageCreateFlags)
	}
	g.Stage = ShaderStageFlagBits(c.stage)
	g.Module = ShaderModule(c.module)
	g.Name = toGoString(c.pName)
	if g.SpecializationInfo != nil {
		g.SpecializationInfo.fromC(c.pSpecializationInfo)
	}
}
func (s *PipelineShaderStageCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
}
func (s *PipelineShaderStageCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineShaderStageCreateInfo)(m.alloc(C.sizeof_VkPipelineShaderStageCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineShaderStageCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineShaderStageCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineShaderStageCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineShaderStageCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineVertexInputStateCreateFlags Flags
type VertexInputBindingDescription struct {
	Binding   uint32
	Stride    uint32
	InputRate VertexInputRate
}

func (g *VertexInputBindingDescription) toC(c *C.VkVertexInputBindingDescription) {
	c.binding = C.uint32_t(g.Binding)
	c.stride = C.uint32_t(g.Stride)
	c.inputRate = C.VkVertexInputRate(g.InputRate)
}
func (g *VertexInputBindingDescription) fromC(c *C.VkVertexInputBindingDescription) {
	g.Binding = uint32(c.binding)
	g.Stride = uint32(c.stride)
	g.InputRate = VertexInputRate(c.inputRate)
}

type VertexInputAttributeDescription struct {
	Location uint32
	Binding  uint32
	Format   Format
	Offset   uint32
}

func (g *VertexInputAttributeDescription) toC(c *C.VkVertexInputAttributeDescription) {
	c.location = C.uint32_t(g.Location)
	c.binding = C.uint32_t(g.Binding)
	c.format = C.VkFormat(g.Format)
	c.offset = C.uint32_t(g.Offset)
}
func (g *VertexInputAttributeDescription) fromC(c *C.VkVertexInputAttributeDescription) {
	g.Location = uint32(c.location)
	g.Binding = uint32(c.binding)
	g.Format = Format(c.format)
	g.Offset = uint32(c.offset)
}

type PipelineVertexInputStateCreateInfo struct {
	Next                        Structure
	Flags                       PipelineVertexInputStateCreateFlags
	VertexBindingDescriptions   []VertexInputBindingDescription
	VertexAttributeDescriptions []VertexInputAttributeDescription
}

func (g *PipelineVertexInputStateCreateInfo) toC(c *C.VkPipelineVertexInputStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineVertexInputStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineVertexInputStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineVertexInputStateCreateFlags(temp_in_VkPipelineVertexInputStateCreateFlags)
	}
	c.vertexBindingDescriptionCount = C.uint32_t(len(g.VertexBindingDescriptions))
	if len(g.VertexBindingDescriptions) != 0 {
		c.pVertexBindingDescriptions = (*C.VkVertexInputBindingDescription)(m.alloc(C.sizeof_VkVertexInputBindingDescription * uint(len(g.VertexBindingDescriptions))))
		slice1 := (*[1 << 31]C.VkVertexInputBindingDescription)(unsafe.Pointer(c.pVertexBindingDescriptions))[:len(g.VertexBindingDescriptions):len(g.VertexBindingDescriptions)]
		for i1, _ := range g.VertexBindingDescriptions {
			g.VertexBindingDescriptions[i1].toC(&slice1[i1])
		}
	} else {
		c.pVertexBindingDescriptions = nil
	}
	c.vertexAttributeDescriptionCount = C.uint32_t(len(g.VertexAttributeDescriptions))
	if len(g.VertexAttributeDescriptions) != 0 {
		c.pVertexAttributeDescriptions = (*C.VkVertexInputAttributeDescription)(m.alloc(C.sizeof_VkVertexInputAttributeDescription * uint(len(g.VertexAttributeDescriptions))))
		slice1 := (*[1 << 31]C.VkVertexInputAttributeDescription)(unsafe.Pointer(c.pVertexAttributeDescriptions))[:len(g.VertexAttributeDescriptions):len(g.VertexAttributeDescriptions)]
		for i1, _ := range g.VertexAttributeDescriptions {
			g.VertexAttributeDescriptions[i1].toC(&slice1[i1])
		}
	} else {
		c.pVertexAttributeDescriptions = nil
	}
}
func (g *PipelineVertexInputStateCreateInfo) fromC(c *C.VkPipelineVertexInputStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineVertexInputStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineVertexInputStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineVertexInputStateCreateFlags(temp_in_VkPipelineVertexInputStateCreateFlags)
	}
	g.VertexBindingDescriptions = make([]VertexInputBindingDescription, int(c.vertexBindingDescriptionCount))
	if len(g.VertexBindingDescriptions) != 0 {
		slice1 := (*[1 << 31]C.VkVertexInputBindingDescription)(unsafe.Pointer(c.pVertexBindingDescriptions))[:len(g.VertexBindingDescriptions):len(g.VertexBindingDescriptions)]
		for i1, _ := range g.VertexBindingDescriptions {
			g.VertexBindingDescriptions[i1].fromC(&slice1[i1])
		}
	}
	g.VertexAttributeDescriptions = make([]VertexInputAttributeDescription, int(c.vertexAttributeDescriptionCount))
	if len(g.VertexAttributeDescriptions) != 0 {
		slice1 := (*[1 << 31]C.VkVertexInputAttributeDescription)(unsafe.Pointer(c.pVertexAttributeDescriptions))[:len(g.VertexAttributeDescriptions):len(g.VertexAttributeDescriptions)]
		for i1, _ := range g.VertexAttributeDescriptions {
			g.VertexAttributeDescriptions[i1].fromC(&slice1[i1])
		}
	}
}
func (s *PipelineVertexInputStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
}
func (s *PipelineVertexInputStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineVertexInputStateCreateInfo)(m.alloc(C.sizeof_VkPipelineVertexInputStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineVertexInputStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineVertexInputStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineVertexInputStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineVertexInputStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineInputAssemblyStateCreateFlags Flags
type PipelineInputAssemblyStateCreateInfo struct {
	Next                   Structure
	Flags                  PipelineInputAssemblyStateCreateFlags
	Topology               PrimitiveTopology
	PrimitiveRestartEnable bool
}

func (g *PipelineInputAssemblyStateCreateInfo) toC(c *C.VkPipelineInputAssemblyStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineInputAssemblyStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineInputAssemblyStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineInputAssemblyStateCreateFlags(temp_in_VkPipelineInputAssemblyStateCreateFlags)
	}
	c.topology = C.VkPrimitiveTopology(g.Topology)
	if g.PrimitiveRestartEnable {
		c.primitiveRestartEnable = 1
	} else {
		c.primitiveRestartEnable = 0
	}
}
func (g *PipelineInputAssemblyStateCreateInfo) fromC(c *C.VkPipelineInputAssemblyStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineInputAssemblyStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineInputAssemblyStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineInputAssemblyStateCreateFlags(temp_in_VkPipelineInputAssemblyStateCreateFlags)
	}
	g.Topology = PrimitiveTopology(c.topology)
	g.PrimitiveRestartEnable = c.primitiveRestartEnable != 0
}
func (s *PipelineInputAssemblyStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
}
func (s *PipelineInputAssemblyStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineInputAssemblyStateCreateInfo)(m.alloc(C.sizeof_VkPipelineInputAssemblyStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineInputAssemblyStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineInputAssemblyStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineInputAssemblyStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineInputAssemblyStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineTessellationStateCreateFlags Flags
type PipelineTessellationStateCreateInfo struct {
	Next               Structure
	Flags              PipelineTessellationStateCreateFlags
	PatchControlPoints uint32
}

func (g *PipelineTessellationStateCreateInfo) toC(c *C.VkPipelineTessellationStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineTessellationStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineTessellationStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineTessellationStateCreateFlags(temp_in_VkPipelineTessellationStateCreateFlags)
	}
	c.patchControlPoints = C.uint32_t(g.PatchControlPoints)
}
func (g *PipelineTessellationStateCreateInfo) fromC(c *C.VkPipelineTessellationStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineTessellationStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineTessellationStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineTessellationStateCreateFlags(temp_in_VkPipelineTessellationStateCreateFlags)
	}
	g.PatchControlPoints = uint32(c.patchControlPoints)
}
func (s *PipelineTessellationStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
}
func (s *PipelineTessellationStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineTessellationStateCreateInfo)(m.alloc(C.sizeof_VkPipelineTessellationStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineTessellationStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineTessellationStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineTessellationStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineTessellationStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineViewportStateCreateFlags Flags
type Viewport struct {
	X        float32
	Y        float32
	Width    float32
	Height   float32
	MinDepth float32
	MaxDepth float32
}

func (g *Viewport) toC(c *C.VkViewport) {
	c.x = C.float(g.X)
	c.y = C.float(g.Y)
	c.width = C.float(g.Width)
	c.height = C.float(g.Height)
	c.minDepth = C.float(g.MinDepth)
	c.maxDepth = C.float(g.MaxDepth)
}
func (g *Viewport) fromC(c *C.VkViewport) {
	g.X = float32(c.x)
	g.Y = float32(c.y)
	g.Width = float32(c.width)
	g.Height = float32(c.height)
	g.MinDepth = float32(c.minDepth)
	g.MaxDepth = float32(c.maxDepth)
}

type Offset2D struct {
	X int32
	Y int32
}

func (g *Offset2D) toC(c *C.VkOffset2D) {
	c.x = C.int32_t(g.X)
	c.y = C.int32_t(g.Y)
}
func (g *Offset2D) fromC(c *C.VkOffset2D) {
	g.X = int32(c.x)
	g.Y = int32(c.y)
}

type Extent2D struct {
	Width  uint32
	Height uint32
}

func (g *Extent2D) toC(c *C.VkExtent2D) {
	c.width = C.uint32_t(g.Width)
	c.height = C.uint32_t(g.Height)
}
func (g *Extent2D) fromC(c *C.VkExtent2D) {
	g.Width = uint32(c.width)
	g.Height = uint32(c.height)
}

type Rect2D struct {
	Offset Offset2D
	Extent Extent2D
}

func (g *Rect2D) toC(c *C.VkRect2D) {
	g.Offset.toC(&c.offset)
	g.Extent.toC(&c.extent)
}
func (g *Rect2D) fromC(c *C.VkRect2D) {
	g.Offset.fromC(&c.offset)
	g.Extent.fromC(&c.extent)
}

type PipelineViewportStateCreateInfo struct {
	Next      Structure
	Flags     PipelineViewportStateCreateFlags
	Viewports []Viewport
	Scissors  []Rect2D
}

func (g *PipelineViewportStateCreateInfo) toC(c *C.VkPipelineViewportStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineViewportStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineViewportStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineViewportStateCreateFlags(temp_in_VkPipelineViewportStateCreateFlags)
	}
	c.viewportCount = C.uint32_t(len(g.Viewports))
	if len(g.Viewports) != 0 {
		c.pViewports = (*C.VkViewport)(m.alloc(C.sizeof_VkViewport * uint(len(g.Viewports))))
		slice1 := (*[1 << 31]C.VkViewport)(unsafe.Pointer(c.pViewports))[:len(g.Viewports):len(g.Viewports)]
		for i1, _ := range g.Viewports {
			g.Viewports[i1].toC(&slice1[i1])
		}
	} else {
		c.pViewports = nil
	}
	c.scissorCount = C.uint32_t(len(g.Scissors))
	if len(g.Scissors) != 0 {
		c.pScissors = (*C.VkRect2D)(m.alloc(C.sizeof_VkRect2D * uint(len(g.Scissors))))
		slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pScissors))[:len(g.Scissors):len(g.Scissors)]
		for i1, _ := range g.Scissors {
			g.Scissors[i1].toC(&slice1[i1])
		}
	} else {
		c.pScissors = nil
	}
}
func (g *PipelineViewportStateCreateInfo) fromC(c *C.VkPipelineViewportStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineViewportStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineViewportStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineViewportStateCreateFlags(temp_in_VkPipelineViewportStateCreateFlags)
	}
	g.Viewports = make([]Viewport, int(c.viewportCount))
	if len(g.Viewports) != 0 {
		slice1 := (*[1 << 31]C.VkViewport)(unsafe.Pointer(c.pViewports))[:len(g.Viewports):len(g.Viewports)]
		for i1, _ := range g.Viewports {
			g.Viewports[i1].fromC(&slice1[i1])
		}
	}
	g.Scissors = make([]Rect2D, int(c.scissorCount))
	if len(g.Scissors) != 0 {
		slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pScissors))[:len(g.Scissors):len(g.Scissors)]
		for i1, _ := range g.Scissors {
			g.Scissors[i1].fromC(&slice1[i1])
		}
	}
}
func (s *PipelineViewportStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
}
func (s *PipelineViewportStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineViewportStateCreateInfo)(m.alloc(C.sizeof_VkPipelineViewportStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineViewportStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineViewportStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineViewportStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineViewportStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineRasterizationStateCreateFlags Flags
type CullModeFlags Flags
type PipelineRasterizationStateCreateInfo struct {
	Next                    Structure
	Flags                   PipelineRasterizationStateCreateFlags
	DepthClampEnable        bool
	RasterizerDiscardEnable bool
	PolygonMode             PolygonMode
	CullMode                CullModeFlags
	FrontFace               FrontFace
	DepthBiasEnable         bool
	DepthBiasConstantFactor float32
	DepthBiasClamp          float32
	DepthBiasSlopeFactor    float32
	LineWidth               float32
}

func (g *PipelineRasterizationStateCreateInfo) toC(c *C.VkPipelineRasterizationStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineRasterizationStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineRasterizationStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineRasterizationStateCreateFlags(temp_in_VkPipelineRasterizationStateCreateFlags)
	}
	if g.DepthClampEnable {
		c.depthClampEnable = 1
	} else {
		c.depthClampEnable = 0
	}
	if g.RasterizerDiscardEnable {
		c.rasterizerDiscardEnable = 1
	} else {
		c.rasterizerDiscardEnable = 0
	}
	c.polygonMode = C.VkPolygonMode(g.PolygonMode)
	{
		var temp_in_VkCullModeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.CullMode)))
			temp_in_VkCullModeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.cullMode = C.VkCullModeFlags(temp_in_VkCullModeFlags)
	}
	c.frontFace = C.VkFrontFace(g.FrontFace)
	if g.DepthBiasEnable {
		c.depthBiasEnable = 1
	} else {
		c.depthBiasEnable = 0
	}
	c.depthBiasConstantFactor = C.float(g.DepthBiasConstantFactor)
	c.depthBiasClamp = C.float(g.DepthBiasClamp)
	c.depthBiasSlopeFactor = C.float(g.DepthBiasSlopeFactor)
	c.lineWidth = C.float(g.LineWidth)
}
func (g *PipelineRasterizationStateCreateInfo) fromC(c *C.VkPipelineRasterizationStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineRasterizationStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineRasterizationStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineRasterizationStateCreateFlags(temp_in_VkPipelineRasterizationStateCreateFlags)
	}
	g.DepthClampEnable = c.depthClampEnable != 0
	g.RasterizerDiscardEnable = c.rasterizerDiscardEnable != 0
	g.PolygonMode = PolygonMode(c.polygonMode)
	{
		var temp_in_VkCullModeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.cullMode)))
			temp_in_VkCullModeFlags = Flags(temp_in_VkFlags)
		}
		g.CullMode = CullModeFlags(temp_in_VkCullModeFlags)
	}
	g.FrontFace = FrontFace(c.frontFace)
	g.DepthBiasEnable = c.depthBiasEnable != 0
	g.DepthBiasConstantFactor = float32(c.depthBiasConstantFactor)
	g.DepthBiasClamp = float32(c.depthBiasClamp)
	g.DepthBiasSlopeFactor = float32(c.depthBiasSlopeFactor)
	g.LineWidth = float32(c.lineWidth)
}
func (s *PipelineRasterizationStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
}
func (s *PipelineRasterizationStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineRasterizationStateCreateInfo)(m.alloc(C.sizeof_VkPipelineRasterizationStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineRasterizationStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineRasterizationStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineRasterizationStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineRasterizationStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineMultisampleStateCreateFlags Flags
type SampleMask uint32
type PipelineMultisampleStateCreateInfo struct {
	Next                  Structure
	Flags                 PipelineMultisampleStateCreateFlags
	RasterizationSamples  SampleCountFlagBits
	SampleShadingEnable   bool
	MinSampleShading      float32
	SampleMask            *SampleMask
	AlphaToCoverageEnable bool
	AlphaToOneEnable      bool
}

func (g *PipelineMultisampleStateCreateInfo) toC(c *C.VkPipelineMultisampleStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineMultisampleStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineMultisampleStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineMultisampleStateCreateFlags(temp_in_VkPipelineMultisampleStateCreateFlags)
	}
	c.rasterizationSamples = C.VkSampleCountFlagBits(g.RasterizationSamples)
	if g.SampleShadingEnable {
		c.sampleShadingEnable = 1
	} else {
		c.sampleShadingEnable = 0
	}
	c.minSampleShading = C.float(g.MinSampleShading)
	if g.SampleMask != nil {
		c.pSampleMask = (*C.VkSampleMask)(m.alloc(C.sizeof_VkSampleMask))
		{
			var temp_in_VkSampleMask C.uint32_t
			temp_in_VkSampleMask = C.uint32_t((uint32)(*g.SampleMask))
			*c.pSampleMask = C.VkSampleMask(temp_in_VkSampleMask)
		}
	} else {
		c.pSampleMask = nil
	}
	if g.AlphaToCoverageEnable {
		c.alphaToCoverageEnable = 1
	} else {
		c.alphaToCoverageEnable = 0
	}
	if g.AlphaToOneEnable {
		c.alphaToOneEnable = 1
	} else {
		c.alphaToOneEnable = 0
	}
}
func (g *PipelineMultisampleStateCreateInfo) fromC(c *C.VkPipelineMultisampleStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineMultisampleStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineMultisampleStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineMultisampleStateCreateFlags(temp_in_VkPipelineMultisampleStateCreateFlags)
	}
	g.RasterizationSamples = SampleCountFlagBits(c.rasterizationSamples)
	g.SampleShadingEnable = c.sampleShadingEnable != 0
	g.MinSampleShading = float32(c.minSampleShading)
	if g.SampleMask != nil {
		var temp_in_VkSampleMask uint32
		temp_in_VkSampleMask = uint32((C.uint32_t)(*c.pSampleMask))
		*g.SampleMask = SampleMask(temp_in_VkSampleMask)
	}
	g.AlphaToCoverageEnable = c.alphaToCoverageEnable != 0
	g.AlphaToOneEnable = c.alphaToOneEnable != 0
}
func (s *PipelineMultisampleStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
}
func (s *PipelineMultisampleStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineMultisampleStateCreateInfo)(m.alloc(C.sizeof_VkPipelineMultisampleStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineMultisampleStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineMultisampleStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineMultisampleStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineMultisampleStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineDepthStencilStateCreateFlags Flags
type StencilOpState struct {
	FailOp      StencilOp
	PassOp      StencilOp
	DepthFailOp StencilOp
	CompareOp   CompareOp
	CompareMask uint32
	WriteMask   uint32
	Reference   uint32
}

func (g *StencilOpState) toC(c *C.VkStencilOpState) {
	c.failOp = C.VkStencilOp(g.FailOp)
	c.passOp = C.VkStencilOp(g.PassOp)
	c.depthFailOp = C.VkStencilOp(g.DepthFailOp)
	c.compareOp = C.VkCompareOp(g.CompareOp)
	c.compareMask = C.uint32_t(g.CompareMask)
	c.writeMask = C.uint32_t(g.WriteMask)
	c.reference = C.uint32_t(g.Reference)
}
func (g *StencilOpState) fromC(c *C.VkStencilOpState) {
	g.FailOp = StencilOp(c.failOp)
	g.PassOp = StencilOp(c.passOp)
	g.DepthFailOp = StencilOp(c.depthFailOp)
	g.CompareOp = CompareOp(c.compareOp)
	g.CompareMask = uint32(c.compareMask)
	g.WriteMask = uint32(c.writeMask)
	g.Reference = uint32(c.reference)
}

type PipelineDepthStencilStateCreateInfo struct {
	Next                  Structure
	Flags                 PipelineDepthStencilStateCreateFlags
	DepthTestEnable       bool
	DepthWriteEnable      bool
	DepthCompareOp        CompareOp
	DepthBoundsTestEnable bool
	StencilTestEnable     bool
	Front                 StencilOpState
	Back                  StencilOpState
	MinDepthBounds        float32
	MaxDepthBounds        float32
}

func (g *PipelineDepthStencilStateCreateInfo) toC(c *C.VkPipelineDepthStencilStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineDepthStencilStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineDepthStencilStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineDepthStencilStateCreateFlags(temp_in_VkPipelineDepthStencilStateCreateFlags)
	}
	if g.DepthTestEnable {
		c.depthTestEnable = 1
	} else {
		c.depthTestEnable = 0
	}
	if g.DepthWriteEnable {
		c.depthWriteEnable = 1
	} else {
		c.depthWriteEnable = 0
	}
	c.depthCompareOp = C.VkCompareOp(g.DepthCompareOp)
	if g.DepthBoundsTestEnable {
		c.depthBoundsTestEnable = 1
	} else {
		c.depthBoundsTestEnable = 0
	}
	if g.StencilTestEnable {
		c.stencilTestEnable = 1
	} else {
		c.stencilTestEnable = 0
	}
	g.Front.toC(&c.front)
	g.Back.toC(&c.back)
	c.minDepthBounds = C.float(g.MinDepthBounds)
	c.maxDepthBounds = C.float(g.MaxDepthBounds)
}
func (g *PipelineDepthStencilStateCreateInfo) fromC(c *C.VkPipelineDepthStencilStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineDepthStencilStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineDepthStencilStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineDepthStencilStateCreateFlags(temp_in_VkPipelineDepthStencilStateCreateFlags)
	}
	g.DepthTestEnable = c.depthTestEnable != 0
	g.DepthWriteEnable = c.depthWriteEnable != 0
	g.DepthCompareOp = CompareOp(c.depthCompareOp)
	g.DepthBoundsTestEnable = c.depthBoundsTestEnable != 0
	g.StencilTestEnable = c.stencilTestEnable != 0
	g.Front.fromC(&c.front)
	g.Back.fromC(&c.back)
	g.MinDepthBounds = float32(c.minDepthBounds)
	g.MaxDepthBounds = float32(c.maxDepthBounds)
}
func (s *PipelineDepthStencilStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
}
func (s *PipelineDepthStencilStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineDepthStencilStateCreateInfo)(m.alloc(C.sizeof_VkPipelineDepthStencilStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineDepthStencilStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineDepthStencilStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineDepthStencilStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineDepthStencilStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineColorBlendStateCreateFlags Flags
type ColorComponentFlags Flags
type PipelineColorBlendAttachmentState struct {
	BlendEnable         bool
	SrcColorBlendFactor BlendFactor
	DstColorBlendFactor BlendFactor
	ColorBlendOp        BlendOp
	SrcAlphaBlendFactor BlendFactor
	DstAlphaBlendFactor BlendFactor
	AlphaBlendOp        BlendOp
	ColorWriteMask      ColorComponentFlags
}

func (g *PipelineColorBlendAttachmentState) toC(c *C.VkPipelineColorBlendAttachmentState) {
	if g.BlendEnable {
		c.blendEnable = 1
	} else {
		c.blendEnable = 0
	}
	c.srcColorBlendFactor = C.VkBlendFactor(g.SrcColorBlendFactor)
	c.dstColorBlendFactor = C.VkBlendFactor(g.DstColorBlendFactor)
	c.colorBlendOp = C.VkBlendOp(g.ColorBlendOp)
	c.srcAlphaBlendFactor = C.VkBlendFactor(g.SrcAlphaBlendFactor)
	c.dstAlphaBlendFactor = C.VkBlendFactor(g.DstAlphaBlendFactor)
	c.alphaBlendOp = C.VkBlendOp(g.AlphaBlendOp)
	{
		var temp_in_VkColorComponentFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ColorWriteMask)))
			temp_in_VkColorComponentFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.colorWriteMask = C.VkColorComponentFlags(temp_in_VkColorComponentFlags)
	}
}
func (g *PipelineColorBlendAttachmentState) fromC(c *C.VkPipelineColorBlendAttachmentState) {
	g.BlendEnable = c.blendEnable != 0
	g.SrcColorBlendFactor = BlendFactor(c.srcColorBlendFactor)
	g.DstColorBlendFactor = BlendFactor(c.dstColorBlendFactor)
	g.ColorBlendOp = BlendOp(c.colorBlendOp)
	g.SrcAlphaBlendFactor = BlendFactor(c.srcAlphaBlendFactor)
	g.DstAlphaBlendFactor = BlendFactor(c.dstAlphaBlendFactor)
	g.AlphaBlendOp = BlendOp(c.alphaBlendOp)
	{
		var temp_in_VkColorComponentFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.colorWriteMask)))
			temp_in_VkColorComponentFlags = Flags(temp_in_VkFlags)
		}
		g.ColorWriteMask = ColorComponentFlags(temp_in_VkColorComponentFlags)
	}
}

type PipelineColorBlendStateCreateInfo struct {
	Next           Structure
	Flags          PipelineColorBlendStateCreateFlags
	LogicOpEnable  bool
	LogicOp        LogicOp
	Attachments    []PipelineColorBlendAttachmentState
	BlendConstants [4]float32
}

func (g *PipelineColorBlendStateCreateInfo) toC(c *C.VkPipelineColorBlendStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineColorBlendStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineColorBlendStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineColorBlendStateCreateFlags(temp_in_VkPipelineColorBlendStateCreateFlags)
	}
	if g.LogicOpEnable {
		c.logicOpEnable = 1
	} else {
		c.logicOpEnable = 0
	}
	c.logicOp = C.VkLogicOp(g.LogicOp)
	c.attachmentCount = C.uint32_t(len(g.Attachments))
	if len(g.Attachments) != 0 {
		c.pAttachments = (*C.VkPipelineColorBlendAttachmentState)(m.alloc(C.sizeof_VkPipelineColorBlendAttachmentState * uint(len(g.Attachments))))
		slice1 := (*[1 << 31]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pAttachments = nil
	}
	for i, _ := range g.BlendConstants {
		c.blendConstants[i] = C.float(g.BlendConstants[i])
	}
}
func (g *PipelineColorBlendStateCreateInfo) fromC(c *C.VkPipelineColorBlendStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineColorBlendStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineColorBlendStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineColorBlendStateCreateFlags(temp_in_VkPipelineColorBlendStateCreateFlags)
	}
	g.LogicOpEnable = c.logicOpEnable != 0
	g.LogicOp = LogicOp(c.logicOp)
	g.Attachments = make([]PipelineColorBlendAttachmentState, int(c.attachmentCount))
	if len(g.Attachments) != 0 {
		slice1 := (*[1 << 31]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].fromC(&slice1[i1])
		}
	}
	for i, _ := range g.BlendConstants {
		g.BlendConstants[i] = float32(c.blendConstants[i])
	}
}
func (s *PipelineColorBlendStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
}
func (s *PipelineColorBlendStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineColorBlendStateCreateInfo)(m.alloc(C.sizeof_VkPipelineColorBlendStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineColorBlendStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineColorBlendStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineColorBlendStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineColorBlendStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineDynamicStateCreateFlags Flags
type PipelineDynamicStateCreateInfo struct {
	Next          Structure
	Flags         PipelineDynamicStateCreateFlags
	DynamicStates []DynamicState
}

func (g *PipelineDynamicStateCreateInfo) toC(c *C.VkPipelineDynamicStateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineDynamicStateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineDynamicStateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineDynamicStateCreateFlags(temp_in_VkPipelineDynamicStateCreateFlags)
	}
	c.dynamicStateCount = C.uint32_t(len(g.DynamicStates))
	if len(g.DynamicStates) != 0 {
		c.pDynamicStates = (*C.VkDynamicState)(m.alloc(C.sizeof_VkDynamicState * uint(len(g.DynamicStates))))
		slice1 := (*[1 << 31]C.VkDynamicState)(unsafe.Pointer(c.pDynamicStates))[:len(g.DynamicStates):len(g.DynamicStates)]
		for i1, _ := range g.DynamicStates {
			slice1[i1] = C.VkDynamicState(g.DynamicStates[i1])
		}
	} else {
		c.pDynamicStates = nil
	}
}
func (g *PipelineDynamicStateCreateInfo) fromC(c *C.VkPipelineDynamicStateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineDynamicStateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineDynamicStateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineDynamicStateCreateFlags(temp_in_VkPipelineDynamicStateCreateFlags)
	}
	g.DynamicStates = make([]DynamicState, int(c.dynamicStateCount))
	if len(g.DynamicStates) != 0 {
		slice1 := (*[1 << 31]C.VkDynamicState)(unsafe.Pointer(c.pDynamicStates))[:len(g.DynamicStates):len(g.DynamicStates)]
		for i1, _ := range g.DynamicStates {
			g.DynamicStates[i1] = DynamicState(slice1[i1])
		}
	}
}
func (s *PipelineDynamicStateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
}
func (s *PipelineDynamicStateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineDynamicStateCreateInfo)(m.alloc(C.sizeof_VkPipelineDynamicStateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineDynamicStateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineDynamicStateCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineDynamicStateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineDynamicStateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type PipelineLayout C.VkPipelineLayout
type RenderPass C.VkRenderPass
type Pipeline C.VkPipeline
type GraphicsPipelineCreateInfo struct {
	Next               Structure
	Flags              PipelineCreateFlags
	Stages             []PipelineShaderStageCreateInfo
	VertexInputState   *PipelineVertexInputStateCreateInfo
	InputAssemblyState *PipelineInputAssemblyStateCreateInfo
	TessellationState  *PipelineTessellationStateCreateInfo
	ViewportState      *PipelineViewportStateCreateInfo
	RasterizationState *PipelineRasterizationStateCreateInfo
	MultisampleState   *PipelineMultisampleStateCreateInfo
	DepthStencilState  *PipelineDepthStencilStateCreateInfo
	ColorBlendState    *PipelineColorBlendStateCreateInfo
	DynamicState       *PipelineDynamicStateCreateInfo
	Layout             PipelineLayout
	RenderPass         RenderPass
	Subpass            uint32
	BasePipelineHandle Pipeline
	BasePipelineIndex  int32
}

func (g *GraphicsPipelineCreateInfo) toC(c *C.VkGraphicsPipelineCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineCreateFlags(temp_in_VkPipelineCreateFlags)
	}
	c.stageCount = C.uint32_t(len(g.Stages))
	if len(g.Stages) != 0 {
		c.pStages = (*C.VkPipelineShaderStageCreateInfo)(m.alloc(C.sizeof_VkPipelineShaderStageCreateInfo * uint(len(g.Stages))))
		slice1 := (*[1 << 31]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(c.pStages))[:len(g.Stages):len(g.Stages)]
		for i1, _ := range g.Stages {
			g.Stages[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pStages = nil
	}
	if g.VertexInputState != nil {
		c.pVertexInputState = (*C.VkPipelineVertexInputStateCreateInfo)(m.alloc(C.sizeof_VkPipelineVertexInputStateCreateInfo))
		g.VertexInputState.toC(c.pVertexInputState, m)
	} else {
		c.pVertexInputState = nil
	}
	if g.InputAssemblyState != nil {
		c.pInputAssemblyState = (*C.VkPipelineInputAssemblyStateCreateInfo)(m.alloc(C.sizeof_VkPipelineInputAssemblyStateCreateInfo))
		g.InputAssemblyState.toC(c.pInputAssemblyState, m)
	} else {
		c.pInputAssemblyState = nil
	}
	if g.TessellationState != nil {
		c.pTessellationState = (*C.VkPipelineTessellationStateCreateInfo)(m.alloc(C.sizeof_VkPipelineTessellationStateCreateInfo))
		g.TessellationState.toC(c.pTessellationState, m)
	} else {
		c.pTessellationState = nil
	}
	if g.ViewportState != nil {
		c.pViewportState = (*C.VkPipelineViewportStateCreateInfo)(m.alloc(C.sizeof_VkPipelineViewportStateCreateInfo))
		g.ViewportState.toC(c.pViewportState, m)
	} else {
		c.pViewportState = nil
	}
	if g.RasterizationState != nil {
		c.pRasterizationState = (*C.VkPipelineRasterizationStateCreateInfo)(m.alloc(C.sizeof_VkPipelineRasterizationStateCreateInfo))
		g.RasterizationState.toC(c.pRasterizationState, m)
	} else {
		c.pRasterizationState = nil
	}
	if g.MultisampleState != nil {
		c.pMultisampleState = (*C.VkPipelineMultisampleStateCreateInfo)(m.alloc(C.sizeof_VkPipelineMultisampleStateCreateInfo))
		g.MultisampleState.toC(c.pMultisampleState, m)
	} else {
		c.pMultisampleState = nil
	}
	if g.DepthStencilState != nil {
		c.pDepthStencilState = (*C.VkPipelineDepthStencilStateCreateInfo)(m.alloc(C.sizeof_VkPipelineDepthStencilStateCreateInfo))
		g.DepthStencilState.toC(c.pDepthStencilState, m)
	} else {
		c.pDepthStencilState = nil
	}
	if g.ColorBlendState != nil {
		c.pColorBlendState = (*C.VkPipelineColorBlendStateCreateInfo)(m.alloc(C.sizeof_VkPipelineColorBlendStateCreateInfo))
		g.ColorBlendState.toC(c.pColorBlendState, m)
	} else {
		c.pColorBlendState = nil
	}
	if g.DynamicState != nil {
		c.pDynamicState = (*C.VkPipelineDynamicStateCreateInfo)(m.alloc(C.sizeof_VkPipelineDynamicStateCreateInfo))
		g.DynamicState.toC(c.pDynamicState, m)
	} else {
		c.pDynamicState = nil
	}
	c.layout = C.VkPipelineLayout(g.Layout)
	c.renderPass = C.VkRenderPass(g.RenderPass)
	c.subpass = C.uint32_t(g.Subpass)
	c.basePipelineHandle = C.VkPipeline(g.BasePipelineHandle)
	c.basePipelineIndex = C.int32_t(g.BasePipelineIndex)
}
func (g *GraphicsPipelineCreateInfo) fromC(c *C.VkGraphicsPipelineCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineCreateFlags(temp_in_VkPipelineCreateFlags)
	}
	g.Stages = make([]PipelineShaderStageCreateInfo, int(c.stageCount))
	if len(g.Stages) != 0 {
		slice1 := (*[1 << 31]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(c.pStages))[:len(g.Stages):len(g.Stages)]
		for i1, _ := range g.Stages {
			g.Stages[i1].fromC(&slice1[i1])
		}
	}
	if g.VertexInputState != nil {
		g.VertexInputState.fromC(c.pVertexInputState)
	}
	if g.InputAssemblyState != nil {
		g.InputAssemblyState.fromC(c.pInputAssemblyState)
	}
	if g.TessellationState != nil {
		g.TessellationState.fromC(c.pTessellationState)
	}
	if g.ViewportState != nil {
		g.ViewportState.fromC(c.pViewportState)
	}
	if g.RasterizationState != nil {
		g.RasterizationState.fromC(c.pRasterizationState)
	}
	if g.MultisampleState != nil {
		g.MultisampleState.fromC(c.pMultisampleState)
	}
	if g.DepthStencilState != nil {
		g.DepthStencilState.fromC(c.pDepthStencilState)
	}
	if g.ColorBlendState != nil {
		g.ColorBlendState.fromC(c.pColorBlendState)
	}
	if g.DynamicState != nil {
		g.DynamicState.fromC(c.pDynamicState)
	}
	g.Layout = PipelineLayout(c.layout)
	g.RenderPass = RenderPass(c.renderPass)
	g.Subpass = uint32(c.subpass)
	g.BasePipelineHandle = Pipeline(c.basePipelineHandle)
	g.BasePipelineIndex = int32(c.basePipelineIndex)
}
func (s *GraphicsPipelineCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
}
func (s *GraphicsPipelineCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkGraphicsPipelineCreateInfo)(m.alloc(C.sizeof_VkGraphicsPipelineCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *GraphicsPipelineCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkGraphicsPipelineCreateInfo)(p)
	s.fromC(c)
}
func (s *GraphicsPipelineCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *GraphicsPipelineCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateGraphicsPipelines func(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result)

func ToCreateGraphicsPipelines(p PFNVoidFunction) (fn FuncCreateGraphicsPipelines) {
	return func(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pipelineCache   C.VkPipelineCache
			createInfoCount C.uint32_t
			pCreateInfos    *C.VkGraphicsPipelineCreateInfo
			pAllocator      *C.VkAllocationCallbacks
			pPipelines      *C.VkPipeline
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipelineCache = C.VkPipelineCache(pipelineCache)
		c.createInfoCount = C.uint32_t(len(createInfos))
		if len(createInfos) != 0 {
			c.pCreateInfos = (*C.VkGraphicsPipelineCreateInfo)(m.alloc(C.sizeof_VkGraphicsPipelineCreateInfo * uint(len(createInfos))))
			slice1 := (*[1 << 31]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(c.pCreateInfos))[:len(createInfos):len(createInfos)]
			for i1, _ := range createInfos {
				createInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pCreateInfos = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if len(pipelines) != 0 {
			c.pPipelines = (*C.VkPipeline)(m.alloc(C.sizeof_VkPipeline * uint(len(pipelines))))
			slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
			for i1, _ := range pipelines {
				slice1[i1] = C.VkPipeline(pipelines[i1])
			}
		} else {
			c.pPipelines = nil
		}
		c._ret = C.callPFN_vkCreateGraphicsPipelines(C.PFN_vkCreateGraphicsPipelines(unsafe.Pointer(p)), c.device, c.pipelineCache, c.createInfoCount, c.pCreateInfos, c.pAllocator, c.pPipelines)
		_ret = Result(c._ret)
		if len(pipelines) != 0 {
			slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
			for i1, _ := range pipelines {
				pipelines[i1] = Pipeline(slice1[i1])
			}
		}
		return
	}
}

type PFNCreateComputePipelines C.PFN_vkCreateComputePipelines
type ComputePipelineCreateInfo struct {
	Next               Structure
	Flags              PipelineCreateFlags
	Stage              PipelineShaderStageCreateInfo
	Layout             PipelineLayout
	BasePipelineHandle Pipeline
	BasePipelineIndex  int32
}

func (g *ComputePipelineCreateInfo) toC(c *C.VkComputePipelineCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineCreateFlags(temp_in_VkPipelineCreateFlags)
	}
	g.Stage.toC(&c.stage, m)
	c.layout = C.VkPipelineLayout(g.Layout)
	c.basePipelineHandle = C.VkPipeline(g.BasePipelineHandle)
	c.basePipelineIndex = C.int32_t(g.BasePipelineIndex)
}
func (g *ComputePipelineCreateInfo) fromC(c *C.VkComputePipelineCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineCreateFlags(temp_in_VkPipelineCreateFlags)
	}
	g.Stage.fromC(&c.stage)
	g.Layout = PipelineLayout(c.layout)
	g.BasePipelineHandle = Pipeline(c.basePipelineHandle)
	g.BasePipelineIndex = int32(c.basePipelineIndex)
}
func (s *ComputePipelineCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
}
func (s *ComputePipelineCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkComputePipelineCreateInfo)(m.alloc(C.sizeof_VkComputePipelineCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ComputePipelineCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkComputePipelineCreateInfo)(p)
	s.fromC(c)
}
func (s *ComputePipelineCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *ComputePipelineCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateComputePipelines func(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result)

func ToCreateComputePipelines(p PFNVoidFunction) (fn FuncCreateComputePipelines) {
	return func(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pipelineCache   C.VkPipelineCache
			createInfoCount C.uint32_t
			pCreateInfos    *C.VkComputePipelineCreateInfo
			pAllocator      *C.VkAllocationCallbacks
			pPipelines      *C.VkPipeline
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipelineCache = C.VkPipelineCache(pipelineCache)
		c.createInfoCount = C.uint32_t(len(createInfos))
		if len(createInfos) != 0 {
			c.pCreateInfos = (*C.VkComputePipelineCreateInfo)(m.alloc(C.sizeof_VkComputePipelineCreateInfo * uint(len(createInfos))))
			slice1 := (*[1 << 31]C.VkComputePipelineCreateInfo)(unsafe.Pointer(c.pCreateInfos))[:len(createInfos):len(createInfos)]
			for i1, _ := range createInfos {
				createInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pCreateInfos = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if len(pipelines) != 0 {
			c.pPipelines = (*C.VkPipeline)(m.alloc(C.sizeof_VkPipeline * uint(len(pipelines))))
			slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
			for i1, _ := range pipelines {
				slice1[i1] = C.VkPipeline(pipelines[i1])
			}
		} else {
			c.pPipelines = nil
		}
		c._ret = C.callPFN_vkCreateComputePipelines(C.PFN_vkCreateComputePipelines(unsafe.Pointer(p)), c.device, c.pipelineCache, c.createInfoCount, c.pCreateInfos, c.pAllocator, c.pPipelines)
		_ret = Result(c._ret)
		if len(pipelines) != 0 {
			slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
			for i1, _ := range pipelines {
				pipelines[i1] = Pipeline(slice1[i1])
			}
		}
		return
	}
}

type PFNDestroyPipeline C.PFN_vkDestroyPipeline
type FuncDestroyPipeline func(device Device, pipeline Pipeline, allocator *AllocationCallbacks)

func ToDestroyPipeline(p PFNVoidFunction) (fn FuncDestroyPipeline) {
	return func(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			pipeline   C.VkPipeline
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipeline = C.VkPipeline(pipeline)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyPipeline(C.PFN_vkDestroyPipeline(unsafe.Pointer(p)), c.device, c.pipeline, c.pAllocator)
	}
}

type PFNCreatePipelineLayout C.PFN_vkCreatePipelineLayout
type PipelineLayoutCreateFlags Flags
type DescriptorSetLayout C.VkDescriptorSetLayout
type ShaderStageFlags Flags
type PushConstantRange struct {
	StageFlags ShaderStageFlags
	Offset     uint32
	Size       uint32
}

func (g *PushConstantRange) toC(c *C.VkPushConstantRange) {
	{
		var temp_in_VkShaderStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.StageFlags)))
			temp_in_VkShaderStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.stageFlags = C.VkShaderStageFlags(temp_in_VkShaderStageFlags)
	}
	c.offset = C.uint32_t(g.Offset)
	c.size = C.uint32_t(g.Size)
}
func (g *PushConstantRange) fromC(c *C.VkPushConstantRange) {
	{
		var temp_in_VkShaderStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.stageFlags)))
			temp_in_VkShaderStageFlags = Flags(temp_in_VkFlags)
		}
		g.StageFlags = ShaderStageFlags(temp_in_VkShaderStageFlags)
	}
	g.Offset = uint32(c.offset)
	g.Size = uint32(c.size)
}

type PipelineLayoutCreateInfo struct {
	Next               Structure
	Flags              PipelineLayoutCreateFlags
	SetLayouts         []DescriptorSetLayout
	PushConstantRanges []PushConstantRange
}

func (g *PipelineLayoutCreateInfo) toC(c *C.VkPipelineLayoutCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkPipelineLayoutCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkPipelineLayoutCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkPipelineLayoutCreateFlags(temp_in_VkPipelineLayoutCreateFlags)
	}
	c.setLayoutCount = C.uint32_t(len(g.SetLayouts))
	if len(g.SetLayouts) != 0 {
		c.pSetLayouts = (*C.VkDescriptorSetLayout)(m.alloc(C.sizeof_VkDescriptorSetLayout * uint(len(g.SetLayouts))))
		slice1 := (*[1 << 31]C.VkDescriptorSetLayout)(unsafe.Pointer(c.pSetLayouts))[:len(g.SetLayouts):len(g.SetLayouts)]
		for i1, _ := range g.SetLayouts {
			slice1[i1] = C.VkDescriptorSetLayout(g.SetLayouts[i1])
		}
	} else {
		c.pSetLayouts = nil
	}
	c.pushConstantRangeCount = C.uint32_t(len(g.PushConstantRanges))
	if len(g.PushConstantRanges) != 0 {
		c.pPushConstantRanges = (*C.VkPushConstantRange)(m.alloc(C.sizeof_VkPushConstantRange * uint(len(g.PushConstantRanges))))
		slice1 := (*[1 << 31]C.VkPushConstantRange)(unsafe.Pointer(c.pPushConstantRanges))[:len(g.PushConstantRanges):len(g.PushConstantRanges)]
		for i1, _ := range g.PushConstantRanges {
			g.PushConstantRanges[i1].toC(&slice1[i1])
		}
	} else {
		c.pPushConstantRanges = nil
	}
}
func (g *PipelineLayoutCreateInfo) fromC(c *C.VkPipelineLayoutCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkPipelineLayoutCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkPipelineLayoutCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = PipelineLayoutCreateFlags(temp_in_VkPipelineLayoutCreateFlags)
	}
	g.SetLayouts = make([]DescriptorSetLayout, int(c.setLayoutCount))
	if len(g.SetLayouts) != 0 {
		slice1 := (*[1 << 31]C.VkDescriptorSetLayout)(unsafe.Pointer(c.pSetLayouts))[:len(g.SetLayouts):len(g.SetLayouts)]
		for i1, _ := range g.SetLayouts {
			g.SetLayouts[i1] = DescriptorSetLayout(slice1[i1])
		}
	}
	g.PushConstantRanges = make([]PushConstantRange, int(c.pushConstantRangeCount))
	if len(g.PushConstantRanges) != 0 {
		slice1 := (*[1 << 31]C.VkPushConstantRange)(unsafe.Pointer(c.pPushConstantRanges))[:len(g.PushConstantRanges):len(g.PushConstantRanges)]
		for i1, _ := range g.PushConstantRanges {
			g.PushConstantRanges[i1].fromC(&slice1[i1])
		}
	}
}
func (s *PipelineLayoutCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
}
func (s *PipelineLayoutCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPipelineLayoutCreateInfo)(m.alloc(C.sizeof_VkPipelineLayoutCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PipelineLayoutCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPipelineLayoutCreateInfo)(p)
	s.fromC(c)
}
func (s *PipelineLayoutCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *PipelineLayoutCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreatePipelineLayout func(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks, pipelineLayout *PipelineLayout) (_ret Result)

func ToCreatePipelineLayout(p PFNVoidFunction) (fn FuncCreatePipelineLayout) {
	return func(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks, pipelineLayout *PipelineLayout) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pCreateInfo     *C.VkPipelineLayoutCreateInfo
			pAllocator      *C.VkAllocationCallbacks
			pPipelineLayout *C.VkPipelineLayout
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkPipelineLayoutCreateInfo)(m.alloc(C.sizeof_VkPipelineLayoutCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if pipelineLayout != nil {
			c.pPipelineLayout = (*C.VkPipelineLayout)(m.alloc(C.sizeof_VkPipelineLayout))
			*c.pPipelineLayout = C.VkPipelineLayout(*pipelineLayout)
		} else {
			c.pPipelineLayout = nil
		}
		c._ret = C.callPFN_vkCreatePipelineLayout(C.PFN_vkCreatePipelineLayout(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pPipelineLayout)
		_ret = Result(c._ret)
		if pipelineLayout != nil {
			*pipelineLayout = PipelineLayout(*c.pPipelineLayout)
		}
		return
	}
}

type PFNDestroyPipelineLayout C.PFN_vkDestroyPipelineLayout
type FuncDestroyPipelineLayout func(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks)

func ToDestroyPipelineLayout(p PFNVoidFunction) (fn FuncDestroyPipelineLayout) {
	return func(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
		var c struct {
			device         C.VkDevice
			pipelineLayout C.VkPipelineLayout
			pAllocator     *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipelineLayout = C.VkPipelineLayout(pipelineLayout)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyPipelineLayout(C.PFN_vkDestroyPipelineLayout(unsafe.Pointer(p)), c.device, c.pipelineLayout, c.pAllocator)
	}
}

type PFNCreateSampler C.PFN_vkCreateSampler
type SamplerCreateFlags Flags
type SamplerCreateInfo struct {
	Next                    Structure
	Flags                   SamplerCreateFlags
	MagFilter               Filter
	MinFilter               Filter
	MipmapMode              SamplerMipmapMode
	AddressModeU            SamplerAddressMode
	AddressModeV            SamplerAddressMode
	AddressModeW            SamplerAddressMode
	MipLodBias              float32
	AnisotropyEnable        bool
	MaxAnisotropy           float32
	CompareEnable           bool
	CompareOp               CompareOp
	MinLod                  float32
	MaxLod                  float32
	BorderColor             BorderColor
	UnnormalizedCoordinates bool
}

func (g *SamplerCreateInfo) toC(c *C.VkSamplerCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkSamplerCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSamplerCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSamplerCreateFlags(temp_in_VkSamplerCreateFlags)
	}
	c.magFilter = C.VkFilter(g.MagFilter)
	c.minFilter = C.VkFilter(g.MinFilter)
	c.mipmapMode = C.VkSamplerMipmapMode(g.MipmapMode)
	c.addressModeU = C.VkSamplerAddressMode(g.AddressModeU)
	c.addressModeV = C.VkSamplerAddressMode(g.AddressModeV)
	c.addressModeW = C.VkSamplerAddressMode(g.AddressModeW)
	c.mipLodBias = C.float(g.MipLodBias)
	if g.AnisotropyEnable {
		c.anisotropyEnable = 1
	} else {
		c.anisotropyEnable = 0
	}
	c.maxAnisotropy = C.float(g.MaxAnisotropy)
	if g.CompareEnable {
		c.compareEnable = 1
	} else {
		c.compareEnable = 0
	}
	c.compareOp = C.VkCompareOp(g.CompareOp)
	c.minLod = C.float(g.MinLod)
	c.maxLod = C.float(g.MaxLod)
	c.borderColor = C.VkBorderColor(g.BorderColor)
	if g.UnnormalizedCoordinates {
		c.unnormalizedCoordinates = 1
	} else {
		c.unnormalizedCoordinates = 0
	}
}
func (g *SamplerCreateInfo) fromC(c *C.VkSamplerCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkSamplerCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSamplerCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SamplerCreateFlags(temp_in_VkSamplerCreateFlags)
	}
	g.MagFilter = Filter(c.magFilter)
	g.MinFilter = Filter(c.minFilter)
	g.MipmapMode = SamplerMipmapMode(c.mipmapMode)
	g.AddressModeU = SamplerAddressMode(c.addressModeU)
	g.AddressModeV = SamplerAddressMode(c.addressModeV)
	g.AddressModeW = SamplerAddressMode(c.addressModeW)
	g.MipLodBias = float32(c.mipLodBias)
	g.AnisotropyEnable = c.anisotropyEnable != 0
	g.MaxAnisotropy = float32(c.maxAnisotropy)
	g.CompareEnable = c.compareEnable != 0
	g.CompareOp = CompareOp(c.compareOp)
	g.MinLod = float32(c.minLod)
	g.MaxLod = float32(c.maxLod)
	g.BorderColor = BorderColor(c.borderColor)
	g.UnnormalizedCoordinates = c.unnormalizedCoordinates != 0
}
func (s *SamplerCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
}
func (s *SamplerCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSamplerCreateInfo)(m.alloc(C.sizeof_VkSamplerCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SamplerCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSamplerCreateInfo)(p)
	s.fromC(c)
}
func (s *SamplerCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *SamplerCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type Sampler C.VkSampler
type FuncCreateSampler func(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks, sampler *Sampler) (_ret Result)

func ToCreateSampler(p PFNVoidFunction) (fn FuncCreateSampler) {
	return func(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks, sampler *Sampler) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkSamplerCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pSampler    *C.VkSampler
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkSamplerCreateInfo)(m.alloc(C.sizeof_VkSamplerCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if sampler != nil {
			c.pSampler = (*C.VkSampler)(m.alloc(C.sizeof_VkSampler))
			*c.pSampler = C.VkSampler(*sampler)
		} else {
			c.pSampler = nil
		}
		c._ret = C.callPFN_vkCreateSampler(C.PFN_vkCreateSampler(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pSampler)
		_ret = Result(c._ret)
		if sampler != nil {
			*sampler = Sampler(*c.pSampler)
		}
		return
	}
}

type PFNDestroySampler C.PFN_vkDestroySampler
type FuncDestroySampler func(device Device, sampler Sampler, allocator *AllocationCallbacks)

func ToDestroySampler(p PFNVoidFunction) (fn FuncDestroySampler) {
	return func(device Device, sampler Sampler, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			sampler    C.VkSampler
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.sampler = C.VkSampler(sampler)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySampler(C.PFN_vkDestroySampler(unsafe.Pointer(p)), c.device, c.sampler, c.pAllocator)
	}
}

type PFNCreateDescriptorSetLayout C.PFN_vkCreateDescriptorSetLayout
type DescriptorSetLayoutCreateFlags Flags
type DescriptorSetLayoutBinding struct {
	Binding           uint32
	DescriptorType    DescriptorType
	DescriptorCount   uint32
	StageFlags        ShaderStageFlags
	ImmutableSamplers *Sampler
}

func (g *DescriptorSetLayoutBinding) toC(c *C.VkDescriptorSetLayoutBinding, m *cmemory) {
	c.binding = C.uint32_t(g.Binding)
	c.descriptorType = C.VkDescriptorType(g.DescriptorType)
	c.descriptorCount = C.uint32_t(g.DescriptorCount)
	{
		var temp_in_VkShaderStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.StageFlags)))
			temp_in_VkShaderStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.stageFlags = C.VkShaderStageFlags(temp_in_VkShaderStageFlags)
	}
	if g.ImmutableSamplers != nil {
		c.pImmutableSamplers = (*C.VkSampler)(m.alloc(C.sizeof_VkSampler))
		*c.pImmutableSamplers = C.VkSampler(*g.ImmutableSamplers)
	} else {
		c.pImmutableSamplers = nil
	}
}
func (g *DescriptorSetLayoutBinding) fromC(c *C.VkDescriptorSetLayoutBinding) {
	g.Binding = uint32(c.binding)
	g.DescriptorType = DescriptorType(c.descriptorType)
	g.DescriptorCount = uint32(c.descriptorCount)
	{
		var temp_in_VkShaderStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.stageFlags)))
			temp_in_VkShaderStageFlags = Flags(temp_in_VkFlags)
		}
		g.StageFlags = ShaderStageFlags(temp_in_VkShaderStageFlags)
	}
	if g.ImmutableSamplers != nil {
		*g.ImmutableSamplers = Sampler(*c.pImmutableSamplers)
	}
}

type DescriptorSetLayoutCreateInfo struct {
	Next     Structure
	Flags    DescriptorSetLayoutCreateFlags
	Bindings []DescriptorSetLayoutBinding
}

func (g *DescriptorSetLayoutCreateInfo) toC(c *C.VkDescriptorSetLayoutCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDescriptorSetLayoutCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDescriptorSetLayoutCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDescriptorSetLayoutCreateFlags(temp_in_VkDescriptorSetLayoutCreateFlags)
	}
	c.bindingCount = C.uint32_t(len(g.Bindings))
	if len(g.Bindings) != 0 {
		c.pBindings = (*C.VkDescriptorSetLayoutBinding)(m.alloc(C.sizeof_VkDescriptorSetLayoutBinding * uint(len(g.Bindings))))
		slice1 := (*[1 << 31]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(c.pBindings))[:len(g.Bindings):len(g.Bindings)]
		for i1, _ := range g.Bindings {
			g.Bindings[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBindings = nil
	}
}
func (g *DescriptorSetLayoutCreateInfo) fromC(c *C.VkDescriptorSetLayoutCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDescriptorSetLayoutCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDescriptorSetLayoutCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DescriptorSetLayoutCreateFlags(temp_in_VkDescriptorSetLayoutCreateFlags)
	}
	g.Bindings = make([]DescriptorSetLayoutBinding, int(c.bindingCount))
	if len(g.Bindings) != 0 {
		slice1 := (*[1 << 31]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(c.pBindings))[:len(g.Bindings):len(g.Bindings)]
		for i1, _ := range g.Bindings {
			g.Bindings[i1].fromC(&slice1[i1])
		}
	}
}
func (s *DescriptorSetLayoutCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
}
func (s *DescriptorSetLayoutCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DescriptorSetLayoutCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDescriptorSetLayoutCreateInfo)(p)
	s.fromC(c)
}
func (s *DescriptorSetLayoutCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *DescriptorSetLayoutCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateDescriptorSetLayout func(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks, setLayout *DescriptorSetLayout) (_ret Result)

func ToCreateDescriptorSetLayout(p PFNVoidFunction) (fn FuncCreateDescriptorSetLayout) {
	return func(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks, setLayout *DescriptorSetLayout) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkDescriptorSetLayoutCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pSetLayout  *C.VkDescriptorSetLayout
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if setLayout != nil {
			c.pSetLayout = (*C.VkDescriptorSetLayout)(m.alloc(C.sizeof_VkDescriptorSetLayout))
			*c.pSetLayout = C.VkDescriptorSetLayout(*setLayout)
		} else {
			c.pSetLayout = nil
		}
		c._ret = C.callPFN_vkCreateDescriptorSetLayout(C.PFN_vkCreateDescriptorSetLayout(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pSetLayout)
		_ret = Result(c._ret)
		if setLayout != nil {
			*setLayout = DescriptorSetLayout(*c.pSetLayout)
		}
		return
	}
}

type PFNDestroyDescriptorSetLayout C.PFN_vkDestroyDescriptorSetLayout
type FuncDestroyDescriptorSetLayout func(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks)

func ToDestroyDescriptorSetLayout(p PFNVoidFunction) (fn FuncDestroyDescriptorSetLayout) {
	return func(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
		var c struct {
			device              C.VkDevice
			descriptorSetLayout C.VkDescriptorSetLayout
			pAllocator          *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorSetLayout = C.VkDescriptorSetLayout(descriptorSetLayout)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDescriptorSetLayout(C.PFN_vkDestroyDescriptorSetLayout(unsafe.Pointer(p)), c.device, c.descriptorSetLayout, c.pAllocator)
	}
}

type PFNCreateDescriptorPool C.PFN_vkCreateDescriptorPool
type DescriptorPoolCreateFlags Flags
type DescriptorPoolSize struct {
	Type            DescriptorType
	DescriptorCount uint32
}

func (g *DescriptorPoolSize) toC(c *C.VkDescriptorPoolSize) {
	c._type = C.VkDescriptorType(g.Type)
	c.descriptorCount = C.uint32_t(g.DescriptorCount)
}
func (g *DescriptorPoolSize) fromC(c *C.VkDescriptorPoolSize) {
	g.Type = DescriptorType(c._type)
	g.DescriptorCount = uint32(c.descriptorCount)
}

type DescriptorPoolCreateInfo struct {
	Next      Structure
	Flags     DescriptorPoolCreateFlags
	MaxSets   uint32
	PoolSizes []DescriptorPoolSize
}

func (g *DescriptorPoolCreateInfo) toC(c *C.VkDescriptorPoolCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDescriptorPoolCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDescriptorPoolCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDescriptorPoolCreateFlags(temp_in_VkDescriptorPoolCreateFlags)
	}
	c.maxSets = C.uint32_t(g.MaxSets)
	c.poolSizeCount = C.uint32_t(len(g.PoolSizes))
	if len(g.PoolSizes) != 0 {
		c.pPoolSizes = (*C.VkDescriptorPoolSize)(m.alloc(C.sizeof_VkDescriptorPoolSize * uint(len(g.PoolSizes))))
		slice1 := (*[1 << 31]C.VkDescriptorPoolSize)(unsafe.Pointer(c.pPoolSizes))[:len(g.PoolSizes):len(g.PoolSizes)]
		for i1, _ := range g.PoolSizes {
			g.PoolSizes[i1].toC(&slice1[i1])
		}
	} else {
		c.pPoolSizes = nil
	}
}
func (g *DescriptorPoolCreateInfo) fromC(c *C.VkDescriptorPoolCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDescriptorPoolCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDescriptorPoolCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DescriptorPoolCreateFlags(temp_in_VkDescriptorPoolCreateFlags)
	}
	g.MaxSets = uint32(c.maxSets)
	g.PoolSizes = make([]DescriptorPoolSize, int(c.poolSizeCount))
	if len(g.PoolSizes) != 0 {
		slice1 := (*[1 << 31]C.VkDescriptorPoolSize)(unsafe.Pointer(c.pPoolSizes))[:len(g.PoolSizes):len(g.PoolSizes)]
		for i1, _ := range g.PoolSizes {
			g.PoolSizes[i1].fromC(&slice1[i1])
		}
	}
}
func (s *DescriptorPoolCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
}
func (s *DescriptorPoolCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDescriptorPoolCreateInfo)(m.alloc(C.sizeof_VkDescriptorPoolCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DescriptorPoolCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDescriptorPoolCreateInfo)(p)
	s.fromC(c)
}
func (s *DescriptorPoolCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *DescriptorPoolCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type DescriptorPool C.VkDescriptorPool
type FuncCreateDescriptorPool func(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks, descriptorPool *DescriptorPool) (_ret Result)

func ToCreateDescriptorPool(p PFNVoidFunction) (fn FuncCreateDescriptorPool) {
	return func(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks, descriptorPool *DescriptorPool) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pCreateInfo     *C.VkDescriptorPoolCreateInfo
			pAllocator      *C.VkAllocationCallbacks
			pDescriptorPool *C.VkDescriptorPool
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorPoolCreateInfo)(m.alloc(C.sizeof_VkDescriptorPoolCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if descriptorPool != nil {
			c.pDescriptorPool = (*C.VkDescriptorPool)(m.alloc(C.sizeof_VkDescriptorPool))
			*c.pDescriptorPool = C.VkDescriptorPool(*descriptorPool)
		} else {
			c.pDescriptorPool = nil
		}
		c._ret = C.callPFN_vkCreateDescriptorPool(C.PFN_vkCreateDescriptorPool(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pDescriptorPool)
		_ret = Result(c._ret)
		if descriptorPool != nil {
			*descriptorPool = DescriptorPool(*c.pDescriptorPool)
		}
		return
	}
}

type PFNDestroyDescriptorPool C.PFN_vkDestroyDescriptorPool
type FuncDestroyDescriptorPool func(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks)

func ToDestroyDescriptorPool(p PFNVoidFunction) (fn FuncDestroyDescriptorPool) {
	return func(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
		var c struct {
			device         C.VkDevice
			descriptorPool C.VkDescriptorPool
			pAllocator     *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorPool = C.VkDescriptorPool(descriptorPool)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDescriptorPool(C.PFN_vkDestroyDescriptorPool(unsafe.Pointer(p)), c.device, c.descriptorPool, c.pAllocator)
	}
}

type PFNResetDescriptorPool C.PFN_vkResetDescriptorPool
type DescriptorPoolResetFlags Flags
type FuncResetDescriptorPool func(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (_ret Result)

func ToResetDescriptorPool(p PFNVoidFunction) (fn FuncResetDescriptorPool) {
	return func(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (_ret Result) {
		var c struct {
			device         C.VkDevice
			descriptorPool C.VkDescriptorPool
			flags          C.VkDescriptorPoolResetFlags
			_ret           C.VkResult
		}
		c.device = C.VkDevice(device)
		c.descriptorPool = C.VkDescriptorPool(descriptorPool)
		{
			var temp_in_VkDescriptorPoolResetFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkDescriptorPoolResetFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkDescriptorPoolResetFlags(temp_in_VkDescriptorPoolResetFlags)
		}
		c._ret = C.callPFN_vkResetDescriptorPool(C.PFN_vkResetDescriptorPool(unsafe.Pointer(p)), c.device, c.descriptorPool, c.flags)
		_ret = Result(c._ret)
		return
	}
}

type PFNAllocateDescriptorSets C.PFN_vkAllocateDescriptorSets
type DescriptorSetAllocateInfo struct {
	Next           Structure
	DescriptorPool DescriptorPool
	SetLayouts     []DescriptorSetLayout
}

func (g *DescriptorSetAllocateInfo) toC(c *C.VkDescriptorSetAllocateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.descriptorPool = C.VkDescriptorPool(g.DescriptorPool)
	c.descriptorSetCount = C.uint32_t(len(g.SetLayouts))
	if len(g.SetLayouts) != 0 {
		c.pSetLayouts = (*C.VkDescriptorSetLayout)(m.alloc(C.sizeof_VkDescriptorSetLayout * uint(len(g.SetLayouts))))
		slice1 := (*[1 << 31]C.VkDescriptorSetLayout)(unsafe.Pointer(c.pSetLayouts))[:len(g.SetLayouts):len(g.SetLayouts)]
		for i1, _ := range g.SetLayouts {
			slice1[i1] = C.VkDescriptorSetLayout(g.SetLayouts[i1])
		}
	} else {
		c.pSetLayouts = nil
	}
}
func (g *DescriptorSetAllocateInfo) fromC(c *C.VkDescriptorSetAllocateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DescriptorPool = DescriptorPool(c.descriptorPool)
	g.SetLayouts = make([]DescriptorSetLayout, int(c.descriptorSetCount))
	if len(g.SetLayouts) != 0 {
		slice1 := (*[1 << 31]C.VkDescriptorSetLayout)(unsafe.Pointer(c.pSetLayouts))[:len(g.SetLayouts):len(g.SetLayouts)]
		for i1, _ := range g.SetLayouts {
			g.SetLayouts[i1] = DescriptorSetLayout(slice1[i1])
		}
	}
}
func (s *DescriptorSetAllocateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
}
func (s *DescriptorSetAllocateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDescriptorSetAllocateInfo)(m.alloc(C.sizeof_VkDescriptorSetAllocateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DescriptorSetAllocateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDescriptorSetAllocateInfo)(p)
	s.fromC(c)
}
func (s *DescriptorSetAllocateInfo) GetNext() Structure {
	return s.Next
}
func (s *DescriptorSetAllocateInfo) SetNext(n Structure) {
	s.Next = n
}

type DescriptorSet C.VkDescriptorSet
type FuncAllocateDescriptorSets func(device Device, allocateInfo *DescriptorSetAllocateInfo, descriptorSets *DescriptorSet) (_ret Result)

func ToAllocateDescriptorSets(p PFNVoidFunction) (fn FuncAllocateDescriptorSets) {
	return func(device Device, allocateInfo *DescriptorSetAllocateInfo, descriptorSets *DescriptorSet) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pAllocateInfo   *C.VkDescriptorSetAllocateInfo
			pDescriptorSets *C.VkDescriptorSet
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if allocateInfo != nil {
			c.pAllocateInfo = (*C.VkDescriptorSetAllocateInfo)(m.alloc(C.sizeof_VkDescriptorSetAllocateInfo))
			allocateInfo.toC(c.pAllocateInfo, m)
		} else {
			c.pAllocateInfo = nil
		}
		if descriptorSets != nil {
			c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet))
			*c.pDescriptorSets = C.VkDescriptorSet(*descriptorSets)
		} else {
			c.pDescriptorSets = nil
		}
		c._ret = C.callPFN_vkAllocateDescriptorSets(C.PFN_vkAllocateDescriptorSets(unsafe.Pointer(p)), c.device, c.pAllocateInfo, c.pDescriptorSets)
		_ret = Result(c._ret)
		if descriptorSets != nil {
			*descriptorSets = DescriptorSet(*c.pDescriptorSets)
		}
		return
	}
}

type PFNFreeDescriptorSets C.PFN_vkFreeDescriptorSets
type FuncFreeDescriptorSets func(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (_ret Result)

func ToFreeDescriptorSets(p PFNVoidFunction) (fn FuncFreeDescriptorSets) {
	return func(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (_ret Result) {
		var c struct {
			device             C.VkDevice
			descriptorPool     C.VkDescriptorPool
			descriptorSetCount C.uint32_t
			pDescriptorSets    *C.VkDescriptorSet
			_ret               C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorPool = C.VkDescriptorPool(descriptorPool)
		c.descriptorSetCount = C.uint32_t(len(descriptorSets))
		if len(descriptorSets) != 0 {
			c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet * uint(len(descriptorSets))))
			slice1 := (*[1 << 31]C.VkDescriptorSet)(unsafe.Pointer(c.pDescriptorSets))[:len(descriptorSets):len(descriptorSets)]
			for i1, _ := range descriptorSets {
				slice1[i1] = C.VkDescriptorSet(descriptorSets[i1])
			}
		} else {
			c.pDescriptorSets = nil
		}
		c._ret = C.callPFN_vkFreeDescriptorSets(C.PFN_vkFreeDescriptorSets(unsafe.Pointer(p)), c.device, c.descriptorPool, c.descriptorSetCount, c.pDescriptorSets)
		_ret = Result(c._ret)
		return
	}
}

type PFNUpdateDescriptorSets C.PFN_vkUpdateDescriptorSets
type DescriptorImageInfo struct {
	Sampler     Sampler
	ImageView   ImageView
	ImageLayout ImageLayout
}

func (g *DescriptorImageInfo) toC(c *C.VkDescriptorImageInfo) {
	c.sampler = C.VkSampler(g.Sampler)
	c.imageView = C.VkImageView(g.ImageView)
	c.imageLayout = C.VkImageLayout(g.ImageLayout)
}
func (g *DescriptorImageInfo) fromC(c *C.VkDescriptorImageInfo) {
	g.Sampler = Sampler(c.sampler)
	g.ImageView = ImageView(c.imageView)
	g.ImageLayout = ImageLayout(c.imageLayout)
}

type DescriptorBufferInfo struct {
	Buffer Buffer
	Offset DeviceSize
	Range  DeviceSize
}

func (g *DescriptorBufferInfo) toC(c *C.VkDescriptorBufferInfo) {
	c.buffer = C.VkBuffer(g.Buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Range))
		c._range = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *DescriptorBufferInfo) fromC(c *C.VkDescriptorBufferInfo) {
	g.Buffer = Buffer(c.buffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c._range))
		g.Range = DeviceSize(temp_in_VkDeviceSize)
	}
}

type WriteDescriptorSet struct {
	Next            Structure
	DstSet          DescriptorSet
	DstBinding      uint32
	DstArrayElement uint32
	DescriptorCount uint32
	DescriptorType  DescriptorType
	ImageInfo       *DescriptorImageInfo
	BufferInfo      *DescriptorBufferInfo
	TexelBufferView *BufferView
}

func (g *WriteDescriptorSet) toC(c *C.VkWriteDescriptorSet, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.dstSet = C.VkDescriptorSet(g.DstSet)
	c.dstBinding = C.uint32_t(g.DstBinding)
	c.dstArrayElement = C.uint32_t(g.DstArrayElement)
	c.descriptorCount = C.uint32_t(g.DescriptorCount)
	c.descriptorType = C.VkDescriptorType(g.DescriptorType)
	if g.ImageInfo != nil {
		c.pImageInfo = (*C.VkDescriptorImageInfo)(m.alloc(C.sizeof_VkDescriptorImageInfo))
		g.ImageInfo.toC(c.pImageInfo)
	} else {
		c.pImageInfo = nil
	}
	if g.BufferInfo != nil {
		c.pBufferInfo = (*C.VkDescriptorBufferInfo)(m.alloc(C.sizeof_VkDescriptorBufferInfo))
		g.BufferInfo.toC(c.pBufferInfo)
	} else {
		c.pBufferInfo = nil
	}
	if g.TexelBufferView != nil {
		c.pTexelBufferView = (*C.VkBufferView)(m.alloc(C.sizeof_VkBufferView))
		*c.pTexelBufferView = C.VkBufferView(*g.TexelBufferView)
	} else {
		c.pTexelBufferView = nil
	}
}
func (g *WriteDescriptorSet) fromC(c *C.VkWriteDescriptorSet) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DstSet = DescriptorSet(c.dstSet)
	g.DstBinding = uint32(c.dstBinding)
	g.DstArrayElement = uint32(c.dstArrayElement)
	g.DescriptorCount = uint32(c.descriptorCount)
	g.DescriptorType = DescriptorType(c.descriptorType)
	if g.ImageInfo != nil {
		g.ImageInfo.fromC(c.pImageInfo)
	}
	if g.BufferInfo != nil {
		g.BufferInfo.fromC(c.pBufferInfo)
	}
	if g.TexelBufferView != nil {
		*g.TexelBufferView = BufferView(*c.pTexelBufferView)
	}
}
func (s *WriteDescriptorSet) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
}
func (s *WriteDescriptorSet) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkWriteDescriptorSet)(m.alloc(C.sizeof_VkWriteDescriptorSet))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *WriteDescriptorSet) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkWriteDescriptorSet)(p)
	s.fromC(c)
}
func (s *WriteDescriptorSet) GetNext() Structure {
	return s.Next
}
func (s *WriteDescriptorSet) SetNext(n Structure) {
	s.Next = n
}

type CopyDescriptorSet struct {
	Next            Structure
	SrcSet          DescriptorSet
	SrcBinding      uint32
	SrcArrayElement uint32
	DstSet          DescriptorSet
	DstBinding      uint32
	DstArrayElement uint32
	DescriptorCount uint32
}

func (g *CopyDescriptorSet) toC(c *C.VkCopyDescriptorSet, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.srcSet = C.VkDescriptorSet(g.SrcSet)
	c.srcBinding = C.uint32_t(g.SrcBinding)
	c.srcArrayElement = C.uint32_t(g.SrcArrayElement)
	c.dstSet = C.VkDescriptorSet(g.DstSet)
	c.dstBinding = C.uint32_t(g.DstBinding)
	c.dstArrayElement = C.uint32_t(g.DstArrayElement)
	c.descriptorCount = C.uint32_t(g.DescriptorCount)
}
func (g *CopyDescriptorSet) fromC(c *C.VkCopyDescriptorSet) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.SrcSet = DescriptorSet(c.srcSet)
	g.SrcBinding = uint32(c.srcBinding)
	g.SrcArrayElement = uint32(c.srcArrayElement)
	g.DstSet = DescriptorSet(c.dstSet)
	g.DstBinding = uint32(c.dstBinding)
	g.DstArrayElement = uint32(c.dstArrayElement)
	g.DescriptorCount = uint32(c.descriptorCount)
}
func (s *CopyDescriptorSet) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
}
func (s *CopyDescriptorSet) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCopyDescriptorSet)(m.alloc(C.sizeof_VkCopyDescriptorSet))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CopyDescriptorSet) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCopyDescriptorSet)(p)
	s.fromC(c)
}
func (s *CopyDescriptorSet) GetNext() Structure {
	return s.Next
}
func (s *CopyDescriptorSet) SetNext(n Structure) {
	s.Next = n
}

type FuncUpdateDescriptorSets func(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet)

func ToUpdateDescriptorSets(p PFNVoidFunction) (fn FuncUpdateDescriptorSets) {
	return func(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
		var c struct {
			device               C.VkDevice
			descriptorWriteCount C.uint32_t
			pDescriptorWrites    *C.VkWriteDescriptorSet
			descriptorCopyCount  C.uint32_t
			pDescriptorCopies    *C.VkCopyDescriptorSet
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorWriteCount = C.uint32_t(len(descriptorWrites))
		if len(descriptorWrites) != 0 {
			c.pDescriptorWrites = (*C.VkWriteDescriptorSet)(m.alloc(C.sizeof_VkWriteDescriptorSet * uint(len(descriptorWrites))))
			slice1 := (*[1 << 31]C.VkWriteDescriptorSet)(unsafe.Pointer(c.pDescriptorWrites))[:len(descriptorWrites):len(descriptorWrites)]
			for i1, _ := range descriptorWrites {
				descriptorWrites[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pDescriptorWrites = nil
		}
		c.descriptorCopyCount = C.uint32_t(len(descriptorCopies))
		if len(descriptorCopies) != 0 {
			c.pDescriptorCopies = (*C.VkCopyDescriptorSet)(m.alloc(C.sizeof_VkCopyDescriptorSet * uint(len(descriptorCopies))))
			slice1 := (*[1 << 31]C.VkCopyDescriptorSet)(unsafe.Pointer(c.pDescriptorCopies))[:len(descriptorCopies):len(descriptorCopies)]
			for i1, _ := range descriptorCopies {
				descriptorCopies[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pDescriptorCopies = nil
		}
		C.callPFN_vkUpdateDescriptorSets(C.PFN_vkUpdateDescriptorSets(unsafe.Pointer(p)), c.device, c.descriptorWriteCount, c.pDescriptorWrites, c.descriptorCopyCount, c.pDescriptorCopies)
	}
}

type PFNCreateFramebuffer C.PFN_vkCreateFramebuffer
type FramebufferCreateFlags Flags
type FramebufferCreateInfo struct {
	Next        Structure
	Flags       FramebufferCreateFlags
	RenderPass  RenderPass
	Attachments []ImageView
	Width       uint32
	Height      uint32
	Layers      uint32
}

func (g *FramebufferCreateInfo) toC(c *C.VkFramebufferCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkFramebufferCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkFramebufferCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkFramebufferCreateFlags(temp_in_VkFramebufferCreateFlags)
	}
	c.renderPass = C.VkRenderPass(g.RenderPass)
	c.attachmentCount = C.uint32_t(len(g.Attachments))
	if len(g.Attachments) != 0 {
		c.pAttachments = (*C.VkImageView)(m.alloc(C.sizeof_VkImageView * uint(len(g.Attachments))))
		slice1 := (*[1 << 31]C.VkImageView)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			slice1[i1] = C.VkImageView(g.Attachments[i1])
		}
	} else {
		c.pAttachments = nil
	}
	c.width = C.uint32_t(g.Width)
	c.height = C.uint32_t(g.Height)
	c.layers = C.uint32_t(g.Layers)
}
func (g *FramebufferCreateInfo) fromC(c *C.VkFramebufferCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkFramebufferCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkFramebufferCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = FramebufferCreateFlags(temp_in_VkFramebufferCreateFlags)
	}
	g.RenderPass = RenderPass(c.renderPass)
	g.Attachments = make([]ImageView, int(c.attachmentCount))
	if len(g.Attachments) != 0 {
		slice1 := (*[1 << 31]C.VkImageView)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1] = ImageView(slice1[i1])
		}
	}
	g.Width = uint32(c.width)
	g.Height = uint32(c.height)
	g.Layers = uint32(c.layers)
}
func (s *FramebufferCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
}
func (s *FramebufferCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkFramebufferCreateInfo)(m.alloc(C.sizeof_VkFramebufferCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *FramebufferCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkFramebufferCreateInfo)(p)
	s.fromC(c)
}
func (s *FramebufferCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *FramebufferCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type Framebuffer C.VkFramebuffer
type FuncCreateFramebuffer func(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks, framebuffer *Framebuffer) (_ret Result)

func ToCreateFramebuffer(p PFNVoidFunction) (fn FuncCreateFramebuffer) {
	return func(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks, framebuffer *Framebuffer) (_ret Result) {
		var c struct {
			device       C.VkDevice
			pCreateInfo  *C.VkFramebufferCreateInfo
			pAllocator   *C.VkAllocationCallbacks
			pFramebuffer *C.VkFramebuffer
			_ret         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkFramebufferCreateInfo)(m.alloc(C.sizeof_VkFramebufferCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if framebuffer != nil {
			c.pFramebuffer = (*C.VkFramebuffer)(m.alloc(C.sizeof_VkFramebuffer))
			*c.pFramebuffer = C.VkFramebuffer(*framebuffer)
		} else {
			c.pFramebuffer = nil
		}
		c._ret = C.callPFN_vkCreateFramebuffer(C.PFN_vkCreateFramebuffer(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pFramebuffer)
		_ret = Result(c._ret)
		if framebuffer != nil {
			*framebuffer = Framebuffer(*c.pFramebuffer)
		}
		return
	}
}

type PFNDestroyFramebuffer C.PFN_vkDestroyFramebuffer
type FuncDestroyFramebuffer func(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks)

func ToDestroyFramebuffer(p PFNVoidFunction) (fn FuncDestroyFramebuffer) {
	return func(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
		var c struct {
			device      C.VkDevice
			framebuffer C.VkFramebuffer
			pAllocator  *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.framebuffer = C.VkFramebuffer(framebuffer)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyFramebuffer(C.PFN_vkDestroyFramebuffer(unsafe.Pointer(p)), c.device, c.framebuffer, c.pAllocator)
	}
}

type PFNCreateRenderPass C.PFN_vkCreateRenderPass
type RenderPassCreateFlags Flags
type AttachmentDescriptionFlags Flags
type AttachmentDescription struct {
	Flags          AttachmentDescriptionFlags
	Format         Format
	Samples        SampleCountFlagBits
	LoadOp         AttachmentLoadOp
	StoreOp        AttachmentStoreOp
	StencilLoadOp  AttachmentLoadOp
	StencilStoreOp AttachmentStoreOp
	InitialLayout  ImageLayout
	FinalLayout    ImageLayout
}

func (g *AttachmentDescription) toC(c *C.VkAttachmentDescription) {
	{
		var temp_in_VkAttachmentDescriptionFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkAttachmentDescriptionFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkAttachmentDescriptionFlags(temp_in_VkAttachmentDescriptionFlags)
	}
	c.format = C.VkFormat(g.Format)
	c.samples = C.VkSampleCountFlagBits(g.Samples)
	c.loadOp = C.VkAttachmentLoadOp(g.LoadOp)
	c.storeOp = C.VkAttachmentStoreOp(g.StoreOp)
	c.stencilLoadOp = C.VkAttachmentLoadOp(g.StencilLoadOp)
	c.stencilStoreOp = C.VkAttachmentStoreOp(g.StencilStoreOp)
	c.initialLayout = C.VkImageLayout(g.InitialLayout)
	c.finalLayout = C.VkImageLayout(g.FinalLayout)
}
func (g *AttachmentDescription) fromC(c *C.VkAttachmentDescription) {
	{
		var temp_in_VkAttachmentDescriptionFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkAttachmentDescriptionFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = AttachmentDescriptionFlags(temp_in_VkAttachmentDescriptionFlags)
	}
	g.Format = Format(c.format)
	g.Samples = SampleCountFlagBits(c.samples)
	g.LoadOp = AttachmentLoadOp(c.loadOp)
	g.StoreOp = AttachmentStoreOp(c.storeOp)
	g.StencilLoadOp = AttachmentLoadOp(c.stencilLoadOp)
	g.StencilStoreOp = AttachmentStoreOp(c.stencilStoreOp)
	g.InitialLayout = ImageLayout(c.initialLayout)
	g.FinalLayout = ImageLayout(c.finalLayout)
}

type SubpassDescriptionFlags Flags
type AttachmentReference struct {
	Attachment uint32
	Layout     ImageLayout
}

func (g *AttachmentReference) toC(c *C.VkAttachmentReference) {
	c.attachment = C.uint32_t(g.Attachment)
	c.layout = C.VkImageLayout(g.Layout)
}
func (g *AttachmentReference) fromC(c *C.VkAttachmentReference) {
	g.Attachment = uint32(c.attachment)
	g.Layout = ImageLayout(c.layout)
}

type SubpassDescription struct {
	Flags                  SubpassDescriptionFlags
	PipelineBindPoint      PipelineBindPoint
	InputAttachments       []AttachmentReference
	ColorAttachments       []AttachmentReference
	ResolveAttachments     []AttachmentReference
	DepthStencilAttachment *AttachmentReference
	PreserveAttachments    []uint32
}

func (g *SubpassDescription) toC(c *C.VkSubpassDescription, m *cmemory) {
	{
		var temp_in_VkSubpassDescriptionFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSubpassDescriptionFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSubpassDescriptionFlags(temp_in_VkSubpassDescriptionFlags)
	}
	c.pipelineBindPoint = C.VkPipelineBindPoint(g.PipelineBindPoint)
	c.inputAttachmentCount = C.uint32_t(len(g.InputAttachments))
	if len(g.InputAttachments) != 0 {
		c.pInputAttachments = (*C.VkAttachmentReference)(m.alloc(C.sizeof_VkAttachmentReference * uint(len(g.InputAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pInputAttachments))[:len(g.InputAttachments):len(g.InputAttachments)]
		for i1, _ := range g.InputAttachments {
			g.InputAttachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pInputAttachments = nil
	}
	c.colorAttachmentCount = C.uint32_t(len(g.ColorAttachments))
	if len(g.ColorAttachments) != 0 {
		c.pColorAttachments = (*C.VkAttachmentReference)(m.alloc(C.sizeof_VkAttachmentReference * uint(len(g.ColorAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pColorAttachments))[:len(g.ColorAttachments):len(g.ColorAttachments)]
		for i1, _ := range g.ColorAttachments {
			g.ColorAttachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pColorAttachments = nil
	}
	if len(g.ResolveAttachments) != 0 {
		c.pResolveAttachments = (*C.VkAttachmentReference)(m.alloc(C.sizeof_VkAttachmentReference * uint(len(g.ResolveAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pResolveAttachments))[:len(g.ResolveAttachments):len(g.ResolveAttachments)]
		for i1, _ := range g.ResolveAttachments {
			g.ResolveAttachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pResolveAttachments = nil
	}
	if g.DepthStencilAttachment != nil {
		c.pDepthStencilAttachment = (*C.VkAttachmentReference)(m.alloc(C.sizeof_VkAttachmentReference))
		g.DepthStencilAttachment.toC(c.pDepthStencilAttachment)
	} else {
		c.pDepthStencilAttachment = nil
	}
	c.preserveAttachmentCount = C.uint32_t(len(g.PreserveAttachments))
	if len(g.PreserveAttachments) != 0 {
		c.pPreserveAttachments = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.PreserveAttachments))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pPreserveAttachments))[:len(g.PreserveAttachments):len(g.PreserveAttachments)]
		for i1, _ := range g.PreserveAttachments {
			slice1[i1] = C.uint32_t(g.PreserveAttachments[i1])
		}
	} else {
		c.pPreserveAttachments = nil
	}
}
func (g *SubpassDescription) fromC(c *C.VkSubpassDescription) {
	{
		var temp_in_VkSubpassDescriptionFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSubpassDescriptionFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SubpassDescriptionFlags(temp_in_VkSubpassDescriptionFlags)
	}
	g.PipelineBindPoint = PipelineBindPoint(c.pipelineBindPoint)
	g.InputAttachments = make([]AttachmentReference, int(c.inputAttachmentCount))
	if len(g.InputAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pInputAttachments))[:len(g.InputAttachments):len(g.InputAttachments)]
		for i1, _ := range g.InputAttachments {
			g.InputAttachments[i1].fromC(&slice1[i1])
		}
	}
	g.ColorAttachments = make([]AttachmentReference, int(c.colorAttachmentCount))
	if len(g.ColorAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pColorAttachments))[:len(g.ColorAttachments):len(g.ColorAttachments)]
		for i1, _ := range g.ColorAttachments {
			g.ColorAttachments[i1].fromC(&slice1[i1])
		}
	}
	if len(g.ResolveAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference)(unsafe.Pointer(c.pResolveAttachments))[:len(g.ResolveAttachments):len(g.ResolveAttachments)]
		for i1, _ := range g.ResolveAttachments {
			g.ResolveAttachments[i1].fromC(&slice1[i1])
		}
	}
	if g.DepthStencilAttachment != nil {
		g.DepthStencilAttachment.fromC(c.pDepthStencilAttachment)
	}
	g.PreserveAttachments = make([]uint32, int(c.preserveAttachmentCount))
	if len(g.PreserveAttachments) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pPreserveAttachments))[:len(g.PreserveAttachments):len(g.PreserveAttachments)]
		for i1, _ := range g.PreserveAttachments {
			g.PreserveAttachments[i1] = uint32(slice1[i1])
		}
	}
}

type AccessFlags Flags
type DependencyFlags Flags
type SubpassDependency struct {
	SrcSubpass      uint32
	DstSubpass      uint32
	SrcStageMask    PipelineStageFlags
	DstStageMask    PipelineStageFlags
	SrcAccessMask   AccessFlags
	DstAccessMask   AccessFlags
	DependencyFlags DependencyFlags
}

func (g *SubpassDependency) toC(c *C.VkSubpassDependency) {
	c.srcSubpass = C.uint32_t(g.SrcSubpass)
	c.dstSubpass = C.uint32_t(g.DstSubpass)
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkDependencyFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DependencyFlags)))
			temp_in_VkDependencyFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dependencyFlags = C.VkDependencyFlags(temp_in_VkDependencyFlags)
	}
}
func (g *SubpassDependency) fromC(c *C.VkSubpassDependency) {
	g.SrcSubpass = uint32(c.srcSubpass)
	g.DstSubpass = uint32(c.dstSubpass)
	{
		var temp_in_VkPipelineStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcStageMask)))
			temp_in_VkPipelineStageFlags = Flags(temp_in_VkFlags)
		}
		g.SrcStageMask = PipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstStageMask)))
			temp_in_VkPipelineStageFlags = Flags(temp_in_VkFlags)
		}
		g.DstStageMask = PipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.SrcAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.DstAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkDependencyFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dependencyFlags)))
			temp_in_VkDependencyFlags = Flags(temp_in_VkFlags)
		}
		g.DependencyFlags = DependencyFlags(temp_in_VkDependencyFlags)
	}
}

type RenderPassCreateInfo struct {
	Next         Structure
	Flags        RenderPassCreateFlags
	Attachments  []AttachmentDescription
	Subpasses    []SubpassDescription
	Dependencies []SubpassDependency
}

func (g *RenderPassCreateInfo) toC(c *C.VkRenderPassCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkRenderPassCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkRenderPassCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkRenderPassCreateFlags(temp_in_VkRenderPassCreateFlags)
	}
	c.attachmentCount = C.uint32_t(len(g.Attachments))
	if len(g.Attachments) != 0 {
		c.pAttachments = (*C.VkAttachmentDescription)(m.alloc(C.sizeof_VkAttachmentDescription * uint(len(g.Attachments))))
		slice1 := (*[1 << 31]C.VkAttachmentDescription)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pAttachments = nil
	}
	c.subpassCount = C.uint32_t(len(g.Subpasses))
	if len(g.Subpasses) != 0 {
		c.pSubpasses = (*C.VkSubpassDescription)(m.alloc(C.sizeof_VkSubpassDescription * uint(len(g.Subpasses))))
		slice1 := (*[1 << 31]C.VkSubpassDescription)(unsafe.Pointer(c.pSubpasses))[:len(g.Subpasses):len(g.Subpasses)]
		for i1, _ := range g.Subpasses {
			g.Subpasses[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pSubpasses = nil
	}
	c.dependencyCount = C.uint32_t(len(g.Dependencies))
	if len(g.Dependencies) != 0 {
		c.pDependencies = (*C.VkSubpassDependency)(m.alloc(C.sizeof_VkSubpassDependency * uint(len(g.Dependencies))))
		slice1 := (*[1 << 31]C.VkSubpassDependency)(unsafe.Pointer(c.pDependencies))[:len(g.Dependencies):len(g.Dependencies)]
		for i1, _ := range g.Dependencies {
			g.Dependencies[i1].toC(&slice1[i1])
		}
	} else {
		c.pDependencies = nil
	}
}
func (g *RenderPassCreateInfo) fromC(c *C.VkRenderPassCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkRenderPassCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkRenderPassCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = RenderPassCreateFlags(temp_in_VkRenderPassCreateFlags)
	}
	g.Attachments = make([]AttachmentDescription, int(c.attachmentCount))
	if len(g.Attachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentDescription)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].fromC(&slice1[i1])
		}
	}
	g.Subpasses = make([]SubpassDescription, int(c.subpassCount))
	if len(g.Subpasses) != 0 {
		slice1 := (*[1 << 31]C.VkSubpassDescription)(unsafe.Pointer(c.pSubpasses))[:len(g.Subpasses):len(g.Subpasses)]
		for i1, _ := range g.Subpasses {
			g.Subpasses[i1].fromC(&slice1[i1])
		}
	}
	g.Dependencies = make([]SubpassDependency, int(c.dependencyCount))
	if len(g.Dependencies) != 0 {
		slice1 := (*[1 << 31]C.VkSubpassDependency)(unsafe.Pointer(c.pDependencies))[:len(g.Dependencies):len(g.Dependencies)]
		for i1, _ := range g.Dependencies {
			g.Dependencies[i1].fromC(&slice1[i1])
		}
	}
}
func (s *RenderPassCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
}
func (s *RenderPassCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkRenderPassCreateInfo)(m.alloc(C.sizeof_VkRenderPassCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *RenderPassCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkRenderPassCreateInfo)(p)
	s.fromC(c)
}
func (s *RenderPassCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *RenderPassCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateRenderPass func(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks, renderPass *RenderPass) (_ret Result)

func ToCreateRenderPass(p PFNVoidFunction) (fn FuncCreateRenderPass) {
	return func(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks, renderPass *RenderPass) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkRenderPassCreateInfo
			pAllocator  *C.VkAllocationCallbacks
			pRenderPass *C.VkRenderPass
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkRenderPassCreateInfo)(m.alloc(C.sizeof_VkRenderPassCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if renderPass != nil {
			c.pRenderPass = (*C.VkRenderPass)(m.alloc(C.sizeof_VkRenderPass))
			*c.pRenderPass = C.VkRenderPass(*renderPass)
		} else {
			c.pRenderPass = nil
		}
		c._ret = C.callPFN_vkCreateRenderPass(C.PFN_vkCreateRenderPass(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pRenderPass)
		_ret = Result(c._ret)
		if renderPass != nil {
			*renderPass = RenderPass(*c.pRenderPass)
		}
		return
	}
}

type PFNDestroyRenderPass C.PFN_vkDestroyRenderPass
type FuncDestroyRenderPass func(device Device, renderPass RenderPass, allocator *AllocationCallbacks)

func ToDestroyRenderPass(p PFNVoidFunction) (fn FuncDestroyRenderPass) {
	return func(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			renderPass C.VkRenderPass
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.renderPass = C.VkRenderPass(renderPass)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyRenderPass(C.PFN_vkDestroyRenderPass(unsafe.Pointer(p)), c.device, c.renderPass, c.pAllocator)
	}
}

type PFNGetRenderAreaGranularity C.PFN_vkGetRenderAreaGranularity
type FuncGetRenderAreaGranularity func(device Device, renderPass RenderPass, granularity *Extent2D)

func ToGetRenderAreaGranularity(p PFNVoidFunction) (fn FuncGetRenderAreaGranularity) {
	return func(device Device, renderPass RenderPass, granularity *Extent2D) {
		var c struct {
			device       C.VkDevice
			renderPass   C.VkRenderPass
			pGranularity *C.VkExtent2D
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.renderPass = C.VkRenderPass(renderPass)
		if granularity != nil {
			c.pGranularity = (*C.VkExtent2D)(m.alloc(C.sizeof_VkExtent2D))
			granularity.toC(c.pGranularity)
		} else {
			c.pGranularity = nil
		}
		C.callPFN_vkGetRenderAreaGranularity(C.PFN_vkGetRenderAreaGranularity(unsafe.Pointer(p)), c.device, c.renderPass, c.pGranularity)
		if granularity != nil {
			granularity.fromC(c.pGranularity)
		}
	}
}

type PFNCreateCommandPool C.PFN_vkCreateCommandPool
type CommandPoolCreateFlags Flags
type CommandPoolCreateInfo struct {
	Next             Structure
	Flags            CommandPoolCreateFlags
	QueueFamilyIndex uint32
}

func (g *CommandPoolCreateInfo) toC(c *C.VkCommandPoolCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkCommandPoolCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkCommandPoolCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkCommandPoolCreateFlags(temp_in_VkCommandPoolCreateFlags)
	}
	c.queueFamilyIndex = C.uint32_t(g.QueueFamilyIndex)
}
func (g *CommandPoolCreateInfo) fromC(c *C.VkCommandPoolCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkCommandPoolCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkCommandPoolCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = CommandPoolCreateFlags(temp_in_VkCommandPoolCreateFlags)
	}
	g.QueueFamilyIndex = uint32(c.queueFamilyIndex)
}
func (s *CommandPoolCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
}
func (s *CommandPoolCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCommandPoolCreateInfo)(m.alloc(C.sizeof_VkCommandPoolCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CommandPoolCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCommandPoolCreateInfo)(p)
	s.fromC(c)
}
func (s *CommandPoolCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *CommandPoolCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type CommandPool C.VkCommandPool
type FuncCreateCommandPool func(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks, commandPool *CommandPool) (_ret Result)

func ToCreateCommandPool(p PFNVoidFunction) (fn FuncCreateCommandPool) {
	return func(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks, commandPool *CommandPool) (_ret Result) {
		var c struct {
			device       C.VkDevice
			pCreateInfo  *C.VkCommandPoolCreateInfo
			pAllocator   *C.VkAllocationCallbacks
			pCommandPool *C.VkCommandPool
			_ret         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkCommandPoolCreateInfo)(m.alloc(C.sizeof_VkCommandPoolCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if commandPool != nil {
			c.pCommandPool = (*C.VkCommandPool)(m.alloc(C.sizeof_VkCommandPool))
			*c.pCommandPool = C.VkCommandPool(*commandPool)
		} else {
			c.pCommandPool = nil
		}
		c._ret = C.callPFN_vkCreateCommandPool(C.PFN_vkCreateCommandPool(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pCommandPool)
		_ret = Result(c._ret)
		if commandPool != nil {
			*commandPool = CommandPool(*c.pCommandPool)
		}
		return
	}
}

type PFNDestroyCommandPool C.PFN_vkDestroyCommandPool
type FuncDestroyCommandPool func(device Device, commandPool CommandPool, allocator *AllocationCallbacks)

func ToDestroyCommandPool(p PFNVoidFunction) (fn FuncDestroyCommandPool) {
	return func(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
		var c struct {
			device      C.VkDevice
			commandPool C.VkCommandPool
			pAllocator  *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.commandPool = C.VkCommandPool(commandPool)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyCommandPool(C.PFN_vkDestroyCommandPool(unsafe.Pointer(p)), c.device, c.commandPool, c.pAllocator)
	}
}

type PFNResetCommandPool C.PFN_vkResetCommandPool
type CommandPoolResetFlags Flags
type FuncResetCommandPool func(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (_ret Result)

func ToResetCommandPool(p PFNVoidFunction) (fn FuncResetCommandPool) {
	return func(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (_ret Result) {
		var c struct {
			device      C.VkDevice
			commandPool C.VkCommandPool
			flags       C.VkCommandPoolResetFlags
			_ret        C.VkResult
		}
		c.device = C.VkDevice(device)
		c.commandPool = C.VkCommandPool(commandPool)
		{
			var temp_in_VkCommandPoolResetFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkCommandPoolResetFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkCommandPoolResetFlags(temp_in_VkCommandPoolResetFlags)
		}
		c._ret = C.callPFN_vkResetCommandPool(C.PFN_vkResetCommandPool(unsafe.Pointer(p)), c.device, c.commandPool, c.flags)
		_ret = Result(c._ret)
		return
	}
}

type PFNAllocateCommandBuffers C.PFN_vkAllocateCommandBuffers
type CommandBufferAllocateInfo struct {
	Next               Structure
	CommandPool        CommandPool
	Level              CommandBufferLevel
	CommandBufferCount uint32
}

func (g *CommandBufferAllocateInfo) toC(c *C.VkCommandBufferAllocateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.commandPool = C.VkCommandPool(g.CommandPool)
	c.level = C.VkCommandBufferLevel(g.Level)
	c.commandBufferCount = C.uint32_t(g.CommandBufferCount)
}
func (g *CommandBufferAllocateInfo) fromC(c *C.VkCommandBufferAllocateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.CommandPool = CommandPool(c.commandPool)
	g.Level = CommandBufferLevel(c.level)
	g.CommandBufferCount = uint32(c.commandBufferCount)
}
func (s *CommandBufferAllocateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
}
func (s *CommandBufferAllocateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCommandBufferAllocateInfo)(m.alloc(C.sizeof_VkCommandBufferAllocateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CommandBufferAllocateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCommandBufferAllocateInfo)(p)
	s.fromC(c)
}
func (s *CommandBufferAllocateInfo) GetNext() Structure {
	return s.Next
}
func (s *CommandBufferAllocateInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncAllocateCommandBuffers func(device Device, allocateInfo *CommandBufferAllocateInfo, commandBuffers *CommandBuffer) (_ret Result)

func ToAllocateCommandBuffers(p PFNVoidFunction) (fn FuncAllocateCommandBuffers) {
	return func(device Device, allocateInfo *CommandBufferAllocateInfo, commandBuffers *CommandBuffer) (_ret Result) {
		var c struct {
			device          C.VkDevice
			pAllocateInfo   *C.VkCommandBufferAllocateInfo
			pCommandBuffers *C.VkCommandBuffer
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if allocateInfo != nil {
			c.pAllocateInfo = (*C.VkCommandBufferAllocateInfo)(m.alloc(C.sizeof_VkCommandBufferAllocateInfo))
			allocateInfo.toC(c.pAllocateInfo, m)
		} else {
			c.pAllocateInfo = nil
		}
		if commandBuffers != nil {
			c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer))
			*c.pCommandBuffers = C.VkCommandBuffer(*commandBuffers)
		} else {
			c.pCommandBuffers = nil
		}
		c._ret = C.callPFN_vkAllocateCommandBuffers(C.PFN_vkAllocateCommandBuffers(unsafe.Pointer(p)), c.device, c.pAllocateInfo, c.pCommandBuffers)
		_ret = Result(c._ret)
		if commandBuffers != nil {
			*commandBuffers = CommandBuffer(*c.pCommandBuffers)
		}
		return
	}
}

type PFNFreeCommandBuffers C.PFN_vkFreeCommandBuffers
type FuncFreeCommandBuffers func(device Device, commandPool CommandPool, commandBuffers []CommandBuffer)

func ToFreeCommandBuffers(p PFNVoidFunction) (fn FuncFreeCommandBuffers) {
	return func(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
		var c struct {
			device             C.VkDevice
			commandPool        C.VkCommandPool
			commandBufferCount C.uint32_t
			pCommandBuffers    *C.VkCommandBuffer
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.commandPool = C.VkCommandPool(commandPool)
		c.commandBufferCount = C.uint32_t(len(commandBuffers))
		if len(commandBuffers) != 0 {
			c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer * uint(len(commandBuffers))))
			slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(commandBuffers):len(commandBuffers)]
			for i1, _ := range commandBuffers {
				slice1[i1] = C.VkCommandBuffer(commandBuffers[i1])
			}
		} else {
			c.pCommandBuffers = nil
		}
		C.callPFN_vkFreeCommandBuffers(C.PFN_vkFreeCommandBuffers(unsafe.Pointer(p)), c.device, c.commandPool, c.commandBufferCount, c.pCommandBuffers)
	}
}

type PFNBeginCommandBuffer C.PFN_vkBeginCommandBuffer
type CommandBufferUsageFlags Flags
type QueryControlFlags Flags
type CommandBufferInheritanceInfo struct {
	Next                 Structure
	RenderPass           RenderPass
	Subpass              uint32
	Framebuffer          Framebuffer
	OcclusionQueryEnable bool
	QueryFlags           QueryControlFlags
	PipelineStatistics   QueryPipelineStatisticFlags
}

func (g *CommandBufferInheritanceInfo) toC(c *C.VkCommandBufferInheritanceInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.renderPass = C.VkRenderPass(g.RenderPass)
	c.subpass = C.uint32_t(g.Subpass)
	c.framebuffer = C.VkFramebuffer(g.Framebuffer)
	if g.OcclusionQueryEnable {
		c.occlusionQueryEnable = 1
	} else {
		c.occlusionQueryEnable = 0
	}
	{
		var temp_in_VkQueryControlFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.QueryFlags)))
			temp_in_VkQueryControlFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.queryFlags = C.VkQueryControlFlags(temp_in_VkQueryControlFlags)
	}
	{
		var temp_in_VkQueryPipelineStatisticFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.PipelineStatistics)))
			temp_in_VkQueryPipelineStatisticFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.pipelineStatistics = C.VkQueryPipelineStatisticFlags(temp_in_VkQueryPipelineStatisticFlags)
	}
}
func (g *CommandBufferInheritanceInfo) fromC(c *C.VkCommandBufferInheritanceInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.RenderPass = RenderPass(c.renderPass)
	g.Subpass = uint32(c.subpass)
	g.Framebuffer = Framebuffer(c.framebuffer)
	g.OcclusionQueryEnable = c.occlusionQueryEnable != 0
	{
		var temp_in_VkQueryControlFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.queryFlags)))
			temp_in_VkQueryControlFlags = Flags(temp_in_VkFlags)
		}
		g.QueryFlags = QueryControlFlags(temp_in_VkQueryControlFlags)
	}
	{
		var temp_in_VkQueryPipelineStatisticFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.pipelineStatistics)))
			temp_in_VkQueryPipelineStatisticFlags = Flags(temp_in_VkFlags)
		}
		g.PipelineStatistics = QueryPipelineStatisticFlags(temp_in_VkQueryPipelineStatisticFlags)
	}
}
func (s *CommandBufferInheritanceInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
}
func (s *CommandBufferInheritanceInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCommandBufferInheritanceInfo)(m.alloc(C.sizeof_VkCommandBufferInheritanceInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CommandBufferInheritanceInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCommandBufferInheritanceInfo)(p)
	s.fromC(c)
}
func (s *CommandBufferInheritanceInfo) GetNext() Structure {
	return s.Next
}
func (s *CommandBufferInheritanceInfo) SetNext(n Structure) {
	s.Next = n
}

type CommandBufferBeginInfo struct {
	Next            Structure
	Flags           CommandBufferUsageFlags
	InheritanceInfo *CommandBufferInheritanceInfo
}

func (g *CommandBufferBeginInfo) toC(c *C.VkCommandBufferBeginInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkCommandBufferUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkCommandBufferUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkCommandBufferUsageFlags(temp_in_VkCommandBufferUsageFlags)
	}
	if g.InheritanceInfo != nil {
		c.pInheritanceInfo = (*C.VkCommandBufferInheritanceInfo)(m.alloc(C.sizeof_VkCommandBufferInheritanceInfo))
		g.InheritanceInfo.toC(c.pInheritanceInfo, m)
	} else {
		c.pInheritanceInfo = nil
	}
}
func (g *CommandBufferBeginInfo) fromC(c *C.VkCommandBufferBeginInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkCommandBufferUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkCommandBufferUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = CommandBufferUsageFlags(temp_in_VkCommandBufferUsageFlags)
	}
	if g.InheritanceInfo != nil {
		g.InheritanceInfo.fromC(c.pInheritanceInfo)
	}
}
func (s *CommandBufferBeginInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
}
func (s *CommandBufferBeginInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCommandBufferBeginInfo)(m.alloc(C.sizeof_VkCommandBufferBeginInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CommandBufferBeginInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCommandBufferBeginInfo)(p)
	s.fromC(c)
}
func (s *CommandBufferBeginInfo) GetNext() Structure {
	return s.Next
}
func (s *CommandBufferBeginInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncBeginCommandBuffer func(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (_ret Result)

func ToBeginCommandBuffer(p PFNVoidFunction) (fn FuncBeginCommandBuffer) {
	return func(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (_ret Result) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pBeginInfo    *C.VkCommandBufferBeginInfo
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if beginInfo != nil {
			c.pBeginInfo = (*C.VkCommandBufferBeginInfo)(m.alloc(C.sizeof_VkCommandBufferBeginInfo))
			beginInfo.toC(c.pBeginInfo, m)
		} else {
			c.pBeginInfo = nil
		}
		c._ret = C.callPFN_vkBeginCommandBuffer(C.PFN_vkBeginCommandBuffer(unsafe.Pointer(p)), c.commandBuffer, c.pBeginInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNEndCommandBuffer C.PFN_vkEndCommandBuffer
type FuncEndCommandBuffer func(commandBuffer CommandBuffer) (_ret Result)

func ToEndCommandBuffer(p PFNVoidFunction) (fn FuncEndCommandBuffer) {
	return func(commandBuffer CommandBuffer) (_ret Result) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			_ret          C.VkResult
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c._ret = C.callPFN_vkEndCommandBuffer(C.PFN_vkEndCommandBuffer(unsafe.Pointer(p)), c.commandBuffer)
		_ret = Result(c._ret)
		return
	}
}

type PFNResetCommandBuffer C.PFN_vkResetCommandBuffer
type CommandBufferResetFlags Flags
type FuncResetCommandBuffer func(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (_ret Result)

func ToResetCommandBuffer(p PFNVoidFunction) (fn FuncResetCommandBuffer) {
	return func(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (_ret Result) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			flags         C.VkCommandBufferResetFlags
			_ret          C.VkResult
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			var temp_in_VkCommandBufferResetFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkCommandBufferResetFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkCommandBufferResetFlags(temp_in_VkCommandBufferResetFlags)
		}
		c._ret = C.callPFN_vkResetCommandBuffer(C.PFN_vkResetCommandBuffer(unsafe.Pointer(p)), c.commandBuffer, c.flags)
		_ret = Result(c._ret)
		return
	}
}

type PFNCmdBindPipeline C.PFN_vkCmdBindPipeline
type FuncCmdBindPipeline func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline)

func ToCmdBindPipeline(p PFNVoidFunction) (fn FuncCmdBindPipeline) {
	return func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			pipelineBindPoint C.VkPipelineBindPoint
			pipeline          C.VkPipeline
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pipelineBindPoint = C.VkPipelineBindPoint(pipelineBindPoint)
		c.pipeline = C.VkPipeline(pipeline)
		C.callPFN_vkCmdBindPipeline(C.PFN_vkCmdBindPipeline(unsafe.Pointer(p)), c.commandBuffer, c.pipelineBindPoint, c.pipeline)
	}
}

type PFNCmdSetViewport C.PFN_vkCmdSetViewport
type FuncCmdSetViewport func(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport)

func ToCmdSetViewport(p PFNVoidFunction) (fn FuncCmdSetViewport) {
	return func(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			firstViewport C.uint32_t
			viewportCount C.uint32_t
			pViewports    *C.VkViewport
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.firstViewport = C.uint32_t(firstViewport)
		c.viewportCount = C.uint32_t(len(viewports))
		if len(viewports) != 0 {
			c.pViewports = (*C.VkViewport)(m.alloc(C.sizeof_VkViewport * uint(len(viewports))))
			slice1 := (*[1 << 31]C.VkViewport)(unsafe.Pointer(c.pViewports))[:len(viewports):len(viewports)]
			for i1, _ := range viewports {
				viewports[i1].toC(&slice1[i1])
			}
		} else {
			c.pViewports = nil
		}
		C.callPFN_vkCmdSetViewport(C.PFN_vkCmdSetViewport(unsafe.Pointer(p)), c.commandBuffer, c.firstViewport, c.viewportCount, c.pViewports)
	}
}

type PFNCmdSetScissor C.PFN_vkCmdSetScissor
type FuncCmdSetScissor func(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D)

func ToCmdSetScissor(p PFNVoidFunction) (fn FuncCmdSetScissor) {
	return func(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			firstScissor  C.uint32_t
			scissorCount  C.uint32_t
			pScissors     *C.VkRect2D
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.firstScissor = C.uint32_t(firstScissor)
		c.scissorCount = C.uint32_t(len(scissors))
		if len(scissors) != 0 {
			c.pScissors = (*C.VkRect2D)(m.alloc(C.sizeof_VkRect2D * uint(len(scissors))))
			slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pScissors))[:len(scissors):len(scissors)]
			for i1, _ := range scissors {
				scissors[i1].toC(&slice1[i1])
			}
		} else {
			c.pScissors = nil
		}
		C.callPFN_vkCmdSetScissor(C.PFN_vkCmdSetScissor(unsafe.Pointer(p)), c.commandBuffer, c.firstScissor, c.scissorCount, c.pScissors)
	}
}

type PFNCmdSetLineWidth C.PFN_vkCmdSetLineWidth
type FuncCmdSetLineWidth func(commandBuffer CommandBuffer, lineWidth float32)

func ToCmdSetLineWidth(p PFNVoidFunction) (fn FuncCmdSetLineWidth) {
	return func(commandBuffer CommandBuffer, lineWidth float32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			lineWidth     C.float
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.lineWidth = C.float(lineWidth)
		C.callPFN_vkCmdSetLineWidth(C.PFN_vkCmdSetLineWidth(unsafe.Pointer(p)), c.commandBuffer, c.lineWidth)
	}
}

type PFNCmdSetDepthBias C.PFN_vkCmdSetDepthBias
type FuncCmdSetDepthBias func(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32)

func ToCmdSetDepthBias(p PFNVoidFunction) (fn FuncCmdSetDepthBias) {
	return func(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {
		var c struct {
			commandBuffer           C.VkCommandBuffer
			depthBiasConstantFactor C.float
			depthBiasClamp          C.float
			depthBiasSlopeFactor    C.float
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.depthBiasConstantFactor = C.float(depthBiasConstantFactor)
		c.depthBiasClamp = C.float(depthBiasClamp)
		c.depthBiasSlopeFactor = C.float(depthBiasSlopeFactor)
		C.callPFN_vkCmdSetDepthBias(C.PFN_vkCmdSetDepthBias(unsafe.Pointer(p)), c.commandBuffer, c.depthBiasConstantFactor, c.depthBiasClamp, c.depthBiasSlopeFactor)
	}
}

type PFNCmdSetBlendConstants C.PFN_vkCmdSetBlendConstants
type FuncCmdSetBlendConstants func(commandBuffer CommandBuffer, blendConstants [4]float32)

func ToCmdSetBlendConstants(p PFNVoidFunction) (fn FuncCmdSetBlendConstants) {
	return func(commandBuffer CommandBuffer, blendConstants [4]float32) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			blendConstants *C.float
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			c.blendConstants = (*C.float)(m.alloc(C.sizeof_float * 4))
			slice1 := (*[1 << 31]C.float)(unsafe.Pointer(c.blendConstants))[:4:4]
			for i1, _ := range blendConstants {
				slice1[i1] = C.float(blendConstants[i1])
			}
		}
		C.callPFN_vkCmdSetBlendConstants(C.PFN_vkCmdSetBlendConstants(unsafe.Pointer(p)), c.commandBuffer, c.blendConstants)
	}
}

type PFNCmdSetDepthBounds C.PFN_vkCmdSetDepthBounds
type FuncCmdSetDepthBounds func(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32)

func ToCmdSetDepthBounds(p PFNVoidFunction) (fn FuncCmdSetDepthBounds) {
	return func(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			minDepthBounds C.float
			maxDepthBounds C.float
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.minDepthBounds = C.float(minDepthBounds)
		c.maxDepthBounds = C.float(maxDepthBounds)
		C.callPFN_vkCmdSetDepthBounds(C.PFN_vkCmdSetDepthBounds(unsafe.Pointer(p)), c.commandBuffer, c.minDepthBounds, c.maxDepthBounds)
	}
}

type PFNCmdSetStencilCompareMask C.PFN_vkCmdSetStencilCompareMask
type StencilFaceFlags Flags
type FuncCmdSetStencilCompareMask func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32)

func ToCmdSetStencilCompareMask(p PFNVoidFunction) (fn FuncCmdSetStencilCompareMask) {
	return func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			faceMask      C.VkStencilFaceFlags
			compareMask   C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			var temp_in_VkStencilFaceFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
				temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
		}
		c.compareMask = C.uint32_t(compareMask)
		C.callPFN_vkCmdSetStencilCompareMask(C.PFN_vkCmdSetStencilCompareMask(unsafe.Pointer(p)), c.commandBuffer, c.faceMask, c.compareMask)
	}
}

type PFNCmdSetStencilWriteMask C.PFN_vkCmdSetStencilWriteMask
type FuncCmdSetStencilWriteMask func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32)

func ToCmdSetStencilWriteMask(p PFNVoidFunction) (fn FuncCmdSetStencilWriteMask) {
	return func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			faceMask      C.VkStencilFaceFlags
			writeMask     C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			var temp_in_VkStencilFaceFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
				temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
		}
		c.writeMask = C.uint32_t(writeMask)
		C.callPFN_vkCmdSetStencilWriteMask(C.PFN_vkCmdSetStencilWriteMask(unsafe.Pointer(p)), c.commandBuffer, c.faceMask, c.writeMask)
	}
}

type PFNCmdSetStencilReference C.PFN_vkCmdSetStencilReference
type FuncCmdSetStencilReference func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32)

func ToCmdSetStencilReference(p PFNVoidFunction) (fn FuncCmdSetStencilReference) {
	return func(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			faceMask      C.VkStencilFaceFlags
			reference     C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			var temp_in_VkStencilFaceFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
				temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
		}
		c.reference = C.uint32_t(reference)
		C.callPFN_vkCmdSetStencilReference(C.PFN_vkCmdSetStencilReference(unsafe.Pointer(p)), c.commandBuffer, c.faceMask, c.reference)
	}
}

type PFNCmdBindDescriptorSets C.PFN_vkCmdBindDescriptorSets
type FuncCmdBindDescriptorSets func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32)

func ToCmdBindDescriptorSets(p PFNVoidFunction) (fn FuncCmdBindDescriptorSets) {
	return func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32) {
		var c struct {
			commandBuffer      C.VkCommandBuffer
			pipelineBindPoint  C.VkPipelineBindPoint
			layout             C.VkPipelineLayout
			firstSet           C.uint32_t
			descriptorSetCount C.uint32_t
			pDescriptorSets    *C.VkDescriptorSet
			dynamicOffsetCount C.uint32_t
			pDynamicOffsets    *C.uint32_t
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pipelineBindPoint = C.VkPipelineBindPoint(pipelineBindPoint)
		c.layout = C.VkPipelineLayout(layout)
		c.firstSet = C.uint32_t(firstSet)
		c.descriptorSetCount = C.uint32_t(len(descriptorSets))
		if len(descriptorSets) != 0 {
			c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet * uint(len(descriptorSets))))
			slice1 := (*[1 << 31]C.VkDescriptorSet)(unsafe.Pointer(c.pDescriptorSets))[:len(descriptorSets):len(descriptorSets)]
			for i1, _ := range descriptorSets {
				slice1[i1] = C.VkDescriptorSet(descriptorSets[i1])
			}
		} else {
			c.pDescriptorSets = nil
		}
		c.dynamicOffsetCount = C.uint32_t(len(dynamicOffsets))
		if len(dynamicOffsets) != 0 {
			c.pDynamicOffsets = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(dynamicOffsets))))
			slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pDynamicOffsets))[:len(dynamicOffsets):len(dynamicOffsets)]
			for i1, _ := range dynamicOffsets {
				slice1[i1] = C.uint32_t(dynamicOffsets[i1])
			}
		} else {
			c.pDynamicOffsets = nil
		}
		C.callPFN_vkCmdBindDescriptorSets(C.PFN_vkCmdBindDescriptorSets(unsafe.Pointer(p)), c.commandBuffer, c.pipelineBindPoint, c.layout, c.firstSet, c.descriptorSetCount, c.pDescriptorSets, c.dynamicOffsetCount, c.pDynamicOffsets)
	}
}

type PFNCmdBindIndexBuffer C.PFN_vkCmdBindIndexBuffer
type FuncCmdBindIndexBuffer func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType)

func ToCmdBindIndexBuffer(p PFNVoidFunction) (fn FuncCmdBindIndexBuffer) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			buffer        C.VkBuffer
			offset        C.VkDeviceSize
			indexType     C.VkIndexType
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.indexType = C.VkIndexType(indexType)
		C.callPFN_vkCmdBindIndexBuffer(C.PFN_vkCmdBindIndexBuffer(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.indexType)
	}
}

type PFNCmdBindVertexBuffers C.PFN_vkCmdBindVertexBuffers
type FuncCmdBindVertexBuffers func(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize)

func ToCmdBindVertexBuffers(p PFNVoidFunction) (fn FuncCmdBindVertexBuffers) {
	return func(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			firstBinding  C.uint32_t
			bindingCount  C.uint32_t
			pBuffers      *C.VkBuffer
			pOffsets      *C.VkDeviceSize
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.firstBinding = C.uint32_t(firstBinding)
		c.bindingCount = C.uint32_t(len(buffers))
		if len(buffers) != 0 {
			c.pBuffers = (*C.VkBuffer)(m.alloc(C.sizeof_VkBuffer * uint(len(buffers))))
			slice1 := (*[1 << 31]C.VkBuffer)(unsafe.Pointer(c.pBuffers))[:len(buffers):len(buffers)]
			for i1, _ := range buffers {
				slice1[i1] = C.VkBuffer(buffers[i1])
			}
		} else {
			c.pBuffers = nil
		}
		if len(offsets) != 0 {
			c.pOffsets = (*C.VkDeviceSize)(m.alloc(C.sizeof_VkDeviceSize * uint(len(offsets))))
			slice1 := (*[1 << 31]C.VkDeviceSize)(unsafe.Pointer(c.pOffsets))[:len(offsets):len(offsets)]
			for i1, _ := range offsets {
				{
					var temp_in_VkDeviceSize C.uint64_t
					temp_in_VkDeviceSize = C.uint64_t((uint64)(offsets[i1]))
					slice1[i1] = C.VkDeviceSize(temp_in_VkDeviceSize)
				}
			}
		} else {
			c.pOffsets = nil
		}
		C.callPFN_vkCmdBindVertexBuffers(C.PFN_vkCmdBindVertexBuffers(unsafe.Pointer(p)), c.commandBuffer, c.firstBinding, c.bindingCount, c.pBuffers, c.pOffsets)
	}
}

type PFNCmdDraw C.PFN_vkCmdDraw
type FuncCmdDraw func(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32)

func ToCmdDraw(p PFNVoidFunction) (fn FuncCmdDraw) {
	return func(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			vertexCount   C.uint32_t
			instanceCount C.uint32_t
			firstVertex   C.uint32_t
			firstInstance C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.vertexCount = C.uint32_t(vertexCount)
		c.instanceCount = C.uint32_t(instanceCount)
		c.firstVertex = C.uint32_t(firstVertex)
		c.firstInstance = C.uint32_t(firstInstance)
		C.callPFN_vkCmdDraw(C.PFN_vkCmdDraw(unsafe.Pointer(p)), c.commandBuffer, c.vertexCount, c.instanceCount, c.firstVertex, c.firstInstance)
	}
}

type PFNCmdDrawIndexed C.PFN_vkCmdDrawIndexed
type FuncCmdDrawIndexed func(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32)

func ToCmdDrawIndexed(p PFNVoidFunction) (fn FuncCmdDrawIndexed) {
	return func(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			indexCount    C.uint32_t
			instanceCount C.uint32_t
			firstIndex    C.uint32_t
			vertexOffset  C.int32_t
			firstInstance C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.indexCount = C.uint32_t(indexCount)
		c.instanceCount = C.uint32_t(instanceCount)
		c.firstIndex = C.uint32_t(firstIndex)
		c.vertexOffset = C.int32_t(vertexOffset)
		c.firstInstance = C.uint32_t(firstInstance)
		C.callPFN_vkCmdDrawIndexed(C.PFN_vkCmdDrawIndexed(unsafe.Pointer(p)), c.commandBuffer, c.indexCount, c.instanceCount, c.firstIndex, c.vertexOffset, c.firstInstance)
	}
}

type PFNCmdDrawIndirect C.PFN_vkCmdDrawIndirect
type FuncCmdDrawIndirect func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32)

func ToCmdDrawIndirect(p PFNVoidFunction) (fn FuncCmdDrawIndirect) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			buffer        C.VkBuffer
			offset        C.VkDeviceSize
			drawCount     C.uint32_t
			stride        C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.drawCount = C.uint32_t(drawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndirect(C.PFN_vkCmdDrawIndirect(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.drawCount, c.stride)
	}
}

type PFNCmdDrawIndexedIndirect C.PFN_vkCmdDrawIndexedIndirect
type FuncCmdDrawIndexedIndirect func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32)

func ToCmdDrawIndexedIndirect(p PFNVoidFunction) (fn FuncCmdDrawIndexedIndirect) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			buffer        C.VkBuffer
			offset        C.VkDeviceSize
			drawCount     C.uint32_t
			stride        C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.drawCount = C.uint32_t(drawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndexedIndirect(C.PFN_vkCmdDrawIndexedIndirect(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.drawCount, c.stride)
	}
}

type PFNCmdDispatch C.PFN_vkCmdDispatch
type FuncCmdDispatch func(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32)

func ToCmdDispatch(p PFNVoidFunction) (fn FuncCmdDispatch) {
	return func(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			groupCountX   C.uint32_t
			groupCountY   C.uint32_t
			groupCountZ   C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.groupCountX = C.uint32_t(groupCountX)
		c.groupCountY = C.uint32_t(groupCountY)
		c.groupCountZ = C.uint32_t(groupCountZ)
		C.callPFN_vkCmdDispatch(C.PFN_vkCmdDispatch(unsafe.Pointer(p)), c.commandBuffer, c.groupCountX, c.groupCountY, c.groupCountZ)
	}
}

type PFNCmdDispatchIndirect C.PFN_vkCmdDispatchIndirect
type FuncCmdDispatchIndirect func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize)

func ToCmdDispatchIndirect(p PFNVoidFunction) (fn FuncCmdDispatchIndirect) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			buffer        C.VkBuffer
			offset        C.VkDeviceSize
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		C.callPFN_vkCmdDispatchIndirect(C.PFN_vkCmdDispatchIndirect(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset)
	}
}

type PFNCmdCopyBuffer C.PFN_vkCmdCopyBuffer
type BufferCopy struct {
	SrcOffset DeviceSize
	DstOffset DeviceSize
	Size      DeviceSize
}

func (g *BufferCopy) toC(c *C.VkBufferCopy) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.SrcOffset))
		c.srcOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.DstOffset))
		c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *BufferCopy) fromC(c *C.VkBufferCopy) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.srcOffset))
		g.SrcOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.dstOffset))
		g.DstOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
}

type FuncCmdCopyBuffer func(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy)

func ToCmdCopyBuffer(p PFNVoidFunction) (fn FuncCmdCopyBuffer) {
	return func(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			srcBuffer     C.VkBuffer
			dstBuffer     C.VkBuffer
			regionCount   C.uint32_t
			pRegions      *C.VkBufferCopy
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcBuffer = C.VkBuffer(srcBuffer)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkBufferCopy)(m.alloc(C.sizeof_VkBufferCopy * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkBufferCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		C.callPFN_vkCmdCopyBuffer(C.PFN_vkCmdCopyBuffer(unsafe.Pointer(p)), c.commandBuffer, c.srcBuffer, c.dstBuffer, c.regionCount, c.pRegions)
	}
}

type PFNCmdCopyImage C.PFN_vkCmdCopyImage
type ImageSubresourceLayers struct {
	AspectMask     ImageAspectFlags
	MipLevel       uint32
	BaseArrayLayer uint32
	LayerCount     uint32
}

func (g *ImageSubresourceLayers) toC(c *C.VkImageSubresourceLayers) {
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	c.mipLevel = C.uint32_t(g.MipLevel)
	c.baseArrayLayer = C.uint32_t(g.BaseArrayLayer)
	c.layerCount = C.uint32_t(g.LayerCount)
}
func (g *ImageSubresourceLayers) fromC(c *C.VkImageSubresourceLayers) {
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.MipLevel = uint32(c.mipLevel)
	g.BaseArrayLayer = uint32(c.baseArrayLayer)
	g.LayerCount = uint32(c.layerCount)
}

type ImageCopy struct {
	SrcSubresource ImageSubresourceLayers
	SrcOffset      Offset3D
	DstSubresource ImageSubresourceLayers
	DstOffset      Offset3D
	Extent         Extent3D
}

func (g *ImageCopy) toC(c *C.VkImageCopy) {
	g.SrcSubresource.toC(&c.srcSubresource)
	g.SrcOffset.toC(&c.srcOffset)
	g.DstSubresource.toC(&c.dstSubresource)
	g.DstOffset.toC(&c.dstOffset)
	g.Extent.toC(&c.extent)
}
func (g *ImageCopy) fromC(c *C.VkImageCopy) {
	g.SrcSubresource.fromC(&c.srcSubresource)
	g.SrcOffset.fromC(&c.srcOffset)
	g.DstSubresource.fromC(&c.dstSubresource)
	g.DstOffset.fromC(&c.dstOffset)
	g.Extent.fromC(&c.extent)
}

type FuncCmdCopyImage func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy)

func ToCmdCopyImage(p PFNVoidFunction) (fn FuncCmdCopyImage) {
	return func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			srcImage       C.VkImage
			srcImageLayout C.VkImageLayout
			dstImage       C.VkImage
			dstImageLayout C.VkImageLayout
			regionCount    C.uint32_t
			pRegions       *C.VkImageCopy
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcImage = C.VkImage(srcImage)
		c.srcImageLayout = C.VkImageLayout(srcImageLayout)
		c.dstImage = C.VkImage(dstImage)
		c.dstImageLayout = C.VkImageLayout(dstImageLayout)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkImageCopy)(m.alloc(C.sizeof_VkImageCopy * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		C.callPFN_vkCmdCopyImage(C.PFN_vkCmdCopyImage(unsafe.Pointer(p)), c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
	}
}

type PFNCmdBlitImage C.PFN_vkCmdBlitImage
type ImageBlit struct {
	SrcSubresource ImageSubresourceLayers
	SrcOffsets     [2]Offset3D
	DstSubresource ImageSubresourceLayers
	DstOffsets     [2]Offset3D
}

func (g *ImageBlit) toC(c *C.VkImageBlit) {
	g.SrcSubresource.toC(&c.srcSubresource)
	for i, _ := range g.SrcOffsets {
		g.SrcOffsets[i].toC(&c.srcOffsets[i])
	}
	g.DstSubresource.toC(&c.dstSubresource)
	for i, _ := range g.DstOffsets {
		g.DstOffsets[i].toC(&c.dstOffsets[i])
	}
}
func (g *ImageBlit) fromC(c *C.VkImageBlit) {
	g.SrcSubresource.fromC(&c.srcSubresource)
	for i, _ := range g.SrcOffsets {
		g.SrcOffsets[i].fromC(&c.srcOffsets[i])
	}
	g.DstSubresource.fromC(&c.dstSubresource)
	for i, _ := range g.DstOffsets {
		g.DstOffsets[i].fromC(&c.dstOffsets[i])
	}
}

type FuncCmdBlitImage func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter)

func ToCmdBlitImage(p PFNVoidFunction) (fn FuncCmdBlitImage) {
	return func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			srcImage       C.VkImage
			srcImageLayout C.VkImageLayout
			dstImage       C.VkImage
			dstImageLayout C.VkImageLayout
			regionCount    C.uint32_t
			pRegions       *C.VkImageBlit
			filter         C.VkFilter
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcImage = C.VkImage(srcImage)
		c.srcImageLayout = C.VkImageLayout(srcImageLayout)
		c.dstImage = C.VkImage(dstImage)
		c.dstImageLayout = C.VkImageLayout(dstImageLayout)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkImageBlit)(m.alloc(C.sizeof_VkImageBlit * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkImageBlit)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		c.filter = C.VkFilter(filter)
		C.callPFN_vkCmdBlitImage(C.PFN_vkCmdBlitImage(unsafe.Pointer(p)), c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions, c.filter)
	}
}

type PFNCmdCopyBufferToImage C.PFN_vkCmdCopyBufferToImage
type BufferImageCopy struct {
	BufferOffset      DeviceSize
	BufferRowLength   uint32
	BufferImageHeight uint32
	ImageSubresource  ImageSubresourceLayers
	ImageOffset       Offset3D
	ImageExtent       Extent3D
}

func (g *BufferImageCopy) toC(c *C.VkBufferImageCopy) {
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.BufferOffset))
		c.bufferOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.bufferRowLength = C.uint32_t(g.BufferRowLength)
	c.bufferImageHeight = C.uint32_t(g.BufferImageHeight)
	g.ImageSubresource.toC(&c.imageSubresource)
	g.ImageOffset.toC(&c.imageOffset)
	g.ImageExtent.toC(&c.imageExtent)
}
func (g *BufferImageCopy) fromC(c *C.VkBufferImageCopy) {
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.bufferOffset))
		g.BufferOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	g.BufferRowLength = uint32(c.bufferRowLength)
	g.BufferImageHeight = uint32(c.bufferImageHeight)
	g.ImageSubresource.fromC(&c.imageSubresource)
	g.ImageOffset.fromC(&c.imageOffset)
	g.ImageExtent.fromC(&c.imageExtent)
}

type FuncCmdCopyBufferToImage func(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy)

func ToCmdCopyBufferToImage(p PFNVoidFunction) (fn FuncCmdCopyBufferToImage) {
	return func(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			srcBuffer      C.VkBuffer
			dstImage       C.VkImage
			dstImageLayout C.VkImageLayout
			regionCount    C.uint32_t
			pRegions       *C.VkBufferImageCopy
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcBuffer = C.VkBuffer(srcBuffer)
		c.dstImage = C.VkImage(dstImage)
		c.dstImageLayout = C.VkImageLayout(dstImageLayout)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkBufferImageCopy)(m.alloc(C.sizeof_VkBufferImageCopy * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkBufferImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		C.callPFN_vkCmdCopyBufferToImage(C.PFN_vkCmdCopyBufferToImage(unsafe.Pointer(p)), c.commandBuffer, c.srcBuffer, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
	}
}

type PFNCmdCopyImageToBuffer C.PFN_vkCmdCopyImageToBuffer
type FuncCmdCopyImageToBuffer func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy)

func ToCmdCopyImageToBuffer(p PFNVoidFunction) (fn FuncCmdCopyImageToBuffer) {
	return func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			srcImage       C.VkImage
			srcImageLayout C.VkImageLayout
			dstBuffer      C.VkBuffer
			regionCount    C.uint32_t
			pRegions       *C.VkBufferImageCopy
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcImage = C.VkImage(srcImage)
		c.srcImageLayout = C.VkImageLayout(srcImageLayout)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkBufferImageCopy)(m.alloc(C.sizeof_VkBufferImageCopy * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkBufferImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		C.callPFN_vkCmdCopyImageToBuffer(C.PFN_vkCmdCopyImageToBuffer(unsafe.Pointer(p)), c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstBuffer, c.regionCount, c.pRegions)
	}
}

type PFNCmdUpdateBuffer C.PFN_vkCmdUpdateBuffer
type FuncCmdUpdateBuffer func(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, data unsafe.Pointer)

func ToCmdUpdateBuffer(p PFNVoidFunction) (fn FuncCmdUpdateBuffer) {
	return func(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, data unsafe.Pointer) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			dstBuffer     C.VkBuffer
			dstOffset     C.VkDeviceSize
			dataSize      C.VkDeviceSize
			pData         unsafe.Pointer
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
			c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(dataSize))
			c.dataSize = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.pData = data
		C.callPFN_vkCmdUpdateBuffer(C.PFN_vkCmdUpdateBuffer(unsafe.Pointer(p)), c.commandBuffer, c.dstBuffer, c.dstOffset, c.dataSize, c.pData)
	}
}

type PFNCmdFillBuffer C.PFN_vkCmdFillBuffer
type FuncCmdFillBuffer func(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32)

func ToCmdFillBuffer(p PFNVoidFunction) (fn FuncCmdFillBuffer) {
	return func(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			dstBuffer     C.VkBuffer
			dstOffset     C.VkDeviceSize
			size          C.VkDeviceSize
			data          C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
			c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(size))
			c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.data = C.uint32_t(data)
		C.callPFN_vkCmdFillBuffer(C.PFN_vkCmdFillBuffer(unsafe.Pointer(p)), c.commandBuffer, c.dstBuffer, c.dstOffset, c.size, c.data)
	}
}

type PFNCmdClearColorImage C.PFN_vkCmdClearColorImage
type ClearColorValue C.VkClearColorValue

func (g *ClearColorValue) AssginFloat32(v [4]float32) {
	var cv [4]C.float
	for i, _ := range v {
		cv[i] = C.float(v[i])
	}
	*(*[4]C.float)(unsafe.Pointer(g)) = cv
}
func (g *ClearColorValue) Float32() (v [4]float32) {
	cv := *(*[4]C.float)(unsafe.Pointer(g))
	for i, _ := range v {
		v[i] = float32(cv[i])
	}
	return
}
func (g *ClearColorValue) AssginInt32(v [4]int32) {
	var cv [4]C.int32_t
	for i, _ := range v {
		cv[i] = C.int32_t(v[i])
	}
	*(*[4]C.int32_t)(unsafe.Pointer(g)) = cv
}
func (g *ClearColorValue) Int32() (v [4]int32) {
	cv := *(*[4]C.int32_t)(unsafe.Pointer(g))
	for i, _ := range v {
		v[i] = int32(cv[i])
	}
	return
}
func (g *ClearColorValue) AssginUint32(v [4]uint32) {
	var cv [4]C.uint32_t
	for i, _ := range v {
		cv[i] = C.uint32_t(v[i])
	}
	*(*[4]C.uint32_t)(unsafe.Pointer(g)) = cv
}
func (g *ClearColorValue) Uint32() (v [4]uint32) {
	cv := *(*[4]C.uint32_t)(unsafe.Pointer(g))
	for i, _ := range v {
		v[i] = uint32(cv[i])
	}
	return
}

type FuncCmdClearColorImage func(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange)

func ToCmdClearColorImage(p PFNVoidFunction) (fn FuncCmdClearColorImage) {
	return func(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			image         C.VkImage
			imageLayout   C.VkImageLayout
			pColor        *C.VkClearColorValue
			rangeCount    C.uint32_t
			pRanges       *C.VkImageSubresourceRange
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.image = C.VkImage(image)
		c.imageLayout = C.VkImageLayout(imageLayout)
		if color != nil {
			c.pColor = (*C.VkClearColorValue)(m.alloc(C.sizeof_VkClearColorValue))
			*c.pColor = C.VkClearColorValue(*color)
		} else {
			c.pColor = nil
		}
		c.rangeCount = C.uint32_t(len(ranges))
		if len(ranges) != 0 {
			c.pRanges = (*C.VkImageSubresourceRange)(m.alloc(C.sizeof_VkImageSubresourceRange * uint(len(ranges))))
			slice1 := (*[1 << 31]C.VkImageSubresourceRange)(unsafe.Pointer(c.pRanges))[:len(ranges):len(ranges)]
			for i1, _ := range ranges {
				ranges[i1].toC(&slice1[i1])
			}
		} else {
			c.pRanges = nil
		}
		C.callPFN_vkCmdClearColorImage(C.PFN_vkCmdClearColorImage(unsafe.Pointer(p)), c.commandBuffer, c.image, c.imageLayout, c.pColor, c.rangeCount, c.pRanges)
	}
}

type PFNCmdClearDepthStencilImage C.PFN_vkCmdClearDepthStencilImage
type ClearDepthStencilValue struct {
	Depth   float32
	Stencil uint32
}

func (g *ClearDepthStencilValue) toC(c *C.VkClearDepthStencilValue) {
	c.depth = C.float(g.Depth)
	c.stencil = C.uint32_t(g.Stencil)
}
func (g *ClearDepthStencilValue) fromC(c *C.VkClearDepthStencilValue) {
	g.Depth = float32(c.depth)
	g.Stencil = uint32(c.stencil)
}

type FuncCmdClearDepthStencilImage func(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange)

func ToCmdClearDepthStencilImage(p PFNVoidFunction) (fn FuncCmdClearDepthStencilImage) {
	return func(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			image         C.VkImage
			imageLayout   C.VkImageLayout
			pDepthStencil *C.VkClearDepthStencilValue
			rangeCount    C.uint32_t
			pRanges       *C.VkImageSubresourceRange
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.image = C.VkImage(image)
		c.imageLayout = C.VkImageLayout(imageLayout)
		if depthStencil != nil {
			c.pDepthStencil = (*C.VkClearDepthStencilValue)(m.alloc(C.sizeof_VkClearDepthStencilValue))
			depthStencil.toC(c.pDepthStencil)
		} else {
			c.pDepthStencil = nil
		}
		c.rangeCount = C.uint32_t(len(ranges))
		if len(ranges) != 0 {
			c.pRanges = (*C.VkImageSubresourceRange)(m.alloc(C.sizeof_VkImageSubresourceRange * uint(len(ranges))))
			slice1 := (*[1 << 31]C.VkImageSubresourceRange)(unsafe.Pointer(c.pRanges))[:len(ranges):len(ranges)]
			for i1, _ := range ranges {
				ranges[i1].toC(&slice1[i1])
			}
		} else {
			c.pRanges = nil
		}
		C.callPFN_vkCmdClearDepthStencilImage(C.PFN_vkCmdClearDepthStencilImage(unsafe.Pointer(p)), c.commandBuffer, c.image, c.imageLayout, c.pDepthStencil, c.rangeCount, c.pRanges)
	}
}

type PFNCmdClearAttachments C.PFN_vkCmdClearAttachments
type ClearValue C.VkClearValue

func (g *ClearValue) AssginColor(v ClearColorValue) {
	var cv C.VkClearColorValue
	cv = C.VkClearColorValue(v)
	*(*C.VkClearColorValue)(unsafe.Pointer(g)) = cv
}
func (g *ClearValue) Color() (v ClearColorValue) {
	cv := *(*C.VkClearColorValue)(unsafe.Pointer(g))
	v = ClearColorValue(cv)
	return
}
func (g *ClearValue) AssginDepthStencil(v ClearDepthStencilValue) {
	var cv C.VkClearDepthStencilValue
	v.toC(&cv)
	*(*C.VkClearDepthStencilValue)(unsafe.Pointer(g)) = cv
}
func (g *ClearValue) DepthStencil() (v ClearDepthStencilValue) {
	cv := *(*C.VkClearDepthStencilValue)(unsafe.Pointer(g))
	v.fromC(&cv)
	return
}

type ClearAttachment struct {
	AspectMask      ImageAspectFlags
	ColorAttachment uint32
	ClearValue      ClearValue
}

func (g *ClearAttachment) toC(c *C.VkClearAttachment) {
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	c.colorAttachment = C.uint32_t(g.ColorAttachment)
	c.clearValue = C.VkClearValue(g.ClearValue)
}
func (g *ClearAttachment) fromC(c *C.VkClearAttachment) {
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
	g.ColorAttachment = uint32(c.colorAttachment)
	g.ClearValue = ClearValue(c.clearValue)
}

type ClearRect struct {
	Rect           Rect2D
	BaseArrayLayer uint32
	LayerCount     uint32
}

func (g *ClearRect) toC(c *C.VkClearRect) {
	g.Rect.toC(&c.rect)
	c.baseArrayLayer = C.uint32_t(g.BaseArrayLayer)
	c.layerCount = C.uint32_t(g.LayerCount)
}
func (g *ClearRect) fromC(c *C.VkClearRect) {
	g.Rect.fromC(&c.rect)
	g.BaseArrayLayer = uint32(c.baseArrayLayer)
	g.LayerCount = uint32(c.layerCount)
}

type FuncCmdClearAttachments func(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect)

func ToCmdClearAttachments(p PFNVoidFunction) (fn FuncCmdClearAttachments) {
	return func(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect) {
		var c struct {
			commandBuffer   C.VkCommandBuffer
			attachmentCount C.uint32_t
			pAttachments    *C.VkClearAttachment
			rectCount       C.uint32_t
			pRects          *C.VkClearRect
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.attachmentCount = C.uint32_t(len(attachments))
		if len(attachments) != 0 {
			c.pAttachments = (*C.VkClearAttachment)(m.alloc(C.sizeof_VkClearAttachment * uint(len(attachments))))
			slice1 := (*[1 << 31]C.VkClearAttachment)(unsafe.Pointer(c.pAttachments))[:len(attachments):len(attachments)]
			for i1, _ := range attachments {
				attachments[i1].toC(&slice1[i1])
			}
		} else {
			c.pAttachments = nil
		}
		c.rectCount = C.uint32_t(len(rects))
		if len(rects) != 0 {
			c.pRects = (*C.VkClearRect)(m.alloc(C.sizeof_VkClearRect * uint(len(rects))))
			slice1 := (*[1 << 31]C.VkClearRect)(unsafe.Pointer(c.pRects))[:len(rects):len(rects)]
			for i1, _ := range rects {
				rects[i1].toC(&slice1[i1])
			}
		} else {
			c.pRects = nil
		}
		C.callPFN_vkCmdClearAttachments(C.PFN_vkCmdClearAttachments(unsafe.Pointer(p)), c.commandBuffer, c.attachmentCount, c.pAttachments, c.rectCount, c.pRects)
	}
}

type PFNCmdResolveImage C.PFN_vkCmdResolveImage
type ImageResolve struct {
	SrcSubresource ImageSubresourceLayers
	SrcOffset      Offset3D
	DstSubresource ImageSubresourceLayers
	DstOffset      Offset3D
	Extent         Extent3D
}

func (g *ImageResolve) toC(c *C.VkImageResolve) {
	g.SrcSubresource.toC(&c.srcSubresource)
	g.SrcOffset.toC(&c.srcOffset)
	g.DstSubresource.toC(&c.dstSubresource)
	g.DstOffset.toC(&c.dstOffset)
	g.Extent.toC(&c.extent)
}
func (g *ImageResolve) fromC(c *C.VkImageResolve) {
	g.SrcSubresource.fromC(&c.srcSubresource)
	g.SrcOffset.fromC(&c.srcOffset)
	g.DstSubresource.fromC(&c.dstSubresource)
	g.DstOffset.fromC(&c.dstOffset)
	g.Extent.fromC(&c.extent)
}

type FuncCmdResolveImage func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve)

func ToCmdResolveImage(p PFNVoidFunction) (fn FuncCmdResolveImage) {
	return func(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve) {
		var c struct {
			commandBuffer  C.VkCommandBuffer
			srcImage       C.VkImage
			srcImageLayout C.VkImageLayout
			dstImage       C.VkImage
			dstImageLayout C.VkImageLayout
			regionCount    C.uint32_t
			pRegions       *C.VkImageResolve
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.srcImage = C.VkImage(srcImage)
		c.srcImageLayout = C.VkImageLayout(srcImageLayout)
		c.dstImage = C.VkImage(dstImage)
		c.dstImageLayout = C.VkImageLayout(dstImageLayout)
		c.regionCount = C.uint32_t(len(regions))
		if len(regions) != 0 {
			c.pRegions = (*C.VkImageResolve)(m.alloc(C.sizeof_VkImageResolve * uint(len(regions))))
			slice1 := (*[1 << 31]C.VkImageResolve)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
			for i1, _ := range regions {
				regions[i1].toC(&slice1[i1])
			}
		} else {
			c.pRegions = nil
		}
		C.callPFN_vkCmdResolveImage(C.PFN_vkCmdResolveImage(unsafe.Pointer(p)), c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
	}
}

type PFNCmdSetEvent C.PFN_vkCmdSetEvent
type FuncCmdSetEvent func(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags)

func ToCmdSetEvent(p PFNVoidFunction) (fn FuncCmdSetEvent) {
	return func(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			event         C.VkEvent
			stageMask     C.VkPipelineStageFlags
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.event = C.VkEvent(event)
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.stageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		C.callPFN_vkCmdSetEvent(C.PFN_vkCmdSetEvent(unsafe.Pointer(p)), c.commandBuffer, c.event, c.stageMask)
	}
}

type PFNCmdResetEvent C.PFN_vkCmdResetEvent
type FuncCmdResetEvent func(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags)

func ToCmdResetEvent(p PFNVoidFunction) (fn FuncCmdResetEvent) {
	return func(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			event         C.VkEvent
			stageMask     C.VkPipelineStageFlags
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.event = C.VkEvent(event)
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.stageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		C.callPFN_vkCmdResetEvent(C.PFN_vkCmdResetEvent(unsafe.Pointer(p)), c.commandBuffer, c.event, c.stageMask)
	}
}

type PFNCmdWaitEvents C.PFN_vkCmdWaitEvents
type MemoryBarrier struct {
	Next          Structure
	SrcAccessMask AccessFlags
	DstAccessMask AccessFlags
}

func (g *MemoryBarrier) toC(c *C.VkMemoryBarrier, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
}
func (g *MemoryBarrier) fromC(c *C.VkMemoryBarrier) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.SrcAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.DstAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
}
func (s *MemoryBarrier) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_BARRIER
}
func (s *MemoryBarrier) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryBarrier)(m.alloc(C.sizeof_VkMemoryBarrier))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryBarrier) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryBarrier)(p)
	s.fromC(c)
}
func (s *MemoryBarrier) GetNext() Structure {
	return s.Next
}
func (s *MemoryBarrier) SetNext(n Structure) {
	s.Next = n
}

type BufferMemoryBarrier struct {
	Next                Structure
	SrcAccessMask       AccessFlags
	DstAccessMask       AccessFlags
	SrcQueueFamilyIndex uint32
	DstQueueFamilyIndex uint32
	Buffer              Buffer
	Offset              DeviceSize
	Size                DeviceSize
}

func (g *BufferMemoryBarrier) toC(c *C.VkBufferMemoryBarrier, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	c.srcQueueFamilyIndex = C.uint32_t(g.SrcQueueFamilyIndex)
	c.dstQueueFamilyIndex = C.uint32_t(g.DstQueueFamilyIndex)
	c.buffer = C.VkBuffer(g.Buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *BufferMemoryBarrier) fromC(c *C.VkBufferMemoryBarrier) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.SrcAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.DstAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	g.SrcQueueFamilyIndex = uint32(c.srcQueueFamilyIndex)
	g.DstQueueFamilyIndex = uint32(c.dstQueueFamilyIndex)
	g.Buffer = Buffer(c.buffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.size))
		g.Size = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *BufferMemoryBarrier) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
}
func (s *BufferMemoryBarrier) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBufferMemoryBarrier)(m.alloc(C.sizeof_VkBufferMemoryBarrier))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BufferMemoryBarrier) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBufferMemoryBarrier)(p)
	s.fromC(c)
}
func (s *BufferMemoryBarrier) GetNext() Structure {
	return s.Next
}
func (s *BufferMemoryBarrier) SetNext(n Structure) {
	s.Next = n
}

type ImageMemoryBarrier struct {
	Next                Structure
	SrcAccessMask       AccessFlags
	DstAccessMask       AccessFlags
	OldLayout           ImageLayout
	NewLayout           ImageLayout
	SrcQueueFamilyIndex uint32
	DstQueueFamilyIndex uint32
	Image               Image
	SubresourceRange    ImageSubresourceRange
}

func (g *ImageMemoryBarrier) toC(c *C.VkImageMemoryBarrier, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	c.oldLayout = C.VkImageLayout(g.OldLayout)
	c.newLayout = C.VkImageLayout(g.NewLayout)
	c.srcQueueFamilyIndex = C.uint32_t(g.SrcQueueFamilyIndex)
	c.dstQueueFamilyIndex = C.uint32_t(g.DstQueueFamilyIndex)
	c.image = C.VkImage(g.Image)
	g.SubresourceRange.toC(&c.subresourceRange)
}
func (g *ImageMemoryBarrier) fromC(c *C.VkImageMemoryBarrier) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.SrcAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.DstAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	g.OldLayout = ImageLayout(c.oldLayout)
	g.NewLayout = ImageLayout(c.newLayout)
	g.SrcQueueFamilyIndex = uint32(c.srcQueueFamilyIndex)
	g.DstQueueFamilyIndex = uint32(c.dstQueueFamilyIndex)
	g.Image = Image(c.image)
	g.SubresourceRange.fromC(&c.subresourceRange)
}
func (s *ImageMemoryBarrier) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
}
func (s *ImageMemoryBarrier) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageMemoryBarrier)(m.alloc(C.sizeof_VkImageMemoryBarrier))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageMemoryBarrier) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageMemoryBarrier)(p)
	s.fromC(c)
}
func (s *ImageMemoryBarrier) GetNext() Structure {
	return s.Next
}
func (s *ImageMemoryBarrier) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdWaitEvents func(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier)

func ToCmdWaitEvents(p PFNVoidFunction) (fn FuncCmdWaitEvents) {
	return func(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
		var c struct {
			commandBuffer            C.VkCommandBuffer
			eventCount               C.uint32_t
			pEvents                  *C.VkEvent
			srcStageMask             C.VkPipelineStageFlags
			dstStageMask             C.VkPipelineStageFlags
			memoryBarrierCount       C.uint32_t
			pMemoryBarriers          *C.VkMemoryBarrier
			bufferMemoryBarrierCount C.uint32_t
			pBufferMemoryBarriers    *C.VkBufferMemoryBarrier
			imageMemoryBarrierCount  C.uint32_t
			pImageMemoryBarriers     *C.VkImageMemoryBarrier
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.eventCount = C.uint32_t(len(events))
		if len(events) != 0 {
			c.pEvents = (*C.VkEvent)(m.alloc(C.sizeof_VkEvent * uint(len(events))))
			slice1 := (*[1 << 31]C.VkEvent)(unsafe.Pointer(c.pEvents))[:len(events):len(events)]
			for i1, _ := range events {
				slice1[i1] = C.VkEvent(events[i1])
			}
		} else {
			c.pEvents = nil
		}
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(srcStageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dstStageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		c.memoryBarrierCount = C.uint32_t(len(memoryBarriers))
		if len(memoryBarriers) != 0 {
			c.pMemoryBarriers = (*C.VkMemoryBarrier)(m.alloc(C.sizeof_VkMemoryBarrier * uint(len(memoryBarriers))))
			slice1 := (*[1 << 31]C.VkMemoryBarrier)(unsafe.Pointer(c.pMemoryBarriers))[:len(memoryBarriers):len(memoryBarriers)]
			for i1, _ := range memoryBarriers {
				memoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pMemoryBarriers = nil
		}
		c.bufferMemoryBarrierCount = C.uint32_t(len(bufferMemoryBarriers))
		if len(bufferMemoryBarriers) != 0 {
			c.pBufferMemoryBarriers = (*C.VkBufferMemoryBarrier)(m.alloc(C.sizeof_VkBufferMemoryBarrier * uint(len(bufferMemoryBarriers))))
			slice1 := (*[1 << 31]C.VkBufferMemoryBarrier)(unsafe.Pointer(c.pBufferMemoryBarriers))[:len(bufferMemoryBarriers):len(bufferMemoryBarriers)]
			for i1, _ := range bufferMemoryBarriers {
				bufferMemoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBufferMemoryBarriers = nil
		}
		c.imageMemoryBarrierCount = C.uint32_t(len(imageMemoryBarriers))
		if len(imageMemoryBarriers) != 0 {
			c.pImageMemoryBarriers = (*C.VkImageMemoryBarrier)(m.alloc(C.sizeof_VkImageMemoryBarrier * uint(len(imageMemoryBarriers))))
			slice1 := (*[1 << 31]C.VkImageMemoryBarrier)(unsafe.Pointer(c.pImageMemoryBarriers))[:len(imageMemoryBarriers):len(imageMemoryBarriers)]
			for i1, _ := range imageMemoryBarriers {
				imageMemoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pImageMemoryBarriers = nil
		}
		C.callPFN_vkCmdWaitEvents(C.PFN_vkCmdWaitEvents(unsafe.Pointer(p)), c.commandBuffer, c.eventCount, c.pEvents, c.srcStageMask, c.dstStageMask, c.memoryBarrierCount, c.pMemoryBarriers, c.bufferMemoryBarrierCount, c.pBufferMemoryBarriers, c.imageMemoryBarrierCount, c.pImageMemoryBarriers)
	}
}

type PFNCmdPipelineBarrier C.PFN_vkCmdPipelineBarrier
type FuncCmdPipelineBarrier func(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier)

func ToCmdPipelineBarrier(p PFNVoidFunction) (fn FuncCmdPipelineBarrier) {
	return func(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
		var c struct {
			commandBuffer            C.VkCommandBuffer
			srcStageMask             C.VkPipelineStageFlags
			dstStageMask             C.VkPipelineStageFlags
			dependencyFlags          C.VkDependencyFlags
			memoryBarrierCount       C.uint32_t
			pMemoryBarriers          *C.VkMemoryBarrier
			bufferMemoryBarrierCount C.uint32_t
			pBufferMemoryBarriers    *C.VkBufferMemoryBarrier
			imageMemoryBarrierCount  C.uint32_t
			pImageMemoryBarriers     *C.VkImageMemoryBarrier
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(srcStageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		{
			var temp_in_VkPipelineStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dstStageMask)))
				temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
		}
		{
			var temp_in_VkDependencyFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dependencyFlags)))
				temp_in_VkDependencyFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.dependencyFlags = C.VkDependencyFlags(temp_in_VkDependencyFlags)
		}
		c.memoryBarrierCount = C.uint32_t(len(memoryBarriers))
		if len(memoryBarriers) != 0 {
			c.pMemoryBarriers = (*C.VkMemoryBarrier)(m.alloc(C.sizeof_VkMemoryBarrier * uint(len(memoryBarriers))))
			slice1 := (*[1 << 31]C.VkMemoryBarrier)(unsafe.Pointer(c.pMemoryBarriers))[:len(memoryBarriers):len(memoryBarriers)]
			for i1, _ := range memoryBarriers {
				memoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pMemoryBarriers = nil
		}
		c.bufferMemoryBarrierCount = C.uint32_t(len(bufferMemoryBarriers))
		if len(bufferMemoryBarriers) != 0 {
			c.pBufferMemoryBarriers = (*C.VkBufferMemoryBarrier)(m.alloc(C.sizeof_VkBufferMemoryBarrier * uint(len(bufferMemoryBarriers))))
			slice1 := (*[1 << 31]C.VkBufferMemoryBarrier)(unsafe.Pointer(c.pBufferMemoryBarriers))[:len(bufferMemoryBarriers):len(bufferMemoryBarriers)]
			for i1, _ := range bufferMemoryBarriers {
				bufferMemoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBufferMemoryBarriers = nil
		}
		c.imageMemoryBarrierCount = C.uint32_t(len(imageMemoryBarriers))
		if len(imageMemoryBarriers) != 0 {
			c.pImageMemoryBarriers = (*C.VkImageMemoryBarrier)(m.alloc(C.sizeof_VkImageMemoryBarrier * uint(len(imageMemoryBarriers))))
			slice1 := (*[1 << 31]C.VkImageMemoryBarrier)(unsafe.Pointer(c.pImageMemoryBarriers))[:len(imageMemoryBarriers):len(imageMemoryBarriers)]
			for i1, _ := range imageMemoryBarriers {
				imageMemoryBarriers[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pImageMemoryBarriers = nil
		}
		C.callPFN_vkCmdPipelineBarrier(C.PFN_vkCmdPipelineBarrier(unsafe.Pointer(p)), c.commandBuffer, c.srcStageMask, c.dstStageMask, c.dependencyFlags, c.memoryBarrierCount, c.pMemoryBarriers, c.bufferMemoryBarrierCount, c.pBufferMemoryBarriers, c.imageMemoryBarrierCount, c.pImageMemoryBarriers)
	}
}

type PFNCmdBeginQuery C.PFN_vkCmdBeginQuery
type FuncCmdBeginQuery func(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags)

func ToCmdBeginQuery(p PFNVoidFunction) (fn FuncCmdBeginQuery) {
	return func(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			queryPool     C.VkQueryPool
			query         C.uint32_t
			flags         C.VkQueryControlFlags
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.queryPool = C.VkQueryPool(queryPool)
		c.query = C.uint32_t(query)
		{
			var temp_in_VkQueryControlFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkQueryControlFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkQueryControlFlags(temp_in_VkQueryControlFlags)
		}
		C.callPFN_vkCmdBeginQuery(C.PFN_vkCmdBeginQuery(unsafe.Pointer(p)), c.commandBuffer, c.queryPool, c.query, c.flags)
	}
}

type PFNCmdEndQuery C.PFN_vkCmdEndQuery
type FuncCmdEndQuery func(commandBuffer CommandBuffer, queryPool QueryPool, query uint32)

func ToCmdEndQuery(p PFNVoidFunction) (fn FuncCmdEndQuery) {
	return func(commandBuffer CommandBuffer, queryPool QueryPool, query uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			queryPool     C.VkQueryPool
			query         C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.queryPool = C.VkQueryPool(queryPool)
		c.query = C.uint32_t(query)
		C.callPFN_vkCmdEndQuery(C.PFN_vkCmdEndQuery(unsafe.Pointer(p)), c.commandBuffer, c.queryPool, c.query)
	}
}

type PFNCmdResetQueryPool C.PFN_vkCmdResetQueryPool
type FuncCmdResetQueryPool func(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32)

func ToCmdResetQueryPool(p PFNVoidFunction) (fn FuncCmdResetQueryPool) {
	return func(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			queryPool     C.VkQueryPool
			firstQuery    C.uint32_t
			queryCount    C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.queryPool = C.VkQueryPool(queryPool)
		c.firstQuery = C.uint32_t(firstQuery)
		c.queryCount = C.uint32_t(queryCount)
		C.callPFN_vkCmdResetQueryPool(C.PFN_vkCmdResetQueryPool(unsafe.Pointer(p)), c.commandBuffer, c.queryPool, c.firstQuery, c.queryCount)
	}
}

type PFNCmdWriteTimestamp C.PFN_vkCmdWriteTimestamp
type FuncCmdWriteTimestamp func(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32)

func ToCmdWriteTimestamp(p PFNVoidFunction) (fn FuncCmdWriteTimestamp) {
	return func(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pipelineStage C.VkPipelineStageFlagBits
			queryPool     C.VkQueryPool
			query         C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pipelineStage = C.VkPipelineStageFlagBits(pipelineStage)
		c.queryPool = C.VkQueryPool(queryPool)
		c.query = C.uint32_t(query)
		C.callPFN_vkCmdWriteTimestamp(C.PFN_vkCmdWriteTimestamp(unsafe.Pointer(p)), c.commandBuffer, c.pipelineStage, c.queryPool, c.query)
	}
}

type PFNCmdCopyQueryPoolResults C.PFN_vkCmdCopyQueryPoolResults
type FuncCmdCopyQueryPoolResults func(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags)

func ToCmdCopyQueryPoolResults(p PFNVoidFunction) (fn FuncCmdCopyQueryPoolResults) {
	return func(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			queryPool     C.VkQueryPool
			firstQuery    C.uint32_t
			queryCount    C.uint32_t
			dstBuffer     C.VkBuffer
			dstOffset     C.VkDeviceSize
			stride        C.VkDeviceSize
			flags         C.VkQueryResultFlags
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.queryPool = C.VkQueryPool(queryPool)
		c.firstQuery = C.uint32_t(firstQuery)
		c.queryCount = C.uint32_t(queryCount)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
			c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(stride))
			c.stride = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		{
			var temp_in_VkQueryResultFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkQueryResultFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkQueryResultFlags(temp_in_VkQueryResultFlags)
		}
		C.callPFN_vkCmdCopyQueryPoolResults(C.PFN_vkCmdCopyQueryPoolResults(unsafe.Pointer(p)), c.commandBuffer, c.queryPool, c.firstQuery, c.queryCount, c.dstBuffer, c.dstOffset, c.stride, c.flags)
	}
}

type PFNCmdPushConstants C.PFN_vkCmdPushConstants
type FuncCmdPushConstants func(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte)

func ToCmdPushConstants(p PFNVoidFunction) (fn FuncCmdPushConstants) {
	return func(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			layout        C.VkPipelineLayout
			stageFlags    C.VkShaderStageFlags
			offset        C.uint32_t
			size          C.uint32_t
			pValues       unsafe.Pointer
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.layout = C.VkPipelineLayout(layout)
		{
			var temp_in_VkShaderStageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageFlags)))
				temp_in_VkShaderStageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.stageFlags = C.VkShaderStageFlags(temp_in_VkShaderStageFlags)
		}
		c.offset = C.uint32_t(offset)
		c.size = C.uint32_t(len(values))
		if len(values) != 0 {
			c.pValues = m.alloc(C.sizeof_char * uint(len(values)))
			slice1 := (*[1 << 31]byte)(c.pValues)[:len(values):len(values)]
			for i1, _ := range values {
				slice1[i1] = values[i1]
			}
		} else {
			c.pValues = nil
		}
		C.callPFN_vkCmdPushConstants(C.PFN_vkCmdPushConstants(unsafe.Pointer(p)), c.commandBuffer, c.layout, c.stageFlags, c.offset, c.size, c.pValues)
	}
}

type PFNCmdBeginRenderPass C.PFN_vkCmdBeginRenderPass
type RenderPassBeginInfo struct {
	Next        Structure
	RenderPass  RenderPass
	Framebuffer Framebuffer
	RenderArea  Rect2D
	ClearValues []ClearValue
}

func (g *RenderPassBeginInfo) toC(c *C.VkRenderPassBeginInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.renderPass = C.VkRenderPass(g.RenderPass)
	c.framebuffer = C.VkFramebuffer(g.Framebuffer)
	g.RenderArea.toC(&c.renderArea)
	c.clearValueCount = C.uint32_t(len(g.ClearValues))
	if len(g.ClearValues) != 0 {
		c.pClearValues = (*C.VkClearValue)(m.alloc(C.sizeof_VkClearValue * uint(len(g.ClearValues))))
		slice1 := (*[1 << 31]C.VkClearValue)(unsafe.Pointer(c.pClearValues))[:len(g.ClearValues):len(g.ClearValues)]
		for i1, _ := range g.ClearValues {
			slice1[i1] = C.VkClearValue(g.ClearValues[i1])
		}
	} else {
		c.pClearValues = nil
	}
}
func (g *RenderPassBeginInfo) fromC(c *C.VkRenderPassBeginInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.RenderPass = RenderPass(c.renderPass)
	g.Framebuffer = Framebuffer(c.framebuffer)
	g.RenderArea.fromC(&c.renderArea)
	g.ClearValues = make([]ClearValue, int(c.clearValueCount))
	if len(g.ClearValues) != 0 {
		slice1 := (*[1 << 31]C.VkClearValue)(unsafe.Pointer(c.pClearValues))[:len(g.ClearValues):len(g.ClearValues)]
		for i1, _ := range g.ClearValues {
			g.ClearValues[i1] = ClearValue(slice1[i1])
		}
	}
}
func (s *RenderPassBeginInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
}
func (s *RenderPassBeginInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkRenderPassBeginInfo)(m.alloc(C.sizeof_VkRenderPassBeginInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *RenderPassBeginInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkRenderPassBeginInfo)(p)
	s.fromC(c)
}
func (s *RenderPassBeginInfo) GetNext() Structure {
	return s.Next
}
func (s *RenderPassBeginInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdBeginRenderPass func(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents)

func ToCmdBeginRenderPass(p PFNVoidFunction) (fn FuncCmdBeginRenderPass) {
	return func(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
		var c struct {
			commandBuffer    C.VkCommandBuffer
			pRenderPassBegin *C.VkRenderPassBeginInfo
			contents         C.VkSubpassContents
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if renderPassBegin != nil {
			c.pRenderPassBegin = (*C.VkRenderPassBeginInfo)(m.alloc(C.sizeof_VkRenderPassBeginInfo))
			renderPassBegin.toC(c.pRenderPassBegin, m)
		} else {
			c.pRenderPassBegin = nil
		}
		c.contents = C.VkSubpassContents(contents)
		C.callPFN_vkCmdBeginRenderPass(C.PFN_vkCmdBeginRenderPass(unsafe.Pointer(p)), c.commandBuffer, c.pRenderPassBegin, c.contents)
	}
}

type PFNCmdNextSubpass C.PFN_vkCmdNextSubpass
type FuncCmdNextSubpass func(commandBuffer CommandBuffer, contents SubpassContents)

func ToCmdNextSubpass(p PFNVoidFunction) (fn FuncCmdNextSubpass) {
	return func(commandBuffer CommandBuffer, contents SubpassContents) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			contents      C.VkSubpassContents
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.contents = C.VkSubpassContents(contents)
		C.callPFN_vkCmdNextSubpass(C.PFN_vkCmdNextSubpass(unsafe.Pointer(p)), c.commandBuffer, c.contents)
	}
}

type PFNCmdEndRenderPass C.PFN_vkCmdEndRenderPass
type FuncCmdEndRenderPass func(commandBuffer CommandBuffer)

func ToCmdEndRenderPass(p PFNVoidFunction) (fn FuncCmdEndRenderPass) {
	return func(commandBuffer CommandBuffer) {
		var c struct{ commandBuffer C.VkCommandBuffer }
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		C.callPFN_vkCmdEndRenderPass(C.PFN_vkCmdEndRenderPass(unsafe.Pointer(p)), c.commandBuffer)
	}
}

type PFNCmdExecuteCommands C.PFN_vkCmdExecuteCommands
type FuncCmdExecuteCommands func(commandBuffer CommandBuffer, commandBuffers []CommandBuffer)

func ToCmdExecuteCommands(p PFNVoidFunction) (fn FuncCmdExecuteCommands) {
	return func(commandBuffer CommandBuffer, commandBuffers []CommandBuffer) {
		var c struct {
			commandBuffer      C.VkCommandBuffer
			commandBufferCount C.uint32_t
			pCommandBuffers    *C.VkCommandBuffer
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.commandBufferCount = C.uint32_t(len(commandBuffers))
		if len(commandBuffers) != 0 {
			c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer * uint(len(commandBuffers))))
			slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(commandBuffers):len(commandBuffers)]
			for i1, _ := range commandBuffers {
				slice1[i1] = C.VkCommandBuffer(commandBuffers[i1])
			}
		} else {
			c.pCommandBuffers = nil
		}
		C.callPFN_vkCmdExecuteCommands(C.PFN_vkCmdExecuteCommands(unsafe.Pointer(p)), c.commandBuffer, c.commandBufferCount, c.pCommandBuffers)
	}
}
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks, instance *Instance) (_ret Result) {
	var c struct {
		pCreateInfo *C.VkInstanceCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pInstance   *C.VkInstance
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkInstanceCreateInfo)(m.alloc(C.sizeof_VkInstanceCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if instance != nil {
		c.pInstance = (*C.VkInstance)(m.alloc(C.sizeof_VkInstance))
		*c.pInstance = C.VkInstance(*instance)
	} else {
		c.pInstance = nil
	}
	c._ret = C.vkCreateInstance(c.pCreateInfo, c.pAllocator, c.pInstance)
	_ret = Result(c._ret)
	if instance != nil {
		*instance = Instance(*c.pInstance)
	}
	return
}
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	var c struct {
		instance   C.VkInstance
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.instance = C.VkInstance(instance)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyInstance(c.instance, c.pAllocator)
}
func EnumeratePhysicalDevices(instance Instance, physicalDeviceCount *uint32, physicalDevices []PhysicalDevice) (_ret Result) {
	var c struct {
		instance             C.VkInstance
		pPhysicalDeviceCount *C.uint32_t
		pPhysicalDevices     *C.VkPhysicalDevice
		_ret                 C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.instance = C.VkInstance(instance)
	if physicalDeviceCount != nil {
		c.pPhysicalDeviceCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPhysicalDeviceCount = C.uint32_t(*physicalDeviceCount)
	} else {
		c.pPhysicalDeviceCount = nil
	}
	if len(physicalDevices) != 0 {
		c.pPhysicalDevices = (*C.VkPhysicalDevice)(m.alloc(C.sizeof_VkPhysicalDevice * uint(len(physicalDevices))))
		slice1 := (*[1 << 31]C.VkPhysicalDevice)(unsafe.Pointer(c.pPhysicalDevices))[:len(physicalDevices):len(physicalDevices)]
		for i1, _ := range physicalDevices {
			slice1[i1] = C.VkPhysicalDevice(physicalDevices[i1])
		}
	} else {
		c.pPhysicalDevices = nil
	}
	c._ret = C.vkEnumeratePhysicalDevices(c.instance, c.pPhysicalDeviceCount, c.pPhysicalDevices)
	_ret = Result(c._ret)
	if physicalDeviceCount != nil {
		*physicalDeviceCount = uint32(*c.pPhysicalDeviceCount)
	}
	if len(physicalDevices) != 0 {
		slice1 := (*[1 << 31]C.VkPhysicalDevice)(unsafe.Pointer(c.pPhysicalDevices))[:len(physicalDevices):len(physicalDevices)]
		for i1, _ := range physicalDevices {
			physicalDevices[i1] = PhysicalDevice(slice1[i1])
		}
	}
	return
}
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pFeatures      *C.VkPhysicalDeviceFeatures
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if features != nil {
		c.pFeatures = (*C.VkPhysicalDeviceFeatures)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures))
		features.toC(c.pFeatures)
	} else {
		c.pFeatures = nil
	}
	C.vkGetPhysicalDeviceFeatures(c.physicalDevice, c.pFeatures)
	if features != nil {
		features.fromC(c.pFeatures)
	}
}
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties) {
	var c struct {
		physicalDevice    C.VkPhysicalDevice
		format            C.VkFormat
		pFormatProperties *C.VkFormatProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	c.format = C.VkFormat(format)
	if formatProperties != nil {
		c.pFormatProperties = (*C.VkFormatProperties)(m.alloc(C.sizeof_VkFormatProperties))
		formatProperties.toC(c.pFormatProperties)
	} else {
		c.pFormatProperties = nil
	}
	C.vkGetPhysicalDeviceFormatProperties(c.physicalDevice, c.format, c.pFormatProperties)
	if formatProperties != nil {
		formatProperties.fromC(c.pFormatProperties)
	}
}
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, _type ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, imageFormatProperties *ImageFormatProperties) (_ret Result) {
	var c struct {
		physicalDevice         C.VkPhysicalDevice
		format                 C.VkFormat
		_type                  C.VkImageType
		tiling                 C.VkImageTiling
		usage                  C.VkImageUsageFlags
		flags                  C.VkImageCreateFlags
		pImageFormatProperties *C.VkImageFormatProperties
		_ret                   C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	c.format = C.VkFormat(format)
	c._type = C.VkImageType(_type)
	c.tiling = C.VkImageTiling(tiling)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(usage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	{
		var temp_in_VkImageCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkImageCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkImageCreateFlags(temp_in_VkImageCreateFlags)
	}
	if imageFormatProperties != nil {
		c.pImageFormatProperties = (*C.VkImageFormatProperties)(m.alloc(C.sizeof_VkImageFormatProperties))
		imageFormatProperties.toC(c.pImageFormatProperties)
	} else {
		c.pImageFormatProperties = nil
	}
	c._ret = C.vkGetPhysicalDeviceImageFormatProperties(c.physicalDevice, c.format, c._type, c.tiling, c.usage, c.flags, c.pImageFormatProperties)
	_ret = Result(c._ret)
	if imageFormatProperties != nil {
		imageFormatProperties.fromC(c.pImageFormatProperties)
	}
	return
}
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pProperties    *C.VkPhysicalDeviceProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if properties != nil {
		c.pProperties = (*C.VkPhysicalDeviceProperties)(m.alloc(C.sizeof_VkPhysicalDeviceProperties))
		properties.toC(c.pProperties)
	} else {
		c.pProperties = nil
	}
	C.vkGetPhysicalDeviceProperties(c.physicalDevice, c.pProperties)
	if properties != nil {
		properties.fromC(c.pProperties)
	}
}
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties) {
	var c struct {
		physicalDevice            C.VkPhysicalDevice
		pQueueFamilyPropertyCount *C.uint32_t
		pQueueFamilyProperties    *C.VkQueueFamilyProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if queueFamilyPropertyCount != nil {
		c.pQueueFamilyPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pQueueFamilyPropertyCount = C.uint32_t(*queueFamilyPropertyCount)
	} else {
		c.pQueueFamilyPropertyCount = nil
	}
	if len(queueFamilyProperties) != 0 {
		c.pQueueFamilyProperties = (*C.VkQueueFamilyProperties)(m.alloc(C.sizeof_VkQueueFamilyProperties * uint(len(queueFamilyProperties))))
		slice1 := (*[1 << 31]C.VkQueueFamilyProperties)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
		for i1, _ := range queueFamilyProperties {
			queueFamilyProperties[i1].toC(&slice1[i1])
		}
	} else {
		c.pQueueFamilyProperties = nil
	}
	C.vkGetPhysicalDeviceQueueFamilyProperties(c.physicalDevice, c.pQueueFamilyPropertyCount, c.pQueueFamilyProperties)
	if queueFamilyPropertyCount != nil {
		*queueFamilyPropertyCount = uint32(*c.pQueueFamilyPropertyCount)
	}
	if len(queueFamilyProperties) != 0 {
		slice1 := (*[1 << 31]C.VkQueueFamilyProperties)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
		for i1, _ := range queueFamilyProperties {
			queueFamilyProperties[i1].fromC(&slice1[i1])
		}
	}
}
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties) {
	var c struct {
		physicalDevice    C.VkPhysicalDevice
		pMemoryProperties *C.VkPhysicalDeviceMemoryProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if memoryProperties != nil {
		c.pMemoryProperties = (*C.VkPhysicalDeviceMemoryProperties)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties))
		memoryProperties.toC(c.pMemoryProperties)
	} else {
		c.pMemoryProperties = nil
	}
	C.vkGetPhysicalDeviceMemoryProperties(c.physicalDevice, c.pMemoryProperties)
	if memoryProperties != nil {
		memoryProperties.fromC(c.pMemoryProperties)
	}
}
func GetInstanceProcAddr(instance Instance, name string) (_ret PFNVoidFunction) {
	var c struct {
		instance C.VkInstance
		pName    *C.char
		_ret     C.PFN_vkVoidFunction
	}
	m := pool.take()
	defer pool.give(m)
	c.instance = C.VkInstance(instance)
	c.pName = toCString(name, m)
	c._ret = C.vkGetInstanceProcAddr(c.instance, c.pName)
	_ret = PFNVoidFunction(c._ret)
	return
}
func GetDeviceProcAddr(device Device, name string) (_ret PFNVoidFunction) {
	var c struct {
		device C.VkDevice
		pName  *C.char
		_ret   C.PFN_vkVoidFunction
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pName = toCString(name, m)
	c._ret = C.vkGetDeviceProcAddr(c.device, c.pName)
	_ret = PFNVoidFunction(c._ret)
	return
}
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks, device *Device) (_ret Result) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pCreateInfo    *C.VkDeviceCreateInfo
		pAllocator     *C.VkAllocationCallbacks
		pDevice        *C.VkDevice
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkDeviceCreateInfo)(m.alloc(C.sizeof_VkDeviceCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if device != nil {
		c.pDevice = (*C.VkDevice)(m.alloc(C.sizeof_VkDevice))
		*c.pDevice = C.VkDevice(*device)
	} else {
		c.pDevice = nil
	}
	c._ret = C.vkCreateDevice(c.physicalDevice, c.pCreateInfo, c.pAllocator, c.pDevice)
	_ret = Result(c._ret)
	if device != nil {
		*device = Device(*c.pDevice)
	}
	return
}
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyDevice(c.device, c.pAllocator)
}
func EnumerateInstanceExtensionProperties(layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result) {
	var c struct {
		pLayerName     *C.char
		pPropertyCount *C.uint32_t
		pProperties    *C.VkExtensionProperties
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.pLayerName = toCString(layerName, m)
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkExtensionProperties)(m.alloc(C.sizeof_VkExtensionProperties * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1])
		}
	} else {
		c.pProperties = nil
	}
	c._ret = C.vkEnumerateInstanceExtensionProperties(c.pLayerName, c.pPropertyCount, c.pProperties)
	_ret = Result(c._ret)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
	return
}
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string, propertyCount *uint32, properties []ExtensionProperties) (_ret Result) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pLayerName     *C.char
		pPropertyCount *C.uint32_t
		pProperties    *C.VkExtensionProperties
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	c.pLayerName = toCString(layerName, m)
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkExtensionProperties)(m.alloc(C.sizeof_VkExtensionProperties * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1])
		}
	} else {
		c.pProperties = nil
	}
	c._ret = C.vkEnumerateDeviceExtensionProperties(c.physicalDevice, c.pLayerName, c.pPropertyCount, c.pProperties)
	_ret = Result(c._ret)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkExtensionProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
	return
}
func EnumerateInstanceLayerProperties(propertyCount *uint32, properties []LayerProperties) (_ret Result) {
	var c struct {
		pPropertyCount *C.uint32_t
		pProperties    *C.VkLayerProperties
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkLayerProperties)(m.alloc(C.sizeof_VkLayerProperties * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1])
		}
	} else {
		c.pProperties = nil
	}
	c._ret = C.vkEnumerateInstanceLayerProperties(c.pPropertyCount, c.pProperties)
	_ret = Result(c._ret)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
	return
}
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice, propertyCount *uint32, properties []LayerProperties) (_ret Result) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pPropertyCount *C.uint32_t
		pProperties    *C.VkLayerProperties
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkLayerProperties)(m.alloc(C.sizeof_VkLayerProperties * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1])
		}
	} else {
		c.pProperties = nil
	}
	c._ret = C.vkEnumerateDeviceLayerProperties(c.physicalDevice, c.pPropertyCount, c.pProperties)
	_ret = Result(c._ret)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkLayerProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
	return
}
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32, queue *Queue) {
	var c struct {
		device           C.VkDevice
		queueFamilyIndex C.uint32_t
		queueIndex       C.uint32_t
		pQueue           *C.VkQueue
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.queueFamilyIndex = C.uint32_t(queueFamilyIndex)
	c.queueIndex = C.uint32_t(queueIndex)
	if queue != nil {
		c.pQueue = (*C.VkQueue)(m.alloc(C.sizeof_VkQueue))
		*c.pQueue = C.VkQueue(*queue)
	} else {
		c.pQueue = nil
	}
	C.vkGetDeviceQueue(c.device, c.queueFamilyIndex, c.queueIndex, c.pQueue)
	if queue != nil {
		*queue = Queue(*c.pQueue)
	}
}
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (_ret Result) {
	var c struct {
		queue       C.VkQueue
		submitCount C.uint32_t
		pSubmits    *C.VkSubmitInfo
		fence       C.VkFence
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.queue = C.VkQueue(queue)
	c.submitCount = C.uint32_t(len(submits))
	if len(submits) != 0 {
		c.pSubmits = (*C.VkSubmitInfo)(m.alloc(C.sizeof_VkSubmitInfo * uint(len(submits))))
		slice1 := (*[1 << 31]C.VkSubmitInfo)(unsafe.Pointer(c.pSubmits))[:len(submits):len(submits)]
		for i1, _ := range submits {
			submits[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pSubmits = nil
	}
	c.fence = C.VkFence(fence)
	c._ret = C.vkQueueSubmit(c.queue, c.submitCount, c.pSubmits, c.fence)
	_ret = Result(c._ret)
	return
}
func QueueWaitIdle(queue Queue) (_ret Result) {
	var c struct {
		queue C.VkQueue
		_ret  C.VkResult
	}
	c.queue = C.VkQueue(queue)
	c._ret = C.vkQueueWaitIdle(c.queue)
	_ret = Result(c._ret)
	return
}
func DeviceWaitIdle(device Device) (_ret Result) {
	var c struct {
		device C.VkDevice
		_ret   C.VkResult
	}
	c.device = C.VkDevice(device)
	c._ret = C.vkDeviceWaitIdle(c.device)
	_ret = Result(c._ret)
	return
}
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks, memory *DeviceMemory) (_ret Result) {
	var c struct {
		device        C.VkDevice
		pAllocateInfo *C.VkMemoryAllocateInfo
		pAllocator    *C.VkAllocationCallbacks
		pMemory       *C.VkDeviceMemory
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if allocateInfo != nil {
		c.pAllocateInfo = (*C.VkMemoryAllocateInfo)(m.alloc(C.sizeof_VkMemoryAllocateInfo))
		allocateInfo.toC(c.pAllocateInfo, m)
	} else {
		c.pAllocateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if memory != nil {
		c.pMemory = (*C.VkDeviceMemory)(m.alloc(C.sizeof_VkDeviceMemory))
		*c.pMemory = C.VkDeviceMemory(*memory)
	} else {
		c.pMemory = nil
	}
	c._ret = C.vkAllocateMemory(c.device, c.pAllocateInfo, c.pAllocator, c.pMemory)
	_ret = Result(c._ret)
	if memory != nil {
		*memory = DeviceMemory(*c.pMemory)
	}
	return
}
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		memory     C.VkDeviceMemory
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.memory = C.VkDeviceMemory(memory)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkFreeMemory(c.device, c.memory, c.pAllocator)
}
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, data *unsafe.Pointer) (_ret Result) {
	var c struct {
		device C.VkDevice
		memory C.VkDeviceMemory
		offset C.VkDeviceSize
		size   C.VkDeviceSize
		flags  C.VkMemoryMapFlags
		ppData *unsafe.Pointer
		_ret   C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.memory = C.VkDeviceMemory(memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkMemoryMapFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkMemoryMapFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkMemoryMapFlags(temp_in_VkMemoryMapFlags)
	}
	if data != nil {
		c.ppData = (*unsafe.Pointer)(m.alloc(C.sizeof_void_pointer))
		*c.ppData = *data
	} else {
		c.ppData = nil
	}
	c._ret = C.vkMapMemory(c.device, c.memory, c.offset, c.size, c.flags, c.ppData)
	_ret = Result(c._ret)
	if data != nil {
		*data = *c.ppData
	}
	return
}
func UnmapMemory(device Device, memory DeviceMemory) {
	var c struct {
		device C.VkDevice
		memory C.VkDeviceMemory
	}
	c.device = C.VkDevice(device)
	c.memory = C.VkDeviceMemory(memory)
	C.vkUnmapMemory(c.device, c.memory)
}
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (_ret Result) {
	var c struct {
		device           C.VkDevice
		memoryRangeCount C.uint32_t
		pMemoryRanges    *C.VkMappedMemoryRange
		_ret             C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.memoryRangeCount = C.uint32_t(len(memoryRanges))
	if len(memoryRanges) != 0 {
		c.pMemoryRanges = (*C.VkMappedMemoryRange)(m.alloc(C.sizeof_VkMappedMemoryRange * uint(len(memoryRanges))))
		slice1 := (*[1 << 31]C.VkMappedMemoryRange)(unsafe.Pointer(c.pMemoryRanges))[:len(memoryRanges):len(memoryRanges)]
		for i1, _ := range memoryRanges {
			memoryRanges[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pMemoryRanges = nil
	}
	c._ret = C.vkFlushMappedMemoryRanges(c.device, c.memoryRangeCount, c.pMemoryRanges)
	_ret = Result(c._ret)
	return
}
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (_ret Result) {
	var c struct {
		device           C.VkDevice
		memoryRangeCount C.uint32_t
		pMemoryRanges    *C.VkMappedMemoryRange
		_ret             C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.memoryRangeCount = C.uint32_t(len(memoryRanges))
	if len(memoryRanges) != 0 {
		c.pMemoryRanges = (*C.VkMappedMemoryRange)(m.alloc(C.sizeof_VkMappedMemoryRange * uint(len(memoryRanges))))
		slice1 := (*[1 << 31]C.VkMappedMemoryRange)(unsafe.Pointer(c.pMemoryRanges))[:len(memoryRanges):len(memoryRanges)]
		for i1, _ := range memoryRanges {
			memoryRanges[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pMemoryRanges = nil
	}
	c._ret = C.vkInvalidateMappedMemoryRanges(c.device, c.memoryRangeCount, c.pMemoryRanges)
	_ret = Result(c._ret)
	return
}
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory, committedMemoryInBytes *DeviceSize) {
	var c struct {
		device                  C.VkDevice
		memory                  C.VkDeviceMemory
		pCommittedMemoryInBytes *C.VkDeviceSize
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.memory = C.VkDeviceMemory(memory)
	if committedMemoryInBytes != nil {
		c.pCommittedMemoryInBytes = (*C.VkDeviceSize)(m.alloc(C.sizeof_VkDeviceSize))
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(*committedMemoryInBytes))
			*c.pCommittedMemoryInBytes = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
	} else {
		c.pCommittedMemoryInBytes = nil
	}
	C.vkGetDeviceMemoryCommitment(c.device, c.memory, c.pCommittedMemoryInBytes)
	if committedMemoryInBytes != nil {
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(*c.pCommittedMemoryInBytes))
		*committedMemoryInBytes = DeviceSize(temp_in_VkDeviceSize)
	}
}
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result) {
	var c struct {
		device       C.VkDevice
		buffer       C.VkBuffer
		memory       C.VkDeviceMemory
		memoryOffset C.VkDeviceSize
		_ret         C.VkResult
	}
	c.device = C.VkDevice(device)
	c.buffer = C.VkBuffer(buffer)
	c.memory = C.VkDeviceMemory(memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(memoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c._ret = C.vkBindBufferMemory(c.device, c.buffer, c.memory, c.memoryOffset)
	_ret = Result(c._ret)
	return
}
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (_ret Result) {
	var c struct {
		device       C.VkDevice
		image        C.VkImage
		memory       C.VkDeviceMemory
		memoryOffset C.VkDeviceSize
		_ret         C.VkResult
	}
	c.device = C.VkDevice(device)
	c.image = C.VkImage(image)
	c.memory = C.VkDeviceMemory(memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(memoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c._ret = C.vkBindImageMemory(c.device, c.image, c.memory, c.memoryOffset)
	_ret = Result(c._ret)
	return
}
func GetBufferMemoryRequirements(device Device, buffer Buffer, memoryRequirements *MemoryRequirements) {
	var c struct {
		device              C.VkDevice
		buffer              C.VkBuffer
		pMemoryRequirements *C.VkMemoryRequirements
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.buffer = C.VkBuffer(buffer)
	if memoryRequirements != nil {
		c.pMemoryRequirements = (*C.VkMemoryRequirements)(m.alloc(C.sizeof_VkMemoryRequirements))
		memoryRequirements.toC(c.pMemoryRequirements)
	} else {
		c.pMemoryRequirements = nil
	}
	C.vkGetBufferMemoryRequirements(c.device, c.buffer, c.pMemoryRequirements)
	if memoryRequirements != nil {
		memoryRequirements.fromC(c.pMemoryRequirements)
	}
}
func GetImageMemoryRequirements(device Device, image Image, memoryRequirements *MemoryRequirements) {
	var c struct {
		device              C.VkDevice
		image               C.VkImage
		pMemoryRequirements *C.VkMemoryRequirements
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.image = C.VkImage(image)
	if memoryRequirements != nil {
		c.pMemoryRequirements = (*C.VkMemoryRequirements)(m.alloc(C.sizeof_VkMemoryRequirements))
		memoryRequirements.toC(c.pMemoryRequirements)
	} else {
		c.pMemoryRequirements = nil
	}
	C.vkGetImageMemoryRequirements(c.device, c.image, c.pMemoryRequirements)
	if memoryRequirements != nil {
		memoryRequirements.fromC(c.pMemoryRequirements)
	}
}
func GetImageSparseMemoryRequirements(device Device, image Image, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements) {
	var c struct {
		device                        C.VkDevice
		image                         C.VkImage
		pSparseMemoryRequirementCount *C.uint32_t
		pSparseMemoryRequirements     *C.VkSparseImageMemoryRequirements
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.image = C.VkImage(image)
	if sparseMemoryRequirementCount != nil {
		c.pSparseMemoryRequirementCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pSparseMemoryRequirementCount = C.uint32_t(*sparseMemoryRequirementCount)
	} else {
		c.pSparseMemoryRequirementCount = nil
	}
	if len(sparseMemoryRequirements) != 0 {
		c.pSparseMemoryRequirements = (*C.VkSparseImageMemoryRequirements)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements * uint(len(sparseMemoryRequirements))))
		slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
		for i1, _ := range sparseMemoryRequirements {
			sparseMemoryRequirements[i1].toC(&slice1[i1])
		}
	} else {
		c.pSparseMemoryRequirements = nil
	}
	C.vkGetImageSparseMemoryRequirements(c.device, c.image, c.pSparseMemoryRequirementCount, c.pSparseMemoryRequirements)
	if sparseMemoryRequirementCount != nil {
		*sparseMemoryRequirementCount = uint32(*c.pSparseMemoryRequirementCount)
	}
	if len(sparseMemoryRequirements) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
		for i1, _ := range sparseMemoryRequirements {
			sparseMemoryRequirements[i1].fromC(&slice1[i1])
		}
	}
}
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, _type ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, propertyCount *uint32, properties []SparseImageFormatProperties) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		format         C.VkFormat
		_type          C.VkImageType
		samples        C.VkSampleCountFlagBits
		usage          C.VkImageUsageFlags
		tiling         C.VkImageTiling
		pPropertyCount *C.uint32_t
		pProperties    *C.VkSparseImageFormatProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	c.format = C.VkFormat(format)
	c._type = C.VkImageType(_type)
	c.samples = C.VkSampleCountFlagBits(samples)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(usage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	c.tiling = C.VkImageTiling(tiling)
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkSparseImageFormatProperties)(m.alloc(C.sizeof_VkSparseImageFormatProperties * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkSparseImageFormatProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1])
		}
	} else {
		c.pProperties = nil
	}
	C.vkGetPhysicalDeviceSparseImageFormatProperties(c.physicalDevice, c.format, c._type, c.samples, c.usage, c.tiling, c.pPropertyCount, c.pProperties)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageFormatProperties)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
}
func QueueBindSparse(queue Queue, bindInfoCount uint32, bindInfo *BindSparseInfo, fence Fence) (_ret Result) {
	var c struct {
		queue         C.VkQueue
		bindInfoCount C.uint32_t
		pBindInfo     *C.VkBindSparseInfo
		fence         C.VkFence
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.queue = C.VkQueue(queue)
	c.bindInfoCount = C.uint32_t(bindInfoCount)
	if bindInfo != nil {
		c.pBindInfo = (*C.VkBindSparseInfo)(m.alloc(C.sizeof_VkBindSparseInfo))
		bindInfo.toC(c.pBindInfo, m)
	} else {
		c.pBindInfo = nil
	}
	c.fence = C.VkFence(fence)
	c._ret = C.vkQueueBindSparse(c.queue, c.bindInfoCount, c.pBindInfo, c.fence)
	_ret = Result(c._ret)
	return
}
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks, fence *Fence) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkFenceCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pFence      *C.VkFence
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkFenceCreateInfo)(m.alloc(C.sizeof_VkFenceCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if fence != nil {
		c.pFence = (*C.VkFence)(m.alloc(C.sizeof_VkFence))
		*c.pFence = C.VkFence(*fence)
	} else {
		c.pFence = nil
	}
	c._ret = C.vkCreateFence(c.device, c.pCreateInfo, c.pAllocator, c.pFence)
	_ret = Result(c._ret)
	if fence != nil {
		*fence = Fence(*c.pFence)
	}
	return
}
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		fence      C.VkFence
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.fence = C.VkFence(fence)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyFence(c.device, c.fence, c.pAllocator)
}
func ResetFences(device Device, fences []Fence) (_ret Result) {
	var c struct {
		device     C.VkDevice
		fenceCount C.uint32_t
		pFences    *C.VkFence
		_ret       C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.fenceCount = C.uint32_t(len(fences))
	if len(fences) != 0 {
		c.pFences = (*C.VkFence)(m.alloc(C.sizeof_VkFence * uint(len(fences))))
		slice1 := (*[1 << 31]C.VkFence)(unsafe.Pointer(c.pFences))[:len(fences):len(fences)]
		for i1, _ := range fences {
			slice1[i1] = C.VkFence(fences[i1])
		}
	} else {
		c.pFences = nil
	}
	c._ret = C.vkResetFences(c.device, c.fenceCount, c.pFences)
	_ret = Result(c._ret)
	return
}
func GetFenceStatus(device Device, fence Fence) (_ret Result) {
	var c struct {
		device C.VkDevice
		fence  C.VkFence
		_ret   C.VkResult
	}
	c.device = C.VkDevice(device)
	c.fence = C.VkFence(fence)
	c._ret = C.vkGetFenceStatus(c.device, c.fence)
	_ret = Result(c._ret)
	return
}
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (_ret Result) {
	var c struct {
		device     C.VkDevice
		fenceCount C.uint32_t
		pFences    *C.VkFence
		waitAll    C.VkBool32
		timeout    C.uint64_t
		_ret       C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.fenceCount = C.uint32_t(len(fences))
	if len(fences) != 0 {
		c.pFences = (*C.VkFence)(m.alloc(C.sizeof_VkFence * uint(len(fences))))
		slice1 := (*[1 << 31]C.VkFence)(unsafe.Pointer(c.pFences))[:len(fences):len(fences)]
		for i1, _ := range fences {
			slice1[i1] = C.VkFence(fences[i1])
		}
	} else {
		c.pFences = nil
	}
	if waitAll {
		c.waitAll = 1
	} else {
		c.waitAll = 0
	}
	c.timeout = C.uint64_t(timeout)
	c._ret = C.vkWaitForFences(c.device, c.fenceCount, c.pFences, c.waitAll, c.timeout)
	_ret = Result(c._ret)
	return
}
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks, semaphore *Semaphore) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkSemaphoreCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pSemaphore  *C.VkSemaphore
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkSemaphoreCreateInfo)(m.alloc(C.sizeof_VkSemaphoreCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if semaphore != nil {
		c.pSemaphore = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore))
		*c.pSemaphore = C.VkSemaphore(*semaphore)
	} else {
		c.pSemaphore = nil
	}
	c._ret = C.vkCreateSemaphore(c.device, c.pCreateInfo, c.pAllocator, c.pSemaphore)
	_ret = Result(c._ret)
	if semaphore != nil {
		*semaphore = Semaphore(*c.pSemaphore)
	}
	return
}
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		semaphore  C.VkSemaphore
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.semaphore = C.VkSemaphore(semaphore)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroySemaphore(c.device, c.semaphore, c.pAllocator)
}
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks, event *Event) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkEventCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pEvent      *C.VkEvent
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkEventCreateInfo)(m.alloc(C.sizeof_VkEventCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if event != nil {
		c.pEvent = (*C.VkEvent)(m.alloc(C.sizeof_VkEvent))
		*c.pEvent = C.VkEvent(*event)
	} else {
		c.pEvent = nil
	}
	c._ret = C.vkCreateEvent(c.device, c.pCreateInfo, c.pAllocator, c.pEvent)
	_ret = Result(c._ret)
	if event != nil {
		*event = Event(*c.pEvent)
	}
	return
}
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		event      C.VkEvent
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.event = C.VkEvent(event)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyEvent(c.device, c.event, c.pAllocator)
}
func GetEventStatus(device Device, event Event) (_ret Result) {
	var c struct {
		device C.VkDevice
		event  C.VkEvent
		_ret   C.VkResult
	}
	c.device = C.VkDevice(device)
	c.event = C.VkEvent(event)
	c._ret = C.vkGetEventStatus(c.device, c.event)
	_ret = Result(c._ret)
	return
}
func SetEvent(device Device, event Event) (_ret Result) {
	var c struct {
		device C.VkDevice
		event  C.VkEvent
		_ret   C.VkResult
	}
	c.device = C.VkDevice(device)
	c.event = C.VkEvent(event)
	c._ret = C.vkSetEvent(c.device, c.event)
	_ret = Result(c._ret)
	return
}
func ResetEvent(device Device, event Event) (_ret Result) {
	var c struct {
		device C.VkDevice
		event  C.VkEvent
		_ret   C.VkResult
	}
	c.device = C.VkDevice(device)
	c.event = C.VkEvent(event)
	c._ret = C.vkResetEvent(c.device, c.event)
	_ret = Result(c._ret)
	return
}
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks, queryPool *QueryPool) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkQueryPoolCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pQueryPool  *C.VkQueryPool
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkQueryPoolCreateInfo)(m.alloc(C.sizeof_VkQueryPoolCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if queryPool != nil {
		c.pQueryPool = (*C.VkQueryPool)(m.alloc(C.sizeof_VkQueryPool))
		*c.pQueryPool = C.VkQueryPool(*queryPool)
	} else {
		c.pQueryPool = nil
	}
	c._ret = C.vkCreateQueryPool(c.device, c.pCreateInfo, c.pAllocator, c.pQueryPool)
	_ret = Result(c._ret)
	if queryPool != nil {
		*queryPool = QueryPool(*c.pQueryPool)
	}
	return
}
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		queryPool  C.VkQueryPool
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.queryPool = C.VkQueryPool(queryPool)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyQueryPool(c.device, c.queryPool, c.pAllocator)
}
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (_ret Result) {
	var c struct {
		device     C.VkDevice
		queryPool  C.VkQueryPool
		firstQuery C.uint32_t
		queryCount C.uint32_t
		dataSize   C.size_t
		pData      unsafe.Pointer
		stride     C.VkDeviceSize
		flags      C.VkQueryResultFlags
		_ret       C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.queryPool = C.VkQueryPool(queryPool)
	c.firstQuery = C.uint32_t(firstQuery)
	c.queryCount = C.uint32_t(queryCount)
	c.dataSize = C.size_t(len(data))
	if len(data) != 0 {
		c.pData = m.alloc(C.sizeof_char * uint(len(data)))
		slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
		for i1, _ := range data {
			slice1[i1] = data[i1]
		}
	} else {
		c.pData = nil
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(stride))
		c.stride = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkQueryResultFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkQueryResultFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkQueryResultFlags(temp_in_VkQueryResultFlags)
	}
	c._ret = C.vkGetQueryPoolResults(c.device, c.queryPool, c.firstQuery, c.queryCount, c.dataSize, c.pData, c.stride, c.flags)
	_ret = Result(c._ret)
	if len(data) != 0 {
		slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
		for i1, _ := range data {
			data[i1] = slice1[i1]
		}
	}
	return
}
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks, buffer *Buffer) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkBufferCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pBuffer     *C.VkBuffer
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkBufferCreateInfo)(m.alloc(C.sizeof_VkBufferCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if buffer != nil {
		c.pBuffer = (*C.VkBuffer)(m.alloc(C.sizeof_VkBuffer))
		*c.pBuffer = C.VkBuffer(*buffer)
	} else {
		c.pBuffer = nil
	}
	c._ret = C.vkCreateBuffer(c.device, c.pCreateInfo, c.pAllocator, c.pBuffer)
	_ret = Result(c._ret)
	if buffer != nil {
		*buffer = Buffer(*c.pBuffer)
	}
	return
}
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		buffer     C.VkBuffer
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.buffer = C.VkBuffer(buffer)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyBuffer(c.device, c.buffer, c.pAllocator)
}
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks, view *BufferView) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkBufferViewCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pView       *C.VkBufferView
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkBufferViewCreateInfo)(m.alloc(C.sizeof_VkBufferViewCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if view != nil {
		c.pView = (*C.VkBufferView)(m.alloc(C.sizeof_VkBufferView))
		*c.pView = C.VkBufferView(*view)
	} else {
		c.pView = nil
	}
	c._ret = C.vkCreateBufferView(c.device, c.pCreateInfo, c.pAllocator, c.pView)
	_ret = Result(c._ret)
	if view != nil {
		*view = BufferView(*c.pView)
	}
	return
}
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		bufferView C.VkBufferView
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.bufferView = C.VkBufferView(bufferView)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyBufferView(c.device, c.bufferView, c.pAllocator)
}
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks, image *Image) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkImageCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pImage      *C.VkImage
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkImageCreateInfo)(m.alloc(C.sizeof_VkImageCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if image != nil {
		c.pImage = (*C.VkImage)(m.alloc(C.sizeof_VkImage))
		*c.pImage = C.VkImage(*image)
	} else {
		c.pImage = nil
	}
	c._ret = C.vkCreateImage(c.device, c.pCreateInfo, c.pAllocator, c.pImage)
	_ret = Result(c._ret)
	if image != nil {
		*image = Image(*c.pImage)
	}
	return
}
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		image      C.VkImage
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.image = C.VkImage(image)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyImage(c.device, c.image, c.pAllocator)
}
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource, layout *SubresourceLayout) {
	var c struct {
		device       C.VkDevice
		image        C.VkImage
		pSubresource *C.VkImageSubresource
		pLayout      *C.VkSubresourceLayout
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.image = C.VkImage(image)
	if subresource != nil {
		c.pSubresource = (*C.VkImageSubresource)(m.alloc(C.sizeof_VkImageSubresource))
		subresource.toC(c.pSubresource)
	} else {
		c.pSubresource = nil
	}
	if layout != nil {
		c.pLayout = (*C.VkSubresourceLayout)(m.alloc(C.sizeof_VkSubresourceLayout))
		layout.toC(c.pLayout)
	} else {
		c.pLayout = nil
	}
	C.vkGetImageSubresourceLayout(c.device, c.image, c.pSubresource, c.pLayout)
	if layout != nil {
		layout.fromC(c.pLayout)
	}
}
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks, view *ImageView) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkImageViewCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pView       *C.VkImageView
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkImageViewCreateInfo)(m.alloc(C.sizeof_VkImageViewCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if view != nil {
		c.pView = (*C.VkImageView)(m.alloc(C.sizeof_VkImageView))
		*c.pView = C.VkImageView(*view)
	} else {
		c.pView = nil
	}
	c._ret = C.vkCreateImageView(c.device, c.pCreateInfo, c.pAllocator, c.pView)
	_ret = Result(c._ret)
	if view != nil {
		*view = ImageView(*c.pView)
	}
	return
}
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		imageView  C.VkImageView
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.imageView = C.VkImageView(imageView)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyImageView(c.device, c.imageView, c.pAllocator)
}
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks, shaderModule *ShaderModule) (_ret Result) {
	var c struct {
		device        C.VkDevice
		pCreateInfo   *C.VkShaderModuleCreateInfo
		pAllocator    *C.VkAllocationCallbacks
		pShaderModule *C.VkShaderModule
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkShaderModuleCreateInfo)(m.alloc(C.sizeof_VkShaderModuleCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if shaderModule != nil {
		c.pShaderModule = (*C.VkShaderModule)(m.alloc(C.sizeof_VkShaderModule))
		*c.pShaderModule = C.VkShaderModule(*shaderModule)
	} else {
		c.pShaderModule = nil
	}
	c._ret = C.vkCreateShaderModule(c.device, c.pCreateInfo, c.pAllocator, c.pShaderModule)
	_ret = Result(c._ret)
	if shaderModule != nil {
		*shaderModule = ShaderModule(*c.pShaderModule)
	}
	return
}
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	var c struct {
		device       C.VkDevice
		shaderModule C.VkShaderModule
		pAllocator   *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.shaderModule = C.VkShaderModule(shaderModule)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyShaderModule(c.device, c.shaderModule, c.pAllocator)
}
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks, pipelineCache *PipelineCache) (_ret Result) {
	var c struct {
		device         C.VkDevice
		pCreateInfo    *C.VkPipelineCacheCreateInfo
		pAllocator     *C.VkAllocationCallbacks
		pPipelineCache *C.VkPipelineCache
		_ret           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkPipelineCacheCreateInfo)(m.alloc(C.sizeof_VkPipelineCacheCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if pipelineCache != nil {
		c.pPipelineCache = (*C.VkPipelineCache)(m.alloc(C.sizeof_VkPipelineCache))
		*c.pPipelineCache = C.VkPipelineCache(*pipelineCache)
	} else {
		c.pPipelineCache = nil
	}
	c._ret = C.vkCreatePipelineCache(c.device, c.pCreateInfo, c.pAllocator, c.pPipelineCache)
	_ret = Result(c._ret)
	if pipelineCache != nil {
		*pipelineCache = PipelineCache(*c.pPipelineCache)
	}
	return
}
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	var c struct {
		device        C.VkDevice
		pipelineCache C.VkPipelineCache
		pAllocator    *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipelineCache = C.VkPipelineCache(pipelineCache)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyPipelineCache(c.device, c.pipelineCache, c.pAllocator)
}
func GetPipelineCacheData(device Device, pipelineCache PipelineCache, dataSize *uint, data []byte) (_ret Result) {
	var c struct {
		device        C.VkDevice
		pipelineCache C.VkPipelineCache
		pDataSize     *C.size_t
		pData         unsafe.Pointer
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipelineCache = C.VkPipelineCache(pipelineCache)
	if dataSize != nil {
		c.pDataSize = (*C.size_t)(m.alloc(C.sizeof_size_t))
		*c.pDataSize = C.size_t(*dataSize)
	} else {
		c.pDataSize = nil
	}
	if len(data) != 0 {
		c.pData = m.alloc(C.sizeof_char * uint(len(data)))
		slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
		for i1, _ := range data {
			slice1[i1] = data[i1]
		}
	} else {
		c.pData = nil
	}
	c._ret = C.vkGetPipelineCacheData(c.device, c.pipelineCache, c.pDataSize, c.pData)
	_ret = Result(c._ret)
	if dataSize != nil {
		*dataSize = uint(*c.pDataSize)
	}
	if len(data) != 0 {
		slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
		for i1, _ := range data {
			data[i1] = slice1[i1]
		}
	}
	return
}
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (_ret Result) {
	var c struct {
		device        C.VkDevice
		dstCache      C.VkPipelineCache
		srcCacheCount C.uint32_t
		pSrcCaches    *C.VkPipelineCache
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.dstCache = C.VkPipelineCache(dstCache)
	c.srcCacheCount = C.uint32_t(len(srcCaches))
	if len(srcCaches) != 0 {
		c.pSrcCaches = (*C.VkPipelineCache)(m.alloc(C.sizeof_VkPipelineCache * uint(len(srcCaches))))
		slice1 := (*[1 << 31]C.VkPipelineCache)(unsafe.Pointer(c.pSrcCaches))[:len(srcCaches):len(srcCaches)]
		for i1, _ := range srcCaches {
			slice1[i1] = C.VkPipelineCache(srcCaches[i1])
		}
	} else {
		c.pSrcCaches = nil
	}
	c._ret = C.vkMergePipelineCaches(c.device, c.dstCache, c.srcCacheCount, c.pSrcCaches)
	_ret = Result(c._ret)
	return
}
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pipelineCache   C.VkPipelineCache
		createInfoCount C.uint32_t
		pCreateInfos    *C.VkGraphicsPipelineCreateInfo
		pAllocator      *C.VkAllocationCallbacks
		pPipelines      *C.VkPipeline
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipelineCache = C.VkPipelineCache(pipelineCache)
	c.createInfoCount = C.uint32_t(len(createInfos))
	if len(createInfos) != 0 {
		c.pCreateInfos = (*C.VkGraphicsPipelineCreateInfo)(m.alloc(C.sizeof_VkGraphicsPipelineCreateInfo * uint(len(createInfos))))
		slice1 := (*[1 << 31]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(c.pCreateInfos))[:len(createInfos):len(createInfos)]
		for i1, _ := range createInfos {
			createInfos[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pCreateInfos = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if len(pipelines) != 0 {
		c.pPipelines = (*C.VkPipeline)(m.alloc(C.sizeof_VkPipeline * uint(len(pipelines))))
		slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
		for i1, _ := range pipelines {
			slice1[i1] = C.VkPipeline(pipelines[i1])
		}
	} else {
		c.pPipelines = nil
	}
	c._ret = C.vkCreateGraphicsPipelines(c.device, c.pipelineCache, c.createInfoCount, c.pCreateInfos, c.pAllocator, c.pPipelines)
	_ret = Result(c._ret)
	if len(pipelines) != 0 {
		slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
		for i1, _ := range pipelines {
			pipelines[i1] = Pipeline(slice1[i1])
		}
	}
	return
}
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks, pipelines []Pipeline) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pipelineCache   C.VkPipelineCache
		createInfoCount C.uint32_t
		pCreateInfos    *C.VkComputePipelineCreateInfo
		pAllocator      *C.VkAllocationCallbacks
		pPipelines      *C.VkPipeline
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipelineCache = C.VkPipelineCache(pipelineCache)
	c.createInfoCount = C.uint32_t(len(createInfos))
	if len(createInfos) != 0 {
		c.pCreateInfos = (*C.VkComputePipelineCreateInfo)(m.alloc(C.sizeof_VkComputePipelineCreateInfo * uint(len(createInfos))))
		slice1 := (*[1 << 31]C.VkComputePipelineCreateInfo)(unsafe.Pointer(c.pCreateInfos))[:len(createInfos):len(createInfos)]
		for i1, _ := range createInfos {
			createInfos[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pCreateInfos = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if len(pipelines) != 0 {
		c.pPipelines = (*C.VkPipeline)(m.alloc(C.sizeof_VkPipeline * uint(len(pipelines))))
		slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
		for i1, _ := range pipelines {
			slice1[i1] = C.VkPipeline(pipelines[i1])
		}
	} else {
		c.pPipelines = nil
	}
	c._ret = C.vkCreateComputePipelines(c.device, c.pipelineCache, c.createInfoCount, c.pCreateInfos, c.pAllocator, c.pPipelines)
	_ret = Result(c._ret)
	if len(pipelines) != 0 {
		slice1 := (*[1 << 31]C.VkPipeline)(unsafe.Pointer(c.pPipelines))[:len(pipelines):len(pipelines)]
		for i1, _ := range pipelines {
			pipelines[i1] = Pipeline(slice1[i1])
		}
	}
	return
}
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		pipeline   C.VkPipeline
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipeline = C.VkPipeline(pipeline)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyPipeline(c.device, c.pipeline, c.pAllocator)
}
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks, pipelineLayout *PipelineLayout) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pCreateInfo     *C.VkPipelineLayoutCreateInfo
		pAllocator      *C.VkAllocationCallbacks
		pPipelineLayout *C.VkPipelineLayout
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkPipelineLayoutCreateInfo)(m.alloc(C.sizeof_VkPipelineLayoutCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if pipelineLayout != nil {
		c.pPipelineLayout = (*C.VkPipelineLayout)(m.alloc(C.sizeof_VkPipelineLayout))
		*c.pPipelineLayout = C.VkPipelineLayout(*pipelineLayout)
	} else {
		c.pPipelineLayout = nil
	}
	c._ret = C.vkCreatePipelineLayout(c.device, c.pCreateInfo, c.pAllocator, c.pPipelineLayout)
	_ret = Result(c._ret)
	if pipelineLayout != nil {
		*pipelineLayout = PipelineLayout(*c.pPipelineLayout)
	}
	return
}
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	var c struct {
		device         C.VkDevice
		pipelineLayout C.VkPipelineLayout
		pAllocator     *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.pipelineLayout = C.VkPipelineLayout(pipelineLayout)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyPipelineLayout(c.device, c.pipelineLayout, c.pAllocator)
}
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks, sampler *Sampler) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkSamplerCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pSampler    *C.VkSampler
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkSamplerCreateInfo)(m.alloc(C.sizeof_VkSamplerCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if sampler != nil {
		c.pSampler = (*C.VkSampler)(m.alloc(C.sizeof_VkSampler))
		*c.pSampler = C.VkSampler(*sampler)
	} else {
		c.pSampler = nil
	}
	c._ret = C.vkCreateSampler(c.device, c.pCreateInfo, c.pAllocator, c.pSampler)
	_ret = Result(c._ret)
	if sampler != nil {
		*sampler = Sampler(*c.pSampler)
	}
	return
}
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		sampler    C.VkSampler
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.sampler = C.VkSampler(sampler)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroySampler(c.device, c.sampler, c.pAllocator)
}
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks, setLayout *DescriptorSetLayout) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkDescriptorSetLayoutCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pSetLayout  *C.VkDescriptorSetLayout
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if setLayout != nil {
		c.pSetLayout = (*C.VkDescriptorSetLayout)(m.alloc(C.sizeof_VkDescriptorSetLayout))
		*c.pSetLayout = C.VkDescriptorSetLayout(*setLayout)
	} else {
		c.pSetLayout = nil
	}
	c._ret = C.vkCreateDescriptorSetLayout(c.device, c.pCreateInfo, c.pAllocator, c.pSetLayout)
	_ret = Result(c._ret)
	if setLayout != nil {
		*setLayout = DescriptorSetLayout(*c.pSetLayout)
	}
	return
}
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	var c struct {
		device              C.VkDevice
		descriptorSetLayout C.VkDescriptorSetLayout
		pAllocator          *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.descriptorSetLayout = C.VkDescriptorSetLayout(descriptorSetLayout)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyDescriptorSetLayout(c.device, c.descriptorSetLayout, c.pAllocator)
}
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks, descriptorPool *DescriptorPool) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pCreateInfo     *C.VkDescriptorPoolCreateInfo
		pAllocator      *C.VkAllocationCallbacks
		pDescriptorPool *C.VkDescriptorPool
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkDescriptorPoolCreateInfo)(m.alloc(C.sizeof_VkDescriptorPoolCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if descriptorPool != nil {
		c.pDescriptorPool = (*C.VkDescriptorPool)(m.alloc(C.sizeof_VkDescriptorPool))
		*c.pDescriptorPool = C.VkDescriptorPool(*descriptorPool)
	} else {
		c.pDescriptorPool = nil
	}
	c._ret = C.vkCreateDescriptorPool(c.device, c.pCreateInfo, c.pAllocator, c.pDescriptorPool)
	_ret = Result(c._ret)
	if descriptorPool != nil {
		*descriptorPool = DescriptorPool(*c.pDescriptorPool)
	}
	return
}
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	var c struct {
		device         C.VkDevice
		descriptorPool C.VkDescriptorPool
		pAllocator     *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.descriptorPool = C.VkDescriptorPool(descriptorPool)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyDescriptorPool(c.device, c.descriptorPool, c.pAllocator)
}
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (_ret Result) {
	var c struct {
		device         C.VkDevice
		descriptorPool C.VkDescriptorPool
		flags          C.VkDescriptorPoolResetFlags
		_ret           C.VkResult
	}
	c.device = C.VkDevice(device)
	c.descriptorPool = C.VkDescriptorPool(descriptorPool)
	{
		var temp_in_VkDescriptorPoolResetFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkDescriptorPoolResetFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDescriptorPoolResetFlags(temp_in_VkDescriptorPoolResetFlags)
	}
	c._ret = C.vkResetDescriptorPool(c.device, c.descriptorPool, c.flags)
	_ret = Result(c._ret)
	return
}
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo, descriptorSets *DescriptorSet) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pAllocateInfo   *C.VkDescriptorSetAllocateInfo
		pDescriptorSets *C.VkDescriptorSet
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if allocateInfo != nil {
		c.pAllocateInfo = (*C.VkDescriptorSetAllocateInfo)(m.alloc(C.sizeof_VkDescriptorSetAllocateInfo))
		allocateInfo.toC(c.pAllocateInfo, m)
	} else {
		c.pAllocateInfo = nil
	}
	if descriptorSets != nil {
		c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet))
		*c.pDescriptorSets = C.VkDescriptorSet(*descriptorSets)
	} else {
		c.pDescriptorSets = nil
	}
	c._ret = C.vkAllocateDescriptorSets(c.device, c.pAllocateInfo, c.pDescriptorSets)
	_ret = Result(c._ret)
	if descriptorSets != nil {
		*descriptorSets = DescriptorSet(*c.pDescriptorSets)
	}
	return
}
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (_ret Result) {
	var c struct {
		device             C.VkDevice
		descriptorPool     C.VkDescriptorPool
		descriptorSetCount C.uint32_t
		pDescriptorSets    *C.VkDescriptorSet
		_ret               C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.descriptorPool = C.VkDescriptorPool(descriptorPool)
	c.descriptorSetCount = C.uint32_t(len(descriptorSets))
	if len(descriptorSets) != 0 {
		c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet * uint(len(descriptorSets))))
		slice1 := (*[1 << 31]C.VkDescriptorSet)(unsafe.Pointer(c.pDescriptorSets))[:len(descriptorSets):len(descriptorSets)]
		for i1, _ := range descriptorSets {
			slice1[i1] = C.VkDescriptorSet(descriptorSets[i1])
		}
	} else {
		c.pDescriptorSets = nil
	}
	c._ret = C.vkFreeDescriptorSets(c.device, c.descriptorPool, c.descriptorSetCount, c.pDescriptorSets)
	_ret = Result(c._ret)
	return
}
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	var c struct {
		device               C.VkDevice
		descriptorWriteCount C.uint32_t
		pDescriptorWrites    *C.VkWriteDescriptorSet
		descriptorCopyCount  C.uint32_t
		pDescriptorCopies    *C.VkCopyDescriptorSet
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.descriptorWriteCount = C.uint32_t(len(descriptorWrites))
	if len(descriptorWrites) != 0 {
		c.pDescriptorWrites = (*C.VkWriteDescriptorSet)(m.alloc(C.sizeof_VkWriteDescriptorSet * uint(len(descriptorWrites))))
		slice1 := (*[1 << 31]C.VkWriteDescriptorSet)(unsafe.Pointer(c.pDescriptorWrites))[:len(descriptorWrites):len(descriptorWrites)]
		for i1, _ := range descriptorWrites {
			descriptorWrites[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pDescriptorWrites = nil
	}
	c.descriptorCopyCount = C.uint32_t(len(descriptorCopies))
	if len(descriptorCopies) != 0 {
		c.pDescriptorCopies = (*C.VkCopyDescriptorSet)(m.alloc(C.sizeof_VkCopyDescriptorSet * uint(len(descriptorCopies))))
		slice1 := (*[1 << 31]C.VkCopyDescriptorSet)(unsafe.Pointer(c.pDescriptorCopies))[:len(descriptorCopies):len(descriptorCopies)]
		for i1, _ := range descriptorCopies {
			descriptorCopies[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pDescriptorCopies = nil
	}
	C.vkUpdateDescriptorSets(c.device, c.descriptorWriteCount, c.pDescriptorWrites, c.descriptorCopyCount, c.pDescriptorCopies)
}
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks, framebuffer *Framebuffer) (_ret Result) {
	var c struct {
		device       C.VkDevice
		pCreateInfo  *C.VkFramebufferCreateInfo
		pAllocator   *C.VkAllocationCallbacks
		pFramebuffer *C.VkFramebuffer
		_ret         C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkFramebufferCreateInfo)(m.alloc(C.sizeof_VkFramebufferCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if framebuffer != nil {
		c.pFramebuffer = (*C.VkFramebuffer)(m.alloc(C.sizeof_VkFramebuffer))
		*c.pFramebuffer = C.VkFramebuffer(*framebuffer)
	} else {
		c.pFramebuffer = nil
	}
	c._ret = C.vkCreateFramebuffer(c.device, c.pCreateInfo, c.pAllocator, c.pFramebuffer)
	_ret = Result(c._ret)
	if framebuffer != nil {
		*framebuffer = Framebuffer(*c.pFramebuffer)
	}
	return
}
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	var c struct {
		device      C.VkDevice
		framebuffer C.VkFramebuffer
		pAllocator  *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.framebuffer = C.VkFramebuffer(framebuffer)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyFramebuffer(c.device, c.framebuffer, c.pAllocator)
}
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks, renderPass *RenderPass) (_ret Result) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkRenderPassCreateInfo
		pAllocator  *C.VkAllocationCallbacks
		pRenderPass *C.VkRenderPass
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkRenderPassCreateInfo)(m.alloc(C.sizeof_VkRenderPassCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if renderPass != nil {
		c.pRenderPass = (*C.VkRenderPass)(m.alloc(C.sizeof_VkRenderPass))
		*c.pRenderPass = C.VkRenderPass(*renderPass)
	} else {
		c.pRenderPass = nil
	}
	c._ret = C.vkCreateRenderPass(c.device, c.pCreateInfo, c.pAllocator, c.pRenderPass)
	_ret = Result(c._ret)
	if renderPass != nil {
		*renderPass = RenderPass(*c.pRenderPass)
	}
	return
}
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	var c struct {
		device     C.VkDevice
		renderPass C.VkRenderPass
		pAllocator *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.renderPass = C.VkRenderPass(renderPass)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyRenderPass(c.device, c.renderPass, c.pAllocator)
}
func GetRenderAreaGranularity(device Device, renderPass RenderPass, granularity *Extent2D) {
	var c struct {
		device       C.VkDevice
		renderPass   C.VkRenderPass
		pGranularity *C.VkExtent2D
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.renderPass = C.VkRenderPass(renderPass)
	if granularity != nil {
		c.pGranularity = (*C.VkExtent2D)(m.alloc(C.sizeof_VkExtent2D))
		granularity.toC(c.pGranularity)
	} else {
		c.pGranularity = nil
	}
	C.vkGetRenderAreaGranularity(c.device, c.renderPass, c.pGranularity)
	if granularity != nil {
		granularity.fromC(c.pGranularity)
	}
}
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks, commandPool *CommandPool) (_ret Result) {
	var c struct {
		device       C.VkDevice
		pCreateInfo  *C.VkCommandPoolCreateInfo
		pAllocator   *C.VkAllocationCallbacks
		pCommandPool *C.VkCommandPool
		_ret         C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkCommandPoolCreateInfo)(m.alloc(C.sizeof_VkCommandPoolCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if commandPool != nil {
		c.pCommandPool = (*C.VkCommandPool)(m.alloc(C.sizeof_VkCommandPool))
		*c.pCommandPool = C.VkCommandPool(*commandPool)
	} else {
		c.pCommandPool = nil
	}
	c._ret = C.vkCreateCommandPool(c.device, c.pCreateInfo, c.pAllocator, c.pCommandPool)
	_ret = Result(c._ret)
	if commandPool != nil {
		*commandPool = CommandPool(*c.pCommandPool)
	}
	return
}
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	var c struct {
		device      C.VkDevice
		commandPool C.VkCommandPool
		pAllocator  *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.commandPool = C.VkCommandPool(commandPool)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyCommandPool(c.device, c.commandPool, c.pAllocator)
}
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (_ret Result) {
	var c struct {
		device      C.VkDevice
		commandPool C.VkCommandPool
		flags       C.VkCommandPoolResetFlags
		_ret        C.VkResult
	}
	c.device = C.VkDevice(device)
	c.commandPool = C.VkCommandPool(commandPool)
	{
		var temp_in_VkCommandPoolResetFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkCommandPoolResetFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkCommandPoolResetFlags(temp_in_VkCommandPoolResetFlags)
	}
	c._ret = C.vkResetCommandPool(c.device, c.commandPool, c.flags)
	_ret = Result(c._ret)
	return
}
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo, commandBuffers *CommandBuffer) (_ret Result) {
	var c struct {
		device          C.VkDevice
		pAllocateInfo   *C.VkCommandBufferAllocateInfo
		pCommandBuffers *C.VkCommandBuffer
		_ret            C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if allocateInfo != nil {
		c.pAllocateInfo = (*C.VkCommandBufferAllocateInfo)(m.alloc(C.sizeof_VkCommandBufferAllocateInfo))
		allocateInfo.toC(c.pAllocateInfo, m)
	} else {
		c.pAllocateInfo = nil
	}
	if commandBuffers != nil {
		c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer))
		*c.pCommandBuffers = C.VkCommandBuffer(*commandBuffers)
	} else {
		c.pCommandBuffers = nil
	}
	c._ret = C.vkAllocateCommandBuffers(c.device, c.pAllocateInfo, c.pCommandBuffers)
	_ret = Result(c._ret)
	if commandBuffers != nil {
		*commandBuffers = CommandBuffer(*c.pCommandBuffers)
	}
	return
}
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	var c struct {
		device             C.VkDevice
		commandPool        C.VkCommandPool
		commandBufferCount C.uint32_t
		pCommandBuffers    *C.VkCommandBuffer
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.commandPool = C.VkCommandPool(commandPool)
	c.commandBufferCount = C.uint32_t(len(commandBuffers))
	if len(commandBuffers) != 0 {
		c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer * uint(len(commandBuffers))))
		slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(commandBuffers):len(commandBuffers)]
		for i1, _ := range commandBuffers {
			slice1[i1] = C.VkCommandBuffer(commandBuffers[i1])
		}
	} else {
		c.pCommandBuffers = nil
	}
	C.vkFreeCommandBuffers(c.device, c.commandPool, c.commandBufferCount, c.pCommandBuffers)
}
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (_ret Result) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		pBeginInfo    *C.VkCommandBufferBeginInfo
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	if beginInfo != nil {
		c.pBeginInfo = (*C.VkCommandBufferBeginInfo)(m.alloc(C.sizeof_VkCommandBufferBeginInfo))
		beginInfo.toC(c.pBeginInfo, m)
	} else {
		c.pBeginInfo = nil
	}
	c._ret = C.vkBeginCommandBuffer(c.commandBuffer, c.pBeginInfo)
	_ret = Result(c._ret)
	return
}
func EndCommandBuffer(commandBuffer CommandBuffer) (_ret Result) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		_ret          C.VkResult
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c._ret = C.vkEndCommandBuffer(c.commandBuffer)
	_ret = Result(c._ret)
	return
}
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (_ret Result) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		flags         C.VkCommandBufferResetFlags
		_ret          C.VkResult
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	{
		var temp_in_VkCommandBufferResetFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkCommandBufferResetFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkCommandBufferResetFlags(temp_in_VkCommandBufferResetFlags)
	}
	c._ret = C.vkResetCommandBuffer(c.commandBuffer, c.flags)
	_ret = Result(c._ret)
	return
}
func CmdBindPipeline(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {
	var c struct {
		commandBuffer     C.VkCommandBuffer
		pipelineBindPoint C.VkPipelineBindPoint
		pipeline          C.VkPipeline
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.pipelineBindPoint = C.VkPipelineBindPoint(pipelineBindPoint)
	c.pipeline = C.VkPipeline(pipeline)
	C.vkCmdBindPipeline(c.commandBuffer, c.pipelineBindPoint, c.pipeline)
}
func CmdSetViewport(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		firstViewport C.uint32_t
		viewportCount C.uint32_t
		pViewports    *C.VkViewport
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.firstViewport = C.uint32_t(firstViewport)
	c.viewportCount = C.uint32_t(len(viewports))
	if len(viewports) != 0 {
		c.pViewports = (*C.VkViewport)(m.alloc(C.sizeof_VkViewport * uint(len(viewports))))
		slice1 := (*[1 << 31]C.VkViewport)(unsafe.Pointer(c.pViewports))[:len(viewports):len(viewports)]
		for i1, _ := range viewports {
			viewports[i1].toC(&slice1[i1])
		}
	} else {
		c.pViewports = nil
	}
	C.vkCmdSetViewport(c.commandBuffer, c.firstViewport, c.viewportCount, c.pViewports)
}
func CmdSetScissor(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		firstScissor  C.uint32_t
		scissorCount  C.uint32_t
		pScissors     *C.VkRect2D
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.firstScissor = C.uint32_t(firstScissor)
	c.scissorCount = C.uint32_t(len(scissors))
	if len(scissors) != 0 {
		c.pScissors = (*C.VkRect2D)(m.alloc(C.sizeof_VkRect2D * uint(len(scissors))))
		slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pScissors))[:len(scissors):len(scissors)]
		for i1, _ := range scissors {
			scissors[i1].toC(&slice1[i1])
		}
	} else {
		c.pScissors = nil
	}
	C.vkCmdSetScissor(c.commandBuffer, c.firstScissor, c.scissorCount, c.pScissors)
}
func CmdSetLineWidth(commandBuffer CommandBuffer, lineWidth float32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		lineWidth     C.float
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.lineWidth = C.float(lineWidth)
	C.vkCmdSetLineWidth(c.commandBuffer, c.lineWidth)
}
func CmdSetDepthBias(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {
	var c struct {
		commandBuffer           C.VkCommandBuffer
		depthBiasConstantFactor C.float
		depthBiasClamp          C.float
		depthBiasSlopeFactor    C.float
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.depthBiasConstantFactor = C.float(depthBiasConstantFactor)
	c.depthBiasClamp = C.float(depthBiasClamp)
	c.depthBiasSlopeFactor = C.float(depthBiasSlopeFactor)
	C.vkCmdSetDepthBias(c.commandBuffer, c.depthBiasConstantFactor, c.depthBiasClamp, c.depthBiasSlopeFactor)
}
func CmdSetBlendConstants(commandBuffer CommandBuffer, blendConstants *float32) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		blendConstants *C.float
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	if blendConstants != nil {
		c.blendConstants = (*C.float)(m.alloc(C.sizeof_float))
		*c.blendConstants = C.float(*blendConstants)
	} else {
		c.blendConstants = nil
	}
	C.vkCmdSetBlendConstants(c.commandBuffer, c.blendConstants)
}
func CmdSetDepthBounds(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		minDepthBounds C.float
		maxDepthBounds C.float
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.minDepthBounds = C.float(minDepthBounds)
	c.maxDepthBounds = C.float(maxDepthBounds)
	C.vkCmdSetDepthBounds(c.commandBuffer, c.minDepthBounds, c.maxDepthBounds)
}
func CmdSetStencilCompareMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		faceMask      C.VkStencilFaceFlags
		compareMask   C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	{
		var temp_in_VkStencilFaceFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
			temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
	}
	c.compareMask = C.uint32_t(compareMask)
	C.vkCmdSetStencilCompareMask(c.commandBuffer, c.faceMask, c.compareMask)
}
func CmdSetStencilWriteMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		faceMask      C.VkStencilFaceFlags
		writeMask     C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	{
		var temp_in_VkStencilFaceFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
			temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
	}
	c.writeMask = C.uint32_t(writeMask)
	C.vkCmdSetStencilWriteMask(c.commandBuffer, c.faceMask, c.writeMask)
}
func CmdSetStencilReference(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		faceMask      C.VkStencilFaceFlags
		reference     C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	{
		var temp_in_VkStencilFaceFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(faceMask)))
			temp_in_VkStencilFaceFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.faceMask = C.VkStencilFaceFlags(temp_in_VkStencilFaceFlags)
	}
	c.reference = C.uint32_t(reference)
	C.vkCmdSetStencilReference(c.commandBuffer, c.faceMask, c.reference)
}
func CmdBindDescriptorSets(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32) {
	var c struct {
		commandBuffer      C.VkCommandBuffer
		pipelineBindPoint  C.VkPipelineBindPoint
		layout             C.VkPipelineLayout
		firstSet           C.uint32_t
		descriptorSetCount C.uint32_t
		pDescriptorSets    *C.VkDescriptorSet
		dynamicOffsetCount C.uint32_t
		pDynamicOffsets    *C.uint32_t
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.pipelineBindPoint = C.VkPipelineBindPoint(pipelineBindPoint)
	c.layout = C.VkPipelineLayout(layout)
	c.firstSet = C.uint32_t(firstSet)
	c.descriptorSetCount = C.uint32_t(len(descriptorSets))
	if len(descriptorSets) != 0 {
		c.pDescriptorSets = (*C.VkDescriptorSet)(m.alloc(C.sizeof_VkDescriptorSet * uint(len(descriptorSets))))
		slice1 := (*[1 << 31]C.VkDescriptorSet)(unsafe.Pointer(c.pDescriptorSets))[:len(descriptorSets):len(descriptorSets)]
		for i1, _ := range descriptorSets {
			slice1[i1] = C.VkDescriptorSet(descriptorSets[i1])
		}
	} else {
		c.pDescriptorSets = nil
	}
	c.dynamicOffsetCount = C.uint32_t(len(dynamicOffsets))
	if len(dynamicOffsets) != 0 {
		c.pDynamicOffsets = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(dynamicOffsets))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pDynamicOffsets))[:len(dynamicOffsets):len(dynamicOffsets)]
		for i1, _ := range dynamicOffsets {
			slice1[i1] = C.uint32_t(dynamicOffsets[i1])
		}
	} else {
		c.pDynamicOffsets = nil
	}
	C.vkCmdBindDescriptorSets(c.commandBuffer, c.pipelineBindPoint, c.layout, c.firstSet, c.descriptorSetCount, c.pDescriptorSets, c.dynamicOffsetCount, c.pDynamicOffsets)
}
func CmdBindIndexBuffer(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		buffer        C.VkBuffer
		offset        C.VkDeviceSize
		indexType     C.VkIndexType
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.buffer = C.VkBuffer(buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.indexType = C.VkIndexType(indexType)
	C.vkCmdBindIndexBuffer(c.commandBuffer, c.buffer, c.offset, c.indexType)
}
func CmdBindVertexBuffers(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		firstBinding  C.uint32_t
		bindingCount  C.uint32_t
		pBuffers      *C.VkBuffer
		pOffsets      *C.VkDeviceSize
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.firstBinding = C.uint32_t(firstBinding)
	c.bindingCount = C.uint32_t(len(buffers))
	if len(buffers) != 0 {
		c.pBuffers = (*C.VkBuffer)(m.alloc(C.sizeof_VkBuffer * uint(len(buffers))))
		slice1 := (*[1 << 31]C.VkBuffer)(unsafe.Pointer(c.pBuffers))[:len(buffers):len(buffers)]
		for i1, _ := range buffers {
			slice1[i1] = C.VkBuffer(buffers[i1])
		}
	} else {
		c.pBuffers = nil
	}
	if len(offsets) != 0 {
		c.pOffsets = (*C.VkDeviceSize)(m.alloc(C.sizeof_VkDeviceSize * uint(len(offsets))))
		slice1 := (*[1 << 31]C.VkDeviceSize)(unsafe.Pointer(c.pOffsets))[:len(offsets):len(offsets)]
		for i1, _ := range offsets {
			{
				var temp_in_VkDeviceSize C.uint64_t
				temp_in_VkDeviceSize = C.uint64_t((uint64)(offsets[i1]))
				slice1[i1] = C.VkDeviceSize(temp_in_VkDeviceSize)
			}
		}
	} else {
		c.pOffsets = nil
	}
	C.vkCmdBindVertexBuffers(c.commandBuffer, c.firstBinding, c.bindingCount, c.pBuffers, c.pOffsets)
}
func CmdDraw(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		vertexCount   C.uint32_t
		instanceCount C.uint32_t
		firstVertex   C.uint32_t
		firstInstance C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.vertexCount = C.uint32_t(vertexCount)
	c.instanceCount = C.uint32_t(instanceCount)
	c.firstVertex = C.uint32_t(firstVertex)
	c.firstInstance = C.uint32_t(firstInstance)
	C.vkCmdDraw(c.commandBuffer, c.vertexCount, c.instanceCount, c.firstVertex, c.firstInstance)
}
func CmdDrawIndexed(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		indexCount    C.uint32_t
		instanceCount C.uint32_t
		firstIndex    C.uint32_t
		vertexOffset  C.int32_t
		firstInstance C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.indexCount = C.uint32_t(indexCount)
	c.instanceCount = C.uint32_t(instanceCount)
	c.firstIndex = C.uint32_t(firstIndex)
	c.vertexOffset = C.int32_t(vertexOffset)
	c.firstInstance = C.uint32_t(firstInstance)
	C.vkCmdDrawIndexed(c.commandBuffer, c.indexCount, c.instanceCount, c.firstIndex, c.vertexOffset, c.firstInstance)
}
func CmdDrawIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		buffer        C.VkBuffer
		offset        C.VkDeviceSize
		drawCount     C.uint32_t
		stride        C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.buffer = C.VkBuffer(buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.drawCount = C.uint32_t(drawCount)
	c.stride = C.uint32_t(stride)
	C.vkCmdDrawIndirect(c.commandBuffer, c.buffer, c.offset, c.drawCount, c.stride)
}
func CmdDrawIndexedIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		buffer        C.VkBuffer
		offset        C.VkDeviceSize
		drawCount     C.uint32_t
		stride        C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.buffer = C.VkBuffer(buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.drawCount = C.uint32_t(drawCount)
	c.stride = C.uint32_t(stride)
	C.vkCmdDrawIndexedIndirect(c.commandBuffer, c.buffer, c.offset, c.drawCount, c.stride)
}
func CmdDispatch(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		groupCountX   C.uint32_t
		groupCountY   C.uint32_t
		groupCountZ   C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.groupCountX = C.uint32_t(groupCountX)
	c.groupCountY = C.uint32_t(groupCountY)
	c.groupCountZ = C.uint32_t(groupCountZ)
	C.vkCmdDispatch(c.commandBuffer, c.groupCountX, c.groupCountY, c.groupCountZ)
}
func CmdDispatchIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		buffer        C.VkBuffer
		offset        C.VkDeviceSize
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.buffer = C.VkBuffer(buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	C.vkCmdDispatchIndirect(c.commandBuffer, c.buffer, c.offset)
}
func CmdCopyBuffer(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		srcBuffer     C.VkBuffer
		dstBuffer     C.VkBuffer
		regionCount   C.uint32_t
		pRegions      *C.VkBufferCopy
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcBuffer = C.VkBuffer(srcBuffer)
	c.dstBuffer = C.VkBuffer(dstBuffer)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkBufferCopy)(m.alloc(C.sizeof_VkBufferCopy * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkBufferCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	C.vkCmdCopyBuffer(c.commandBuffer, c.srcBuffer, c.dstBuffer, c.regionCount, c.pRegions)
}
func CmdCopyImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		srcImage       C.VkImage
		srcImageLayout C.VkImageLayout
		dstImage       C.VkImage
		dstImageLayout C.VkImageLayout
		regionCount    C.uint32_t
		pRegions       *C.VkImageCopy
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcImage = C.VkImage(srcImage)
	c.srcImageLayout = C.VkImageLayout(srcImageLayout)
	c.dstImage = C.VkImage(dstImage)
	c.dstImageLayout = C.VkImageLayout(dstImageLayout)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkImageCopy)(m.alloc(C.sizeof_VkImageCopy * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	C.vkCmdCopyImage(c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
}
func CmdBlitImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		srcImage       C.VkImage
		srcImageLayout C.VkImageLayout
		dstImage       C.VkImage
		dstImageLayout C.VkImageLayout
		regionCount    C.uint32_t
		pRegions       *C.VkImageBlit
		filter         C.VkFilter
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcImage = C.VkImage(srcImage)
	c.srcImageLayout = C.VkImageLayout(srcImageLayout)
	c.dstImage = C.VkImage(dstImage)
	c.dstImageLayout = C.VkImageLayout(dstImageLayout)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkImageBlit)(m.alloc(C.sizeof_VkImageBlit * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkImageBlit)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	c.filter = C.VkFilter(filter)
	C.vkCmdBlitImage(c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions, c.filter)
}
func CmdCopyBufferToImage(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		srcBuffer      C.VkBuffer
		dstImage       C.VkImage
		dstImageLayout C.VkImageLayout
		regionCount    C.uint32_t
		pRegions       *C.VkBufferImageCopy
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcBuffer = C.VkBuffer(srcBuffer)
	c.dstImage = C.VkImage(dstImage)
	c.dstImageLayout = C.VkImageLayout(dstImageLayout)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkBufferImageCopy)(m.alloc(C.sizeof_VkBufferImageCopy * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkBufferImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	C.vkCmdCopyBufferToImage(c.commandBuffer, c.srcBuffer, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
}
func CmdCopyImageToBuffer(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		srcImage       C.VkImage
		srcImageLayout C.VkImageLayout
		dstBuffer      C.VkBuffer
		regionCount    C.uint32_t
		pRegions       *C.VkBufferImageCopy
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcImage = C.VkImage(srcImage)
	c.srcImageLayout = C.VkImageLayout(srcImageLayout)
	c.dstBuffer = C.VkBuffer(dstBuffer)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkBufferImageCopy)(m.alloc(C.sizeof_VkBufferImageCopy * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkBufferImageCopy)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	C.vkCmdCopyImageToBuffer(c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstBuffer, c.regionCount, c.pRegions)
}
func CmdUpdateBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, data unsafe.Pointer) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		dstBuffer     C.VkBuffer
		dstOffset     C.VkDeviceSize
		dataSize      C.VkDeviceSize
		pData         unsafe.Pointer
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.dstBuffer = C.VkBuffer(dstBuffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
		c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(dataSize))
		c.dataSize = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.pData = data
	C.vkCmdUpdateBuffer(c.commandBuffer, c.dstBuffer, c.dstOffset, c.dataSize, c.pData)
}
func CmdFillBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		dstBuffer     C.VkBuffer
		dstOffset     C.VkDeviceSize
		size          C.VkDeviceSize
		data          C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.dstBuffer = C.VkBuffer(dstBuffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
		c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(size))
		c.size = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.data = C.uint32_t(data)
	C.vkCmdFillBuffer(c.commandBuffer, c.dstBuffer, c.dstOffset, c.size, c.data)
}
func CmdClearColorImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		image         C.VkImage
		imageLayout   C.VkImageLayout
		pColor        *C.VkClearColorValue
		rangeCount    C.uint32_t
		pRanges       *C.VkImageSubresourceRange
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.image = C.VkImage(image)
	c.imageLayout = C.VkImageLayout(imageLayout)
	if color != nil {
		c.pColor = (*C.VkClearColorValue)(m.alloc(C.sizeof_VkClearColorValue))
		*c.pColor = C.VkClearColorValue(*color)
	} else {
		c.pColor = nil
	}
	c.rangeCount = C.uint32_t(len(ranges))
	if len(ranges) != 0 {
		c.pRanges = (*C.VkImageSubresourceRange)(m.alloc(C.sizeof_VkImageSubresourceRange * uint(len(ranges))))
		slice1 := (*[1 << 31]C.VkImageSubresourceRange)(unsafe.Pointer(c.pRanges))[:len(ranges):len(ranges)]
		for i1, _ := range ranges {
			ranges[i1].toC(&slice1[i1])
		}
	} else {
		c.pRanges = nil
	}
	C.vkCmdClearColorImage(c.commandBuffer, c.image, c.imageLayout, c.pColor, c.rangeCount, c.pRanges)
}
func CmdClearDepthStencilImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		image         C.VkImage
		imageLayout   C.VkImageLayout
		pDepthStencil *C.VkClearDepthStencilValue
		rangeCount    C.uint32_t
		pRanges       *C.VkImageSubresourceRange
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.image = C.VkImage(image)
	c.imageLayout = C.VkImageLayout(imageLayout)
	if depthStencil != nil {
		c.pDepthStencil = (*C.VkClearDepthStencilValue)(m.alloc(C.sizeof_VkClearDepthStencilValue))
		depthStencil.toC(c.pDepthStencil)
	} else {
		c.pDepthStencil = nil
	}
	c.rangeCount = C.uint32_t(len(ranges))
	if len(ranges) != 0 {
		c.pRanges = (*C.VkImageSubresourceRange)(m.alloc(C.sizeof_VkImageSubresourceRange * uint(len(ranges))))
		slice1 := (*[1 << 31]C.VkImageSubresourceRange)(unsafe.Pointer(c.pRanges))[:len(ranges):len(ranges)]
		for i1, _ := range ranges {
			ranges[i1].toC(&slice1[i1])
		}
	} else {
		c.pRanges = nil
	}
	C.vkCmdClearDepthStencilImage(c.commandBuffer, c.image, c.imageLayout, c.pDepthStencil, c.rangeCount, c.pRanges)
}
func CmdClearAttachments(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect) {
	var c struct {
		commandBuffer   C.VkCommandBuffer
		attachmentCount C.uint32_t
		pAttachments    *C.VkClearAttachment
		rectCount       C.uint32_t
		pRects          *C.VkClearRect
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.attachmentCount = C.uint32_t(len(attachments))
	if len(attachments) != 0 {
		c.pAttachments = (*C.VkClearAttachment)(m.alloc(C.sizeof_VkClearAttachment * uint(len(attachments))))
		slice1 := (*[1 << 31]C.VkClearAttachment)(unsafe.Pointer(c.pAttachments))[:len(attachments):len(attachments)]
		for i1, _ := range attachments {
			attachments[i1].toC(&slice1[i1])
		}
	} else {
		c.pAttachments = nil
	}
	c.rectCount = C.uint32_t(len(rects))
	if len(rects) != 0 {
		c.pRects = (*C.VkClearRect)(m.alloc(C.sizeof_VkClearRect * uint(len(rects))))
		slice1 := (*[1 << 31]C.VkClearRect)(unsafe.Pointer(c.pRects))[:len(rects):len(rects)]
		for i1, _ := range rects {
			rects[i1].toC(&slice1[i1])
		}
	} else {
		c.pRects = nil
	}
	C.vkCmdClearAttachments(c.commandBuffer, c.attachmentCount, c.pAttachments, c.rectCount, c.pRects)
}
func CmdResolveImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve) {
	var c struct {
		commandBuffer  C.VkCommandBuffer
		srcImage       C.VkImage
		srcImageLayout C.VkImageLayout
		dstImage       C.VkImage
		dstImageLayout C.VkImageLayout
		regionCount    C.uint32_t
		pRegions       *C.VkImageResolve
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.srcImage = C.VkImage(srcImage)
	c.srcImageLayout = C.VkImageLayout(srcImageLayout)
	c.dstImage = C.VkImage(dstImage)
	c.dstImageLayout = C.VkImageLayout(dstImageLayout)
	c.regionCount = C.uint32_t(len(regions))
	if len(regions) != 0 {
		c.pRegions = (*C.VkImageResolve)(m.alloc(C.sizeof_VkImageResolve * uint(len(regions))))
		slice1 := (*[1 << 31]C.VkImageResolve)(unsafe.Pointer(c.pRegions))[:len(regions):len(regions)]
		for i1, _ := range regions {
			regions[i1].toC(&slice1[i1])
		}
	} else {
		c.pRegions = nil
	}
	C.vkCmdResolveImage(c.commandBuffer, c.srcImage, c.srcImageLayout, c.dstImage, c.dstImageLayout, c.regionCount, c.pRegions)
}
func CmdSetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		event         C.VkEvent
		stageMask     C.VkPipelineStageFlags
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.event = C.VkEvent(event)
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.stageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	C.vkCmdSetEvent(c.commandBuffer, c.event, c.stageMask)
}
func CmdResetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		event         C.VkEvent
		stageMask     C.VkPipelineStageFlags
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.event = C.VkEvent(event)
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.stageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	C.vkCmdResetEvent(c.commandBuffer, c.event, c.stageMask)
}
func CmdWaitEvents(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	var c struct {
		commandBuffer            C.VkCommandBuffer
		eventCount               C.uint32_t
		pEvents                  *C.VkEvent
		srcStageMask             C.VkPipelineStageFlags
		dstStageMask             C.VkPipelineStageFlags
		memoryBarrierCount       C.uint32_t
		pMemoryBarriers          *C.VkMemoryBarrier
		bufferMemoryBarrierCount C.uint32_t
		pBufferMemoryBarriers    *C.VkBufferMemoryBarrier
		imageMemoryBarrierCount  C.uint32_t
		pImageMemoryBarriers     *C.VkImageMemoryBarrier
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.eventCount = C.uint32_t(len(events))
	if len(events) != 0 {
		c.pEvents = (*C.VkEvent)(m.alloc(C.sizeof_VkEvent * uint(len(events))))
		slice1 := (*[1 << 31]C.VkEvent)(unsafe.Pointer(c.pEvents))[:len(events):len(events)]
		for i1, _ := range events {
			slice1[i1] = C.VkEvent(events[i1])
		}
	} else {
		c.pEvents = nil
	}
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(srcStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dstStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	c.memoryBarrierCount = C.uint32_t(len(memoryBarriers))
	if len(memoryBarriers) != 0 {
		c.pMemoryBarriers = (*C.VkMemoryBarrier)(m.alloc(C.sizeof_VkMemoryBarrier * uint(len(memoryBarriers))))
		slice1 := (*[1 << 31]C.VkMemoryBarrier)(unsafe.Pointer(c.pMemoryBarriers))[:len(memoryBarriers):len(memoryBarriers)]
		for i1, _ := range memoryBarriers {
			memoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pMemoryBarriers = nil
	}
	c.bufferMemoryBarrierCount = C.uint32_t(len(bufferMemoryBarriers))
	if len(bufferMemoryBarriers) != 0 {
		c.pBufferMemoryBarriers = (*C.VkBufferMemoryBarrier)(m.alloc(C.sizeof_VkBufferMemoryBarrier * uint(len(bufferMemoryBarriers))))
		slice1 := (*[1 << 31]C.VkBufferMemoryBarrier)(unsafe.Pointer(c.pBufferMemoryBarriers))[:len(bufferMemoryBarriers):len(bufferMemoryBarriers)]
		for i1, _ := range bufferMemoryBarriers {
			bufferMemoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBufferMemoryBarriers = nil
	}
	c.imageMemoryBarrierCount = C.uint32_t(len(imageMemoryBarriers))
	if len(imageMemoryBarriers) != 0 {
		c.pImageMemoryBarriers = (*C.VkImageMemoryBarrier)(m.alloc(C.sizeof_VkImageMemoryBarrier * uint(len(imageMemoryBarriers))))
		slice1 := (*[1 << 31]C.VkImageMemoryBarrier)(unsafe.Pointer(c.pImageMemoryBarriers))[:len(imageMemoryBarriers):len(imageMemoryBarriers)]
		for i1, _ := range imageMemoryBarriers {
			imageMemoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pImageMemoryBarriers = nil
	}
	C.vkCmdWaitEvents(c.commandBuffer, c.eventCount, c.pEvents, c.srcStageMask, c.dstStageMask, c.memoryBarrierCount, c.pMemoryBarriers, c.bufferMemoryBarrierCount, c.pBufferMemoryBarriers, c.imageMemoryBarrierCount, c.pImageMemoryBarriers)
}
func CmdPipelineBarrier(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	var c struct {
		commandBuffer            C.VkCommandBuffer
		srcStageMask             C.VkPipelineStageFlags
		dstStageMask             C.VkPipelineStageFlags
		dependencyFlags          C.VkDependencyFlags
		memoryBarrierCount       C.uint32_t
		pMemoryBarriers          *C.VkMemoryBarrier
		bufferMemoryBarrierCount C.uint32_t
		pBufferMemoryBarriers    *C.VkBufferMemoryBarrier
		imageMemoryBarrierCount  C.uint32_t
		pImageMemoryBarriers     *C.VkImageMemoryBarrier
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(srcStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dstStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkDependencyFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(dependencyFlags)))
			temp_in_VkDependencyFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dependencyFlags = C.VkDependencyFlags(temp_in_VkDependencyFlags)
	}
	c.memoryBarrierCount = C.uint32_t(len(memoryBarriers))
	if len(memoryBarriers) != 0 {
		c.pMemoryBarriers = (*C.VkMemoryBarrier)(m.alloc(C.sizeof_VkMemoryBarrier * uint(len(memoryBarriers))))
		slice1 := (*[1 << 31]C.VkMemoryBarrier)(unsafe.Pointer(c.pMemoryBarriers))[:len(memoryBarriers):len(memoryBarriers)]
		for i1, _ := range memoryBarriers {
			memoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pMemoryBarriers = nil
	}
	c.bufferMemoryBarrierCount = C.uint32_t(len(bufferMemoryBarriers))
	if len(bufferMemoryBarriers) != 0 {
		c.pBufferMemoryBarriers = (*C.VkBufferMemoryBarrier)(m.alloc(C.sizeof_VkBufferMemoryBarrier * uint(len(bufferMemoryBarriers))))
		slice1 := (*[1 << 31]C.VkBufferMemoryBarrier)(unsafe.Pointer(c.pBufferMemoryBarriers))[:len(bufferMemoryBarriers):len(bufferMemoryBarriers)]
		for i1, _ := range bufferMemoryBarriers {
			bufferMemoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBufferMemoryBarriers = nil
	}
	c.imageMemoryBarrierCount = C.uint32_t(len(imageMemoryBarriers))
	if len(imageMemoryBarriers) != 0 {
		c.pImageMemoryBarriers = (*C.VkImageMemoryBarrier)(m.alloc(C.sizeof_VkImageMemoryBarrier * uint(len(imageMemoryBarriers))))
		slice1 := (*[1 << 31]C.VkImageMemoryBarrier)(unsafe.Pointer(c.pImageMemoryBarriers))[:len(imageMemoryBarriers):len(imageMemoryBarriers)]
		for i1, _ := range imageMemoryBarriers {
			imageMemoryBarriers[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pImageMemoryBarriers = nil
	}
	C.vkCmdPipelineBarrier(c.commandBuffer, c.srcStageMask, c.dstStageMask, c.dependencyFlags, c.memoryBarrierCount, c.pMemoryBarriers, c.bufferMemoryBarrierCount, c.pBufferMemoryBarriers, c.imageMemoryBarrierCount, c.pImageMemoryBarriers)
}
func CmdBeginQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		queryPool     C.VkQueryPool
		query         C.uint32_t
		flags         C.VkQueryControlFlags
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.queryPool = C.VkQueryPool(queryPool)
	c.query = C.uint32_t(query)
	{
		var temp_in_VkQueryControlFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkQueryControlFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkQueryControlFlags(temp_in_VkQueryControlFlags)
	}
	C.vkCmdBeginQuery(c.commandBuffer, c.queryPool, c.query, c.flags)
}
func CmdEndQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		queryPool     C.VkQueryPool
		query         C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.queryPool = C.VkQueryPool(queryPool)
	c.query = C.uint32_t(query)
	C.vkCmdEndQuery(c.commandBuffer, c.queryPool, c.query)
}
func CmdResetQueryPool(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		queryPool     C.VkQueryPool
		firstQuery    C.uint32_t
		queryCount    C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.queryPool = C.VkQueryPool(queryPool)
	c.firstQuery = C.uint32_t(firstQuery)
	c.queryCount = C.uint32_t(queryCount)
	C.vkCmdResetQueryPool(c.commandBuffer, c.queryPool, c.firstQuery, c.queryCount)
}
func CmdWriteTimestamp(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		pipelineStage C.VkPipelineStageFlagBits
		queryPool     C.VkQueryPool
		query         C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.pipelineStage = C.VkPipelineStageFlagBits(pipelineStage)
	c.queryPool = C.VkQueryPool(queryPool)
	c.query = C.uint32_t(query)
	C.vkCmdWriteTimestamp(c.commandBuffer, c.pipelineStage, c.queryPool, c.query)
}
func CmdCopyQueryPoolResults(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		queryPool     C.VkQueryPool
		firstQuery    C.uint32_t
		queryCount    C.uint32_t
		dstBuffer     C.VkBuffer
		dstOffset     C.VkDeviceSize
		stride        C.VkDeviceSize
		flags         C.VkQueryResultFlags
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.queryPool = C.VkQueryPool(queryPool)
	c.firstQuery = C.uint32_t(firstQuery)
	c.queryCount = C.uint32_t(queryCount)
	c.dstBuffer = C.VkBuffer(dstBuffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
		c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(stride))
		c.stride = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkQueryResultFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkQueryResultFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkQueryResultFlags(temp_in_VkQueryResultFlags)
	}
	C.vkCmdCopyQueryPoolResults(c.commandBuffer, c.queryPool, c.firstQuery, c.queryCount, c.dstBuffer, c.dstOffset, c.stride, c.flags)
}
func CmdPushConstants(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		layout        C.VkPipelineLayout
		stageFlags    C.VkShaderStageFlags
		offset        C.uint32_t
		size          C.uint32_t
		pValues       unsafe.Pointer
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.layout = C.VkPipelineLayout(layout)
	{
		var temp_in_VkShaderStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(stageFlags)))
			temp_in_VkShaderStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.stageFlags = C.VkShaderStageFlags(temp_in_VkShaderStageFlags)
	}
	c.offset = C.uint32_t(offset)
	c.size = C.uint32_t(len(values))
	if len(values) != 0 {
		c.pValues = m.alloc(C.sizeof_char * uint(len(values)))
		slice1 := (*[1 << 31]byte)(c.pValues)[:len(values):len(values)]
		for i1, _ := range values {
			slice1[i1] = values[i1]
		}
	} else {
		c.pValues = nil
	}
	C.vkCmdPushConstants(c.commandBuffer, c.layout, c.stageFlags, c.offset, c.size, c.pValues)
}
func CmdBeginRenderPass(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	var c struct {
		commandBuffer    C.VkCommandBuffer
		pRenderPassBegin *C.VkRenderPassBeginInfo
		contents         C.VkSubpassContents
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	if renderPassBegin != nil {
		c.pRenderPassBegin = (*C.VkRenderPassBeginInfo)(m.alloc(C.sizeof_VkRenderPassBeginInfo))
		renderPassBegin.toC(c.pRenderPassBegin, m)
	} else {
		c.pRenderPassBegin = nil
	}
	c.contents = C.VkSubpassContents(contents)
	C.vkCmdBeginRenderPass(c.commandBuffer, c.pRenderPassBegin, c.contents)
}
func CmdNextSubpass(commandBuffer CommandBuffer, contents SubpassContents) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		contents      C.VkSubpassContents
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.contents = C.VkSubpassContents(contents)
	C.vkCmdNextSubpass(c.commandBuffer, c.contents)
}
func CmdEndRenderPass(commandBuffer CommandBuffer) {
	var c struct{ commandBuffer C.VkCommandBuffer }
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	C.vkCmdEndRenderPass(c.commandBuffer)
}
func CmdExecuteCommands(commandBuffer CommandBuffer, commandBuffers []CommandBuffer) {
	var c struct {
		commandBuffer      C.VkCommandBuffer
		commandBufferCount C.uint32_t
		pCommandBuffers    *C.VkCommandBuffer
	}
	m := pool.take()
	defer pool.give(m)
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.commandBufferCount = C.uint32_t(len(commandBuffers))
	if len(commandBuffers) != 0 {
		c.pCommandBuffers = (*C.VkCommandBuffer)(m.alloc(C.sizeof_VkCommandBuffer * uint(len(commandBuffers))))
		slice1 := (*[1 << 31]C.VkCommandBuffer)(unsafe.Pointer(c.pCommandBuffers))[:len(commandBuffers):len(commandBuffers)]
		for i1, _ := range commandBuffers {
			slice1[i1] = C.VkCommandBuffer(commandBuffers[i1])
		}
	} else {
		c.pCommandBuffers = nil
	}
	C.vkCmdExecuteCommands(c.commandBuffer, c.commandBufferCount, c.pCommandBuffers)
}

type PointClippingBehavior int

const (
	POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES           PointClippingBehavior = 0
	POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY     PointClippingBehavior = 1
	POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR       PointClippingBehavior = POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
	POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR PointClippingBehavior = POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
	POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE               PointClippingBehavior = POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
	POINT_CLIPPING_BEHAVIOR_END_RANGE                 PointClippingBehavior = POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
	POINT_CLIPPING_BEHAVIOR_RANGE_SIZE                PointClippingBehavior = (POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY - POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES + 1)
	POINT_CLIPPING_BEHAVIOR_MAX_ENUM                  PointClippingBehavior = 2147483647
)

type TessellationDomainOrigin int

const (
	TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT     TessellationDomainOrigin = 0
	TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT     TessellationDomainOrigin = 1
	TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR TessellationDomainOrigin = TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
	TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR TessellationDomainOrigin = TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
	TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE    TessellationDomainOrigin = TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
	TESSELLATION_DOMAIN_ORIGIN_END_RANGE      TessellationDomainOrigin = TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
	TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE     TessellationDomainOrigin = (TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT - TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT + 1)
	TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM       TessellationDomainOrigin = 2147483647
)

type SamplerYcbcrModelConversion int

const (
	SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY       SamplerYcbcrModelConversion = 0
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY     SamplerYcbcrModelConversion = 1
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709          SamplerYcbcrModelConversion = 2
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601          SamplerYcbcrModelConversion = 3
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020         SamplerYcbcrModelConversion = 4
	SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR   SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR      SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR      SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601
	SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR     SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
	SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE        SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
	SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE          SamplerYcbcrModelConversion = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
	SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE         SamplerYcbcrModelConversion = (SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 - SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY + 1)
	SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM           SamplerYcbcrModelConversion = 2147483647
)

type SamplerYcbcrRange int

const (
	SAMPLER_YCBCR_RANGE_ITU_FULL       SamplerYcbcrRange = 0
	SAMPLER_YCBCR_RANGE_ITU_NARROW     SamplerYcbcrRange = 1
	SAMPLER_YCBCR_RANGE_ITU_FULL_KHR   SamplerYcbcrRange = SAMPLER_YCBCR_RANGE_ITU_FULL
	SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR SamplerYcbcrRange = SAMPLER_YCBCR_RANGE_ITU_NARROW
	SAMPLER_YCBCR_RANGE_BEGIN_RANGE    SamplerYcbcrRange = SAMPLER_YCBCR_RANGE_ITU_FULL
	SAMPLER_YCBCR_RANGE_END_RANGE      SamplerYcbcrRange = SAMPLER_YCBCR_RANGE_ITU_NARROW
	SAMPLER_YCBCR_RANGE_RANGE_SIZE     SamplerYcbcrRange = (SAMPLER_YCBCR_RANGE_ITU_NARROW - SAMPLER_YCBCR_RANGE_ITU_FULL + 1)
	SAMPLER_YCBCR_RANGE_MAX_ENUM       SamplerYcbcrRange = 2147483647
)

type ChromaLocation int

const (
	CHROMA_LOCATION_COSITED_EVEN     ChromaLocation = 0
	CHROMA_LOCATION_MIDPOINT         ChromaLocation = 1
	CHROMA_LOCATION_COSITED_EVEN_KHR ChromaLocation = CHROMA_LOCATION_COSITED_EVEN
	CHROMA_LOCATION_MIDPOINT_KHR     ChromaLocation = CHROMA_LOCATION_MIDPOINT
	CHROMA_LOCATION_BEGIN_RANGE      ChromaLocation = CHROMA_LOCATION_COSITED_EVEN
	CHROMA_LOCATION_END_RANGE        ChromaLocation = CHROMA_LOCATION_MIDPOINT
	CHROMA_LOCATION_RANGE_SIZE       ChromaLocation = (CHROMA_LOCATION_MIDPOINT - CHROMA_LOCATION_COSITED_EVEN + 1)
	CHROMA_LOCATION_MAX_ENUM         ChromaLocation = 2147483647
)

type DescriptorUpdateTemplateType int

const (
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET       DescriptorUpdateTemplateType = 0
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR DescriptorUpdateTemplateType = 1
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR   DescriptorUpdateTemplateType = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE          DescriptorUpdateTemplateType = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE            DescriptorUpdateTemplateType = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE           DescriptorUpdateTemplateType = (DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET - DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET + 1)
	DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM             DescriptorUpdateTemplateType = 2147483647
)

type SubgroupFeatureFlagBits int

const (
	SUBGROUP_FEATURE_BASIC_BIT            SubgroupFeatureFlagBits = 1
	SUBGROUP_FEATURE_VOTE_BIT             SubgroupFeatureFlagBits = 2
	SUBGROUP_FEATURE_ARITHMETIC_BIT       SubgroupFeatureFlagBits = 4
	SUBGROUP_FEATURE_BALLOT_BIT           SubgroupFeatureFlagBits = 8
	SUBGROUP_FEATURE_SHUFFLE_BIT          SubgroupFeatureFlagBits = 16
	SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT SubgroupFeatureFlagBits = 32
	SUBGROUP_FEATURE_CLUSTERED_BIT        SubgroupFeatureFlagBits = 64
	SUBGROUP_FEATURE_QUAD_BIT             SubgroupFeatureFlagBits = 128
	SUBGROUP_FEATURE_PARTITIONED_BIT_NV   SubgroupFeatureFlagBits = 256
	SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM   SubgroupFeatureFlagBits = 2147483647
)

type PeerMemoryFeatureFlagBits int

const (
	PEER_MEMORY_FEATURE_COPY_SRC_BIT        PeerMemoryFeatureFlagBits = 1
	PEER_MEMORY_FEATURE_COPY_DST_BIT        PeerMemoryFeatureFlagBits = 2
	PEER_MEMORY_FEATURE_GENERIC_SRC_BIT     PeerMemoryFeatureFlagBits = 4
	PEER_MEMORY_FEATURE_GENERIC_DST_BIT     PeerMemoryFeatureFlagBits = 8
	PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR    PeerMemoryFeatureFlagBits = PEER_MEMORY_FEATURE_COPY_SRC_BIT
	PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR    PeerMemoryFeatureFlagBits = PEER_MEMORY_FEATURE_COPY_DST_BIT
	PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR PeerMemoryFeatureFlagBits = PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
	PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR PeerMemoryFeatureFlagBits = PEER_MEMORY_FEATURE_GENERIC_DST_BIT
	PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM  PeerMemoryFeatureFlagBits = 2147483647
)

type MemoryAllocateFlagBits int

const (
	MEMORY_ALLOCATE_DEVICE_MASK_BIT     MemoryAllocateFlagBits = 1
	MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR MemoryAllocateFlagBits = MEMORY_ALLOCATE_DEVICE_MASK_BIT
	MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM  MemoryAllocateFlagBits = 2147483647
)

type ExternalMemoryHandleTypeFlagBits int

const (
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT                       ExternalMemoryHandleTypeFlagBits = 1
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT                    ExternalMemoryHandleTypeFlagBits = 2
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT                ExternalMemoryHandleTypeFlagBits = 4
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT                   ExternalMemoryHandleTypeFlagBits = 8
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT               ExternalMemoryHandleTypeFlagBits = 16
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT                      ExternalMemoryHandleTypeFlagBits = 32
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT                  ExternalMemoryHandleTypeFlagBits = 64
	EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT                     ExternalMemoryHandleTypeFlagBits = 512
	EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID ExternalMemoryHandleTypeFlagBits = 1024
	EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT             ExternalMemoryHandleTypeFlagBits = 128
	EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT  ExternalMemoryHandleTypeFlagBits = 256
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR                   ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR                ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR            ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR               ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR           ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR                  ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR              ExternalMemoryHandleTypeFlagBits = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM                  ExternalMemoryHandleTypeFlagBits = 2147483647
)

type ExternalMemoryFeatureFlagBits int

const (
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT     ExternalMemoryFeatureFlagBits = 1
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT         ExternalMemoryFeatureFlagBits = 2
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT         ExternalMemoryFeatureFlagBits = 4
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR ExternalMemoryFeatureFlagBits = EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR     ExternalMemoryFeatureFlagBits = EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR     ExternalMemoryFeatureFlagBits = EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM     ExternalMemoryFeatureFlagBits = 2147483647
)

type ExternalFenceHandleTypeFlagBits int

const (
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT            ExternalFenceHandleTypeFlagBits = 1
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT         ExternalFenceHandleTypeFlagBits = 2
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT     ExternalFenceHandleTypeFlagBits = 4
	EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT              ExternalFenceHandleTypeFlagBits = 8
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR        ExternalFenceHandleTypeFlagBits = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR     ExternalFenceHandleTypeFlagBits = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
	EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR ExternalFenceHandleTypeFlagBits = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
	EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR          ExternalFenceHandleTypeFlagBits = EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
	EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM       ExternalFenceHandleTypeFlagBits = 2147483647
)

type ExternalFenceFeatureFlagBits int

const (
	EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT     ExternalFenceFeatureFlagBits = 1
	EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT     ExternalFenceFeatureFlagBits = 2
	EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR ExternalFenceFeatureFlagBits = EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
	EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR ExternalFenceFeatureFlagBits = EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
	EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM ExternalFenceFeatureFlagBits = 2147483647
)

type FenceImportFlagBits int

const (
	FENCE_IMPORT_TEMPORARY_BIT      FenceImportFlagBits = 1
	FENCE_IMPORT_TEMPORARY_BIT_KHR  FenceImportFlagBits = FENCE_IMPORT_TEMPORARY_BIT
	FENCE_IMPORT_FLAG_BITS_MAX_ENUM FenceImportFlagBits = 2147483647
)

type SemaphoreImportFlagBits int

const (
	SEMAPHORE_IMPORT_TEMPORARY_BIT      SemaphoreImportFlagBits = 1
	SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR  SemaphoreImportFlagBits = SEMAPHORE_IMPORT_TEMPORARY_BIT
	SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM SemaphoreImportFlagBits = 2147483647
)

type ExternalSemaphoreHandleTypeFlagBits int

const (
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT            ExternalSemaphoreHandleTypeFlagBits = 1
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT         ExternalSemaphoreHandleTypeFlagBits = 2
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT     ExternalSemaphoreHandleTypeFlagBits = 4
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT          ExternalSemaphoreHandleTypeFlagBits = 8
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT              ExternalSemaphoreHandleTypeFlagBits = 16
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR        ExternalSemaphoreHandleTypeFlagBits = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR     ExternalSemaphoreHandleTypeFlagBits = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR ExternalSemaphoreHandleTypeFlagBits = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR      ExternalSemaphoreHandleTypeFlagBits = EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR          ExternalSemaphoreHandleTypeFlagBits = EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
	EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM       ExternalSemaphoreHandleTypeFlagBits = 2147483647
)

type ExternalSemaphoreFeatureFlagBits int

const (
	EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT     ExternalSemaphoreFeatureFlagBits = 1
	EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT     ExternalSemaphoreFeatureFlagBits = 2
	EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR ExternalSemaphoreFeatureFlagBits = EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
	EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR ExternalSemaphoreFeatureFlagBits = EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
	EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM ExternalSemaphoreFeatureFlagBits = 2147483647
)

type PFNEnumerateInstanceVersion C.PFN_vkEnumerateInstanceVersion
type FuncEnumerateInstanceVersion func(apiVersion *uint32) (_ret Result)

func ToEnumerateInstanceVersion(p PFNVoidFunction) (fn FuncEnumerateInstanceVersion) {
	return func(apiVersion *uint32) (_ret Result) {
		var c struct {
			pApiVersion *C.uint32_t
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		if apiVersion != nil {
			c.pApiVersion = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pApiVersion = C.uint32_t(*apiVersion)
		} else {
			c.pApiVersion = nil
		}
		c._ret = C.callPFN_vkEnumerateInstanceVersion(C.PFN_vkEnumerateInstanceVersion(unsafe.Pointer(p)), c.pApiVersion)
		_ret = Result(c._ret)
		if apiVersion != nil {
			*apiVersion = uint32(*c.pApiVersion)
		}
		return
	}
}

type PFNBindBufferMemory2 C.PFN_vkBindBufferMemory2
type BindBufferMemoryInfo struct {
	Next         Structure
	Buffer       Buffer
	Memory       DeviceMemory
	MemoryOffset DeviceSize
}

func (g *BindBufferMemoryInfo) toC(c *C.VkBindBufferMemoryInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.buffer = C.VkBuffer(g.Buffer)
	c.memory = C.VkDeviceMemory(g.Memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MemoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *BindBufferMemoryInfo) fromC(c *C.VkBindBufferMemoryInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Buffer = Buffer(c.buffer)
	g.Memory = DeviceMemory(c.memory)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.memoryOffset))
		g.MemoryOffset = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *BindBufferMemoryInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
}
func (s *BindBufferMemoryInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBindBufferMemoryInfo)(m.alloc(C.sizeof_VkBindBufferMemoryInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BindBufferMemoryInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBindBufferMemoryInfo)(p)
	s.fromC(c)
}
func (s *BindBufferMemoryInfo) GetNext() Structure {
	return s.Next
}
func (s *BindBufferMemoryInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncBindBufferMemory2 func(device Device, bindInfos []BindBufferMemoryInfo) (_ret Result)

func ToBindBufferMemory2(p PFNVoidFunction) (fn FuncBindBufferMemory2) {
	return func(device Device, bindInfos []BindBufferMemoryInfo) (_ret Result) {
		var c struct {
			device        C.VkDevice
			bindInfoCount C.uint32_t
			pBindInfos    *C.VkBindBufferMemoryInfo
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.bindInfoCount = C.uint32_t(len(bindInfos))
		if len(bindInfos) != 0 {
			c.pBindInfos = (*C.VkBindBufferMemoryInfo)(m.alloc(C.sizeof_VkBindBufferMemoryInfo * uint(len(bindInfos))))
			slice1 := (*[1 << 31]C.VkBindBufferMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
			for i1, _ := range bindInfos {
				bindInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBindInfos = nil
		}
		c._ret = C.callPFN_vkBindBufferMemory2(C.PFN_vkBindBufferMemory2(unsafe.Pointer(p)), c.device, c.bindInfoCount, c.pBindInfos)
		_ret = Result(c._ret)
		return
	}
}

type PFNBindImageMemory2 C.PFN_vkBindImageMemory2
type BindImageMemoryInfo struct {
	Next         Structure
	Image        Image
	Memory       DeviceMemory
	MemoryOffset DeviceSize
}

func (g *BindImageMemoryInfo) toC(c *C.VkBindImageMemoryInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.image = C.VkImage(g.Image)
	c.memory = C.VkDeviceMemory(g.Memory)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.MemoryOffset))
		c.memoryOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *BindImageMemoryInfo) fromC(c *C.VkBindImageMemoryInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Image = Image(c.image)
	g.Memory = DeviceMemory(c.memory)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.memoryOffset))
		g.MemoryOffset = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *BindImageMemoryInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
}
func (s *BindImageMemoryInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBindImageMemoryInfo)(m.alloc(C.sizeof_VkBindImageMemoryInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BindImageMemoryInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBindImageMemoryInfo)(p)
	s.fromC(c)
}
func (s *BindImageMemoryInfo) GetNext() Structure {
	return s.Next
}
func (s *BindImageMemoryInfo) SetNext(n Structure) {
	s.Next = n
}

type FuncBindImageMemory2 func(device Device, bindInfos []BindImageMemoryInfo) (_ret Result)

func ToBindImageMemory2(p PFNVoidFunction) (fn FuncBindImageMemory2) {
	return func(device Device, bindInfos []BindImageMemoryInfo) (_ret Result) {
		var c struct {
			device        C.VkDevice
			bindInfoCount C.uint32_t
			pBindInfos    *C.VkBindImageMemoryInfo
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.bindInfoCount = C.uint32_t(len(bindInfos))
		if len(bindInfos) != 0 {
			c.pBindInfos = (*C.VkBindImageMemoryInfo)(m.alloc(C.sizeof_VkBindImageMemoryInfo * uint(len(bindInfos))))
			slice1 := (*[1 << 31]C.VkBindImageMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
			for i1, _ := range bindInfos {
				bindInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBindInfos = nil
		}
		c._ret = C.callPFN_vkBindImageMemory2(C.PFN_vkBindImageMemory2(unsafe.Pointer(p)), c.device, c.bindInfoCount, c.pBindInfos)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetDeviceGroupPeerMemoryFeatures C.PFN_vkGetDeviceGroupPeerMemoryFeatures
type PeerMemoryFeatureFlags Flags
type FuncGetDeviceGroupPeerMemoryFeatures func(device Device, heapIndex uint32, localDeviceIndex uint32, peerMemoryFeatures []PeerMemoryFeatureFlags)

func ToGetDeviceGroupPeerMemoryFeatures(p PFNVoidFunction) (fn FuncGetDeviceGroupPeerMemoryFeatures) {
	return func(device Device, heapIndex uint32, localDeviceIndex uint32, peerMemoryFeatures []PeerMemoryFeatureFlags) {
		var c struct {
			device              C.VkDevice
			heapIndex           C.uint32_t
			localDeviceIndex    C.uint32_t
			remoteDeviceIndex   C.uint32_t
			pPeerMemoryFeatures *C.VkPeerMemoryFeatureFlags
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.heapIndex = C.uint32_t(heapIndex)
		c.localDeviceIndex = C.uint32_t(localDeviceIndex)
		c.remoteDeviceIndex = C.uint32_t(len(peerMemoryFeatures))
		if len(peerMemoryFeatures) != 0 {
			c.pPeerMemoryFeatures = (*C.VkPeerMemoryFeatureFlags)(m.alloc(C.sizeof_VkPeerMemoryFeatureFlags * uint(len(peerMemoryFeatures))))
			slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
			for i1, _ := range peerMemoryFeatures {
				{
					var temp_in_VkPeerMemoryFeatureFlags C.VkFlags
					{
						var temp_in_VkFlags C.uint32_t
						temp_in_VkFlags = C.uint32_t((uint32)((Flags)(peerMemoryFeatures[i1])))
						temp_in_VkPeerMemoryFeatureFlags = C.VkFlags(temp_in_VkFlags)
					}
					slice1[i1] = C.VkPeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
				}
			}
		} else {
			c.pPeerMemoryFeatures = nil
		}
		C.callPFN_vkGetDeviceGroupPeerMemoryFeatures(C.PFN_vkGetDeviceGroupPeerMemoryFeatures(unsafe.Pointer(p)), c.device, c.heapIndex, c.localDeviceIndex, c.remoteDeviceIndex, c.pPeerMemoryFeatures)
		if len(peerMemoryFeatures) != 0 {
			slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
			for i1, _ := range peerMemoryFeatures {
				{
					var temp_in_VkPeerMemoryFeatureFlags Flags
					{
						var temp_in_VkFlags uint32
						temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(slice1[i1])))
						temp_in_VkPeerMemoryFeatureFlags = Flags(temp_in_VkFlags)
					}
					peerMemoryFeatures[i1] = PeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
				}
			}
		}
	}
}

type PFNCmdSetDeviceMask C.PFN_vkCmdSetDeviceMask
type FuncCmdSetDeviceMask func(commandBuffer CommandBuffer, deviceMask uint32)

func ToCmdSetDeviceMask(p PFNVoidFunction) (fn FuncCmdSetDeviceMask) {
	return func(commandBuffer CommandBuffer, deviceMask uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			deviceMask    C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.deviceMask = C.uint32_t(deviceMask)
		C.callPFN_vkCmdSetDeviceMask(C.PFN_vkCmdSetDeviceMask(unsafe.Pointer(p)), c.commandBuffer, c.deviceMask)
	}
}

type PFNCmdDispatchBase C.PFN_vkCmdDispatchBase
type FuncCmdDispatchBase func(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32)

func ToCmdDispatchBase(p PFNVoidFunction) (fn FuncCmdDispatchBase) {
	return func(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			baseGroupX    C.uint32_t
			baseGroupY    C.uint32_t
			baseGroupZ    C.uint32_t
			groupCountX   C.uint32_t
			groupCountY   C.uint32_t
			groupCountZ   C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.baseGroupX = C.uint32_t(baseGroupX)
		c.baseGroupY = C.uint32_t(baseGroupY)
		c.baseGroupZ = C.uint32_t(baseGroupZ)
		c.groupCountX = C.uint32_t(groupCountX)
		c.groupCountY = C.uint32_t(groupCountY)
		c.groupCountZ = C.uint32_t(groupCountZ)
		C.callPFN_vkCmdDispatchBase(C.PFN_vkCmdDispatchBase(unsafe.Pointer(p)), c.commandBuffer, c.baseGroupX, c.baseGroupY, c.baseGroupZ, c.groupCountX, c.groupCountY, c.groupCountZ)
	}
}

type PFNEnumeratePhysicalDeviceGroups C.PFN_vkEnumeratePhysicalDeviceGroups
type PhysicalDeviceGroupProperties struct {
	Next                Structure
	PhysicalDeviceCount uint32
	PhysicalDevices     [32]PhysicalDevice
	SubsetAllocation    bool
}

func (g *PhysicalDeviceGroupProperties) toC(c *C.VkPhysicalDeviceGroupProperties, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.physicalDeviceCount = C.uint32_t(g.PhysicalDeviceCount)
	for i, _ := range g.PhysicalDevices {
		c.physicalDevices[i] = C.VkPhysicalDevice(g.PhysicalDevices[i])
	}
	if g.SubsetAllocation {
		c.subsetAllocation = 1
	} else {
		c.subsetAllocation = 0
	}
}
func (g *PhysicalDeviceGroupProperties) fromC(c *C.VkPhysicalDeviceGroupProperties) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.PhysicalDeviceCount = uint32(c.physicalDeviceCount)
	for i, _ := range g.PhysicalDevices {
		g.PhysicalDevices[i] = PhysicalDevice(c.physicalDevices[i])
	}
	g.SubsetAllocation = c.subsetAllocation != 0
}
func (s *PhysicalDeviceGroupProperties) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
}
func (s *PhysicalDeviceGroupProperties) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceGroupProperties)(m.alloc(C.sizeof_VkPhysicalDeviceGroupProperties))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceGroupProperties) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceGroupProperties)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceGroupProperties) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceGroupProperties) SetNext(n Structure) {
	s.Next = n
}

type FuncEnumeratePhysicalDeviceGroups func(instance Instance, physicalDeviceGroupCount *uint32, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) (_ret Result)

func ToEnumeratePhysicalDeviceGroups(p PFNVoidFunction) (fn FuncEnumeratePhysicalDeviceGroups) {
	return func(instance Instance, physicalDeviceGroupCount *uint32, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) (_ret Result) {
		var c struct {
			instance                       C.VkInstance
			pPhysicalDeviceGroupCount      *C.uint32_t
			pPhysicalDeviceGroupProperties *C.VkPhysicalDeviceGroupProperties
			_ret                           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if physicalDeviceGroupCount != nil {
			c.pPhysicalDeviceGroupCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPhysicalDeviceGroupCount = C.uint32_t(*physicalDeviceGroupCount)
		} else {
			c.pPhysicalDeviceGroupCount = nil
		}
		if len(physicalDeviceGroupProperties) != 0 {
			c.pPhysicalDeviceGroupProperties = (*C.VkPhysicalDeviceGroupProperties)(m.alloc(C.sizeof_VkPhysicalDeviceGroupProperties * uint(len(physicalDeviceGroupProperties))))
			slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
			for i1, _ := range physicalDeviceGroupProperties {
				physicalDeviceGroupProperties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pPhysicalDeviceGroupProperties = nil
		}
		c._ret = C.callPFN_vkEnumeratePhysicalDeviceGroups(C.PFN_vkEnumeratePhysicalDeviceGroups(unsafe.Pointer(p)), c.instance, c.pPhysicalDeviceGroupCount, c.pPhysicalDeviceGroupProperties)
		_ret = Result(c._ret)
		if physicalDeviceGroupCount != nil {
			*physicalDeviceGroupCount = uint32(*c.pPhysicalDeviceGroupCount)
		}
		if len(physicalDeviceGroupProperties) != 0 {
			slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
			for i1, _ := range physicalDeviceGroupProperties {
				physicalDeviceGroupProperties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetImageMemoryRequirements2 C.PFN_vkGetImageMemoryRequirements2
type ImageMemoryRequirementsInfo2 struct {
	Next  Structure
	Image Image
}

func (g *ImageMemoryRequirementsInfo2) toC(c *C.VkImageMemoryRequirementsInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.image = C.VkImage(g.Image)
}
func (g *ImageMemoryRequirementsInfo2) fromC(c *C.VkImageMemoryRequirementsInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Image = Image(c.image)
}
func (s *ImageMemoryRequirementsInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
}
func (s *ImageMemoryRequirementsInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageMemoryRequirementsInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageMemoryRequirementsInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageMemoryRequirementsInfo2)(p)
	s.fromC(c)
}
func (s *ImageMemoryRequirementsInfo2) GetNext() Structure {
	return s.Next
}
func (s *ImageMemoryRequirementsInfo2) SetNext(n Structure) {
	s.Next = n
}

type MemoryRequirements2 struct {
	Next               Structure
	MemoryRequirements MemoryRequirements
}

func (g *MemoryRequirements2) toC(c *C.VkMemoryRequirements2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.MemoryRequirements.toC(&c.memoryRequirements)
}
func (g *MemoryRequirements2) fromC(c *C.VkMemoryRequirements2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MemoryRequirements.fromC(&c.memoryRequirements)
}
func (s *MemoryRequirements2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
}
func (s *MemoryRequirements2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryRequirements2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryRequirements2)(p)
	s.fromC(c)
}
func (s *MemoryRequirements2) GetNext() Structure {
	return s.Next
}
func (s *MemoryRequirements2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetImageMemoryRequirements2 func(device Device, info *ImageMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2)

func ToGetImageMemoryRequirements2(p PFNVoidFunction) (fn FuncGetImageMemoryRequirements2) {
	return func(device Device, info *ImageMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
		var c struct {
			device              C.VkDevice
			pInfo               *C.VkImageMemoryRequirementsInfo2
			pMemoryRequirements *C.VkMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkImageMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
			memoryRequirements.toC(c.pMemoryRequirements, m)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetImageMemoryRequirements2(C.PFN_vkGetImageMemoryRequirements2(unsafe.Pointer(p)), c.device, c.pInfo, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetBufferMemoryRequirements2 C.PFN_vkGetBufferMemoryRequirements2
type BufferMemoryRequirementsInfo2 struct {
	Next   Structure
	Buffer Buffer
}

func (g *BufferMemoryRequirementsInfo2) toC(c *C.VkBufferMemoryRequirementsInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.buffer = C.VkBuffer(g.Buffer)
}
func (g *BufferMemoryRequirementsInfo2) fromC(c *C.VkBufferMemoryRequirementsInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Buffer = Buffer(c.buffer)
}
func (s *BufferMemoryRequirementsInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
}
func (s *BufferMemoryRequirementsInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkBufferMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkBufferMemoryRequirementsInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *BufferMemoryRequirementsInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkBufferMemoryRequirementsInfo2)(p)
	s.fromC(c)
}
func (s *BufferMemoryRequirementsInfo2) GetNext() Structure {
	return s.Next
}
func (s *BufferMemoryRequirementsInfo2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetBufferMemoryRequirements2 func(device Device, info *BufferMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2)

func ToGetBufferMemoryRequirements2(p PFNVoidFunction) (fn FuncGetBufferMemoryRequirements2) {
	return func(device Device, info *BufferMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
		var c struct {
			device              C.VkDevice
			pInfo               *C.VkBufferMemoryRequirementsInfo2
			pMemoryRequirements *C.VkMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkBufferMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkBufferMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
			memoryRequirements.toC(c.pMemoryRequirements, m)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetBufferMemoryRequirements2(C.PFN_vkGetBufferMemoryRequirements2(unsafe.Pointer(p)), c.device, c.pInfo, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetImageSparseMemoryRequirements2 C.PFN_vkGetImageSparseMemoryRequirements2
type ImageSparseMemoryRequirementsInfo2 struct {
	Next  Structure
	Image Image
}

func (g *ImageSparseMemoryRequirementsInfo2) toC(c *C.VkImageSparseMemoryRequirementsInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.image = C.VkImage(g.Image)
}
func (g *ImageSparseMemoryRequirementsInfo2) fromC(c *C.VkImageSparseMemoryRequirementsInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Image = Image(c.image)
}
func (s *ImageSparseMemoryRequirementsInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
}
func (s *ImageSparseMemoryRequirementsInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageSparseMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageSparseMemoryRequirementsInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageSparseMemoryRequirementsInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageSparseMemoryRequirementsInfo2)(p)
	s.fromC(c)
}
func (s *ImageSparseMemoryRequirementsInfo2) GetNext() Structure {
	return s.Next
}
func (s *ImageSparseMemoryRequirementsInfo2) SetNext(n Structure) {
	s.Next = n
}

type SparseImageMemoryRequirements2 struct {
	Next               Structure
	MemoryRequirements SparseImageMemoryRequirements
}

func (g *SparseImageMemoryRequirements2) toC(c *C.VkSparseImageMemoryRequirements2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.MemoryRequirements.toC(&c.memoryRequirements)
}
func (g *SparseImageMemoryRequirements2) fromC(c *C.VkSparseImageMemoryRequirements2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MemoryRequirements.fromC(&c.memoryRequirements)
}
func (s *SparseImageMemoryRequirements2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
}
func (s *SparseImageMemoryRequirements2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSparseImageMemoryRequirements2)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SparseImageMemoryRequirements2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSparseImageMemoryRequirements2)(p)
	s.fromC(c)
}
func (s *SparseImageMemoryRequirements2) GetNext() Structure {
	return s.Next
}
func (s *SparseImageMemoryRequirements2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetImageSparseMemoryRequirements2 func(device Device, info *ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements2)

func ToGetImageSparseMemoryRequirements2(p PFNVoidFunction) (fn FuncGetImageSparseMemoryRequirements2) {
	return func(device Device, info *ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements2) {
		var c struct {
			device                        C.VkDevice
			pInfo                         *C.VkImageSparseMemoryRequirementsInfo2
			pSparseMemoryRequirementCount *C.uint32_t
			pSparseMemoryRequirements     *C.VkSparseImageMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkImageSparseMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageSparseMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if sparseMemoryRequirementCount != nil {
			c.pSparseMemoryRequirementCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSparseMemoryRequirementCount = C.uint32_t(*sparseMemoryRequirementCount)
		} else {
			c.pSparseMemoryRequirementCount = nil
		}
		if len(sparseMemoryRequirements) != 0 {
			c.pSparseMemoryRequirements = (*C.VkSparseImageMemoryRequirements2)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements2 * uint(len(sparseMemoryRequirements))))
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pSparseMemoryRequirements = nil
		}
		C.callPFN_vkGetImageSparseMemoryRequirements2(C.PFN_vkGetImageSparseMemoryRequirements2(unsafe.Pointer(p)), c.device, c.pInfo, c.pSparseMemoryRequirementCount, c.pSparseMemoryRequirements)
		if sparseMemoryRequirementCount != nil {
			*sparseMemoryRequirementCount = uint32(*c.pSparseMemoryRequirementCount)
		}
		if len(sparseMemoryRequirements) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetPhysicalDeviceFeatures2 C.PFN_vkGetPhysicalDeviceFeatures2
type PhysicalDeviceFeatures2 struct {
	Next     Structure
	Features PhysicalDeviceFeatures
}

func (g *PhysicalDeviceFeatures2) toC(c *C.VkPhysicalDeviceFeatures2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.Features.toC(&c.features)
}
func (g *PhysicalDeviceFeatures2) fromC(c *C.VkPhysicalDeviceFeatures2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Features.fromC(&c.features)
}
func (s *PhysicalDeviceFeatures2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
}
func (s *PhysicalDeviceFeatures2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceFeatures2)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceFeatures2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceFeatures2)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceFeatures2) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceFeatures2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceFeatures2 func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures2)

func ToGetPhysicalDeviceFeatures2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFeatures2) {
	return func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFeatures      *C.VkPhysicalDeviceFeatures2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if features != nil {
			c.pFeatures = (*C.VkPhysicalDeviceFeatures2)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures2))
			features.toC(c.pFeatures, m)
		} else {
			c.pFeatures = nil
		}
		C.callPFN_vkGetPhysicalDeviceFeatures2(C.PFN_vkGetPhysicalDeviceFeatures2(unsafe.Pointer(p)), c.physicalDevice, c.pFeatures)
		if features != nil {
			features.fromC(c.pFeatures)
		}
	}
}

type PFNGetPhysicalDeviceProperties2 C.PFN_vkGetPhysicalDeviceProperties2
type PhysicalDeviceProperties2 struct {
	Next       Structure
	Properties PhysicalDeviceProperties
}

func (g *PhysicalDeviceProperties2) toC(c *C.VkPhysicalDeviceProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.Properties.toC(&c.properties)
}
func (g *PhysicalDeviceProperties2) fromC(c *C.VkPhysicalDeviceProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Properties.fromC(&c.properties)
}
func (s *PhysicalDeviceProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
}
func (s *PhysicalDeviceProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceProperties2)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceProperties2) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceProperties2 func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties2)

func ToGetPhysicalDeviceProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceProperties2) {
	return func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pProperties    *C.VkPhysicalDeviceProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if properties != nil {
			c.pProperties = (*C.VkPhysicalDeviceProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceProperties2))
			properties.toC(c.pProperties, m)
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceProperties2(C.PFN_vkGetPhysicalDeviceProperties2(unsafe.Pointer(p)), c.physicalDevice, c.pProperties)
		if properties != nil {
			properties.fromC(c.pProperties)
		}
	}
}

type PFNGetPhysicalDeviceFormatProperties2 C.PFN_vkGetPhysicalDeviceFormatProperties2
type FormatProperties2 struct {
	Next             Structure
	FormatProperties FormatProperties
}

func (g *FormatProperties2) toC(c *C.VkFormatProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.FormatProperties.toC(&c.formatProperties)
}
func (g *FormatProperties2) fromC(c *C.VkFormatProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.FormatProperties.fromC(&c.formatProperties)
}
func (s *FormatProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
}
func (s *FormatProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkFormatProperties2)(m.alloc(C.sizeof_VkFormatProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *FormatProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkFormatProperties2)(p)
	s.fromC(c)
}
func (s *FormatProperties2) GetNext() Structure {
	return s.Next
}
func (s *FormatProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceFormatProperties2 func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties2)

func ToGetPhysicalDeviceFormatProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFormatProperties2) {
	return func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties2) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			format            C.VkFormat
			pFormatProperties *C.VkFormatProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		if formatProperties != nil {
			c.pFormatProperties = (*C.VkFormatProperties2)(m.alloc(C.sizeof_VkFormatProperties2))
			formatProperties.toC(c.pFormatProperties, m)
		} else {
			c.pFormatProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceFormatProperties2(C.PFN_vkGetPhysicalDeviceFormatProperties2(unsafe.Pointer(p)), c.physicalDevice, c.format, c.pFormatProperties)
		if formatProperties != nil {
			formatProperties.fromC(c.pFormatProperties)
		}
	}
}

type PFNGetPhysicalDeviceImageFormatProperties2 C.PFN_vkGetPhysicalDeviceImageFormatProperties2
type PhysicalDeviceImageFormatInfo2 struct {
	Next   Structure
	Format Format
	Type   ImageType
	Tiling ImageTiling
	Usage  ImageUsageFlags
	Flags  ImageCreateFlags
}

func (g *PhysicalDeviceImageFormatInfo2) toC(c *C.VkPhysicalDeviceImageFormatInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.format = C.VkFormat(g.Format)
	c._type = C.VkImageType(g.Type)
	c.tiling = C.VkImageTiling(g.Tiling)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Usage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	{
		var temp_in_VkImageCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkImageCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkImageCreateFlags(temp_in_VkImageCreateFlags)
	}
}
func (g *PhysicalDeviceImageFormatInfo2) fromC(c *C.VkPhysicalDeviceImageFormatInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Format = Format(c.format)
	g.Type = ImageType(c._type)
	g.Tiling = ImageTiling(c.tiling)
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.usage)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Usage = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	{
		var temp_in_VkImageCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkImageCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = ImageCreateFlags(temp_in_VkImageCreateFlags)
	}
}
func (s *PhysicalDeviceImageFormatInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
}
func (s *PhysicalDeviceImageFormatInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceImageFormatInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceImageFormatInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceImageFormatInfo2)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceImageFormatInfo2) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceImageFormatInfo2) SetNext(n Structure) {
	s.Next = n
}

type ImageFormatProperties2 struct {
	Next                  Structure
	ImageFormatProperties ImageFormatProperties
}

func (g *ImageFormatProperties2) toC(c *C.VkImageFormatProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.ImageFormatProperties.toC(&c.imageFormatProperties)
}
func (g *ImageFormatProperties2) fromC(c *C.VkImageFormatProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ImageFormatProperties.fromC(&c.imageFormatProperties)
}
func (s *ImageFormatProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
}
func (s *ImageFormatProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImageFormatProperties2)(m.alloc(C.sizeof_VkImageFormatProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImageFormatProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImageFormatProperties2)(p)
	s.fromC(c)
}
func (s *ImageFormatProperties2) GetNext() Structure {
	return s.Next
}
func (s *ImageFormatProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceImageFormatProperties2 func(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2, imageFormatProperties *ImageFormatProperties2) (_ret Result)

func ToGetPhysicalDeviceImageFormatProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceImageFormatProperties2) {
	return func(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2, imageFormatProperties *ImageFormatProperties2) (_ret Result) {
		var c struct {
			physicalDevice         C.VkPhysicalDevice
			pImageFormatInfo       *C.VkPhysicalDeviceImageFormatInfo2
			pImageFormatProperties *C.VkImageFormatProperties2
			_ret                   C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if imageFormatInfo != nil {
			c.pImageFormatInfo = (*C.VkPhysicalDeviceImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceImageFormatInfo2))
			imageFormatInfo.toC(c.pImageFormatInfo, m)
		} else {
			c.pImageFormatInfo = nil
		}
		if imageFormatProperties != nil {
			c.pImageFormatProperties = (*C.VkImageFormatProperties2)(m.alloc(C.sizeof_VkImageFormatProperties2))
			imageFormatProperties.toC(c.pImageFormatProperties, m)
		} else {
			c.pImageFormatProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceImageFormatProperties2(C.PFN_vkGetPhysicalDeviceImageFormatProperties2(unsafe.Pointer(p)), c.physicalDevice, c.pImageFormatInfo, c.pImageFormatProperties)
		_ret = Result(c._ret)
		if imageFormatProperties != nil {
			imageFormatProperties.fromC(c.pImageFormatProperties)
		}
		return
	}
}

type PFNGetPhysicalDeviceQueueFamilyProperties2 C.PFN_vkGetPhysicalDeviceQueueFamilyProperties2
type QueueFamilyProperties2 struct {
	Next                  Structure
	QueueFamilyProperties QueueFamilyProperties
}

func (g *QueueFamilyProperties2) toC(c *C.VkQueueFamilyProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.QueueFamilyProperties.toC(&c.queueFamilyProperties)
}
func (g *QueueFamilyProperties2) fromC(c *C.VkQueueFamilyProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.QueueFamilyProperties.fromC(&c.queueFamilyProperties)
}
func (s *QueueFamilyProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
}
func (s *QueueFamilyProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkQueueFamilyProperties2)(m.alloc(C.sizeof_VkQueueFamilyProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *QueueFamilyProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkQueueFamilyProperties2)(p)
	s.fromC(c)
}
func (s *QueueFamilyProperties2) GetNext() Structure {
	return s.Next
}
func (s *QueueFamilyProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceQueueFamilyProperties2 func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties2)

func ToGetPhysicalDeviceQueueFamilyProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceQueueFamilyProperties2) {
	return func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties2) {
		var c struct {
			physicalDevice            C.VkPhysicalDevice
			pQueueFamilyPropertyCount *C.uint32_t
			pQueueFamilyProperties    *C.VkQueueFamilyProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if queueFamilyPropertyCount != nil {
			c.pQueueFamilyPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pQueueFamilyPropertyCount = C.uint32_t(*queueFamilyPropertyCount)
		} else {
			c.pQueueFamilyPropertyCount = nil
		}
		if len(queueFamilyProperties) != 0 {
			c.pQueueFamilyProperties = (*C.VkQueueFamilyProperties2)(m.alloc(C.sizeof_VkQueueFamilyProperties2 * uint(len(queueFamilyProperties))))
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pQueueFamilyProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceQueueFamilyProperties2(C.PFN_vkGetPhysicalDeviceQueueFamilyProperties2(unsafe.Pointer(p)), c.physicalDevice, c.pQueueFamilyPropertyCount, c.pQueueFamilyProperties)
		if queueFamilyPropertyCount != nil {
			*queueFamilyPropertyCount = uint32(*c.pQueueFamilyPropertyCount)
		}
		if len(queueFamilyProperties) != 0 {
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetPhysicalDeviceMemoryProperties2 C.PFN_vkGetPhysicalDeviceMemoryProperties2
type PhysicalDeviceMemoryProperties2 struct {
	Next             Structure
	MemoryProperties PhysicalDeviceMemoryProperties
}

func (g *PhysicalDeviceMemoryProperties2) toC(c *C.VkPhysicalDeviceMemoryProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.MemoryProperties.toC(&c.memoryProperties)
}
func (g *PhysicalDeviceMemoryProperties2) fromC(c *C.VkPhysicalDeviceMemoryProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MemoryProperties.fromC(&c.memoryProperties)
}
func (s *PhysicalDeviceMemoryProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
}
func (s *PhysicalDeviceMemoryProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceMemoryProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceMemoryProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceMemoryProperties2)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceMemoryProperties2) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceMemoryProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceMemoryProperties2 func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties2)

func ToGetPhysicalDeviceMemoryProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceMemoryProperties2) {
	return func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties2) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			pMemoryProperties *C.VkPhysicalDeviceMemoryProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if memoryProperties != nil {
			c.pMemoryProperties = (*C.VkPhysicalDeviceMemoryProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties2))
			memoryProperties.toC(c.pMemoryProperties, m)
		} else {
			c.pMemoryProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceMemoryProperties2(C.PFN_vkGetPhysicalDeviceMemoryProperties2(unsafe.Pointer(p)), c.physicalDevice, c.pMemoryProperties)
		if memoryProperties != nil {
			memoryProperties.fromC(c.pMemoryProperties)
		}
	}
}

type PFNGetPhysicalDeviceSparseImageFormatProperties2 C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2
type PhysicalDeviceSparseImageFormatInfo2 struct {
	Next    Structure
	Format  Format
	Type    ImageType
	Samples SampleCountFlagBits
	Usage   ImageUsageFlags
	Tiling  ImageTiling
}

func (g *PhysicalDeviceSparseImageFormatInfo2) toC(c *C.VkPhysicalDeviceSparseImageFormatInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.format = C.VkFormat(g.Format)
	c._type = C.VkImageType(g.Type)
	c.samples = C.VkSampleCountFlagBits(g.Samples)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Usage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	c.tiling = C.VkImageTiling(g.Tiling)
}
func (g *PhysicalDeviceSparseImageFormatInfo2) fromC(c *C.VkPhysicalDeviceSparseImageFormatInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Format = Format(c.format)
	g.Type = ImageType(c._type)
	g.Samples = SampleCountFlagBits(c.samples)
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.usage)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Usage = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	g.Tiling = ImageTiling(c.tiling)
}
func (s *PhysicalDeviceSparseImageFormatInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
}
func (s *PhysicalDeviceSparseImageFormatInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceSparseImageFormatInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceSparseImageFormatInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceSparseImageFormatInfo2) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceSparseImageFormatInfo2) SetNext(n Structure) {
	s.Next = n
}

type SparseImageFormatProperties2 struct {
	Next       Structure
	Properties SparseImageFormatProperties
}

func (g *SparseImageFormatProperties2) toC(c *C.VkSparseImageFormatProperties2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.Properties.toC(&c.properties)
}
func (g *SparseImageFormatProperties2) fromC(c *C.VkSparseImageFormatProperties2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Properties.fromC(&c.properties)
}
func (s *SparseImageFormatProperties2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
}
func (s *SparseImageFormatProperties2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSparseImageFormatProperties2)(m.alloc(C.sizeof_VkSparseImageFormatProperties2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SparseImageFormatProperties2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSparseImageFormatProperties2)(p)
	s.fromC(c)
}
func (s *SparseImageFormatProperties2) GetNext() Structure {
	return s.Next
}
func (s *SparseImageFormatProperties2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceSparseImageFormatProperties2 func(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2, propertyCount *uint32, properties []SparseImageFormatProperties2)

func ToGetPhysicalDeviceSparseImageFormatProperties2(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSparseImageFormatProperties2) {
	return func(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2, propertyCount *uint32, properties []SparseImageFormatProperties2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFormatInfo    *C.VkPhysicalDeviceSparseImageFormatInfo2
			pPropertyCount *C.uint32_t
			pProperties    *C.VkSparseImageFormatProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if formatInfo != nil {
			c.pFormatInfo = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceSparseImageFormatInfo2))
			formatInfo.toC(c.pFormatInfo, m)
		} else {
			c.pFormatInfo = nil
		}
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkSparseImageFormatProperties2)(m.alloc(C.sizeof_VkSparseImageFormatProperties2 * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceSparseImageFormatProperties2(C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2(unsafe.Pointer(p)), c.physicalDevice, c.pFormatInfo, c.pPropertyCount, c.pProperties)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNTrimCommandPool C.PFN_vkTrimCommandPool
type CommandPoolTrimFlags Flags
type FuncTrimCommandPool func(device Device, commandPool CommandPool, flags CommandPoolTrimFlags)

func ToTrimCommandPool(p PFNVoidFunction) (fn FuncTrimCommandPool) {
	return func(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {
		var c struct {
			device      C.VkDevice
			commandPool C.VkCommandPool
			flags       C.VkCommandPoolTrimFlags
		}
		c.device = C.VkDevice(device)
		c.commandPool = C.VkCommandPool(commandPool)
		{
			var temp_in_VkCommandPoolTrimFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkCommandPoolTrimFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkCommandPoolTrimFlags(temp_in_VkCommandPoolTrimFlags)
		}
		C.callPFN_vkTrimCommandPool(C.PFN_vkTrimCommandPool(unsafe.Pointer(p)), c.device, c.commandPool, c.flags)
	}
}

type PFNGetDeviceQueue2 C.PFN_vkGetDeviceQueue2
type DeviceQueueInfo2 struct {
	Next             Structure
	Flags            DeviceQueueCreateFlags
	QueueFamilyIndex uint32
	QueueIndex       uint32
}

func (g *DeviceQueueInfo2) toC(c *C.VkDeviceQueueInfo2, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDeviceQueueCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDeviceQueueCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDeviceQueueCreateFlags(temp_in_VkDeviceQueueCreateFlags)
	}
	c.queueFamilyIndex = C.uint32_t(g.QueueFamilyIndex)
	c.queueIndex = C.uint32_t(g.QueueIndex)
}
func (g *DeviceQueueInfo2) fromC(c *C.VkDeviceQueueInfo2) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDeviceQueueCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDeviceQueueCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DeviceQueueCreateFlags(temp_in_VkDeviceQueueCreateFlags)
	}
	g.QueueFamilyIndex = uint32(c.queueFamilyIndex)
	g.QueueIndex = uint32(c.queueIndex)
}
func (s *DeviceQueueInfo2) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2
}
func (s *DeviceQueueInfo2) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceQueueInfo2)(m.alloc(C.sizeof_VkDeviceQueueInfo2))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceQueueInfo2) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceQueueInfo2)(p)
	s.fromC(c)
}
func (s *DeviceQueueInfo2) GetNext() Structure {
	return s.Next
}
func (s *DeviceQueueInfo2) SetNext(n Structure) {
	s.Next = n
}

type FuncGetDeviceQueue2 func(device Device, queueInfo *DeviceQueueInfo2, queue *Queue)

func ToGetDeviceQueue2(p PFNVoidFunction) (fn FuncGetDeviceQueue2) {
	return func(device Device, queueInfo *DeviceQueueInfo2, queue *Queue) {
		var c struct {
			device     C.VkDevice
			pQueueInfo *C.VkDeviceQueueInfo2
			pQueue     *C.VkQueue
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if queueInfo != nil {
			c.pQueueInfo = (*C.VkDeviceQueueInfo2)(m.alloc(C.sizeof_VkDeviceQueueInfo2))
			queueInfo.toC(c.pQueueInfo, m)
		} else {
			c.pQueueInfo = nil
		}
		if queue != nil {
			c.pQueue = (*C.VkQueue)(m.alloc(C.sizeof_VkQueue))
			*c.pQueue = C.VkQueue(*queue)
		} else {
			c.pQueue = nil
		}
		C.callPFN_vkGetDeviceQueue2(C.PFN_vkGetDeviceQueue2(unsafe.Pointer(p)), c.device, c.pQueueInfo, c.pQueue)
		if queue != nil {
			*queue = Queue(*c.pQueue)
		}
	}
}

type PFNCreateSamplerYcbcrConversion C.PFN_vkCreateSamplerYcbcrConversion
type SamplerYcbcrConversionCreateInfo struct {
	Next                        Structure
	Format                      Format
	YcbcrModel                  SamplerYcbcrModelConversion
	YcbcrRange                  SamplerYcbcrRange
	Components                  ComponentMapping
	XChromaOffset               ChromaLocation
	YChromaOffset               ChromaLocation
	ChromaFilter                Filter
	ForceExplicitReconstruction bool
}

func (g *SamplerYcbcrConversionCreateInfo) toC(c *C.VkSamplerYcbcrConversionCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.format = C.VkFormat(g.Format)
	c.ycbcrModel = C.VkSamplerYcbcrModelConversion(g.YcbcrModel)
	c.ycbcrRange = C.VkSamplerYcbcrRange(g.YcbcrRange)
	g.Components.toC(&c.components)
	c.xChromaOffset = C.VkChromaLocation(g.XChromaOffset)
	c.yChromaOffset = C.VkChromaLocation(g.YChromaOffset)
	c.chromaFilter = C.VkFilter(g.ChromaFilter)
	if g.ForceExplicitReconstruction {
		c.forceExplicitReconstruction = 1
	} else {
		c.forceExplicitReconstruction = 0
	}
}
func (g *SamplerYcbcrConversionCreateInfo) fromC(c *C.VkSamplerYcbcrConversionCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Format = Format(c.format)
	g.YcbcrModel = SamplerYcbcrModelConversion(c.ycbcrModel)
	g.YcbcrRange = SamplerYcbcrRange(c.ycbcrRange)
	g.Components.fromC(&c.components)
	g.XChromaOffset = ChromaLocation(c.xChromaOffset)
	g.YChromaOffset = ChromaLocation(c.yChromaOffset)
	g.ChromaFilter = Filter(c.chromaFilter)
	g.ForceExplicitReconstruction = c.forceExplicitReconstruction != 0
}
func (s *SamplerYcbcrConversionCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
}
func (s *SamplerYcbcrConversionCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSamplerYcbcrConversionCreateInfo)(m.alloc(C.sizeof_VkSamplerYcbcrConversionCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SamplerYcbcrConversionCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSamplerYcbcrConversionCreateInfo)(p)
	s.fromC(c)
}
func (s *SamplerYcbcrConversionCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *SamplerYcbcrConversionCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type SamplerYcbcrConversion C.VkSamplerYcbcrConversion
type FuncCreateSamplerYcbcrConversion func(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks, ycbcrConversion *SamplerYcbcrConversion) (_ret Result)

func ToCreateSamplerYcbcrConversion(p PFNVoidFunction) (fn FuncCreateSamplerYcbcrConversion) {
	return func(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks, ycbcrConversion *SamplerYcbcrConversion) (_ret Result) {
		var c struct {
			device           C.VkDevice
			pCreateInfo      *C.VkSamplerYcbcrConversionCreateInfo
			pAllocator       *C.VkAllocationCallbacks
			pYcbcrConversion *C.VkSamplerYcbcrConversion
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkSamplerYcbcrConversionCreateInfo)(m.alloc(C.sizeof_VkSamplerYcbcrConversionCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if ycbcrConversion != nil {
			c.pYcbcrConversion = (*C.VkSamplerYcbcrConversion)(m.alloc(C.sizeof_VkSamplerYcbcrConversion))
			*c.pYcbcrConversion = C.VkSamplerYcbcrConversion(*ycbcrConversion)
		} else {
			c.pYcbcrConversion = nil
		}
		c._ret = C.callPFN_vkCreateSamplerYcbcrConversion(C.PFN_vkCreateSamplerYcbcrConversion(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pYcbcrConversion)
		_ret = Result(c._ret)
		if ycbcrConversion != nil {
			*ycbcrConversion = SamplerYcbcrConversion(*c.pYcbcrConversion)
		}
		return
	}
}

type PFNDestroySamplerYcbcrConversion C.PFN_vkDestroySamplerYcbcrConversion
type FuncDestroySamplerYcbcrConversion func(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks)

func ToDestroySamplerYcbcrConversion(p PFNVoidFunction) (fn FuncDestroySamplerYcbcrConversion) {
	return func(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
		var c struct {
			device          C.VkDevice
			ycbcrConversion C.VkSamplerYcbcrConversion
			pAllocator      *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.ycbcrConversion = C.VkSamplerYcbcrConversion(ycbcrConversion)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySamplerYcbcrConversion(C.PFN_vkDestroySamplerYcbcrConversion(unsafe.Pointer(p)), c.device, c.ycbcrConversion, c.pAllocator)
	}
}

type PFNCreateDescriptorUpdateTemplate C.PFN_vkCreateDescriptorUpdateTemplate
type DescriptorUpdateTemplateCreateFlags Flags
type DescriptorUpdateTemplateEntry struct {
	DstBinding      uint32
	DstArrayElement uint32
	DescriptorCount uint32
	DescriptorType  DescriptorType
	Offset          uint
	Stride          uint
}

func (g *DescriptorUpdateTemplateEntry) toC(c *C.VkDescriptorUpdateTemplateEntry) {
	c.dstBinding = C.uint32_t(g.DstBinding)
	c.dstArrayElement = C.uint32_t(g.DstArrayElement)
	c.descriptorCount = C.uint32_t(g.DescriptorCount)
	c.descriptorType = C.VkDescriptorType(g.DescriptorType)
	c.offset = C.size_t(g.Offset)
	c.stride = C.size_t(g.Stride)
}
func (g *DescriptorUpdateTemplateEntry) fromC(c *C.VkDescriptorUpdateTemplateEntry) {
	g.DstBinding = uint32(c.dstBinding)
	g.DstArrayElement = uint32(c.dstArrayElement)
	g.DescriptorCount = uint32(c.descriptorCount)
	g.DescriptorType = DescriptorType(c.descriptorType)
	g.Offset = uint(c.offset)
	g.Stride = uint(c.stride)
}

type DescriptorUpdateTemplateCreateInfo struct {
	Next                    Structure
	Flags                   DescriptorUpdateTemplateCreateFlags
	DescriptorUpdateEntries []DescriptorUpdateTemplateEntry
	TemplateType            DescriptorUpdateTemplateType
	DescriptorSetLayout     DescriptorSetLayout
	PipelineBindPoint       PipelineBindPoint
	PipelineLayout          PipelineLayout
	Set                     uint32
}

func (g *DescriptorUpdateTemplateCreateInfo) toC(c *C.VkDescriptorUpdateTemplateCreateInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDescriptorUpdateTemplateCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDescriptorUpdateTemplateCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDescriptorUpdateTemplateCreateFlags(temp_in_VkDescriptorUpdateTemplateCreateFlags)
	}
	c.descriptorUpdateEntryCount = C.uint32_t(len(g.DescriptorUpdateEntries))
	if len(g.DescriptorUpdateEntries) != 0 {
		c.pDescriptorUpdateEntries = (*C.VkDescriptorUpdateTemplateEntry)(m.alloc(C.sizeof_VkDescriptorUpdateTemplateEntry * uint(len(g.DescriptorUpdateEntries))))
		slice1 := (*[1 << 31]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(c.pDescriptorUpdateEntries))[:len(g.DescriptorUpdateEntries):len(g.DescriptorUpdateEntries)]
		for i1, _ := range g.DescriptorUpdateEntries {
			g.DescriptorUpdateEntries[i1].toC(&slice1[i1])
		}
	} else {
		c.pDescriptorUpdateEntries = nil
	}
	c.templateType = C.VkDescriptorUpdateTemplateType(g.TemplateType)
	c.descriptorSetLayout = C.VkDescriptorSetLayout(g.DescriptorSetLayout)
	c.pipelineBindPoint = C.VkPipelineBindPoint(g.PipelineBindPoint)
	c.pipelineLayout = C.VkPipelineLayout(g.PipelineLayout)
	c.set = C.uint32_t(g.Set)
}
func (g *DescriptorUpdateTemplateCreateInfo) fromC(c *C.VkDescriptorUpdateTemplateCreateInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDescriptorUpdateTemplateCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDescriptorUpdateTemplateCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = DescriptorUpdateTemplateCreateFlags(temp_in_VkDescriptorUpdateTemplateCreateFlags)
	}
	g.DescriptorUpdateEntries = make([]DescriptorUpdateTemplateEntry, int(c.descriptorUpdateEntryCount))
	if len(g.DescriptorUpdateEntries) != 0 {
		slice1 := (*[1 << 31]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(c.pDescriptorUpdateEntries))[:len(g.DescriptorUpdateEntries):len(g.DescriptorUpdateEntries)]
		for i1, _ := range g.DescriptorUpdateEntries {
			g.DescriptorUpdateEntries[i1].fromC(&slice1[i1])
		}
	}
	g.TemplateType = DescriptorUpdateTemplateType(c.templateType)
	g.DescriptorSetLayout = DescriptorSetLayout(c.descriptorSetLayout)
	g.PipelineBindPoint = PipelineBindPoint(c.pipelineBindPoint)
	g.PipelineLayout = PipelineLayout(c.pipelineLayout)
	g.Set = uint32(c.set)
}
func (s *DescriptorUpdateTemplateCreateInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
}
func (s *DescriptorUpdateTemplateCreateInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDescriptorUpdateTemplateCreateInfo)(m.alloc(C.sizeof_VkDescriptorUpdateTemplateCreateInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DescriptorUpdateTemplateCreateInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDescriptorUpdateTemplateCreateInfo)(p)
	s.fromC(c)
}
func (s *DescriptorUpdateTemplateCreateInfo) GetNext() Structure {
	return s.Next
}
func (s *DescriptorUpdateTemplateCreateInfo) SetNext(n Structure) {
	s.Next = n
}

type DescriptorUpdateTemplate C.VkDescriptorUpdateTemplate
type FuncCreateDescriptorUpdateTemplate func(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks, descriptorUpdateTemplate *DescriptorUpdateTemplate) (_ret Result)

func ToCreateDescriptorUpdateTemplate(p PFNVoidFunction) (fn FuncCreateDescriptorUpdateTemplate) {
	return func(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks, descriptorUpdateTemplate *DescriptorUpdateTemplate) (_ret Result) {
		var c struct {
			device                    C.VkDevice
			pCreateInfo               *C.VkDescriptorUpdateTemplateCreateInfo
			pAllocator                *C.VkAllocationCallbacks
			pDescriptorUpdateTemplate *C.VkDescriptorUpdateTemplate
			_ret                      C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorUpdateTemplateCreateInfo)(m.alloc(C.sizeof_VkDescriptorUpdateTemplateCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if descriptorUpdateTemplate != nil {
			c.pDescriptorUpdateTemplate = (*C.VkDescriptorUpdateTemplate)(m.alloc(C.sizeof_VkDescriptorUpdateTemplate))
			*c.pDescriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(*descriptorUpdateTemplate)
		} else {
			c.pDescriptorUpdateTemplate = nil
		}
		c._ret = C.callPFN_vkCreateDescriptorUpdateTemplate(C.PFN_vkCreateDescriptorUpdateTemplate(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pDescriptorUpdateTemplate)
		_ret = Result(c._ret)
		if descriptorUpdateTemplate != nil {
			*descriptorUpdateTemplate = DescriptorUpdateTemplate(*c.pDescriptorUpdateTemplate)
		}
		return
	}
}

type PFNDestroyDescriptorUpdateTemplate C.PFN_vkDestroyDescriptorUpdateTemplate
type FuncDestroyDescriptorUpdateTemplate func(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks)

func ToDestroyDescriptorUpdateTemplate(p PFNVoidFunction) (fn FuncDestroyDescriptorUpdateTemplate) {
	return func(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
		var c struct {
			device                   C.VkDevice
			descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
			pAllocator               *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDescriptorUpdateTemplate(C.PFN_vkDestroyDescriptorUpdateTemplate(unsafe.Pointer(p)), c.device, c.descriptorUpdateTemplate, c.pAllocator)
	}
}

type PFNUpdateDescriptorSetWithTemplate C.PFN_vkUpdateDescriptorSetWithTemplate
type FuncUpdateDescriptorSetWithTemplate func(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data unsafe.Pointer)

func ToUpdateDescriptorSetWithTemplate(p PFNVoidFunction) (fn FuncUpdateDescriptorSetWithTemplate) {
	return func(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data unsafe.Pointer) {
		var c struct {
			device                   C.VkDevice
			descriptorSet            C.VkDescriptorSet
			descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
			pData                    unsafe.Pointer
		}
		c.device = C.VkDevice(device)
		c.descriptorSet = C.VkDescriptorSet(descriptorSet)
		c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
		c.pData = data
		C.callPFN_vkUpdateDescriptorSetWithTemplate(C.PFN_vkUpdateDescriptorSetWithTemplate(unsafe.Pointer(p)), c.device, c.descriptorSet, c.descriptorUpdateTemplate, c.pData)
	}
}

type PFNGetPhysicalDeviceExternalBufferProperties C.PFN_vkGetPhysicalDeviceExternalBufferProperties
type PhysicalDeviceExternalBufferInfo struct {
	Next       Structure
	Flags      BufferCreateFlags
	Usage      BufferUsageFlags
	HandleType ExternalMemoryHandleTypeFlagBits
}

func (g *PhysicalDeviceExternalBufferInfo) toC(c *C.VkPhysicalDeviceExternalBufferInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkBufferCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkBufferCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkBufferCreateFlags(temp_in_VkBufferCreateFlags)
	}
	{
		var temp_in_VkBufferUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Usage)))
			temp_in_VkBufferUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.usage = C.VkBufferUsageFlags(temp_in_VkBufferUsageFlags)
	}
	c.handleType = C.VkExternalMemoryHandleTypeFlagBits(g.HandleType)
}
func (g *PhysicalDeviceExternalBufferInfo) fromC(c *C.VkPhysicalDeviceExternalBufferInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkBufferCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkBufferCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = BufferCreateFlags(temp_in_VkBufferCreateFlags)
	}
	{
		var temp_in_VkBufferUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.usage)))
			temp_in_VkBufferUsageFlags = Flags(temp_in_VkFlags)
		}
		g.Usage = BufferUsageFlags(temp_in_VkBufferUsageFlags)
	}
	g.HandleType = ExternalMemoryHandleTypeFlagBits(c.handleType)
}
func (s *PhysicalDeviceExternalBufferInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
}
func (s *PhysicalDeviceExternalBufferInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceExternalBufferInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalBufferInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceExternalBufferInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceExternalBufferInfo)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceExternalBufferInfo) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceExternalBufferInfo) SetNext(n Structure) {
	s.Next = n
}

type ExternalMemoryFeatureFlags Flags
type ExternalMemoryHandleTypeFlags Flags
type ExternalMemoryProperties struct {
	ExternalMemoryFeatures        ExternalMemoryFeatureFlags
	ExportFromImportedHandleTypes ExternalMemoryHandleTypeFlags
	CompatibleHandleTypes         ExternalMemoryHandleTypeFlags
}

func (g *ExternalMemoryProperties) toC(c *C.VkExternalMemoryProperties) {
	{
		var temp_in_VkExternalMemoryFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExternalMemoryFeatures)))
			temp_in_VkExternalMemoryFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.externalMemoryFeatures = C.VkExternalMemoryFeatureFlags(temp_in_VkExternalMemoryFeatureFlags)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExportFromImportedHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.exportFromImportedHandleTypes = C.VkExternalMemoryHandleTypeFlags(temp_in_VkExternalMemoryHandleTypeFlags)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.CompatibleHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.compatibleHandleTypes = C.VkExternalMemoryHandleTypeFlags(temp_in_VkExternalMemoryHandleTypeFlags)
	}
}
func (g *ExternalMemoryProperties) fromC(c *C.VkExternalMemoryProperties) {
	{
		var temp_in_VkExternalMemoryFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.externalMemoryFeatures)))
			temp_in_VkExternalMemoryFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.ExternalMemoryFeatures = ExternalMemoryFeatureFlags(temp_in_VkExternalMemoryFeatureFlags)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.exportFromImportedHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.ExportFromImportedHandleTypes = ExternalMemoryHandleTypeFlags(temp_in_VkExternalMemoryHandleTypeFlags)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.compatibleHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.CompatibleHandleTypes = ExternalMemoryHandleTypeFlags(temp_in_VkExternalMemoryHandleTypeFlags)
	}
}

type ExternalBufferProperties struct {
	Next                     Structure
	ExternalMemoryProperties ExternalMemoryProperties
}

func (g *ExternalBufferProperties) toC(c *C.VkExternalBufferProperties, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.ExternalMemoryProperties.toC(&c.externalMemoryProperties)
}
func (g *ExternalBufferProperties) fromC(c *C.VkExternalBufferProperties) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ExternalMemoryProperties.fromC(&c.externalMemoryProperties)
}
func (s *ExternalBufferProperties) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
}
func (s *ExternalBufferProperties) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkExternalBufferProperties)(m.alloc(C.sizeof_VkExternalBufferProperties))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ExternalBufferProperties) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkExternalBufferProperties)(p)
	s.fromC(c)
}
func (s *ExternalBufferProperties) GetNext() Structure {
	return s.Next
}
func (s *ExternalBufferProperties) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceExternalBufferProperties func(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo, externalBufferProperties *ExternalBufferProperties)

func ToGetPhysicalDeviceExternalBufferProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalBufferProperties) {
	return func(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo, externalBufferProperties *ExternalBufferProperties) {
		var c struct {
			physicalDevice            C.VkPhysicalDevice
			pExternalBufferInfo       *C.VkPhysicalDeviceExternalBufferInfo
			pExternalBufferProperties *C.VkExternalBufferProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalBufferInfo != nil {
			c.pExternalBufferInfo = (*C.VkPhysicalDeviceExternalBufferInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalBufferInfo))
			externalBufferInfo.toC(c.pExternalBufferInfo, m)
		} else {
			c.pExternalBufferInfo = nil
		}
		if externalBufferProperties != nil {
			c.pExternalBufferProperties = (*C.VkExternalBufferProperties)(m.alloc(C.sizeof_VkExternalBufferProperties))
			externalBufferProperties.toC(c.pExternalBufferProperties, m)
		} else {
			c.pExternalBufferProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalBufferProperties(C.PFN_vkGetPhysicalDeviceExternalBufferProperties(unsafe.Pointer(p)), c.physicalDevice, c.pExternalBufferInfo, c.pExternalBufferProperties)
		if externalBufferProperties != nil {
			externalBufferProperties.fromC(c.pExternalBufferProperties)
		}
	}
}

type PFNGetPhysicalDeviceExternalFenceProperties C.PFN_vkGetPhysicalDeviceExternalFenceProperties
type PhysicalDeviceExternalFenceInfo struct {
	Next       Structure
	HandleType ExternalFenceHandleTypeFlagBits
}

func (g *PhysicalDeviceExternalFenceInfo) toC(c *C.VkPhysicalDeviceExternalFenceInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.handleType = C.VkExternalFenceHandleTypeFlagBits(g.HandleType)
}
func (g *PhysicalDeviceExternalFenceInfo) fromC(c *C.VkPhysicalDeviceExternalFenceInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.HandleType = ExternalFenceHandleTypeFlagBits(c.handleType)
}
func (s *PhysicalDeviceExternalFenceInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
}
func (s *PhysicalDeviceExternalFenceInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceExternalFenceInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalFenceInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceExternalFenceInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceExternalFenceInfo)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceExternalFenceInfo) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceExternalFenceInfo) SetNext(n Structure) {
	s.Next = n
}

type ExternalFenceHandleTypeFlags Flags
type ExternalFenceFeatureFlags Flags
type ExternalFenceProperties struct {
	Next                          Structure
	ExportFromImportedHandleTypes ExternalFenceHandleTypeFlags
	CompatibleHandleTypes         ExternalFenceHandleTypeFlags
	ExternalFenceFeatures         ExternalFenceFeatureFlags
}

func (g *ExternalFenceProperties) toC(c *C.VkExternalFenceProperties, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkExternalFenceHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExportFromImportedHandleTypes)))
			temp_in_VkExternalFenceHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.exportFromImportedHandleTypes = C.VkExternalFenceHandleTypeFlags(temp_in_VkExternalFenceHandleTypeFlags)
	}
	{
		var temp_in_VkExternalFenceHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.CompatibleHandleTypes)))
			temp_in_VkExternalFenceHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.compatibleHandleTypes = C.VkExternalFenceHandleTypeFlags(temp_in_VkExternalFenceHandleTypeFlags)
	}
	{
		var temp_in_VkExternalFenceFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExternalFenceFeatures)))
			temp_in_VkExternalFenceFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.externalFenceFeatures = C.VkExternalFenceFeatureFlags(temp_in_VkExternalFenceFeatureFlags)
	}
}
func (g *ExternalFenceProperties) fromC(c *C.VkExternalFenceProperties) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkExternalFenceHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.exportFromImportedHandleTypes)))
			temp_in_VkExternalFenceHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.ExportFromImportedHandleTypes = ExternalFenceHandleTypeFlags(temp_in_VkExternalFenceHandleTypeFlags)
	}
	{
		var temp_in_VkExternalFenceHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.compatibleHandleTypes)))
			temp_in_VkExternalFenceHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.CompatibleHandleTypes = ExternalFenceHandleTypeFlags(temp_in_VkExternalFenceHandleTypeFlags)
	}
	{
		var temp_in_VkExternalFenceFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.externalFenceFeatures)))
			temp_in_VkExternalFenceFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.ExternalFenceFeatures = ExternalFenceFeatureFlags(temp_in_VkExternalFenceFeatureFlags)
	}
}
func (s *ExternalFenceProperties) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
}
func (s *ExternalFenceProperties) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkExternalFenceProperties)(m.alloc(C.sizeof_VkExternalFenceProperties))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ExternalFenceProperties) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkExternalFenceProperties)(p)
	s.fromC(c)
}
func (s *ExternalFenceProperties) GetNext() Structure {
	return s.Next
}
func (s *ExternalFenceProperties) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceExternalFenceProperties func(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo, externalFenceProperties *ExternalFenceProperties)

func ToGetPhysicalDeviceExternalFenceProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalFenceProperties) {
	return func(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo, externalFenceProperties *ExternalFenceProperties) {
		var c struct {
			physicalDevice           C.VkPhysicalDevice
			pExternalFenceInfo       *C.VkPhysicalDeviceExternalFenceInfo
			pExternalFenceProperties *C.VkExternalFenceProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalFenceInfo != nil {
			c.pExternalFenceInfo = (*C.VkPhysicalDeviceExternalFenceInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalFenceInfo))
			externalFenceInfo.toC(c.pExternalFenceInfo, m)
		} else {
			c.pExternalFenceInfo = nil
		}
		if externalFenceProperties != nil {
			c.pExternalFenceProperties = (*C.VkExternalFenceProperties)(m.alloc(C.sizeof_VkExternalFenceProperties))
			externalFenceProperties.toC(c.pExternalFenceProperties, m)
		} else {
			c.pExternalFenceProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalFenceProperties(C.PFN_vkGetPhysicalDeviceExternalFenceProperties(unsafe.Pointer(p)), c.physicalDevice, c.pExternalFenceInfo, c.pExternalFenceProperties)
		if externalFenceProperties != nil {
			externalFenceProperties.fromC(c.pExternalFenceProperties)
		}
	}
}

type PFNGetPhysicalDeviceExternalSemaphoreProperties C.PFN_vkGetPhysicalDeviceExternalSemaphoreProperties
type PhysicalDeviceExternalSemaphoreInfo struct {
	Next       Structure
	HandleType ExternalSemaphoreHandleTypeFlagBits
}

func (g *PhysicalDeviceExternalSemaphoreInfo) toC(c *C.VkPhysicalDeviceExternalSemaphoreInfo, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.handleType = C.VkExternalSemaphoreHandleTypeFlagBits(g.HandleType)
}
func (g *PhysicalDeviceExternalSemaphoreInfo) fromC(c *C.VkPhysicalDeviceExternalSemaphoreInfo) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.HandleType = ExternalSemaphoreHandleTypeFlagBits(c.handleType)
}
func (s *PhysicalDeviceExternalSemaphoreInfo) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
}
func (s *PhysicalDeviceExternalSemaphoreInfo) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalSemaphoreInfo))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceExternalSemaphoreInfo) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceExternalSemaphoreInfo) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceExternalSemaphoreInfo) SetNext(n Structure) {
	s.Next = n
}

type ExternalSemaphoreHandleTypeFlags Flags
type ExternalSemaphoreFeatureFlags Flags
type ExternalSemaphoreProperties struct {
	Next                          Structure
	ExportFromImportedHandleTypes ExternalSemaphoreHandleTypeFlags
	CompatibleHandleTypes         ExternalSemaphoreHandleTypeFlags
	ExternalSemaphoreFeatures     ExternalSemaphoreFeatureFlags
}

func (g *ExternalSemaphoreProperties) toC(c *C.VkExternalSemaphoreProperties, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkExternalSemaphoreHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExportFromImportedHandleTypes)))
			temp_in_VkExternalSemaphoreHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.exportFromImportedHandleTypes = C.VkExternalSemaphoreHandleTypeFlags(temp_in_VkExternalSemaphoreHandleTypeFlags)
	}
	{
		var temp_in_VkExternalSemaphoreHandleTypeFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.CompatibleHandleTypes)))
			temp_in_VkExternalSemaphoreHandleTypeFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.compatibleHandleTypes = C.VkExternalSemaphoreHandleTypeFlags(temp_in_VkExternalSemaphoreHandleTypeFlags)
	}
	{
		var temp_in_VkExternalSemaphoreFeatureFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExternalSemaphoreFeatures)))
			temp_in_VkExternalSemaphoreFeatureFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.externalSemaphoreFeatures = C.VkExternalSemaphoreFeatureFlags(temp_in_VkExternalSemaphoreFeatureFlags)
	}
}
func (g *ExternalSemaphoreProperties) fromC(c *C.VkExternalSemaphoreProperties) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkExternalSemaphoreHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.exportFromImportedHandleTypes)))
			temp_in_VkExternalSemaphoreHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.ExportFromImportedHandleTypes = ExternalSemaphoreHandleTypeFlags(temp_in_VkExternalSemaphoreHandleTypeFlags)
	}
	{
		var temp_in_VkExternalSemaphoreHandleTypeFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.compatibleHandleTypes)))
			temp_in_VkExternalSemaphoreHandleTypeFlags = Flags(temp_in_VkFlags)
		}
		g.CompatibleHandleTypes = ExternalSemaphoreHandleTypeFlags(temp_in_VkExternalSemaphoreHandleTypeFlags)
	}
	{
		var temp_in_VkExternalSemaphoreFeatureFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.externalSemaphoreFeatures)))
			temp_in_VkExternalSemaphoreFeatureFlags = Flags(temp_in_VkFlags)
		}
		g.ExternalSemaphoreFeatures = ExternalSemaphoreFeatureFlags(temp_in_VkExternalSemaphoreFeatureFlags)
	}
}
func (s *ExternalSemaphoreProperties) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
}
func (s *ExternalSemaphoreProperties) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkExternalSemaphoreProperties)(m.alloc(C.sizeof_VkExternalSemaphoreProperties))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ExternalSemaphoreProperties) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkExternalSemaphoreProperties)(p)
	s.fromC(c)
}
func (s *ExternalSemaphoreProperties) GetNext() Structure {
	return s.Next
}
func (s *ExternalSemaphoreProperties) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceExternalSemaphoreProperties func(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, externalSemaphoreProperties *ExternalSemaphoreProperties)

func ToGetPhysicalDeviceExternalSemaphoreProperties(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalSemaphoreProperties) {
	return func(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, externalSemaphoreProperties *ExternalSemaphoreProperties) {
		var c struct {
			physicalDevice               C.VkPhysicalDevice
			pExternalSemaphoreInfo       *C.VkPhysicalDeviceExternalSemaphoreInfo
			pExternalSemaphoreProperties *C.VkExternalSemaphoreProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalSemaphoreInfo != nil {
			c.pExternalSemaphoreInfo = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalSemaphoreInfo))
			externalSemaphoreInfo.toC(c.pExternalSemaphoreInfo, m)
		} else {
			c.pExternalSemaphoreInfo = nil
		}
		if externalSemaphoreProperties != nil {
			c.pExternalSemaphoreProperties = (*C.VkExternalSemaphoreProperties)(m.alloc(C.sizeof_VkExternalSemaphoreProperties))
			externalSemaphoreProperties.toC(c.pExternalSemaphoreProperties, m)
		} else {
			c.pExternalSemaphoreProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalSemaphoreProperties(C.PFN_vkGetPhysicalDeviceExternalSemaphoreProperties(unsafe.Pointer(p)), c.physicalDevice, c.pExternalSemaphoreInfo, c.pExternalSemaphoreProperties)
		if externalSemaphoreProperties != nil {
			externalSemaphoreProperties.fromC(c.pExternalSemaphoreProperties)
		}
	}
}

type PFNGetDescriptorSetLayoutSupport C.PFN_vkGetDescriptorSetLayoutSupport
type DescriptorSetLayoutSupport struct {
	Next      Structure
	Supported bool
}

func (g *DescriptorSetLayoutSupport) toC(c *C.VkDescriptorSetLayoutSupport, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	if g.Supported {
		c.supported = 1
	} else {
		c.supported = 0
	}
}
func (g *DescriptorSetLayoutSupport) fromC(c *C.VkDescriptorSetLayoutSupport) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Supported = c.supported != 0
}
func (s *DescriptorSetLayoutSupport) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
}
func (s *DescriptorSetLayoutSupport) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDescriptorSetLayoutSupport)(m.alloc(C.sizeof_VkDescriptorSetLayoutSupport))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DescriptorSetLayoutSupport) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDescriptorSetLayoutSupport)(p)
	s.fromC(c)
}
func (s *DescriptorSetLayoutSupport) GetNext() Structure {
	return s.Next
}
func (s *DescriptorSetLayoutSupport) SetNext(n Structure) {
	s.Next = n
}

type FuncGetDescriptorSetLayoutSupport func(device Device, createInfo *DescriptorSetLayoutCreateInfo, support *DescriptorSetLayoutSupport)

func ToGetDescriptorSetLayoutSupport(p PFNVoidFunction) (fn FuncGetDescriptorSetLayoutSupport) {
	return func(device Device, createInfo *DescriptorSetLayoutCreateInfo, support *DescriptorSetLayoutSupport) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkDescriptorSetLayoutCreateInfo
			pSupport    *C.VkDescriptorSetLayoutSupport
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if support != nil {
			c.pSupport = (*C.VkDescriptorSetLayoutSupport)(m.alloc(C.sizeof_VkDescriptorSetLayoutSupport))
			support.toC(c.pSupport, m)
		} else {
			c.pSupport = nil
		}
		C.callPFN_vkGetDescriptorSetLayoutSupport(C.PFN_vkGetDescriptorSetLayoutSupport(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pSupport)
		if support != nil {
			support.fromC(c.pSupport)
		}
	}
}
func EnumerateInstanceVersion(apiVersion *uint32) (_ret Result) {
	var c struct {
		pApiVersion *C.uint32_t
		_ret        C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	if apiVersion != nil {
		c.pApiVersion = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pApiVersion = C.uint32_t(*apiVersion)
	} else {
		c.pApiVersion = nil
	}
	c._ret = C.vkEnumerateInstanceVersion(c.pApiVersion)
	_ret = Result(c._ret)
	if apiVersion != nil {
		*apiVersion = uint32(*c.pApiVersion)
	}
	return
}
func BindBufferMemory2(device Device, bindInfos []BindBufferMemoryInfo) (_ret Result) {
	var c struct {
		device        C.VkDevice
		bindInfoCount C.uint32_t
		pBindInfos    *C.VkBindBufferMemoryInfo
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.bindInfoCount = C.uint32_t(len(bindInfos))
	if len(bindInfos) != 0 {
		c.pBindInfos = (*C.VkBindBufferMemoryInfo)(m.alloc(C.sizeof_VkBindBufferMemoryInfo * uint(len(bindInfos))))
		slice1 := (*[1 << 31]C.VkBindBufferMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
		for i1, _ := range bindInfos {
			bindInfos[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBindInfos = nil
	}
	c._ret = C.vkBindBufferMemory2(c.device, c.bindInfoCount, c.pBindInfos)
	_ret = Result(c._ret)
	return
}
func BindImageMemory2(device Device, bindInfos []BindImageMemoryInfo) (_ret Result) {
	var c struct {
		device        C.VkDevice
		bindInfoCount C.uint32_t
		pBindInfos    *C.VkBindImageMemoryInfo
		_ret          C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.bindInfoCount = C.uint32_t(len(bindInfos))
	if len(bindInfos) != 0 {
		c.pBindInfos = (*C.VkBindImageMemoryInfo)(m.alloc(C.sizeof_VkBindImageMemoryInfo * uint(len(bindInfos))))
		slice1 := (*[1 << 31]C.VkBindImageMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
		for i1, _ := range bindInfos {
			bindInfos[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pBindInfos = nil
	}
	c._ret = C.vkBindImageMemory2(c.device, c.bindInfoCount, c.pBindInfos)
	_ret = Result(c._ret)
	return
}
func GetDeviceGroupPeerMemoryFeatures(device Device, heapIndex uint32, localDeviceIndex uint32, peerMemoryFeatures []PeerMemoryFeatureFlags) {
	var c struct {
		device              C.VkDevice
		heapIndex           C.uint32_t
		localDeviceIndex    C.uint32_t
		remoteDeviceIndex   C.uint32_t
		pPeerMemoryFeatures *C.VkPeerMemoryFeatureFlags
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.heapIndex = C.uint32_t(heapIndex)
	c.localDeviceIndex = C.uint32_t(localDeviceIndex)
	c.remoteDeviceIndex = C.uint32_t(len(peerMemoryFeatures))
	if len(peerMemoryFeatures) != 0 {
		c.pPeerMemoryFeatures = (*C.VkPeerMemoryFeatureFlags)(m.alloc(C.sizeof_VkPeerMemoryFeatureFlags * uint(len(peerMemoryFeatures))))
		slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
		for i1, _ := range peerMemoryFeatures {
			{
				var temp_in_VkPeerMemoryFeatureFlags C.VkFlags
				{
					var temp_in_VkFlags C.uint32_t
					temp_in_VkFlags = C.uint32_t((uint32)((Flags)(peerMemoryFeatures[i1])))
					temp_in_VkPeerMemoryFeatureFlags = C.VkFlags(temp_in_VkFlags)
				}
				slice1[i1] = C.VkPeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
			}
		}
	} else {
		c.pPeerMemoryFeatures = nil
	}
	C.vkGetDeviceGroupPeerMemoryFeatures(c.device, c.heapIndex, c.localDeviceIndex, c.remoteDeviceIndex, c.pPeerMemoryFeatures)
	if len(peerMemoryFeatures) != 0 {
		slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
		for i1, _ := range peerMemoryFeatures {
			{
				var temp_in_VkPeerMemoryFeatureFlags Flags
				{
					var temp_in_VkFlags uint32
					temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(slice1[i1])))
					temp_in_VkPeerMemoryFeatureFlags = Flags(temp_in_VkFlags)
				}
				peerMemoryFeatures[i1] = PeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
			}
		}
	}
}
func CmdSetDeviceMask(commandBuffer CommandBuffer, deviceMask uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		deviceMask    C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.deviceMask = C.uint32_t(deviceMask)
	C.vkCmdSetDeviceMask(c.commandBuffer, c.deviceMask)
}
func CmdDispatchBase(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	var c struct {
		commandBuffer C.VkCommandBuffer
		baseGroupX    C.uint32_t
		baseGroupY    C.uint32_t
		baseGroupZ    C.uint32_t
		groupCountX   C.uint32_t
		groupCountY   C.uint32_t
		groupCountZ   C.uint32_t
	}
	c.commandBuffer = C.VkCommandBuffer(commandBuffer)
	c.baseGroupX = C.uint32_t(baseGroupX)
	c.baseGroupY = C.uint32_t(baseGroupY)
	c.baseGroupZ = C.uint32_t(baseGroupZ)
	c.groupCountX = C.uint32_t(groupCountX)
	c.groupCountY = C.uint32_t(groupCountY)
	c.groupCountZ = C.uint32_t(groupCountZ)
	C.vkCmdDispatchBase(c.commandBuffer, c.baseGroupX, c.baseGroupY, c.baseGroupZ, c.groupCountX, c.groupCountY, c.groupCountZ)
}
func EnumeratePhysicalDeviceGroups(instance Instance, physicalDeviceGroupCount *uint32, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) (_ret Result) {
	var c struct {
		instance                       C.VkInstance
		pPhysicalDeviceGroupCount      *C.uint32_t
		pPhysicalDeviceGroupProperties *C.VkPhysicalDeviceGroupProperties
		_ret                           C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.instance = C.VkInstance(instance)
	if physicalDeviceGroupCount != nil {
		c.pPhysicalDeviceGroupCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPhysicalDeviceGroupCount = C.uint32_t(*physicalDeviceGroupCount)
	} else {
		c.pPhysicalDeviceGroupCount = nil
	}
	if len(physicalDeviceGroupProperties) != 0 {
		c.pPhysicalDeviceGroupProperties = (*C.VkPhysicalDeviceGroupProperties)(m.alloc(C.sizeof_VkPhysicalDeviceGroupProperties * uint(len(physicalDeviceGroupProperties))))
		slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
		for i1, _ := range physicalDeviceGroupProperties {
			physicalDeviceGroupProperties[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pPhysicalDeviceGroupProperties = nil
	}
	c._ret = C.vkEnumeratePhysicalDeviceGroups(c.instance, c.pPhysicalDeviceGroupCount, c.pPhysicalDeviceGroupProperties)
	_ret = Result(c._ret)
	if physicalDeviceGroupCount != nil {
		*physicalDeviceGroupCount = uint32(*c.pPhysicalDeviceGroupCount)
	}
	if len(physicalDeviceGroupProperties) != 0 {
		slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
		for i1, _ := range physicalDeviceGroupProperties {
			physicalDeviceGroupProperties[i1].fromC(&slice1[i1])
		}
	}
	return
}
func GetImageMemoryRequirements2(device Device, info *ImageMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
	var c struct {
		device              C.VkDevice
		pInfo               *C.VkImageMemoryRequirementsInfo2
		pMemoryRequirements *C.VkMemoryRequirements2
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if info != nil {
		c.pInfo = (*C.VkImageMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageMemoryRequirementsInfo2))
		info.toC(c.pInfo, m)
	} else {
		c.pInfo = nil
	}
	if memoryRequirements != nil {
		c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
		memoryRequirements.toC(c.pMemoryRequirements, m)
	} else {
		c.pMemoryRequirements = nil
	}
	C.vkGetImageMemoryRequirements2(c.device, c.pInfo, c.pMemoryRequirements)
	if memoryRequirements != nil {
		memoryRequirements.fromC(c.pMemoryRequirements)
	}
}
func GetBufferMemoryRequirements2(device Device, info *BufferMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
	var c struct {
		device              C.VkDevice
		pInfo               *C.VkBufferMemoryRequirementsInfo2
		pMemoryRequirements *C.VkMemoryRequirements2
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if info != nil {
		c.pInfo = (*C.VkBufferMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkBufferMemoryRequirementsInfo2))
		info.toC(c.pInfo, m)
	} else {
		c.pInfo = nil
	}
	if memoryRequirements != nil {
		c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
		memoryRequirements.toC(c.pMemoryRequirements, m)
	} else {
		c.pMemoryRequirements = nil
	}
	C.vkGetBufferMemoryRequirements2(c.device, c.pInfo, c.pMemoryRequirements)
	if memoryRequirements != nil {
		memoryRequirements.fromC(c.pMemoryRequirements)
	}
}
func GetImageSparseMemoryRequirements2(device Device, info *ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	var c struct {
		device                        C.VkDevice
		pInfo                         *C.VkImageSparseMemoryRequirementsInfo2
		pSparseMemoryRequirementCount *C.uint32_t
		pSparseMemoryRequirements     *C.VkSparseImageMemoryRequirements2
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if info != nil {
		c.pInfo = (*C.VkImageSparseMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageSparseMemoryRequirementsInfo2))
		info.toC(c.pInfo, m)
	} else {
		c.pInfo = nil
	}
	if sparseMemoryRequirementCount != nil {
		c.pSparseMemoryRequirementCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pSparseMemoryRequirementCount = C.uint32_t(*sparseMemoryRequirementCount)
	} else {
		c.pSparseMemoryRequirementCount = nil
	}
	if len(sparseMemoryRequirements) != 0 {
		c.pSparseMemoryRequirements = (*C.VkSparseImageMemoryRequirements2)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements2 * uint(len(sparseMemoryRequirements))))
		slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
		for i1, _ := range sparseMemoryRequirements {
			sparseMemoryRequirements[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pSparseMemoryRequirements = nil
	}
	C.vkGetImageSparseMemoryRequirements2(c.device, c.pInfo, c.pSparseMemoryRequirementCount, c.pSparseMemoryRequirements)
	if sparseMemoryRequirementCount != nil {
		*sparseMemoryRequirementCount = uint32(*c.pSparseMemoryRequirementCount)
	}
	if len(sparseMemoryRequirements) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
		for i1, _ := range sparseMemoryRequirements {
			sparseMemoryRequirements[i1].fromC(&slice1[i1])
		}
	}
}
func GetPhysicalDeviceFeatures2(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures2) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pFeatures      *C.VkPhysicalDeviceFeatures2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if features != nil {
		c.pFeatures = (*C.VkPhysicalDeviceFeatures2)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures2))
		features.toC(c.pFeatures, m)
	} else {
		c.pFeatures = nil
	}
	C.vkGetPhysicalDeviceFeatures2(c.physicalDevice, c.pFeatures)
	if features != nil {
		features.fromC(c.pFeatures)
	}
}
func GetPhysicalDeviceProperties2(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties2) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pProperties    *C.VkPhysicalDeviceProperties2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if properties != nil {
		c.pProperties = (*C.VkPhysicalDeviceProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceProperties2))
		properties.toC(c.pProperties, m)
	} else {
		c.pProperties = nil
	}
	C.vkGetPhysicalDeviceProperties2(c.physicalDevice, c.pProperties)
	if properties != nil {
		properties.fromC(c.pProperties)
	}
}
func GetPhysicalDeviceFormatProperties2(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties2) {
	var c struct {
		physicalDevice    C.VkPhysicalDevice
		format            C.VkFormat
		pFormatProperties *C.VkFormatProperties2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	c.format = C.VkFormat(format)
	if formatProperties != nil {
		c.pFormatProperties = (*C.VkFormatProperties2)(m.alloc(C.sizeof_VkFormatProperties2))
		formatProperties.toC(c.pFormatProperties, m)
	} else {
		c.pFormatProperties = nil
	}
	C.vkGetPhysicalDeviceFormatProperties2(c.physicalDevice, c.format, c.pFormatProperties)
	if formatProperties != nil {
		formatProperties.fromC(c.pFormatProperties)
	}
}
func GetPhysicalDeviceImageFormatProperties2(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2, imageFormatProperties *ImageFormatProperties2) (_ret Result) {
	var c struct {
		physicalDevice         C.VkPhysicalDevice
		pImageFormatInfo       *C.VkPhysicalDeviceImageFormatInfo2
		pImageFormatProperties *C.VkImageFormatProperties2
		_ret                   C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if imageFormatInfo != nil {
		c.pImageFormatInfo = (*C.VkPhysicalDeviceImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceImageFormatInfo2))
		imageFormatInfo.toC(c.pImageFormatInfo, m)
	} else {
		c.pImageFormatInfo = nil
	}
	if imageFormatProperties != nil {
		c.pImageFormatProperties = (*C.VkImageFormatProperties2)(m.alloc(C.sizeof_VkImageFormatProperties2))
		imageFormatProperties.toC(c.pImageFormatProperties, m)
	} else {
		c.pImageFormatProperties = nil
	}
	c._ret = C.vkGetPhysicalDeviceImageFormatProperties2(c.physicalDevice, c.pImageFormatInfo, c.pImageFormatProperties)
	_ret = Result(c._ret)
	if imageFormatProperties != nil {
		imageFormatProperties.fromC(c.pImageFormatProperties)
	}
	return
}
func GetPhysicalDeviceQueueFamilyProperties2(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties2) {
	var c struct {
		physicalDevice            C.VkPhysicalDevice
		pQueueFamilyPropertyCount *C.uint32_t
		pQueueFamilyProperties    *C.VkQueueFamilyProperties2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if queueFamilyPropertyCount != nil {
		c.pQueueFamilyPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pQueueFamilyPropertyCount = C.uint32_t(*queueFamilyPropertyCount)
	} else {
		c.pQueueFamilyPropertyCount = nil
	}
	if len(queueFamilyProperties) != 0 {
		c.pQueueFamilyProperties = (*C.VkQueueFamilyProperties2)(m.alloc(C.sizeof_VkQueueFamilyProperties2 * uint(len(queueFamilyProperties))))
		slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
		for i1, _ := range queueFamilyProperties {
			queueFamilyProperties[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pQueueFamilyProperties = nil
	}
	C.vkGetPhysicalDeviceQueueFamilyProperties2(c.physicalDevice, c.pQueueFamilyPropertyCount, c.pQueueFamilyProperties)
	if queueFamilyPropertyCount != nil {
		*queueFamilyPropertyCount = uint32(*c.pQueueFamilyPropertyCount)
	}
	if len(queueFamilyProperties) != 0 {
		slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
		for i1, _ := range queueFamilyProperties {
			queueFamilyProperties[i1].fromC(&slice1[i1])
		}
	}
}
func GetPhysicalDeviceMemoryProperties2(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties2) {
	var c struct {
		physicalDevice    C.VkPhysicalDevice
		pMemoryProperties *C.VkPhysicalDeviceMemoryProperties2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if memoryProperties != nil {
		c.pMemoryProperties = (*C.VkPhysicalDeviceMemoryProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties2))
		memoryProperties.toC(c.pMemoryProperties, m)
	} else {
		c.pMemoryProperties = nil
	}
	C.vkGetPhysicalDeviceMemoryProperties2(c.physicalDevice, c.pMemoryProperties)
	if memoryProperties != nil {
		memoryProperties.fromC(c.pMemoryProperties)
	}
}
func GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2, propertyCount *uint32, properties []SparseImageFormatProperties2) {
	var c struct {
		physicalDevice C.VkPhysicalDevice
		pFormatInfo    *C.VkPhysicalDeviceSparseImageFormatInfo2
		pPropertyCount *C.uint32_t
		pProperties    *C.VkSparseImageFormatProperties2
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if formatInfo != nil {
		c.pFormatInfo = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceSparseImageFormatInfo2))
		formatInfo.toC(c.pFormatInfo, m)
	} else {
		c.pFormatInfo = nil
	}
	if propertyCount != nil {
		c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
		*c.pPropertyCount = C.uint32_t(*propertyCount)
	} else {
		c.pPropertyCount = nil
	}
	if len(properties) != 0 {
		c.pProperties = (*C.VkSparseImageFormatProperties2)(m.alloc(C.sizeof_VkSparseImageFormatProperties2 * uint(len(properties))))
		slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pProperties = nil
	}
	C.vkGetPhysicalDeviceSparseImageFormatProperties2(c.physicalDevice, c.pFormatInfo, c.pPropertyCount, c.pProperties)
	if propertyCount != nil {
		*propertyCount = uint32(*c.pPropertyCount)
	}
	if len(properties) != 0 {
		slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
		for i1, _ := range properties {
			properties[i1].fromC(&slice1[i1])
		}
	}
}
func TrimCommandPool(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {
	var c struct {
		device      C.VkDevice
		commandPool C.VkCommandPool
		flags       C.VkCommandPoolTrimFlags
	}
	c.device = C.VkDevice(device)
	c.commandPool = C.VkCommandPool(commandPool)
	{
		var temp_in_VkCommandPoolTrimFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
			temp_in_VkCommandPoolTrimFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkCommandPoolTrimFlags(temp_in_VkCommandPoolTrimFlags)
	}
	C.vkTrimCommandPool(c.device, c.commandPool, c.flags)
}
func GetDeviceQueue2(device Device, queueInfo *DeviceQueueInfo2, queue *Queue) {
	var c struct {
		device     C.VkDevice
		pQueueInfo *C.VkDeviceQueueInfo2
		pQueue     *C.VkQueue
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if queueInfo != nil {
		c.pQueueInfo = (*C.VkDeviceQueueInfo2)(m.alloc(C.sizeof_VkDeviceQueueInfo2))
		queueInfo.toC(c.pQueueInfo, m)
	} else {
		c.pQueueInfo = nil
	}
	if queue != nil {
		c.pQueue = (*C.VkQueue)(m.alloc(C.sizeof_VkQueue))
		*c.pQueue = C.VkQueue(*queue)
	} else {
		c.pQueue = nil
	}
	C.vkGetDeviceQueue2(c.device, c.pQueueInfo, c.pQueue)
	if queue != nil {
		*queue = Queue(*c.pQueue)
	}
}
func CreateSamplerYcbcrConversion(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks, ycbcrConversion *SamplerYcbcrConversion) (_ret Result) {
	var c struct {
		device           C.VkDevice
		pCreateInfo      *C.VkSamplerYcbcrConversionCreateInfo
		pAllocator       *C.VkAllocationCallbacks
		pYcbcrConversion *C.VkSamplerYcbcrConversion
		_ret             C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkSamplerYcbcrConversionCreateInfo)(m.alloc(C.sizeof_VkSamplerYcbcrConversionCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if ycbcrConversion != nil {
		c.pYcbcrConversion = (*C.VkSamplerYcbcrConversion)(m.alloc(C.sizeof_VkSamplerYcbcrConversion))
		*c.pYcbcrConversion = C.VkSamplerYcbcrConversion(*ycbcrConversion)
	} else {
		c.pYcbcrConversion = nil
	}
	c._ret = C.vkCreateSamplerYcbcrConversion(c.device, c.pCreateInfo, c.pAllocator, c.pYcbcrConversion)
	_ret = Result(c._ret)
	if ycbcrConversion != nil {
		*ycbcrConversion = SamplerYcbcrConversion(*c.pYcbcrConversion)
	}
	return
}
func DestroySamplerYcbcrConversion(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
	var c struct {
		device          C.VkDevice
		ycbcrConversion C.VkSamplerYcbcrConversion
		pAllocator      *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.ycbcrConversion = C.VkSamplerYcbcrConversion(ycbcrConversion)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroySamplerYcbcrConversion(c.device, c.ycbcrConversion, c.pAllocator)
}
func CreateDescriptorUpdateTemplate(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks, descriptorUpdateTemplate *DescriptorUpdateTemplate) (_ret Result) {
	var c struct {
		device                    C.VkDevice
		pCreateInfo               *C.VkDescriptorUpdateTemplateCreateInfo
		pAllocator                *C.VkAllocationCallbacks
		pDescriptorUpdateTemplate *C.VkDescriptorUpdateTemplate
		_ret                      C.VkResult
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkDescriptorUpdateTemplateCreateInfo)(m.alloc(C.sizeof_VkDescriptorUpdateTemplateCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	if descriptorUpdateTemplate != nil {
		c.pDescriptorUpdateTemplate = (*C.VkDescriptorUpdateTemplate)(m.alloc(C.sizeof_VkDescriptorUpdateTemplate))
		*c.pDescriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(*descriptorUpdateTemplate)
	} else {
		c.pDescriptorUpdateTemplate = nil
	}
	c._ret = C.vkCreateDescriptorUpdateTemplate(c.device, c.pCreateInfo, c.pAllocator, c.pDescriptorUpdateTemplate)
	_ret = Result(c._ret)
	if descriptorUpdateTemplate != nil {
		*descriptorUpdateTemplate = DescriptorUpdateTemplate(*c.pDescriptorUpdateTemplate)
	}
	return
}
func DestroyDescriptorUpdateTemplate(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
	var c struct {
		device                   C.VkDevice
		descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
		pAllocator               *C.VkAllocationCallbacks
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
	if allocator != nil {
		c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
		allocator.toC(c.pAllocator)
	} else {
		c.pAllocator = nil
	}
	C.vkDestroyDescriptorUpdateTemplate(c.device, c.descriptorUpdateTemplate, c.pAllocator)
}
func UpdateDescriptorSetWithTemplate(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data unsafe.Pointer) {
	var c struct {
		device                   C.VkDevice
		descriptorSet            C.VkDescriptorSet
		descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
		pData                    unsafe.Pointer
	}
	c.device = C.VkDevice(device)
	c.descriptorSet = C.VkDescriptorSet(descriptorSet)
	c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
	c.pData = data
	C.vkUpdateDescriptorSetWithTemplate(c.device, c.descriptorSet, c.descriptorUpdateTemplate, c.pData)
}
func GetPhysicalDeviceExternalBufferProperties(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo, externalBufferProperties *ExternalBufferProperties) {
	var c struct {
		physicalDevice            C.VkPhysicalDevice
		pExternalBufferInfo       *C.VkPhysicalDeviceExternalBufferInfo
		pExternalBufferProperties *C.VkExternalBufferProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if externalBufferInfo != nil {
		c.pExternalBufferInfo = (*C.VkPhysicalDeviceExternalBufferInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalBufferInfo))
		externalBufferInfo.toC(c.pExternalBufferInfo, m)
	} else {
		c.pExternalBufferInfo = nil
	}
	if externalBufferProperties != nil {
		c.pExternalBufferProperties = (*C.VkExternalBufferProperties)(m.alloc(C.sizeof_VkExternalBufferProperties))
		externalBufferProperties.toC(c.pExternalBufferProperties, m)
	} else {
		c.pExternalBufferProperties = nil
	}
	C.vkGetPhysicalDeviceExternalBufferProperties(c.physicalDevice, c.pExternalBufferInfo, c.pExternalBufferProperties)
	if externalBufferProperties != nil {
		externalBufferProperties.fromC(c.pExternalBufferProperties)
	}
}
func GetPhysicalDeviceExternalFenceProperties(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo, externalFenceProperties *ExternalFenceProperties) {
	var c struct {
		physicalDevice           C.VkPhysicalDevice
		pExternalFenceInfo       *C.VkPhysicalDeviceExternalFenceInfo
		pExternalFenceProperties *C.VkExternalFenceProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if externalFenceInfo != nil {
		c.pExternalFenceInfo = (*C.VkPhysicalDeviceExternalFenceInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalFenceInfo))
		externalFenceInfo.toC(c.pExternalFenceInfo, m)
	} else {
		c.pExternalFenceInfo = nil
	}
	if externalFenceProperties != nil {
		c.pExternalFenceProperties = (*C.VkExternalFenceProperties)(m.alloc(C.sizeof_VkExternalFenceProperties))
		externalFenceProperties.toC(c.pExternalFenceProperties, m)
	} else {
		c.pExternalFenceProperties = nil
	}
	C.vkGetPhysicalDeviceExternalFenceProperties(c.physicalDevice, c.pExternalFenceInfo, c.pExternalFenceProperties)
	if externalFenceProperties != nil {
		externalFenceProperties.fromC(c.pExternalFenceProperties)
	}
}
func GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, externalSemaphoreProperties *ExternalSemaphoreProperties) {
	var c struct {
		physicalDevice               C.VkPhysicalDevice
		pExternalSemaphoreInfo       *C.VkPhysicalDeviceExternalSemaphoreInfo
		pExternalSemaphoreProperties *C.VkExternalSemaphoreProperties
	}
	m := pool.take()
	defer pool.give(m)
	c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
	if externalSemaphoreInfo != nil {
		c.pExternalSemaphoreInfo = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalSemaphoreInfo))
		externalSemaphoreInfo.toC(c.pExternalSemaphoreInfo, m)
	} else {
		c.pExternalSemaphoreInfo = nil
	}
	if externalSemaphoreProperties != nil {
		c.pExternalSemaphoreProperties = (*C.VkExternalSemaphoreProperties)(m.alloc(C.sizeof_VkExternalSemaphoreProperties))
		externalSemaphoreProperties.toC(c.pExternalSemaphoreProperties, m)
	} else {
		c.pExternalSemaphoreProperties = nil
	}
	C.vkGetPhysicalDeviceExternalSemaphoreProperties(c.physicalDevice, c.pExternalSemaphoreInfo, c.pExternalSemaphoreProperties)
	if externalSemaphoreProperties != nil {
		externalSemaphoreProperties.fromC(c.pExternalSemaphoreProperties)
	}
}
func GetDescriptorSetLayoutSupport(device Device, createInfo *DescriptorSetLayoutCreateInfo, support *DescriptorSetLayoutSupport) {
	var c struct {
		device      C.VkDevice
		pCreateInfo *C.VkDescriptorSetLayoutCreateInfo
		pSupport    *C.VkDescriptorSetLayoutSupport
	}
	m := pool.take()
	defer pool.give(m)
	c.device = C.VkDevice(device)
	if createInfo != nil {
		c.pCreateInfo = (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
		createInfo.toC(c.pCreateInfo, m)
	} else {
		c.pCreateInfo = nil
	}
	if support != nil {
		c.pSupport = (*C.VkDescriptorSetLayoutSupport)(m.alloc(C.sizeof_VkDescriptorSetLayoutSupport))
		support.toC(c.pSupport, m)
	} else {
		c.pSupport = nil
	}
	C.vkGetDescriptorSetLayoutSupport(c.device, c.pCreateInfo, c.pSupport)
	if support != nil {
		support.fromC(c.pSupport)
	}
}

type ColorSpaceKHR int

const (
	COLOR_SPACE_SRGB_NONLINEAR_KHR          ColorSpaceKHR = 0
	COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT    ColorSpaceKHR = 1000104001
	COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT    ColorSpaceKHR = 1000104002
	COLOR_SPACE_DCI_P3_LINEAR_EXT           ColorSpaceKHR = 1000104003
	COLOR_SPACE_DCI_P3_NONLINEAR_EXT        ColorSpaceKHR = 1000104004
	COLOR_SPACE_BT709_LINEAR_EXT            ColorSpaceKHR = 1000104005
	COLOR_SPACE_BT709_NONLINEAR_EXT         ColorSpaceKHR = 1000104006
	COLOR_SPACE_BT2020_LINEAR_EXT           ColorSpaceKHR = 1000104007
	COLOR_SPACE_HDR10_ST2084_EXT            ColorSpaceKHR = 1000104008
	COLOR_SPACE_DOLBYVISION_EXT             ColorSpaceKHR = 1000104009
	COLOR_SPACE_HDR10_HLG_EXT               ColorSpaceKHR = 1000104010
	COLOR_SPACE_ADOBERGB_LINEAR_EXT         ColorSpaceKHR = 1000104011
	COLOR_SPACE_ADOBERGB_NONLINEAR_EXT      ColorSpaceKHR = 1000104012
	COLOR_SPACE_PASS_THROUGH_EXT            ColorSpaceKHR = 1000104013
	COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT ColorSpaceKHR = 1000104014
	COLOR_SPACE_BEGIN_RANGE_KHR             ColorSpaceKHR = COLOR_SPACE_SRGB_NONLINEAR_KHR
	COLOR_SPACE_END_RANGE_KHR               ColorSpaceKHR = COLOR_SPACE_SRGB_NONLINEAR_KHR
	COLOR_SPACE_RANGE_SIZE_KHR              ColorSpaceKHR = (COLOR_SPACE_SRGB_NONLINEAR_KHR - COLOR_SPACE_SRGB_NONLINEAR_KHR + 1)
	COLOR_SPACE_MAX_ENUM_KHR                ColorSpaceKHR = 2147483647
)

type PresentModeKHR int

const (
	PRESENT_MODE_IMMEDIATE_KHR                 PresentModeKHR = 0
	PRESENT_MODE_MAILBOX_KHR                   PresentModeKHR = 1
	PRESENT_MODE_FIFO_KHR                      PresentModeKHR = 2
	PRESENT_MODE_FIFO_RELAXED_KHR              PresentModeKHR = 3
	PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR     PresentModeKHR = 1000111000
	PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR PresentModeKHR = 1000111001
	PRESENT_MODE_BEGIN_RANGE_KHR               PresentModeKHR = PRESENT_MODE_IMMEDIATE_KHR
	PRESENT_MODE_END_RANGE_KHR                 PresentModeKHR = PRESENT_MODE_FIFO_RELAXED_KHR
	PRESENT_MODE_RANGE_SIZE_KHR                PresentModeKHR = (PRESENT_MODE_FIFO_RELAXED_KHR - PRESENT_MODE_IMMEDIATE_KHR + 1)
	PRESENT_MODE_MAX_ENUM_KHR                  PresentModeKHR = 2147483647
)

type SurfaceTransformFlagBitsKHR int

const (
	SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     SurfaceTransformFlagBitsKHR = 1
	SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    SurfaceTransformFlagBitsKHR = 2
	SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   SurfaceTransformFlagBitsKHR = 4
	SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   SurfaceTransformFlagBitsKHR = 8
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            SurfaceTransformFlagBitsKHR = 16
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  SurfaceTransformFlagBitsKHR = 32
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR SurfaceTransformFlagBitsKHR = 64
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR SurfaceTransformFlagBitsKHR = 128
	SURFACE_TRANSFORM_INHERIT_BIT_KHR                      SurfaceTransformFlagBitsKHR = 256
	SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR               SurfaceTransformFlagBitsKHR = 2147483647
)

type CompositeAlphaFlagBitsKHR int

const (
	COMPOSITE_ALPHA_OPAQUE_BIT_KHR          CompositeAlphaFlagBitsKHR = 1
	COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  CompositeAlphaFlagBitsKHR = 2
	COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR CompositeAlphaFlagBitsKHR = 4
	COMPOSITE_ALPHA_INHERIT_BIT_KHR         CompositeAlphaFlagBitsKHR = 8
	COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR  CompositeAlphaFlagBitsKHR = 2147483647
)

type PFNDestroySurfaceKHR C.PFN_vkDestroySurfaceKHR
type SurfaceKHR C.VkSurfaceKHR
type FuncDestroySurfaceKHR func(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks)

func ToDestroySurfaceKHR(p PFNVoidFunction) (fn FuncDestroySurfaceKHR) {
	return func(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks) {
		var c struct {
			instance   C.VkInstance
			surface    C.VkSurfaceKHR
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		c.surface = C.VkSurfaceKHR(surface)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySurfaceKHR(C.PFN_vkDestroySurfaceKHR(unsafe.Pointer(p)), c.instance, c.surface, c.pAllocator)
	}
}

type PFNGetPhysicalDeviceSurfaceSupportKHR C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR
type FuncGetPhysicalDeviceSurfaceSupportKHR func(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR, supported *bool) (_ret Result)

func ToGetPhysicalDeviceSurfaceSupportKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceSupportKHR) {
	return func(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR, supported *bool) (_ret Result) {
		var c struct {
			physicalDevice   C.VkPhysicalDevice
			queueFamilyIndex C.uint32_t
			surface          C.VkSurfaceKHR
			pSupported       *C.VkBool32
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.queueFamilyIndex = C.uint32_t(queueFamilyIndex)
		c.surface = C.VkSurfaceKHR(surface)
		if supported != nil {
			c.pSupported = (*C.VkBool32)(m.alloc(C.sizeof_VkBool32))
			if *supported {
				*c.pSupported = 1
			} else {
				*c.pSupported = 0
			}
		} else {
			c.pSupported = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceSupportKHR(C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR(unsafe.Pointer(p)), c.physicalDevice, c.queueFamilyIndex, c.surface, c.pSupported)
		_ret = Result(c._ret)
		if supported != nil {
			*supported = *c.pSupported != 0
		}
		return
	}
}

type PFNGetPhysicalDeviceSurfaceCapabilitiesKHR C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR
type SurfaceTransformFlagsKHR Flags
type CompositeAlphaFlagsKHR Flags
type SurfaceCapabilitiesKHR struct {
	MinImageCount           uint32
	MaxImageCount           uint32
	CurrentExtent           Extent2D
	MinImageExtent          Extent2D
	MaxImageExtent          Extent2D
	MaxImageArrayLayers     uint32
	SupportedTransforms     SurfaceTransformFlagsKHR
	CurrentTransform        SurfaceTransformFlagBitsKHR
	SupportedCompositeAlpha CompositeAlphaFlagsKHR
	SupportedUsageFlags     ImageUsageFlags
}

func (g *SurfaceCapabilitiesKHR) toC(c *C.VkSurfaceCapabilitiesKHR) {
	c.minImageCount = C.uint32_t(g.MinImageCount)
	c.maxImageCount = C.uint32_t(g.MaxImageCount)
	g.CurrentExtent.toC(&c.currentExtent)
	g.MinImageExtent.toC(&c.minImageExtent)
	g.MaxImageExtent.toC(&c.maxImageExtent)
	c.maxImageArrayLayers = C.uint32_t(g.MaxImageArrayLayers)
	{
		var temp_in_VkSurfaceTransformFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedTransforms = C.VkSurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	c.currentTransform = C.VkSurfaceTransformFlagBitsKHR(g.CurrentTransform)
	{
		var temp_in_VkCompositeAlphaFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedCompositeAlpha)))
			temp_in_VkCompositeAlphaFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedCompositeAlpha = C.VkCompositeAlphaFlagsKHR(temp_in_VkCompositeAlphaFlagsKHR)
	}
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedUsageFlags)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedUsageFlags = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
}
func (g *SurfaceCapabilitiesKHR) fromC(c *C.VkSurfaceCapabilitiesKHR) {
	g.MinImageCount = uint32(c.minImageCount)
	g.MaxImageCount = uint32(c.maxImageCount)
	g.CurrentExtent.fromC(&c.currentExtent)
	g.MinImageExtent.fromC(&c.minImageExtent)
	g.MaxImageExtent.fromC(&c.maxImageExtent)
	g.MaxImageArrayLayers = uint32(c.maxImageArrayLayers)
	{
		var temp_in_VkSurfaceTransformFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedTransforms = SurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	g.CurrentTransform = SurfaceTransformFlagBitsKHR(c.currentTransform)
	{
		var temp_in_VkCompositeAlphaFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedCompositeAlpha)))
			temp_in_VkCompositeAlphaFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedCompositeAlpha = CompositeAlphaFlagsKHR(temp_in_VkCompositeAlphaFlagsKHR)
	}
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedUsageFlags)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.SupportedUsageFlags = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
}

type FuncGetPhysicalDeviceSurfaceCapabilitiesKHR func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceCapabilities *SurfaceCapabilitiesKHR) (_ret Result)

func ToGetPhysicalDeviceSurfaceCapabilitiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceCapabilitiesKHR) {
	return func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceCapabilities *SurfaceCapabilitiesKHR) (_ret Result) {
		var c struct {
			physicalDevice       C.VkPhysicalDevice
			surface              C.VkSurfaceKHR
			pSurfaceCapabilities *C.VkSurfaceCapabilitiesKHR
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.surface = C.VkSurfaceKHR(surface)
		if surfaceCapabilities != nil {
			c.pSurfaceCapabilities = (*C.VkSurfaceCapabilitiesKHR)(m.alloc(C.sizeof_VkSurfaceCapabilitiesKHR))
			surfaceCapabilities.toC(c.pSurfaceCapabilities)
		} else {
			c.pSurfaceCapabilities = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.surface, c.pSurfaceCapabilities)
		_ret = Result(c._ret)
		if surfaceCapabilities != nil {
			surfaceCapabilities.fromC(c.pSurfaceCapabilities)
		}
		return
	}
}

type PFNGetPhysicalDeviceSurfaceFormatsKHR C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR
type SurfaceFormatKHR struct {
	Format     Format
	ColorSpace ColorSpaceKHR
}

func (g *SurfaceFormatKHR) toC(c *C.VkSurfaceFormatKHR) {
	c.format = C.VkFormat(g.Format)
	c.colorSpace = C.VkColorSpaceKHR(g.ColorSpace)
}
func (g *SurfaceFormatKHR) fromC(c *C.VkSurfaceFormatKHR) {
	g.Format = Format(c.format)
	g.ColorSpace = ColorSpaceKHR(c.colorSpace)
}

type FuncGetPhysicalDeviceSurfaceFormatsKHR func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceFormatCount *uint32, surfaceFormats []SurfaceFormatKHR) (_ret Result)

func ToGetPhysicalDeviceSurfaceFormatsKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceFormatsKHR) {
	return func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceFormatCount *uint32, surfaceFormats []SurfaceFormatKHR) (_ret Result) {
		var c struct {
			physicalDevice      C.VkPhysicalDevice
			surface             C.VkSurfaceKHR
			pSurfaceFormatCount *C.uint32_t
			pSurfaceFormats     *C.VkSurfaceFormatKHR
			_ret                C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.surface = C.VkSurfaceKHR(surface)
		if surfaceFormatCount != nil {
			c.pSurfaceFormatCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSurfaceFormatCount = C.uint32_t(*surfaceFormatCount)
		} else {
			c.pSurfaceFormatCount = nil
		}
		if len(surfaceFormats) != 0 {
			c.pSurfaceFormats = (*C.VkSurfaceFormatKHR)(m.alloc(C.sizeof_VkSurfaceFormatKHR * uint(len(surfaceFormats))))
			slice1 := (*[1 << 31]C.VkSurfaceFormatKHR)(unsafe.Pointer(c.pSurfaceFormats))[:len(surfaceFormats):len(surfaceFormats)]
			for i1, _ := range surfaceFormats {
				surfaceFormats[i1].toC(&slice1[i1])
			}
		} else {
			c.pSurfaceFormats = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceFormatsKHR(C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR(unsafe.Pointer(p)), c.physicalDevice, c.surface, c.pSurfaceFormatCount, c.pSurfaceFormats)
		_ret = Result(c._ret)
		if surfaceFormatCount != nil {
			*surfaceFormatCount = uint32(*c.pSurfaceFormatCount)
		}
		if len(surfaceFormats) != 0 {
			slice1 := (*[1 << 31]C.VkSurfaceFormatKHR)(unsafe.Pointer(c.pSurfaceFormats))[:len(surfaceFormats):len(surfaceFormats)]
			for i1, _ := range surfaceFormats {
				surfaceFormats[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceSurfacePresentModesKHR C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR
type FuncGetPhysicalDeviceSurfacePresentModesKHR func(physicalDevice PhysicalDevice, surface SurfaceKHR, presentModeCount *uint32, presentModes []PresentModeKHR) (_ret Result)

func ToGetPhysicalDeviceSurfacePresentModesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfacePresentModesKHR) {
	return func(physicalDevice PhysicalDevice, surface SurfaceKHR, presentModeCount *uint32, presentModes []PresentModeKHR) (_ret Result) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			surface           C.VkSurfaceKHR
			pPresentModeCount *C.uint32_t
			pPresentModes     *C.VkPresentModeKHR
			_ret              C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.surface = C.VkSurfaceKHR(surface)
		if presentModeCount != nil {
			c.pPresentModeCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPresentModeCount = C.uint32_t(*presentModeCount)
		} else {
			c.pPresentModeCount = nil
		}
		if len(presentModes) != 0 {
			c.pPresentModes = (*C.VkPresentModeKHR)(m.alloc(C.sizeof_VkPresentModeKHR * uint(len(presentModes))))
			slice1 := (*[1 << 31]C.VkPresentModeKHR)(unsafe.Pointer(c.pPresentModes))[:len(presentModes):len(presentModes)]
			for i1, _ := range presentModes {
				slice1[i1] = C.VkPresentModeKHR(presentModes[i1])
			}
		} else {
			c.pPresentModes = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfacePresentModesKHR(C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR(unsafe.Pointer(p)), c.physicalDevice, c.surface, c.pPresentModeCount, c.pPresentModes)
		_ret = Result(c._ret)
		if presentModeCount != nil {
			*presentModeCount = uint32(*c.pPresentModeCount)
		}
		if len(presentModes) != 0 {
			slice1 := (*[1 << 31]C.VkPresentModeKHR)(unsafe.Pointer(c.pPresentModes))[:len(presentModes):len(presentModes)]
			for i1, _ := range presentModes {
				presentModes[i1] = PresentModeKHR(slice1[i1])
			}
		}
		return
	}
}

type SwapchainCreateFlagBitsKHR int

const (
	SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR SwapchainCreateFlagBitsKHR = 1
	SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                   SwapchainCreateFlagBitsKHR = 2
	SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR              SwapchainCreateFlagBitsKHR = 2147483647
)

type DeviceGroupPresentModeFlagBitsKHR int

const (
	DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR              DeviceGroupPresentModeFlagBitsKHR = 1
	DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR             DeviceGroupPresentModeFlagBitsKHR = 2
	DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR                DeviceGroupPresentModeFlagBitsKHR = 4
	DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = 8
	DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR     DeviceGroupPresentModeFlagBitsKHR = 2147483647
)

type PFNCreateSwapchainKHR C.PFN_vkCreateSwapchainKHR
type SwapchainCreateFlagsKHR Flags
type SwapchainKHR C.VkSwapchainKHR
type SwapchainCreateInfoKHR struct {
	Next               Structure
	Flags              SwapchainCreateFlagsKHR
	Surface            SurfaceKHR
	MinImageCount      uint32
	ImageFormat        Format
	ImageColorSpace    ColorSpaceKHR
	ImageExtent        Extent2D
	ImageArrayLayers   uint32
	ImageUsage         ImageUsageFlags
	ImageSharingMode   SharingMode
	QueueFamilyIndices []uint32
	PreTransform       SurfaceTransformFlagBitsKHR
	CompositeAlpha     CompositeAlphaFlagBitsKHR
	PresentMode        PresentModeKHR
	Clipped            bool
	OldSwapchain       SwapchainKHR
}

func (g *SwapchainCreateInfoKHR) toC(c *C.VkSwapchainCreateInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkSwapchainCreateFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSwapchainCreateFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSwapchainCreateFlagsKHR(temp_in_VkSwapchainCreateFlagsKHR)
	}
	c.surface = C.VkSurfaceKHR(g.Surface)
	c.minImageCount = C.uint32_t(g.MinImageCount)
	c.imageFormat = C.VkFormat(g.ImageFormat)
	c.imageColorSpace = C.VkColorSpaceKHR(g.ImageColorSpace)
	g.ImageExtent.toC(&c.imageExtent)
	c.imageArrayLayers = C.uint32_t(g.ImageArrayLayers)
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ImageUsage)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.imageUsage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	c.imageSharingMode = C.VkSharingMode(g.ImageSharingMode)
	c.queueFamilyIndexCount = C.uint32_t(len(g.QueueFamilyIndices))
	if len(g.QueueFamilyIndices) != 0 {
		c.pQueueFamilyIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.QueueFamilyIndices))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			slice1[i1] = C.uint32_t(g.QueueFamilyIndices[i1])
		}
	} else {
		c.pQueueFamilyIndices = nil
	}
	c.preTransform = C.VkSurfaceTransformFlagBitsKHR(g.PreTransform)
	c.compositeAlpha = C.VkCompositeAlphaFlagBitsKHR(g.CompositeAlpha)
	c.presentMode = C.VkPresentModeKHR(g.PresentMode)
	if g.Clipped {
		c.clipped = 1
	} else {
		c.clipped = 0
	}
	c.oldSwapchain = C.VkSwapchainKHR(g.OldSwapchain)
}
func (g *SwapchainCreateInfoKHR) fromC(c *C.VkSwapchainCreateInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkSwapchainCreateFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSwapchainCreateFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.Flags = SwapchainCreateFlagsKHR(temp_in_VkSwapchainCreateFlagsKHR)
	}
	g.Surface = SurfaceKHR(c.surface)
	g.MinImageCount = uint32(c.minImageCount)
	g.ImageFormat = Format(c.imageFormat)
	g.ImageColorSpace = ColorSpaceKHR(c.imageColorSpace)
	g.ImageExtent.fromC(&c.imageExtent)
	g.ImageArrayLayers = uint32(c.imageArrayLayers)
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.imageUsage)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.ImageUsage = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	g.ImageSharingMode = SharingMode(c.imageSharingMode)
	g.QueueFamilyIndices = make([]uint32, int(c.queueFamilyIndexCount))
	if len(g.QueueFamilyIndices) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pQueueFamilyIndices))[:len(g.QueueFamilyIndices):len(g.QueueFamilyIndices)]
		for i1, _ := range g.QueueFamilyIndices {
			g.QueueFamilyIndices[i1] = uint32(slice1[i1])
		}
	}
	g.PreTransform = SurfaceTransformFlagBitsKHR(c.preTransform)
	g.CompositeAlpha = CompositeAlphaFlagBitsKHR(c.compositeAlpha)
	g.PresentMode = PresentModeKHR(c.presentMode)
	g.Clipped = c.clipped != 0
	g.OldSwapchain = SwapchainKHR(c.oldSwapchain)
}
func (s *SwapchainCreateInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
}
func (s *SwapchainCreateInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSwapchainCreateInfoKHR)(m.alloc(C.sizeof_VkSwapchainCreateInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SwapchainCreateInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSwapchainCreateInfoKHR)(p)
	s.fromC(c)
}
func (s *SwapchainCreateInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *SwapchainCreateInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateSwapchainKHR func(device Device, createInfo *SwapchainCreateInfoKHR, allocator *AllocationCallbacks, swapchain *SwapchainKHR) (_ret Result)

func ToCreateSwapchainKHR(p PFNVoidFunction) (fn FuncCreateSwapchainKHR) {
	return func(device Device, createInfo *SwapchainCreateInfoKHR, allocator *AllocationCallbacks, swapchain *SwapchainKHR) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkSwapchainCreateInfoKHR
			pAllocator  *C.VkAllocationCallbacks
			pSwapchain  *C.VkSwapchainKHR
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkSwapchainCreateInfoKHR)(m.alloc(C.sizeof_VkSwapchainCreateInfoKHR))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if swapchain != nil {
			c.pSwapchain = (*C.VkSwapchainKHR)(m.alloc(C.sizeof_VkSwapchainKHR))
			*c.pSwapchain = C.VkSwapchainKHR(*swapchain)
		} else {
			c.pSwapchain = nil
		}
		c._ret = C.callPFN_vkCreateSwapchainKHR(C.PFN_vkCreateSwapchainKHR(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pSwapchain)
		_ret = Result(c._ret)
		if swapchain != nil {
			*swapchain = SwapchainKHR(*c.pSwapchain)
		}
		return
	}
}

type PFNDestroySwapchainKHR C.PFN_vkDestroySwapchainKHR
type FuncDestroySwapchainKHR func(device Device, swapchain SwapchainKHR, allocator *AllocationCallbacks)

func ToDestroySwapchainKHR(p PFNVoidFunction) (fn FuncDestroySwapchainKHR) {
	return func(device Device, swapchain SwapchainKHR, allocator *AllocationCallbacks) {
		var c struct {
			device     C.VkDevice
			swapchain  C.VkSwapchainKHR
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySwapchainKHR(C.PFN_vkDestroySwapchainKHR(unsafe.Pointer(p)), c.device, c.swapchain, c.pAllocator)
	}
}

type PFNGetSwapchainImagesKHR C.PFN_vkGetSwapchainImagesKHR
type FuncGetSwapchainImagesKHR func(device Device, swapchain SwapchainKHR, swapchainImageCount *uint32, swapchainImages []Image) (_ret Result)

func ToGetSwapchainImagesKHR(p PFNVoidFunction) (fn FuncGetSwapchainImagesKHR) {
	return func(device Device, swapchain SwapchainKHR, swapchainImageCount *uint32, swapchainImages []Image) (_ret Result) {
		var c struct {
			device               C.VkDevice
			swapchain            C.VkSwapchainKHR
			pSwapchainImageCount *C.uint32_t
			pSwapchainImages     *C.VkImage
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		if swapchainImageCount != nil {
			c.pSwapchainImageCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSwapchainImageCount = C.uint32_t(*swapchainImageCount)
		} else {
			c.pSwapchainImageCount = nil
		}
		if len(swapchainImages) != 0 {
			c.pSwapchainImages = (*C.VkImage)(m.alloc(C.sizeof_VkImage * uint(len(swapchainImages))))
			slice1 := (*[1 << 31]C.VkImage)(unsafe.Pointer(c.pSwapchainImages))[:len(swapchainImages):len(swapchainImages)]
			for i1, _ := range swapchainImages {
				slice1[i1] = C.VkImage(swapchainImages[i1])
			}
		} else {
			c.pSwapchainImages = nil
		}
		c._ret = C.callPFN_vkGetSwapchainImagesKHR(C.PFN_vkGetSwapchainImagesKHR(unsafe.Pointer(p)), c.device, c.swapchain, c.pSwapchainImageCount, c.pSwapchainImages)
		_ret = Result(c._ret)
		if swapchainImageCount != nil {
			*swapchainImageCount = uint32(*c.pSwapchainImageCount)
		}
		if len(swapchainImages) != 0 {
			slice1 := (*[1 << 31]C.VkImage)(unsafe.Pointer(c.pSwapchainImages))[:len(swapchainImages):len(swapchainImages)]
			for i1, _ := range swapchainImages {
				swapchainImages[i1] = Image(slice1[i1])
			}
		}
		return
	}
}

type PFNAcquireNextImageKHR C.PFN_vkAcquireNextImageKHR
type FuncAcquireNextImageKHR func(device Device, swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence, imageIndex *uint32) (_ret Result)

func ToAcquireNextImageKHR(p PFNVoidFunction) (fn FuncAcquireNextImageKHR) {
	return func(device Device, swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence, imageIndex *uint32) (_ret Result) {
		var c struct {
			device      C.VkDevice
			swapchain   C.VkSwapchainKHR
			timeout     C.uint64_t
			semaphore   C.VkSemaphore
			fence       C.VkFence
			pImageIndex *C.uint32_t
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		c.timeout = C.uint64_t(timeout)
		c.semaphore = C.VkSemaphore(semaphore)
		c.fence = C.VkFence(fence)
		if imageIndex != nil {
			c.pImageIndex = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pImageIndex = C.uint32_t(*imageIndex)
		} else {
			c.pImageIndex = nil
		}
		c._ret = C.callPFN_vkAcquireNextImageKHR(C.PFN_vkAcquireNextImageKHR(unsafe.Pointer(p)), c.device, c.swapchain, c.timeout, c.semaphore, c.fence, c.pImageIndex)
		_ret = Result(c._ret)
		if imageIndex != nil {
			*imageIndex = uint32(*c.pImageIndex)
		}
		return
	}
}

type PFNQueuePresentKHR C.PFN_vkQueuePresentKHR
type PresentInfoKHR struct {
	Next           Structure
	WaitSemaphores []Semaphore
	Swapchains     []SwapchainKHR
	ImageIndices   []uint32
	Results        []Result
}

func (g *PresentInfoKHR) toC(c *C.VkPresentInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.waitSemaphoreCount = C.uint32_t(len(g.WaitSemaphores))
	if len(g.WaitSemaphores) != 0 {
		c.pWaitSemaphores = (*C.VkSemaphore)(m.alloc(C.sizeof_VkSemaphore * uint(len(g.WaitSemaphores))))
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			slice1[i1] = C.VkSemaphore(g.WaitSemaphores[i1])
		}
	} else {
		c.pWaitSemaphores = nil
	}
	c.swapchainCount = C.uint32_t(len(g.Swapchains))
	if len(g.Swapchains) != 0 {
		c.pSwapchains = (*C.VkSwapchainKHR)(m.alloc(C.sizeof_VkSwapchainKHR * uint(len(g.Swapchains))))
		slice1 := (*[1 << 31]C.VkSwapchainKHR)(unsafe.Pointer(c.pSwapchains))[:len(g.Swapchains):len(g.Swapchains)]
		for i1, _ := range g.Swapchains {
			slice1[i1] = C.VkSwapchainKHR(g.Swapchains[i1])
		}
	} else {
		c.pSwapchains = nil
	}
	if len(g.ImageIndices) != 0 {
		c.pImageIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.ImageIndices))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pImageIndices))[:len(g.ImageIndices):len(g.ImageIndices)]
		for i1, _ := range g.ImageIndices {
			slice1[i1] = C.uint32_t(g.ImageIndices[i1])
		}
	} else {
		c.pImageIndices = nil
	}
	if len(g.Results) != 0 {
		c.pResults = (*C.VkResult)(m.alloc(C.sizeof_VkResult * uint(len(g.Results))))
		slice1 := (*[1 << 31]C.VkResult)(unsafe.Pointer(c.pResults))[:len(g.Results):len(g.Results)]
		for i1, _ := range g.Results {
			slice1[i1] = C.VkResult(g.Results[i1])
		}
	} else {
		c.pResults = nil
	}
}
func (g *PresentInfoKHR) fromC(c *C.VkPresentInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.WaitSemaphores = make([]Semaphore, int(c.waitSemaphoreCount))
	if len(g.WaitSemaphores) != 0 {
		slice1 := (*[1 << 31]C.VkSemaphore)(unsafe.Pointer(c.pWaitSemaphores))[:len(g.WaitSemaphores):len(g.WaitSemaphores)]
		for i1, _ := range g.WaitSemaphores {
			g.WaitSemaphores[i1] = Semaphore(slice1[i1])
		}
	}
	g.Swapchains = make([]SwapchainKHR, int(c.swapchainCount))
	if len(g.Swapchains) != 0 {
		slice1 := (*[1 << 31]C.VkSwapchainKHR)(unsafe.Pointer(c.pSwapchains))[:len(g.Swapchains):len(g.Swapchains)]
		for i1, _ := range g.Swapchains {
			g.Swapchains[i1] = SwapchainKHR(slice1[i1])
		}
	}
	if len(g.ImageIndices) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pImageIndices))[:len(g.ImageIndices):len(g.ImageIndices)]
		for i1, _ := range g.ImageIndices {
			g.ImageIndices[i1] = uint32(slice1[i1])
		}
	}
	if len(g.Results) != 0 {
		slice1 := (*[1 << 31]C.VkResult)(unsafe.Pointer(c.pResults))[:len(g.Results):len(g.Results)]
		for i1, _ := range g.Results {
			g.Results[i1] = Result(slice1[i1])
		}
	}
}
func (s *PresentInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
}
func (s *PresentInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPresentInfoKHR)(m.alloc(C.sizeof_VkPresentInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PresentInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPresentInfoKHR)(p)
	s.fromC(c)
}
func (s *PresentInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *PresentInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncQueuePresentKHR func(queue Queue, presentInfo *PresentInfoKHR) (_ret Result)

func ToQueuePresentKHR(p PFNVoidFunction) (fn FuncQueuePresentKHR) {
	return func(queue Queue, presentInfo *PresentInfoKHR) (_ret Result) {
		var c struct {
			queue        C.VkQueue
			pPresentInfo *C.VkPresentInfoKHR
			_ret         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		if presentInfo != nil {
			c.pPresentInfo = (*C.VkPresentInfoKHR)(m.alloc(C.sizeof_VkPresentInfoKHR))
			presentInfo.toC(c.pPresentInfo, m)
		} else {
			c.pPresentInfo = nil
		}
		c._ret = C.callPFN_vkQueuePresentKHR(C.PFN_vkQueuePresentKHR(unsafe.Pointer(p)), c.queue, c.pPresentInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetDeviceGroupPresentCapabilitiesKHR C.PFN_vkGetDeviceGroupPresentCapabilitiesKHR
type DeviceGroupPresentModeFlagsKHR Flags
type DeviceGroupPresentCapabilitiesKHR struct {
	Next        Structure
	PresentMask [32]uint32
	Modes       DeviceGroupPresentModeFlagsKHR
}

func (g *DeviceGroupPresentCapabilitiesKHR) toC(c *C.VkDeviceGroupPresentCapabilitiesKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	for i, _ := range g.PresentMask {
		c.presentMask[i] = C.uint32_t(g.PresentMask[i])
	}
	{
		var temp_in_VkDeviceGroupPresentModeFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Modes)))
			temp_in_VkDeviceGroupPresentModeFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.modes = C.VkDeviceGroupPresentModeFlagsKHR(temp_in_VkDeviceGroupPresentModeFlagsKHR)
	}
}
func (g *DeviceGroupPresentCapabilitiesKHR) fromC(c *C.VkDeviceGroupPresentCapabilitiesKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	for i, _ := range g.PresentMask {
		g.PresentMask[i] = uint32(c.presentMask[i])
	}
	{
		var temp_in_VkDeviceGroupPresentModeFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.modes)))
			temp_in_VkDeviceGroupPresentModeFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.Modes = DeviceGroupPresentModeFlagsKHR(temp_in_VkDeviceGroupPresentModeFlagsKHR)
	}
}
func (s *DeviceGroupPresentCapabilitiesKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
}
func (s *DeviceGroupPresentCapabilitiesKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceGroupPresentCapabilitiesKHR)(m.alloc(C.sizeof_VkDeviceGroupPresentCapabilitiesKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceGroupPresentCapabilitiesKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceGroupPresentCapabilitiesKHR)(p)
	s.fromC(c)
}
func (s *DeviceGroupPresentCapabilitiesKHR) GetNext() Structure {
	return s.Next
}
func (s *DeviceGroupPresentCapabilitiesKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetDeviceGroupPresentCapabilitiesKHR func(device Device, deviceGroupPresentCapabilities *DeviceGroupPresentCapabilitiesKHR) (_ret Result)

func ToGetDeviceGroupPresentCapabilitiesKHR(p PFNVoidFunction) (fn FuncGetDeviceGroupPresentCapabilitiesKHR) {
	return func(device Device, deviceGroupPresentCapabilities *DeviceGroupPresentCapabilitiesKHR) (_ret Result) {
		var c struct {
			device                          C.VkDevice
			pDeviceGroupPresentCapabilities *C.VkDeviceGroupPresentCapabilitiesKHR
			_ret                            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if deviceGroupPresentCapabilities != nil {
			c.pDeviceGroupPresentCapabilities = (*C.VkDeviceGroupPresentCapabilitiesKHR)(m.alloc(C.sizeof_VkDeviceGroupPresentCapabilitiesKHR))
			deviceGroupPresentCapabilities.toC(c.pDeviceGroupPresentCapabilities, m)
		} else {
			c.pDeviceGroupPresentCapabilities = nil
		}
		c._ret = C.callPFN_vkGetDeviceGroupPresentCapabilitiesKHR(C.PFN_vkGetDeviceGroupPresentCapabilitiesKHR(unsafe.Pointer(p)), c.device, c.pDeviceGroupPresentCapabilities)
		_ret = Result(c._ret)
		if deviceGroupPresentCapabilities != nil {
			deviceGroupPresentCapabilities.fromC(c.pDeviceGroupPresentCapabilities)
		}
		return
	}
}

type PFNGetDeviceGroupSurfacePresentModesKHR C.PFN_vkGetDeviceGroupSurfacePresentModesKHR
type FuncGetDeviceGroupSurfacePresentModesKHR func(device Device, surface SurfaceKHR, modes *DeviceGroupPresentModeFlagsKHR) (_ret Result)

func ToGetDeviceGroupSurfacePresentModesKHR(p PFNVoidFunction) (fn FuncGetDeviceGroupSurfacePresentModesKHR) {
	return func(device Device, surface SurfaceKHR, modes *DeviceGroupPresentModeFlagsKHR) (_ret Result) {
		var c struct {
			device  C.VkDevice
			surface C.VkSurfaceKHR
			pModes  *C.VkDeviceGroupPresentModeFlagsKHR
			_ret    C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.surface = C.VkSurfaceKHR(surface)
		if modes != nil {
			c.pModes = (*C.VkDeviceGroupPresentModeFlagsKHR)(m.alloc(C.sizeof_VkDeviceGroupPresentModeFlagsKHR))
			{
				var temp_in_VkDeviceGroupPresentModeFlagsKHR C.VkFlags
				{
					var temp_in_VkFlags C.uint32_t
					temp_in_VkFlags = C.uint32_t((uint32)((Flags)(*modes)))
					temp_in_VkDeviceGroupPresentModeFlagsKHR = C.VkFlags(temp_in_VkFlags)
				}
				*c.pModes = C.VkDeviceGroupPresentModeFlagsKHR(temp_in_VkDeviceGroupPresentModeFlagsKHR)
			}
		} else {
			c.pModes = nil
		}
		c._ret = C.callPFN_vkGetDeviceGroupSurfacePresentModesKHR(C.PFN_vkGetDeviceGroupSurfacePresentModesKHR(unsafe.Pointer(p)), c.device, c.surface, c.pModes)
		_ret = Result(c._ret)
		if modes != nil {
			var temp_in_VkDeviceGroupPresentModeFlagsKHR Flags
			{
				var temp_in_VkFlags uint32
				temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(*c.pModes)))
				temp_in_VkDeviceGroupPresentModeFlagsKHR = Flags(temp_in_VkFlags)
			}
			*modes = DeviceGroupPresentModeFlagsKHR(temp_in_VkDeviceGroupPresentModeFlagsKHR)
		}
		return
	}
}

type PFNGetPhysicalDevicePresentRectanglesKHR C.PFN_vkGetPhysicalDevicePresentRectanglesKHR
type FuncGetPhysicalDevicePresentRectanglesKHR func(physicalDevice PhysicalDevice, surface SurfaceKHR, rectCount *uint32, rects []Rect2D) (_ret Result)

func ToGetPhysicalDevicePresentRectanglesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDevicePresentRectanglesKHR) {
	return func(physicalDevice PhysicalDevice, surface SurfaceKHR, rectCount *uint32, rects []Rect2D) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			surface        C.VkSurfaceKHR
			pRectCount     *C.uint32_t
			pRects         *C.VkRect2D
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.surface = C.VkSurfaceKHR(surface)
		if rectCount != nil {
			c.pRectCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pRectCount = C.uint32_t(*rectCount)
		} else {
			c.pRectCount = nil
		}
		if len(rects) != 0 {
			c.pRects = (*C.VkRect2D)(m.alloc(C.sizeof_VkRect2D * uint(len(rects))))
			slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pRects))[:len(rects):len(rects)]
			for i1, _ := range rects {
				rects[i1].toC(&slice1[i1])
			}
		} else {
			c.pRects = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDevicePresentRectanglesKHR(C.PFN_vkGetPhysicalDevicePresentRectanglesKHR(unsafe.Pointer(p)), c.physicalDevice, c.surface, c.pRectCount, c.pRects)
		_ret = Result(c._ret)
		if rectCount != nil {
			*rectCount = uint32(*c.pRectCount)
		}
		if len(rects) != 0 {
			slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pRects))[:len(rects):len(rects)]
			for i1, _ := range rects {
				rects[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNAcquireNextImage2KHR C.PFN_vkAcquireNextImage2KHR
type AcquireNextImageInfoKHR struct {
	Next       Structure
	Swapchain  SwapchainKHR
	Timeout    uint64
	Semaphore  Semaphore
	Fence      Fence
	DeviceMask uint32
}

func (g *AcquireNextImageInfoKHR) toC(c *C.VkAcquireNextImageInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.swapchain = C.VkSwapchainKHR(g.Swapchain)
	c.timeout = C.uint64_t(g.Timeout)
	c.semaphore = C.VkSemaphore(g.Semaphore)
	c.fence = C.VkFence(g.Fence)
	c.deviceMask = C.uint32_t(g.DeviceMask)
}
func (g *AcquireNextImageInfoKHR) fromC(c *C.VkAcquireNextImageInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Swapchain = SwapchainKHR(c.swapchain)
	g.Timeout = uint64(c.timeout)
	g.Semaphore = Semaphore(c.semaphore)
	g.Fence = Fence(c.fence)
	g.DeviceMask = uint32(c.deviceMask)
}
func (s *AcquireNextImageInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
}
func (s *AcquireNextImageInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkAcquireNextImageInfoKHR)(m.alloc(C.sizeof_VkAcquireNextImageInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *AcquireNextImageInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkAcquireNextImageInfoKHR)(p)
	s.fromC(c)
}
func (s *AcquireNextImageInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *AcquireNextImageInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncAcquireNextImage2KHR func(device Device, acquireInfo *AcquireNextImageInfoKHR, imageIndex *uint32) (_ret Result)

func ToAcquireNextImage2KHR(p PFNVoidFunction) (fn FuncAcquireNextImage2KHR) {
	return func(device Device, acquireInfo *AcquireNextImageInfoKHR, imageIndex *uint32) (_ret Result) {
		var c struct {
			device       C.VkDevice
			pAcquireInfo *C.VkAcquireNextImageInfoKHR
			pImageIndex  *C.uint32_t
			_ret         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if acquireInfo != nil {
			c.pAcquireInfo = (*C.VkAcquireNextImageInfoKHR)(m.alloc(C.sizeof_VkAcquireNextImageInfoKHR))
			acquireInfo.toC(c.pAcquireInfo, m)
		} else {
			c.pAcquireInfo = nil
		}
		if imageIndex != nil {
			c.pImageIndex = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pImageIndex = C.uint32_t(*imageIndex)
		} else {
			c.pImageIndex = nil
		}
		c._ret = C.callPFN_vkAcquireNextImage2KHR(C.PFN_vkAcquireNextImage2KHR(unsafe.Pointer(p)), c.device, c.pAcquireInfo, c.pImageIndex)
		_ret = Result(c._ret)
		if imageIndex != nil {
			*imageIndex = uint32(*c.pImageIndex)
		}
		return
	}
}

type DisplayPlaneAlphaFlagBitsKHR int

const (
	DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = 1
	DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = 2
	DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               DisplayPlaneAlphaFlagBitsKHR = 4
	DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = 8
	DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR          DisplayPlaneAlphaFlagBitsKHR = 2147483647
)

type PFNGetPhysicalDeviceDisplayPropertiesKHR C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR
type DisplayKHR C.VkDisplayKHR
type DisplayPropertiesKHR struct {
	Display              DisplayKHR
	DisplayName          string
	PhysicalDimensions   Extent2D
	PhysicalResolution   Extent2D
	SupportedTransforms  SurfaceTransformFlagsKHR
	PlaneReorderPossible bool
	PersistentContent    bool
}

func (g *DisplayPropertiesKHR) toC(c *C.VkDisplayPropertiesKHR, m *cmemory) {
	c.display = C.VkDisplayKHR(g.Display)
	c.displayName = toCString(g.DisplayName, m)
	g.PhysicalDimensions.toC(&c.physicalDimensions)
	g.PhysicalResolution.toC(&c.physicalResolution)
	{
		var temp_in_VkSurfaceTransformFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedTransforms = C.VkSurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	if g.PlaneReorderPossible {
		c.planeReorderPossible = 1
	} else {
		c.planeReorderPossible = 0
	}
	if g.PersistentContent {
		c.persistentContent = 1
	} else {
		c.persistentContent = 0
	}
}
func (g *DisplayPropertiesKHR) fromC(c *C.VkDisplayPropertiesKHR) {
	g.Display = DisplayKHR(c.display)
	g.DisplayName = toGoString(c.displayName)
	g.PhysicalDimensions.fromC(&c.physicalDimensions)
	g.PhysicalResolution.fromC(&c.physicalResolution)
	{
		var temp_in_VkSurfaceTransformFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedTransforms = SurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	g.PlaneReorderPossible = c.planeReorderPossible != 0
	g.PersistentContent = c.persistentContent != 0
}

type FuncGetPhysicalDeviceDisplayPropertiesKHR func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPropertiesKHR) (_ret Result)

func ToGetPhysicalDeviceDisplayPropertiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceDisplayPropertiesKHR) {
	return func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPropertiesKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayPropertiesKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayPropertiesKHR)(m.alloc(C.sizeof_VkDisplayPropertiesKHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayPropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceDisplayPropertiesKHR(C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayPropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceDisplayPlanePropertiesKHR C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR
type DisplayPlanePropertiesKHR struct {
	CurrentDisplay    DisplayKHR
	CurrentStackIndex uint32
}

func (g *DisplayPlanePropertiesKHR) toC(c *C.VkDisplayPlanePropertiesKHR) {
	c.currentDisplay = C.VkDisplayKHR(g.CurrentDisplay)
	c.currentStackIndex = C.uint32_t(g.CurrentStackIndex)
}
func (g *DisplayPlanePropertiesKHR) fromC(c *C.VkDisplayPlanePropertiesKHR) {
	g.CurrentDisplay = DisplayKHR(c.currentDisplay)
	g.CurrentStackIndex = uint32(c.currentStackIndex)
}

type FuncGetPhysicalDeviceDisplayPlanePropertiesKHR func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPlanePropertiesKHR) (_ret Result)

func ToGetPhysicalDeviceDisplayPlanePropertiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceDisplayPlanePropertiesKHR) {
	return func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPlanePropertiesKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayPlanePropertiesKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayPlanePropertiesKHR)(m.alloc(C.sizeof_VkDisplayPlanePropertiesKHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetDisplayPlaneSupportedDisplaysKHR C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR
type FuncGetDisplayPlaneSupportedDisplaysKHR func(physicalDevice PhysicalDevice, planeIndex uint32, displayCount *uint32, displays []DisplayKHR) (_ret Result)

func ToGetDisplayPlaneSupportedDisplaysKHR(p PFNVoidFunction) (fn FuncGetDisplayPlaneSupportedDisplaysKHR) {
	return func(physicalDevice PhysicalDevice, planeIndex uint32, displayCount *uint32, displays []DisplayKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			planeIndex     C.uint32_t
			pDisplayCount  *C.uint32_t
			pDisplays      *C.VkDisplayKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.planeIndex = C.uint32_t(planeIndex)
		if displayCount != nil {
			c.pDisplayCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pDisplayCount = C.uint32_t(*displayCount)
		} else {
			c.pDisplayCount = nil
		}
		if len(displays) != 0 {
			c.pDisplays = (*C.VkDisplayKHR)(m.alloc(C.sizeof_VkDisplayKHR * uint(len(displays))))
			slice1 := (*[1 << 31]C.VkDisplayKHR)(unsafe.Pointer(c.pDisplays))[:len(displays):len(displays)]
			for i1, _ := range displays {
				slice1[i1] = C.VkDisplayKHR(displays[i1])
			}
		} else {
			c.pDisplays = nil
		}
		c._ret = C.callPFN_vkGetDisplayPlaneSupportedDisplaysKHR(C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR(unsafe.Pointer(p)), c.physicalDevice, c.planeIndex, c.pDisplayCount, c.pDisplays)
		_ret = Result(c._ret)
		if displayCount != nil {
			*displayCount = uint32(*c.pDisplayCount)
		}
		if len(displays) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayKHR)(unsafe.Pointer(c.pDisplays))[:len(displays):len(displays)]
			for i1, _ := range displays {
				displays[i1] = DisplayKHR(slice1[i1])
			}
		}
		return
	}
}

type PFNGetDisplayModePropertiesKHR C.PFN_vkGetDisplayModePropertiesKHR
type DisplayModeKHR C.VkDisplayModeKHR
type DisplayModeParametersKHR struct {
	VisibleRegion Extent2D
	RefreshRate   uint32
}

func (g *DisplayModeParametersKHR) toC(c *C.VkDisplayModeParametersKHR) {
	g.VisibleRegion.toC(&c.visibleRegion)
	c.refreshRate = C.uint32_t(g.RefreshRate)
}
func (g *DisplayModeParametersKHR) fromC(c *C.VkDisplayModeParametersKHR) {
	g.VisibleRegion.fromC(&c.visibleRegion)
	g.RefreshRate = uint32(c.refreshRate)
}

type DisplayModePropertiesKHR struct {
	DisplayMode DisplayModeKHR
	Parameters  DisplayModeParametersKHR
}

func (g *DisplayModePropertiesKHR) toC(c *C.VkDisplayModePropertiesKHR) {
	c.displayMode = C.VkDisplayModeKHR(g.DisplayMode)
	g.Parameters.toC(&c.parameters)
}
func (g *DisplayModePropertiesKHR) fromC(c *C.VkDisplayModePropertiesKHR) {
	g.DisplayMode = DisplayModeKHR(c.displayMode)
	g.Parameters.fromC(&c.parameters)
}

type FuncGetDisplayModePropertiesKHR func(physicalDevice PhysicalDevice, display DisplayKHR, propertyCount *uint32, properties []DisplayModePropertiesKHR) (_ret Result)

func ToGetDisplayModePropertiesKHR(p PFNVoidFunction) (fn FuncGetDisplayModePropertiesKHR) {
	return func(physicalDevice PhysicalDevice, display DisplayKHR, propertyCount *uint32, properties []DisplayModePropertiesKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			display        C.VkDisplayKHR
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayModePropertiesKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.display = C.VkDisplayKHR(display)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayModePropertiesKHR)(m.alloc(C.sizeof_VkDisplayModePropertiesKHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1])
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetDisplayModePropertiesKHR(C.PFN_vkGetDisplayModePropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.display, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNCreateDisplayModeKHR C.PFN_vkCreateDisplayModeKHR
type DisplayModeCreateFlagsKHR Flags
type DisplayModeCreateInfoKHR struct {
	Next       Structure
	Flags      DisplayModeCreateFlagsKHR
	Parameters DisplayModeParametersKHR
}

func (g *DisplayModeCreateInfoKHR) toC(c *C.VkDisplayModeCreateInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDisplayModeCreateFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDisplayModeCreateFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDisplayModeCreateFlagsKHR(temp_in_VkDisplayModeCreateFlagsKHR)
	}
	g.Parameters.toC(&c.parameters)
}
func (g *DisplayModeCreateInfoKHR) fromC(c *C.VkDisplayModeCreateInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDisplayModeCreateFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDisplayModeCreateFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.Flags = DisplayModeCreateFlagsKHR(temp_in_VkDisplayModeCreateFlagsKHR)
	}
	g.Parameters.fromC(&c.parameters)
}
func (s *DisplayModeCreateInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
}
func (s *DisplayModeCreateInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayModeCreateInfoKHR)(m.alloc(C.sizeof_VkDisplayModeCreateInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayModeCreateInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayModeCreateInfoKHR)(p)
	s.fromC(c)
}
func (s *DisplayModeCreateInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayModeCreateInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateDisplayModeKHR func(physicalDevice PhysicalDevice, display DisplayKHR, createInfo *DisplayModeCreateInfoKHR, allocator *AllocationCallbacks, mode *DisplayModeKHR) (_ret Result)

func ToCreateDisplayModeKHR(p PFNVoidFunction) (fn FuncCreateDisplayModeKHR) {
	return func(physicalDevice PhysicalDevice, display DisplayKHR, createInfo *DisplayModeCreateInfoKHR, allocator *AllocationCallbacks, mode *DisplayModeKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			display        C.VkDisplayKHR
			pCreateInfo    *C.VkDisplayModeCreateInfoKHR
			pAllocator     *C.VkAllocationCallbacks
			pMode          *C.VkDisplayModeKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.display = C.VkDisplayKHR(display)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDisplayModeCreateInfoKHR)(m.alloc(C.sizeof_VkDisplayModeCreateInfoKHR))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if mode != nil {
			c.pMode = (*C.VkDisplayModeKHR)(m.alloc(C.sizeof_VkDisplayModeKHR))
			*c.pMode = C.VkDisplayModeKHR(*mode)
		} else {
			c.pMode = nil
		}
		c._ret = C.callPFN_vkCreateDisplayModeKHR(C.PFN_vkCreateDisplayModeKHR(unsafe.Pointer(p)), c.physicalDevice, c.display, c.pCreateInfo, c.pAllocator, c.pMode)
		_ret = Result(c._ret)
		if mode != nil {
			*mode = DisplayModeKHR(*c.pMode)
		}
		return
	}
}

type PFNGetDisplayPlaneCapabilitiesKHR C.PFN_vkGetDisplayPlaneCapabilitiesKHR
type DisplayPlaneAlphaFlagsKHR Flags
type DisplayPlaneCapabilitiesKHR struct {
	SupportedAlpha DisplayPlaneAlphaFlagsKHR
	MinSrcPosition Offset2D
	MaxSrcPosition Offset2D
	MinSrcExtent   Extent2D
	MaxSrcExtent   Extent2D
	MinDstPosition Offset2D
	MaxDstPosition Offset2D
	MinDstExtent   Extent2D
	MaxDstExtent   Extent2D
}

func (g *DisplayPlaneCapabilitiesKHR) toC(c *C.VkDisplayPlaneCapabilitiesKHR) {
	{
		var temp_in_VkDisplayPlaneAlphaFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedAlpha)))
			temp_in_VkDisplayPlaneAlphaFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedAlpha = C.VkDisplayPlaneAlphaFlagsKHR(temp_in_VkDisplayPlaneAlphaFlagsKHR)
	}
	g.MinSrcPosition.toC(&c.minSrcPosition)
	g.MaxSrcPosition.toC(&c.maxSrcPosition)
	g.MinSrcExtent.toC(&c.minSrcExtent)
	g.MaxSrcExtent.toC(&c.maxSrcExtent)
	g.MinDstPosition.toC(&c.minDstPosition)
	g.MaxDstPosition.toC(&c.maxDstPosition)
	g.MinDstExtent.toC(&c.minDstExtent)
	g.MaxDstExtent.toC(&c.maxDstExtent)
}
func (g *DisplayPlaneCapabilitiesKHR) fromC(c *C.VkDisplayPlaneCapabilitiesKHR) {
	{
		var temp_in_VkDisplayPlaneAlphaFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedAlpha)))
			temp_in_VkDisplayPlaneAlphaFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedAlpha = DisplayPlaneAlphaFlagsKHR(temp_in_VkDisplayPlaneAlphaFlagsKHR)
	}
	g.MinSrcPosition.fromC(&c.minSrcPosition)
	g.MaxSrcPosition.fromC(&c.maxSrcPosition)
	g.MinSrcExtent.fromC(&c.minSrcExtent)
	g.MaxSrcExtent.fromC(&c.maxSrcExtent)
	g.MinDstPosition.fromC(&c.minDstPosition)
	g.MaxDstPosition.fromC(&c.maxDstPosition)
	g.MinDstExtent.fromC(&c.minDstExtent)
	g.MaxDstExtent.fromC(&c.maxDstExtent)
}

type FuncGetDisplayPlaneCapabilitiesKHR func(physicalDevice PhysicalDevice, mode DisplayModeKHR, capabilities []DisplayPlaneCapabilitiesKHR) (_ret Result)

func ToGetDisplayPlaneCapabilitiesKHR(p PFNVoidFunction) (fn FuncGetDisplayPlaneCapabilitiesKHR) {
	return func(physicalDevice PhysicalDevice, mode DisplayModeKHR, capabilities []DisplayPlaneCapabilitiesKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			mode           C.VkDisplayModeKHR
			planeIndex     C.uint32_t
			pCapabilities  *C.VkDisplayPlaneCapabilitiesKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.mode = C.VkDisplayModeKHR(mode)
		c.planeIndex = C.uint32_t(len(capabilities))
		if len(capabilities) != 0 {
			c.pCapabilities = (*C.VkDisplayPlaneCapabilitiesKHR)(m.alloc(C.sizeof_VkDisplayPlaneCapabilitiesKHR * uint(len(capabilities))))
			slice1 := (*[1 << 31]C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(c.pCapabilities))[:len(capabilities):len(capabilities)]
			for i1, _ := range capabilities {
				capabilities[i1].toC(&slice1[i1])
			}
		} else {
			c.pCapabilities = nil
		}
		c._ret = C.callPFN_vkGetDisplayPlaneCapabilitiesKHR(C.PFN_vkGetDisplayPlaneCapabilitiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.mode, c.planeIndex, c.pCapabilities)
		_ret = Result(c._ret)
		if len(capabilities) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(c.pCapabilities))[:len(capabilities):len(capabilities)]
			for i1, _ := range capabilities {
				capabilities[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNCreateDisplayPlaneSurfaceKHR C.PFN_vkCreateDisplayPlaneSurfaceKHR
type DisplaySurfaceCreateFlagsKHR Flags
type DisplaySurfaceCreateInfoKHR struct {
	Next            Structure
	Flags           DisplaySurfaceCreateFlagsKHR
	DisplayMode     DisplayModeKHR
	PlaneIndex      uint32
	PlaneStackIndex uint32
	Transform       SurfaceTransformFlagBitsKHR
	GlobalAlpha     float32
	AlphaMode       DisplayPlaneAlphaFlagBitsKHR
	ImageExtent     Extent2D
}

func (g *DisplaySurfaceCreateInfoKHR) toC(c *C.VkDisplaySurfaceCreateInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDisplaySurfaceCreateFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDisplaySurfaceCreateFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDisplaySurfaceCreateFlagsKHR(temp_in_VkDisplaySurfaceCreateFlagsKHR)
	}
	c.displayMode = C.VkDisplayModeKHR(g.DisplayMode)
	c.planeIndex = C.uint32_t(g.PlaneIndex)
	c.planeStackIndex = C.uint32_t(g.PlaneStackIndex)
	c.transform = C.VkSurfaceTransformFlagBitsKHR(g.Transform)
	c.globalAlpha = C.float(g.GlobalAlpha)
	c.alphaMode = C.VkDisplayPlaneAlphaFlagBitsKHR(g.AlphaMode)
	g.ImageExtent.toC(&c.imageExtent)
}
func (g *DisplaySurfaceCreateInfoKHR) fromC(c *C.VkDisplaySurfaceCreateInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDisplaySurfaceCreateFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDisplaySurfaceCreateFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.Flags = DisplaySurfaceCreateFlagsKHR(temp_in_VkDisplaySurfaceCreateFlagsKHR)
	}
	g.DisplayMode = DisplayModeKHR(c.displayMode)
	g.PlaneIndex = uint32(c.planeIndex)
	g.PlaneStackIndex = uint32(c.planeStackIndex)
	g.Transform = SurfaceTransformFlagBitsKHR(c.transform)
	g.GlobalAlpha = float32(c.globalAlpha)
	g.AlphaMode = DisplayPlaneAlphaFlagBitsKHR(c.alphaMode)
	g.ImageExtent.fromC(&c.imageExtent)
}
func (s *DisplaySurfaceCreateInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
}
func (s *DisplaySurfaceCreateInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplaySurfaceCreateInfoKHR)(m.alloc(C.sizeof_VkDisplaySurfaceCreateInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplaySurfaceCreateInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplaySurfaceCreateInfoKHR)(p)
	s.fromC(c)
}
func (s *DisplaySurfaceCreateInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *DisplaySurfaceCreateInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateDisplayPlaneSurfaceKHR func(instance Instance, createInfo *DisplaySurfaceCreateInfoKHR, allocator *AllocationCallbacks, surface *SurfaceKHR) (_ret Result)

func ToCreateDisplayPlaneSurfaceKHR(p PFNVoidFunction) (fn FuncCreateDisplayPlaneSurfaceKHR) {
	return func(instance Instance, createInfo *DisplaySurfaceCreateInfoKHR, allocator *AllocationCallbacks, surface *SurfaceKHR) (_ret Result) {
		var c struct {
			instance    C.VkInstance
			pCreateInfo *C.VkDisplaySurfaceCreateInfoKHR
			pAllocator  *C.VkAllocationCallbacks
			pSurface    *C.VkSurfaceKHR
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDisplaySurfaceCreateInfoKHR)(m.alloc(C.sizeof_VkDisplaySurfaceCreateInfoKHR))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if surface != nil {
			c.pSurface = (*C.VkSurfaceKHR)(m.alloc(C.sizeof_VkSurfaceKHR))
			*c.pSurface = C.VkSurfaceKHR(*surface)
		} else {
			c.pSurface = nil
		}
		c._ret = C.callPFN_vkCreateDisplayPlaneSurfaceKHR(C.PFN_vkCreateDisplayPlaneSurfaceKHR(unsafe.Pointer(p)), c.instance, c.pCreateInfo, c.pAllocator, c.pSurface)
		_ret = Result(c._ret)
		if surface != nil {
			*surface = SurfaceKHR(*c.pSurface)
		}
		return
	}
}

type PFNCreateSharedSwapchainsKHR C.PFN_vkCreateSharedSwapchainsKHR
type FuncCreateSharedSwapchainsKHR func(device Device, createInfos []SwapchainCreateInfoKHR, allocator *AllocationCallbacks, swapchains []SwapchainKHR) (_ret Result)

func ToCreateSharedSwapchainsKHR(p PFNVoidFunction) (fn FuncCreateSharedSwapchainsKHR) {
	return func(device Device, createInfos []SwapchainCreateInfoKHR, allocator *AllocationCallbacks, swapchains []SwapchainKHR) (_ret Result) {
		var c struct {
			device         C.VkDevice
			swapchainCount C.uint32_t
			pCreateInfos   *C.VkSwapchainCreateInfoKHR
			pAllocator     *C.VkAllocationCallbacks
			pSwapchains    *C.VkSwapchainKHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchainCount = C.uint32_t(len(createInfos))
		if len(createInfos) != 0 {
			c.pCreateInfos = (*C.VkSwapchainCreateInfoKHR)(m.alloc(C.sizeof_VkSwapchainCreateInfoKHR * uint(len(createInfos))))
			slice1 := (*[1 << 31]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(c.pCreateInfos))[:len(createInfos):len(createInfos)]
			for i1, _ := range createInfos {
				createInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pCreateInfos = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if len(swapchains) != 0 {
			c.pSwapchains = (*C.VkSwapchainKHR)(m.alloc(C.sizeof_VkSwapchainKHR * uint(len(swapchains))))
			slice1 := (*[1 << 31]C.VkSwapchainKHR)(unsafe.Pointer(c.pSwapchains))[:len(swapchains):len(swapchains)]
			for i1, _ := range swapchains {
				slice1[i1] = C.VkSwapchainKHR(swapchains[i1])
			}
		} else {
			c.pSwapchains = nil
		}
		c._ret = C.callPFN_vkCreateSharedSwapchainsKHR(C.PFN_vkCreateSharedSwapchainsKHR(unsafe.Pointer(p)), c.device, c.swapchainCount, c.pCreateInfos, c.pAllocator, c.pSwapchains)
		_ret = Result(c._ret)
		if len(swapchains) != 0 {
			slice1 := (*[1 << 31]C.VkSwapchainKHR)(unsafe.Pointer(c.pSwapchains))[:len(swapchains):len(swapchains)]
			for i1, _ := range swapchains {
				swapchains[i1] = SwapchainKHR(slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceFeatures2KHR C.PFN_vkGetPhysicalDeviceFeatures2KHR
type FuncGetPhysicalDeviceFeatures2KHR func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures2)

func ToGetPhysicalDeviceFeatures2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFeatures2KHR) {
	return func(physicalDevice PhysicalDevice, features *PhysicalDeviceFeatures2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFeatures      *C.VkPhysicalDeviceFeatures2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if features != nil {
			c.pFeatures = (*C.VkPhysicalDeviceFeatures2)(m.alloc(C.sizeof_VkPhysicalDeviceFeatures2))
			features.toC(c.pFeatures, m)
		} else {
			c.pFeatures = nil
		}
		C.callPFN_vkGetPhysicalDeviceFeatures2KHR(C.PFN_vkGetPhysicalDeviceFeatures2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pFeatures)
		if features != nil {
			features.fromC(c.pFeatures)
		}
	}
}

type PFNGetPhysicalDeviceProperties2KHR C.PFN_vkGetPhysicalDeviceProperties2KHR
type FuncGetPhysicalDeviceProperties2KHR func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties2)

func ToGetPhysicalDeviceProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceProperties2KHR) {
	return func(physicalDevice PhysicalDevice, properties *PhysicalDeviceProperties2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pProperties    *C.VkPhysicalDeviceProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if properties != nil {
			c.pProperties = (*C.VkPhysicalDeviceProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceProperties2))
			properties.toC(c.pProperties, m)
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceProperties2KHR(C.PFN_vkGetPhysicalDeviceProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pProperties)
		if properties != nil {
			properties.fromC(c.pProperties)
		}
	}
}

type PFNGetPhysicalDeviceFormatProperties2KHR C.PFN_vkGetPhysicalDeviceFormatProperties2KHR
type FuncGetPhysicalDeviceFormatProperties2KHR func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties2)

func ToGetPhysicalDeviceFormatProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceFormatProperties2KHR) {
	return func(physicalDevice PhysicalDevice, format Format, formatProperties *FormatProperties2) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			format            C.VkFormat
			pFormatProperties *C.VkFormatProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		if formatProperties != nil {
			c.pFormatProperties = (*C.VkFormatProperties2)(m.alloc(C.sizeof_VkFormatProperties2))
			formatProperties.toC(c.pFormatProperties, m)
		} else {
			c.pFormatProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceFormatProperties2KHR(C.PFN_vkGetPhysicalDeviceFormatProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.format, c.pFormatProperties)
		if formatProperties != nil {
			formatProperties.fromC(c.pFormatProperties)
		}
	}
}

type PFNGetPhysicalDeviceImageFormatProperties2KHR C.PFN_vkGetPhysicalDeviceImageFormatProperties2KHR
type FuncGetPhysicalDeviceImageFormatProperties2KHR func(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2, imageFormatProperties *ImageFormatProperties2) (_ret Result)

func ToGetPhysicalDeviceImageFormatProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceImageFormatProperties2KHR) {
	return func(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2, imageFormatProperties *ImageFormatProperties2) (_ret Result) {
		var c struct {
			physicalDevice         C.VkPhysicalDevice
			pImageFormatInfo       *C.VkPhysicalDeviceImageFormatInfo2
			pImageFormatProperties *C.VkImageFormatProperties2
			_ret                   C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if imageFormatInfo != nil {
			c.pImageFormatInfo = (*C.VkPhysicalDeviceImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceImageFormatInfo2))
			imageFormatInfo.toC(c.pImageFormatInfo, m)
		} else {
			c.pImageFormatInfo = nil
		}
		if imageFormatProperties != nil {
			c.pImageFormatProperties = (*C.VkImageFormatProperties2)(m.alloc(C.sizeof_VkImageFormatProperties2))
			imageFormatProperties.toC(c.pImageFormatProperties, m)
		} else {
			c.pImageFormatProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceImageFormatProperties2KHR(C.PFN_vkGetPhysicalDeviceImageFormatProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pImageFormatInfo, c.pImageFormatProperties)
		_ret = Result(c._ret)
		if imageFormatProperties != nil {
			imageFormatProperties.fromC(c.pImageFormatProperties)
		}
		return
	}
}

type PFNGetPhysicalDeviceQueueFamilyProperties2KHR C.PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR
type FuncGetPhysicalDeviceQueueFamilyProperties2KHR func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties2)

func ToGetPhysicalDeviceQueueFamilyProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceQueueFamilyProperties2KHR) {
	return func(physicalDevice PhysicalDevice, queueFamilyPropertyCount *uint32, queueFamilyProperties []QueueFamilyProperties2) {
		var c struct {
			physicalDevice            C.VkPhysicalDevice
			pQueueFamilyPropertyCount *C.uint32_t
			pQueueFamilyProperties    *C.VkQueueFamilyProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if queueFamilyPropertyCount != nil {
			c.pQueueFamilyPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pQueueFamilyPropertyCount = C.uint32_t(*queueFamilyPropertyCount)
		} else {
			c.pQueueFamilyPropertyCount = nil
		}
		if len(queueFamilyProperties) != 0 {
			c.pQueueFamilyProperties = (*C.VkQueueFamilyProperties2)(m.alloc(C.sizeof_VkQueueFamilyProperties2 * uint(len(queueFamilyProperties))))
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pQueueFamilyProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR(C.PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pQueueFamilyPropertyCount, c.pQueueFamilyProperties)
		if queueFamilyPropertyCount != nil {
			*queueFamilyPropertyCount = uint32(*c.pQueueFamilyPropertyCount)
		}
		if len(queueFamilyProperties) != 0 {
			slice1 := (*[1 << 31]C.VkQueueFamilyProperties2)(unsafe.Pointer(c.pQueueFamilyProperties))[:len(queueFamilyProperties):len(queueFamilyProperties)]
			for i1, _ := range queueFamilyProperties {
				queueFamilyProperties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetPhysicalDeviceMemoryProperties2KHR C.PFN_vkGetPhysicalDeviceMemoryProperties2KHR
type FuncGetPhysicalDeviceMemoryProperties2KHR func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties2)

func ToGetPhysicalDeviceMemoryProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceMemoryProperties2KHR) {
	return func(physicalDevice PhysicalDevice, memoryProperties *PhysicalDeviceMemoryProperties2) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			pMemoryProperties *C.VkPhysicalDeviceMemoryProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if memoryProperties != nil {
			c.pMemoryProperties = (*C.VkPhysicalDeviceMemoryProperties2)(m.alloc(C.sizeof_VkPhysicalDeviceMemoryProperties2))
			memoryProperties.toC(c.pMemoryProperties, m)
		} else {
			c.pMemoryProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceMemoryProperties2KHR(C.PFN_vkGetPhysicalDeviceMemoryProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pMemoryProperties)
		if memoryProperties != nil {
			memoryProperties.fromC(c.pMemoryProperties)
		}
	}
}

type PFNGetPhysicalDeviceSparseImageFormatProperties2KHR C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR
type FuncGetPhysicalDeviceSparseImageFormatProperties2KHR func(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2, propertyCount *uint32, properties []SparseImageFormatProperties2)

func ToGetPhysicalDeviceSparseImageFormatProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSparseImageFormatProperties2KHR) {
	return func(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2, propertyCount *uint32, properties []SparseImageFormatProperties2) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFormatInfo    *C.VkPhysicalDeviceSparseImageFormatInfo2
			pPropertyCount *C.uint32_t
			pProperties    *C.VkSparseImageFormatProperties2
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if formatInfo != nil {
			c.pFormatInfo = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(m.alloc(C.sizeof_VkPhysicalDeviceSparseImageFormatInfo2))
			formatInfo.toC(c.pFormatInfo, m)
		} else {
			c.pFormatInfo = nil
		}
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkSparseImageFormatProperties2)(m.alloc(C.sizeof_VkSparseImageFormatProperties2 * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pFormatInfo, c.pPropertyCount, c.pProperties)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageFormatProperties2)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNGetDeviceGroupPeerMemoryFeaturesKHR C.PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR
type FuncGetDeviceGroupPeerMemoryFeaturesKHR func(device Device, heapIndex uint32, localDeviceIndex uint32, peerMemoryFeatures []PeerMemoryFeatureFlags)

func ToGetDeviceGroupPeerMemoryFeaturesKHR(p PFNVoidFunction) (fn FuncGetDeviceGroupPeerMemoryFeaturesKHR) {
	return func(device Device, heapIndex uint32, localDeviceIndex uint32, peerMemoryFeatures []PeerMemoryFeatureFlags) {
		var c struct {
			device              C.VkDevice
			heapIndex           C.uint32_t
			localDeviceIndex    C.uint32_t
			remoteDeviceIndex   C.uint32_t
			pPeerMemoryFeatures *C.VkPeerMemoryFeatureFlags
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.heapIndex = C.uint32_t(heapIndex)
		c.localDeviceIndex = C.uint32_t(localDeviceIndex)
		c.remoteDeviceIndex = C.uint32_t(len(peerMemoryFeatures))
		if len(peerMemoryFeatures) != 0 {
			c.pPeerMemoryFeatures = (*C.VkPeerMemoryFeatureFlags)(m.alloc(C.sizeof_VkPeerMemoryFeatureFlags * uint(len(peerMemoryFeatures))))
			slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
			for i1, _ := range peerMemoryFeatures {
				{
					var temp_in_VkPeerMemoryFeatureFlags C.VkFlags
					{
						var temp_in_VkFlags C.uint32_t
						temp_in_VkFlags = C.uint32_t((uint32)((Flags)(peerMemoryFeatures[i1])))
						temp_in_VkPeerMemoryFeatureFlags = C.VkFlags(temp_in_VkFlags)
					}
					slice1[i1] = C.VkPeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
				}
			}
		} else {
			c.pPeerMemoryFeatures = nil
		}
		C.callPFN_vkGetDeviceGroupPeerMemoryFeaturesKHR(C.PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR(unsafe.Pointer(p)), c.device, c.heapIndex, c.localDeviceIndex, c.remoteDeviceIndex, c.pPeerMemoryFeatures)
		if len(peerMemoryFeatures) != 0 {
			slice1 := (*[1 << 31]C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(c.pPeerMemoryFeatures))[:len(peerMemoryFeatures):len(peerMemoryFeatures)]
			for i1, _ := range peerMemoryFeatures {
				{
					var temp_in_VkPeerMemoryFeatureFlags Flags
					{
						var temp_in_VkFlags uint32
						temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(slice1[i1])))
						temp_in_VkPeerMemoryFeatureFlags = Flags(temp_in_VkFlags)
					}
					peerMemoryFeatures[i1] = PeerMemoryFeatureFlags(temp_in_VkPeerMemoryFeatureFlags)
				}
			}
		}
	}
}

type PFNCmdSetDeviceMaskKHR C.PFN_vkCmdSetDeviceMaskKHR
type FuncCmdSetDeviceMaskKHR func(commandBuffer CommandBuffer, deviceMask uint32)

func ToCmdSetDeviceMaskKHR(p PFNVoidFunction) (fn FuncCmdSetDeviceMaskKHR) {
	return func(commandBuffer CommandBuffer, deviceMask uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			deviceMask    C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.deviceMask = C.uint32_t(deviceMask)
		C.callPFN_vkCmdSetDeviceMaskKHR(C.PFN_vkCmdSetDeviceMaskKHR(unsafe.Pointer(p)), c.commandBuffer, c.deviceMask)
	}
}

type PFNCmdDispatchBaseKHR C.PFN_vkCmdDispatchBaseKHR
type FuncCmdDispatchBaseKHR func(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32)

func ToCmdDispatchBaseKHR(p PFNVoidFunction) (fn FuncCmdDispatchBaseKHR) {
	return func(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			baseGroupX    C.uint32_t
			baseGroupY    C.uint32_t
			baseGroupZ    C.uint32_t
			groupCountX   C.uint32_t
			groupCountY   C.uint32_t
			groupCountZ   C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.baseGroupX = C.uint32_t(baseGroupX)
		c.baseGroupY = C.uint32_t(baseGroupY)
		c.baseGroupZ = C.uint32_t(baseGroupZ)
		c.groupCountX = C.uint32_t(groupCountX)
		c.groupCountY = C.uint32_t(groupCountY)
		c.groupCountZ = C.uint32_t(groupCountZ)
		C.callPFN_vkCmdDispatchBaseKHR(C.PFN_vkCmdDispatchBaseKHR(unsafe.Pointer(p)), c.commandBuffer, c.baseGroupX, c.baseGroupY, c.baseGroupZ, c.groupCountX, c.groupCountY, c.groupCountZ)
	}
}

type PFNTrimCommandPoolKHR C.PFN_vkTrimCommandPoolKHR
type FuncTrimCommandPoolKHR func(device Device, commandPool CommandPool, flags CommandPoolTrimFlags)

func ToTrimCommandPoolKHR(p PFNVoidFunction) (fn FuncTrimCommandPoolKHR) {
	return func(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {
		var c struct {
			device      C.VkDevice
			commandPool C.VkCommandPool
			flags       C.VkCommandPoolTrimFlags
		}
		c.device = C.VkDevice(device)
		c.commandPool = C.VkCommandPool(commandPool)
		{
			var temp_in_VkCommandPoolTrimFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkCommandPoolTrimFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkCommandPoolTrimFlags(temp_in_VkCommandPoolTrimFlags)
		}
		C.callPFN_vkTrimCommandPoolKHR(C.PFN_vkTrimCommandPoolKHR(unsafe.Pointer(p)), c.device, c.commandPool, c.flags)
	}
}

type PFNEnumeratePhysicalDeviceGroupsKHR C.PFN_vkEnumeratePhysicalDeviceGroupsKHR
type FuncEnumeratePhysicalDeviceGroupsKHR func(instance Instance, physicalDeviceGroupCount *uint32, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) (_ret Result)

func ToEnumeratePhysicalDeviceGroupsKHR(p PFNVoidFunction) (fn FuncEnumeratePhysicalDeviceGroupsKHR) {
	return func(instance Instance, physicalDeviceGroupCount *uint32, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) (_ret Result) {
		var c struct {
			instance                       C.VkInstance
			pPhysicalDeviceGroupCount      *C.uint32_t
			pPhysicalDeviceGroupProperties *C.VkPhysicalDeviceGroupProperties
			_ret                           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if physicalDeviceGroupCount != nil {
			c.pPhysicalDeviceGroupCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPhysicalDeviceGroupCount = C.uint32_t(*physicalDeviceGroupCount)
		} else {
			c.pPhysicalDeviceGroupCount = nil
		}
		if len(physicalDeviceGroupProperties) != 0 {
			c.pPhysicalDeviceGroupProperties = (*C.VkPhysicalDeviceGroupProperties)(m.alloc(C.sizeof_VkPhysicalDeviceGroupProperties * uint(len(physicalDeviceGroupProperties))))
			slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
			for i1, _ := range physicalDeviceGroupProperties {
				physicalDeviceGroupProperties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pPhysicalDeviceGroupProperties = nil
		}
		c._ret = C.callPFN_vkEnumeratePhysicalDeviceGroupsKHR(C.PFN_vkEnumeratePhysicalDeviceGroupsKHR(unsafe.Pointer(p)), c.instance, c.pPhysicalDeviceGroupCount, c.pPhysicalDeviceGroupProperties)
		_ret = Result(c._ret)
		if physicalDeviceGroupCount != nil {
			*physicalDeviceGroupCount = uint32(*c.pPhysicalDeviceGroupCount)
		}
		if len(physicalDeviceGroupProperties) != 0 {
			slice1 := (*[1 << 31]C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(c.pPhysicalDeviceGroupProperties))[:len(physicalDeviceGroupProperties):len(physicalDeviceGroupProperties)]
			for i1, _ := range physicalDeviceGroupProperties {
				physicalDeviceGroupProperties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceExternalBufferPropertiesKHR C.PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR
type FuncGetPhysicalDeviceExternalBufferPropertiesKHR func(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo, externalBufferProperties *ExternalBufferProperties)

func ToGetPhysicalDeviceExternalBufferPropertiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalBufferPropertiesKHR) {
	return func(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo, externalBufferProperties *ExternalBufferProperties) {
		var c struct {
			physicalDevice            C.VkPhysicalDevice
			pExternalBufferInfo       *C.VkPhysicalDeviceExternalBufferInfo
			pExternalBufferProperties *C.VkExternalBufferProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalBufferInfo != nil {
			c.pExternalBufferInfo = (*C.VkPhysicalDeviceExternalBufferInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalBufferInfo))
			externalBufferInfo.toC(c.pExternalBufferInfo, m)
		} else {
			c.pExternalBufferInfo = nil
		}
		if externalBufferProperties != nil {
			c.pExternalBufferProperties = (*C.VkExternalBufferProperties)(m.alloc(C.sizeof_VkExternalBufferProperties))
			externalBufferProperties.toC(c.pExternalBufferProperties, m)
		} else {
			c.pExternalBufferProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR(C.PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.pExternalBufferInfo, c.pExternalBufferProperties)
		if externalBufferProperties != nil {
			externalBufferProperties.fromC(c.pExternalBufferProperties)
		}
	}
}

type PFNGetMemoryFdKHR C.PFN_vkGetMemoryFdKHR
type MemoryGetFdInfoKHR struct {
	Next       Structure
	Memory     DeviceMemory
	HandleType ExternalMemoryHandleTypeFlagBits
}

func (g *MemoryGetFdInfoKHR) toC(c *C.VkMemoryGetFdInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.memory = C.VkDeviceMemory(g.Memory)
	c.handleType = C.VkExternalMemoryHandleTypeFlagBits(g.HandleType)
}
func (g *MemoryGetFdInfoKHR) fromC(c *C.VkMemoryGetFdInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Memory = DeviceMemory(c.memory)
	g.HandleType = ExternalMemoryHandleTypeFlagBits(c.handleType)
}
func (s *MemoryGetFdInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
}
func (s *MemoryGetFdInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryGetFdInfoKHR)(m.alloc(C.sizeof_VkMemoryGetFdInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryGetFdInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryGetFdInfoKHR)(p)
	s.fromC(c)
}
func (s *MemoryGetFdInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *MemoryGetFdInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetMemoryFdKHR func(device Device, getFdInfo *MemoryGetFdInfoKHR, fd *int32) (_ret Result)

func ToGetMemoryFdKHR(p PFNVoidFunction) (fn FuncGetMemoryFdKHR) {
	return func(device Device, getFdInfo *MemoryGetFdInfoKHR, fd *int32) (_ret Result) {
		var c struct {
			device     C.VkDevice
			pGetFdInfo *C.VkMemoryGetFdInfoKHR
			pFd        *C.int
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if getFdInfo != nil {
			c.pGetFdInfo = (*C.VkMemoryGetFdInfoKHR)(m.alloc(C.sizeof_VkMemoryGetFdInfoKHR))
			getFdInfo.toC(c.pGetFdInfo, m)
		} else {
			c.pGetFdInfo = nil
		}
		if fd != nil {
			c.pFd = (*C.int)(m.alloc(C.sizeof_int))
			*c.pFd = C.int(*fd)
		} else {
			c.pFd = nil
		}
		c._ret = C.callPFN_vkGetMemoryFdKHR(C.PFN_vkGetMemoryFdKHR(unsafe.Pointer(p)), c.device, c.pGetFdInfo, c.pFd)
		_ret = Result(c._ret)
		if fd != nil {
			*fd = int32(*c.pFd)
		}
		return
	}
}

type PFNGetMemoryFdPropertiesKHR C.PFN_vkGetMemoryFdPropertiesKHR
type MemoryFdPropertiesKHR struct {
	Next           Structure
	MemoryTypeBits uint32
}

func (g *MemoryFdPropertiesKHR) toC(c *C.VkMemoryFdPropertiesKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.memoryTypeBits = C.uint32_t(g.MemoryTypeBits)
}
func (g *MemoryFdPropertiesKHR) fromC(c *C.VkMemoryFdPropertiesKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MemoryTypeBits = uint32(c.memoryTypeBits)
}
func (s *MemoryFdPropertiesKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
}
func (s *MemoryFdPropertiesKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryFdPropertiesKHR)(m.alloc(C.sizeof_VkMemoryFdPropertiesKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryFdPropertiesKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryFdPropertiesKHR)(p)
	s.fromC(c)
}
func (s *MemoryFdPropertiesKHR) GetNext() Structure {
	return s.Next
}
func (s *MemoryFdPropertiesKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetMemoryFdPropertiesKHR func(device Device, handleType ExternalMemoryHandleTypeFlagBits, fd int32, memoryFdProperties *MemoryFdPropertiesKHR) (_ret Result)

func ToGetMemoryFdPropertiesKHR(p PFNVoidFunction) (fn FuncGetMemoryFdPropertiesKHR) {
	return func(device Device, handleType ExternalMemoryHandleTypeFlagBits, fd int32, memoryFdProperties *MemoryFdPropertiesKHR) (_ret Result) {
		var c struct {
			device              C.VkDevice
			handleType          C.VkExternalMemoryHandleTypeFlagBits
			fd                  C.int
			pMemoryFdProperties *C.VkMemoryFdPropertiesKHR
			_ret                C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.handleType = C.VkExternalMemoryHandleTypeFlagBits(handleType)
		c.fd = C.int(fd)
		if memoryFdProperties != nil {
			c.pMemoryFdProperties = (*C.VkMemoryFdPropertiesKHR)(m.alloc(C.sizeof_VkMemoryFdPropertiesKHR))
			memoryFdProperties.toC(c.pMemoryFdProperties, m)
		} else {
			c.pMemoryFdProperties = nil
		}
		c._ret = C.callPFN_vkGetMemoryFdPropertiesKHR(C.PFN_vkGetMemoryFdPropertiesKHR(unsafe.Pointer(p)), c.device, c.handleType, c.fd, c.pMemoryFdProperties)
		_ret = Result(c._ret)
		if memoryFdProperties != nil {
			memoryFdProperties.fromC(c.pMemoryFdProperties)
		}
		return
	}
}

type PFNGetPhysicalDeviceExternalSemaphorePropertiesKHR C.PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
type FuncGetPhysicalDeviceExternalSemaphorePropertiesKHR func(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, externalSemaphoreProperties *ExternalSemaphoreProperties)

func ToGetPhysicalDeviceExternalSemaphorePropertiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalSemaphorePropertiesKHR) {
	return func(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, externalSemaphoreProperties *ExternalSemaphoreProperties) {
		var c struct {
			physicalDevice               C.VkPhysicalDevice
			pExternalSemaphoreInfo       *C.VkPhysicalDeviceExternalSemaphoreInfo
			pExternalSemaphoreProperties *C.VkExternalSemaphoreProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalSemaphoreInfo != nil {
			c.pExternalSemaphoreInfo = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalSemaphoreInfo))
			externalSemaphoreInfo.toC(c.pExternalSemaphoreInfo, m)
		} else {
			c.pExternalSemaphoreInfo = nil
		}
		if externalSemaphoreProperties != nil {
			c.pExternalSemaphoreProperties = (*C.VkExternalSemaphoreProperties)(m.alloc(C.sizeof_VkExternalSemaphoreProperties))
			externalSemaphoreProperties.toC(c.pExternalSemaphoreProperties, m)
		} else {
			c.pExternalSemaphoreProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(C.PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.pExternalSemaphoreInfo, c.pExternalSemaphoreProperties)
		if externalSemaphoreProperties != nil {
			externalSemaphoreProperties.fromC(c.pExternalSemaphoreProperties)
		}
	}
}

type PFNImportSemaphoreFdKHR C.PFN_vkImportSemaphoreFdKHR
type SemaphoreImportFlags Flags
type ImportSemaphoreFdInfoKHR struct {
	Next       Structure
	Semaphore  Semaphore
	Flags      SemaphoreImportFlags
	HandleType ExternalSemaphoreHandleTypeFlagBits
	Fd         int32
}

func (g *ImportSemaphoreFdInfoKHR) toC(c *C.VkImportSemaphoreFdInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.semaphore = C.VkSemaphore(g.Semaphore)
	{
		var temp_in_VkSemaphoreImportFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSemaphoreImportFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSemaphoreImportFlags(temp_in_VkSemaphoreImportFlags)
	}
	c.handleType = C.VkExternalSemaphoreHandleTypeFlagBits(g.HandleType)
	c.fd = C.int(g.Fd)
}
func (g *ImportSemaphoreFdInfoKHR) fromC(c *C.VkImportSemaphoreFdInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Semaphore = Semaphore(c.semaphore)
	{
		var temp_in_VkSemaphoreImportFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSemaphoreImportFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SemaphoreImportFlags(temp_in_VkSemaphoreImportFlags)
	}
	g.HandleType = ExternalSemaphoreHandleTypeFlagBits(c.handleType)
	g.Fd = int32(c.fd)
}
func (s *ImportSemaphoreFdInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
}
func (s *ImportSemaphoreFdInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImportSemaphoreFdInfoKHR)(m.alloc(C.sizeof_VkImportSemaphoreFdInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImportSemaphoreFdInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImportSemaphoreFdInfoKHR)(p)
	s.fromC(c)
}
func (s *ImportSemaphoreFdInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *ImportSemaphoreFdInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncImportSemaphoreFdKHR func(device Device, importSemaphoreFdInfo *ImportSemaphoreFdInfoKHR) (_ret Result)

func ToImportSemaphoreFdKHR(p PFNVoidFunction) (fn FuncImportSemaphoreFdKHR) {
	return func(device Device, importSemaphoreFdInfo *ImportSemaphoreFdInfoKHR) (_ret Result) {
		var c struct {
			device                 C.VkDevice
			pImportSemaphoreFdInfo *C.VkImportSemaphoreFdInfoKHR
			_ret                   C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if importSemaphoreFdInfo != nil {
			c.pImportSemaphoreFdInfo = (*C.VkImportSemaphoreFdInfoKHR)(m.alloc(C.sizeof_VkImportSemaphoreFdInfoKHR))
			importSemaphoreFdInfo.toC(c.pImportSemaphoreFdInfo, m)
		} else {
			c.pImportSemaphoreFdInfo = nil
		}
		c._ret = C.callPFN_vkImportSemaphoreFdKHR(C.PFN_vkImportSemaphoreFdKHR(unsafe.Pointer(p)), c.device, c.pImportSemaphoreFdInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetSemaphoreFdKHR C.PFN_vkGetSemaphoreFdKHR
type SemaphoreGetFdInfoKHR struct {
	Next       Structure
	Semaphore  Semaphore
	HandleType ExternalSemaphoreHandleTypeFlagBits
}

func (g *SemaphoreGetFdInfoKHR) toC(c *C.VkSemaphoreGetFdInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.semaphore = C.VkSemaphore(g.Semaphore)
	c.handleType = C.VkExternalSemaphoreHandleTypeFlagBits(g.HandleType)
}
func (g *SemaphoreGetFdInfoKHR) fromC(c *C.VkSemaphoreGetFdInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Semaphore = Semaphore(c.semaphore)
	g.HandleType = ExternalSemaphoreHandleTypeFlagBits(c.handleType)
}
func (s *SemaphoreGetFdInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
}
func (s *SemaphoreGetFdInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSemaphoreGetFdInfoKHR)(m.alloc(C.sizeof_VkSemaphoreGetFdInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SemaphoreGetFdInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSemaphoreGetFdInfoKHR)(p)
	s.fromC(c)
}
func (s *SemaphoreGetFdInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *SemaphoreGetFdInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetSemaphoreFdKHR func(device Device, getFdInfo *SemaphoreGetFdInfoKHR, fd *int32) (_ret Result)

func ToGetSemaphoreFdKHR(p PFNVoidFunction) (fn FuncGetSemaphoreFdKHR) {
	return func(device Device, getFdInfo *SemaphoreGetFdInfoKHR, fd *int32) (_ret Result) {
		var c struct {
			device     C.VkDevice
			pGetFdInfo *C.VkSemaphoreGetFdInfoKHR
			pFd        *C.int
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if getFdInfo != nil {
			c.pGetFdInfo = (*C.VkSemaphoreGetFdInfoKHR)(m.alloc(C.sizeof_VkSemaphoreGetFdInfoKHR))
			getFdInfo.toC(c.pGetFdInfo, m)
		} else {
			c.pGetFdInfo = nil
		}
		if fd != nil {
			c.pFd = (*C.int)(m.alloc(C.sizeof_int))
			*c.pFd = C.int(*fd)
		} else {
			c.pFd = nil
		}
		c._ret = C.callPFN_vkGetSemaphoreFdKHR(C.PFN_vkGetSemaphoreFdKHR(unsafe.Pointer(p)), c.device, c.pGetFdInfo, c.pFd)
		_ret = Result(c._ret)
		if fd != nil {
			*fd = int32(*c.pFd)
		}
		return
	}
}

type PFNCmdPushDescriptorSetKHR C.PFN_vkCmdPushDescriptorSetKHR
type FuncCmdPushDescriptorSetKHR func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32, descriptorWrites []WriteDescriptorSet)

func ToCmdPushDescriptorSetKHR(p PFNVoidFunction) (fn FuncCmdPushDescriptorSetKHR) {
	return func(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32, descriptorWrites []WriteDescriptorSet) {
		var c struct {
			commandBuffer        C.VkCommandBuffer
			pipelineBindPoint    C.VkPipelineBindPoint
			layout               C.VkPipelineLayout
			set                  C.uint32_t
			descriptorWriteCount C.uint32_t
			pDescriptorWrites    *C.VkWriteDescriptorSet
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pipelineBindPoint = C.VkPipelineBindPoint(pipelineBindPoint)
		c.layout = C.VkPipelineLayout(layout)
		c.set = C.uint32_t(set)
		c.descriptorWriteCount = C.uint32_t(len(descriptorWrites))
		if len(descriptorWrites) != 0 {
			c.pDescriptorWrites = (*C.VkWriteDescriptorSet)(m.alloc(C.sizeof_VkWriteDescriptorSet * uint(len(descriptorWrites))))
			slice1 := (*[1 << 31]C.VkWriteDescriptorSet)(unsafe.Pointer(c.pDescriptorWrites))[:len(descriptorWrites):len(descriptorWrites)]
			for i1, _ := range descriptorWrites {
				descriptorWrites[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pDescriptorWrites = nil
		}
		C.callPFN_vkCmdPushDescriptorSetKHR(C.PFN_vkCmdPushDescriptorSetKHR(unsafe.Pointer(p)), c.commandBuffer, c.pipelineBindPoint, c.layout, c.set, c.descriptorWriteCount, c.pDescriptorWrites)
	}
}

type PFNCmdPushDescriptorSetWithTemplateKHR C.PFN_vkCmdPushDescriptorSetWithTemplateKHR
type FuncCmdPushDescriptorSetWithTemplateKHR func(commandBuffer CommandBuffer, descriptorUpdateTemplate DescriptorUpdateTemplate, layout PipelineLayout, data []byte)

func ToCmdPushDescriptorSetWithTemplateKHR(p PFNVoidFunction) (fn FuncCmdPushDescriptorSetWithTemplateKHR) {
	return func(commandBuffer CommandBuffer, descriptorUpdateTemplate DescriptorUpdateTemplate, layout PipelineLayout, data []byte) {
		var c struct {
			commandBuffer            C.VkCommandBuffer
			descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
			layout                   C.VkPipelineLayout
			set                      C.uint32_t
			pData                    unsafe.Pointer
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
		c.layout = C.VkPipelineLayout(layout)
		c.set = C.uint32_t(len(data))
		if len(data) != 0 {
			c.pData = m.alloc(C.sizeof_char * uint(len(data)))
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				slice1[i1] = data[i1]
			}
		} else {
			c.pData = nil
		}
		C.callPFN_vkCmdPushDescriptorSetWithTemplateKHR(C.PFN_vkCmdPushDescriptorSetWithTemplateKHR(unsafe.Pointer(p)), c.commandBuffer, c.descriptorUpdateTemplate, c.layout, c.set, c.pData)
	}
}

type PFNCreateDescriptorUpdateTemplateKHR C.PFN_vkCreateDescriptorUpdateTemplateKHR
type FuncCreateDescriptorUpdateTemplateKHR func(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks, descriptorUpdateTemplate *DescriptorUpdateTemplate) (_ret Result)

func ToCreateDescriptorUpdateTemplateKHR(p PFNVoidFunction) (fn FuncCreateDescriptorUpdateTemplateKHR) {
	return func(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks, descriptorUpdateTemplate *DescriptorUpdateTemplate) (_ret Result) {
		var c struct {
			device                    C.VkDevice
			pCreateInfo               *C.VkDescriptorUpdateTemplateCreateInfo
			pAllocator                *C.VkAllocationCallbacks
			pDescriptorUpdateTemplate *C.VkDescriptorUpdateTemplate
			_ret                      C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorUpdateTemplateCreateInfo)(m.alloc(C.sizeof_VkDescriptorUpdateTemplateCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if descriptorUpdateTemplate != nil {
			c.pDescriptorUpdateTemplate = (*C.VkDescriptorUpdateTemplate)(m.alloc(C.sizeof_VkDescriptorUpdateTemplate))
			*c.pDescriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(*descriptorUpdateTemplate)
		} else {
			c.pDescriptorUpdateTemplate = nil
		}
		c._ret = C.callPFN_vkCreateDescriptorUpdateTemplateKHR(C.PFN_vkCreateDescriptorUpdateTemplateKHR(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pDescriptorUpdateTemplate)
		_ret = Result(c._ret)
		if descriptorUpdateTemplate != nil {
			*descriptorUpdateTemplate = DescriptorUpdateTemplate(*c.pDescriptorUpdateTemplate)
		}
		return
	}
}

type PFNDestroyDescriptorUpdateTemplateKHR C.PFN_vkDestroyDescriptorUpdateTemplateKHR
type FuncDestroyDescriptorUpdateTemplateKHR func(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks)

func ToDestroyDescriptorUpdateTemplateKHR(p PFNVoidFunction) (fn FuncDestroyDescriptorUpdateTemplateKHR) {
	return func(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
		var c struct {
			device                   C.VkDevice
			descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
			pAllocator               *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDescriptorUpdateTemplateKHR(C.PFN_vkDestroyDescriptorUpdateTemplateKHR(unsafe.Pointer(p)), c.device, c.descriptorUpdateTemplate, c.pAllocator)
	}
}

type PFNUpdateDescriptorSetWithTemplateKHR C.PFN_vkUpdateDescriptorSetWithTemplateKHR
type FuncUpdateDescriptorSetWithTemplateKHR func(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data unsafe.Pointer)

func ToUpdateDescriptorSetWithTemplateKHR(p PFNVoidFunction) (fn FuncUpdateDescriptorSetWithTemplateKHR) {
	return func(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data unsafe.Pointer) {
		var c struct {
			device                   C.VkDevice
			descriptorSet            C.VkDescriptorSet
			descriptorUpdateTemplate C.VkDescriptorUpdateTemplate
			pData                    unsafe.Pointer
		}
		c.device = C.VkDevice(device)
		c.descriptorSet = C.VkDescriptorSet(descriptorSet)
		c.descriptorUpdateTemplate = C.VkDescriptorUpdateTemplate(descriptorUpdateTemplate)
		c.pData = data
		C.callPFN_vkUpdateDescriptorSetWithTemplateKHR(C.PFN_vkUpdateDescriptorSetWithTemplateKHR(unsafe.Pointer(p)), c.device, c.descriptorSet, c.descriptorUpdateTemplate, c.pData)
	}
}

type PFNCreateRenderPass2KHR C.PFN_vkCreateRenderPass2KHR
type AttachmentDescription2KHR struct {
	Next           Structure
	Flags          AttachmentDescriptionFlags
	Format         Format
	Samples        SampleCountFlagBits
	LoadOp         AttachmentLoadOp
	StoreOp        AttachmentStoreOp
	StencilLoadOp  AttachmentLoadOp
	StencilStoreOp AttachmentStoreOp
	InitialLayout  ImageLayout
	FinalLayout    ImageLayout
}

func (g *AttachmentDescription2KHR) toC(c *C.VkAttachmentDescription2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkAttachmentDescriptionFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkAttachmentDescriptionFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkAttachmentDescriptionFlags(temp_in_VkAttachmentDescriptionFlags)
	}
	c.format = C.VkFormat(g.Format)
	c.samples = C.VkSampleCountFlagBits(g.Samples)
	c.loadOp = C.VkAttachmentLoadOp(g.LoadOp)
	c.storeOp = C.VkAttachmentStoreOp(g.StoreOp)
	c.stencilLoadOp = C.VkAttachmentLoadOp(g.StencilLoadOp)
	c.stencilStoreOp = C.VkAttachmentStoreOp(g.StencilStoreOp)
	c.initialLayout = C.VkImageLayout(g.InitialLayout)
	c.finalLayout = C.VkImageLayout(g.FinalLayout)
}
func (g *AttachmentDescription2KHR) fromC(c *C.VkAttachmentDescription2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkAttachmentDescriptionFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkAttachmentDescriptionFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = AttachmentDescriptionFlags(temp_in_VkAttachmentDescriptionFlags)
	}
	g.Format = Format(c.format)
	g.Samples = SampleCountFlagBits(c.samples)
	g.LoadOp = AttachmentLoadOp(c.loadOp)
	g.StoreOp = AttachmentStoreOp(c.storeOp)
	g.StencilLoadOp = AttachmentLoadOp(c.stencilLoadOp)
	g.StencilStoreOp = AttachmentStoreOp(c.stencilStoreOp)
	g.InitialLayout = ImageLayout(c.initialLayout)
	g.FinalLayout = ImageLayout(c.finalLayout)
}
func (s *AttachmentDescription2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
}
func (s *AttachmentDescription2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkAttachmentDescription2KHR)(m.alloc(C.sizeof_VkAttachmentDescription2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *AttachmentDescription2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkAttachmentDescription2KHR)(p)
	s.fromC(c)
}
func (s *AttachmentDescription2KHR) GetNext() Structure {
	return s.Next
}
func (s *AttachmentDescription2KHR) SetNext(n Structure) {
	s.Next = n
}

type AttachmentReference2KHR struct {
	Next       Structure
	Attachment uint32
	Layout     ImageLayout
	AspectMask ImageAspectFlags
}

func (g *AttachmentReference2KHR) toC(c *C.VkAttachmentReference2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.attachment = C.uint32_t(g.Attachment)
	c.layout = C.VkImageLayout(g.Layout)
	{
		var temp_in_VkImageAspectFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.AspectMask)))
			temp_in_VkImageAspectFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.aspectMask = C.VkImageAspectFlags(temp_in_VkImageAspectFlags)
	}
}
func (g *AttachmentReference2KHR) fromC(c *C.VkAttachmentReference2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Attachment = uint32(c.attachment)
	g.Layout = ImageLayout(c.layout)
	{
		var temp_in_VkImageAspectFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.aspectMask)))
			temp_in_VkImageAspectFlags = Flags(temp_in_VkFlags)
		}
		g.AspectMask = ImageAspectFlags(temp_in_VkImageAspectFlags)
	}
}
func (s *AttachmentReference2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
}
func (s *AttachmentReference2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkAttachmentReference2KHR)(m.alloc(C.sizeof_VkAttachmentReference2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *AttachmentReference2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkAttachmentReference2KHR)(p)
	s.fromC(c)
}
func (s *AttachmentReference2KHR) GetNext() Structure {
	return s.Next
}
func (s *AttachmentReference2KHR) SetNext(n Structure) {
	s.Next = n
}

type SubpassDescription2KHR struct {
	Next                   Structure
	Flags                  SubpassDescriptionFlags
	PipelineBindPoint      PipelineBindPoint
	ViewMask               uint32
	InputAttachments       []AttachmentReference2KHR
	ColorAttachments       []AttachmentReference2KHR
	ResolveAttachments     []AttachmentReference2KHR
	DepthStencilAttachment *AttachmentReference2KHR
	PreserveAttachments    []uint32
}

func (g *SubpassDescription2KHR) toC(c *C.VkSubpassDescription2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkSubpassDescriptionFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkSubpassDescriptionFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkSubpassDescriptionFlags(temp_in_VkSubpassDescriptionFlags)
	}
	c.pipelineBindPoint = C.VkPipelineBindPoint(g.PipelineBindPoint)
	c.viewMask = C.uint32_t(g.ViewMask)
	c.inputAttachmentCount = C.uint32_t(len(g.InputAttachments))
	if len(g.InputAttachments) != 0 {
		c.pInputAttachments = (*C.VkAttachmentReference2KHR)(m.alloc(C.sizeof_VkAttachmentReference2KHR * uint(len(g.InputAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pInputAttachments))[:len(g.InputAttachments):len(g.InputAttachments)]
		for i1, _ := range g.InputAttachments {
			g.InputAttachments[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pInputAttachments = nil
	}
	c.colorAttachmentCount = C.uint32_t(len(g.ColorAttachments))
	if len(g.ColorAttachments) != 0 {
		c.pColorAttachments = (*C.VkAttachmentReference2KHR)(m.alloc(C.sizeof_VkAttachmentReference2KHR * uint(len(g.ColorAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pColorAttachments))[:len(g.ColorAttachments):len(g.ColorAttachments)]
		for i1, _ := range g.ColorAttachments {
			g.ColorAttachments[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pColorAttachments = nil
	}
	if len(g.ResolveAttachments) != 0 {
		c.pResolveAttachments = (*C.VkAttachmentReference2KHR)(m.alloc(C.sizeof_VkAttachmentReference2KHR * uint(len(g.ResolveAttachments))))
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pResolveAttachments))[:len(g.ResolveAttachments):len(g.ResolveAttachments)]
		for i1, _ := range g.ResolveAttachments {
			g.ResolveAttachments[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pResolveAttachments = nil
	}
	if g.DepthStencilAttachment != nil {
		c.pDepthStencilAttachment = (*C.VkAttachmentReference2KHR)(m.alloc(C.sizeof_VkAttachmentReference2KHR))
		g.DepthStencilAttachment.toC(c.pDepthStencilAttachment, m)
	} else {
		c.pDepthStencilAttachment = nil
	}
	c.preserveAttachmentCount = C.uint32_t(len(g.PreserveAttachments))
	if len(g.PreserveAttachments) != 0 {
		c.pPreserveAttachments = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.PreserveAttachments))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pPreserveAttachments))[:len(g.PreserveAttachments):len(g.PreserveAttachments)]
		for i1, _ := range g.PreserveAttachments {
			slice1[i1] = C.uint32_t(g.PreserveAttachments[i1])
		}
	} else {
		c.pPreserveAttachments = nil
	}
}
func (g *SubpassDescription2KHR) fromC(c *C.VkSubpassDescription2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkSubpassDescriptionFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkSubpassDescriptionFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = SubpassDescriptionFlags(temp_in_VkSubpassDescriptionFlags)
	}
	g.PipelineBindPoint = PipelineBindPoint(c.pipelineBindPoint)
	g.ViewMask = uint32(c.viewMask)
	g.InputAttachments = make([]AttachmentReference2KHR, int(c.inputAttachmentCount))
	if len(g.InputAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pInputAttachments))[:len(g.InputAttachments):len(g.InputAttachments)]
		for i1, _ := range g.InputAttachments {
			g.InputAttachments[i1].fromC(&slice1[i1])
		}
	}
	g.ColorAttachments = make([]AttachmentReference2KHR, int(c.colorAttachmentCount))
	if len(g.ColorAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pColorAttachments))[:len(g.ColorAttachments):len(g.ColorAttachments)]
		for i1, _ := range g.ColorAttachments {
			g.ColorAttachments[i1].fromC(&slice1[i1])
		}
	}
	if len(g.ResolveAttachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentReference2KHR)(unsafe.Pointer(c.pResolveAttachments))[:len(g.ResolveAttachments):len(g.ResolveAttachments)]
		for i1, _ := range g.ResolveAttachments {
			g.ResolveAttachments[i1].fromC(&slice1[i1])
		}
	}
	if g.DepthStencilAttachment != nil {
		g.DepthStencilAttachment.fromC(c.pDepthStencilAttachment)
	}
	g.PreserveAttachments = make([]uint32, int(c.preserveAttachmentCount))
	if len(g.PreserveAttachments) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pPreserveAttachments))[:len(g.PreserveAttachments):len(g.PreserveAttachments)]
		for i1, _ := range g.PreserveAttachments {
			g.PreserveAttachments[i1] = uint32(slice1[i1])
		}
	}
}
func (s *SubpassDescription2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
}
func (s *SubpassDescription2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSubpassDescription2KHR)(m.alloc(C.sizeof_VkSubpassDescription2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SubpassDescription2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSubpassDescription2KHR)(p)
	s.fromC(c)
}
func (s *SubpassDescription2KHR) GetNext() Structure {
	return s.Next
}
func (s *SubpassDescription2KHR) SetNext(n Structure) {
	s.Next = n
}

type SubpassDependency2KHR struct {
	Next            Structure
	SrcSubpass      uint32
	DstSubpass      uint32
	SrcStageMask    PipelineStageFlags
	DstStageMask    PipelineStageFlags
	SrcAccessMask   AccessFlags
	DstAccessMask   AccessFlags
	DependencyFlags DependencyFlags
	ViewOffset      int32
}

func (g *SubpassDependency2KHR) toC(c *C.VkSubpassDependency2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.srcSubpass = C.uint32_t(g.SrcSubpass)
	c.dstSubpass = C.uint32_t(g.DstSubpass)
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstStageMask)))
			temp_in_VkPipelineStageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstStageMask = C.VkPipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SrcAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.srcAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DstAccessMask)))
			temp_in_VkAccessFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dstAccessMask = C.VkAccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkDependencyFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.DependencyFlags)))
			temp_in_VkDependencyFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.dependencyFlags = C.VkDependencyFlags(temp_in_VkDependencyFlags)
	}
	c.viewOffset = C.int32_t(g.ViewOffset)
}
func (g *SubpassDependency2KHR) fromC(c *C.VkSubpassDependency2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.SrcSubpass = uint32(c.srcSubpass)
	g.DstSubpass = uint32(c.dstSubpass)
	{
		var temp_in_VkPipelineStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcStageMask)))
			temp_in_VkPipelineStageFlags = Flags(temp_in_VkFlags)
		}
		g.SrcStageMask = PipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkPipelineStageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstStageMask)))
			temp_in_VkPipelineStageFlags = Flags(temp_in_VkFlags)
		}
		g.DstStageMask = PipelineStageFlags(temp_in_VkPipelineStageFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.srcAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.SrcAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkAccessFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dstAccessMask)))
			temp_in_VkAccessFlags = Flags(temp_in_VkFlags)
		}
		g.DstAccessMask = AccessFlags(temp_in_VkAccessFlags)
	}
	{
		var temp_in_VkDependencyFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.dependencyFlags)))
			temp_in_VkDependencyFlags = Flags(temp_in_VkFlags)
		}
		g.DependencyFlags = DependencyFlags(temp_in_VkDependencyFlags)
	}
	g.ViewOffset = int32(c.viewOffset)
}
func (s *SubpassDependency2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
}
func (s *SubpassDependency2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSubpassDependency2KHR)(m.alloc(C.sizeof_VkSubpassDependency2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SubpassDependency2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSubpassDependency2KHR)(p)
	s.fromC(c)
}
func (s *SubpassDependency2KHR) GetNext() Structure {
	return s.Next
}
func (s *SubpassDependency2KHR) SetNext(n Structure) {
	s.Next = n
}

type RenderPassCreateInfo2KHR struct {
	Next                Structure
	Flags               RenderPassCreateFlags
	Attachments         []AttachmentDescription2KHR
	Subpasses           []SubpassDescription2KHR
	Dependencies        []SubpassDependency2KHR
	CorrelatedViewMasks []uint32
}

func (g *RenderPassCreateInfo2KHR) toC(c *C.VkRenderPassCreateInfo2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkRenderPassCreateFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkRenderPassCreateFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkRenderPassCreateFlags(temp_in_VkRenderPassCreateFlags)
	}
	c.attachmentCount = C.uint32_t(len(g.Attachments))
	if len(g.Attachments) != 0 {
		c.pAttachments = (*C.VkAttachmentDescription2KHR)(m.alloc(C.sizeof_VkAttachmentDescription2KHR * uint(len(g.Attachments))))
		slice1 := (*[1 << 31]C.VkAttachmentDescription2KHR)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pAttachments = nil
	}
	c.subpassCount = C.uint32_t(len(g.Subpasses))
	if len(g.Subpasses) != 0 {
		c.pSubpasses = (*C.VkSubpassDescription2KHR)(m.alloc(C.sizeof_VkSubpassDescription2KHR * uint(len(g.Subpasses))))
		slice1 := (*[1 << 31]C.VkSubpassDescription2KHR)(unsafe.Pointer(c.pSubpasses))[:len(g.Subpasses):len(g.Subpasses)]
		for i1, _ := range g.Subpasses {
			g.Subpasses[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pSubpasses = nil
	}
	c.dependencyCount = C.uint32_t(len(g.Dependencies))
	if len(g.Dependencies) != 0 {
		c.pDependencies = (*C.VkSubpassDependency2KHR)(m.alloc(C.sizeof_VkSubpassDependency2KHR * uint(len(g.Dependencies))))
		slice1 := (*[1 << 31]C.VkSubpassDependency2KHR)(unsafe.Pointer(c.pDependencies))[:len(g.Dependencies):len(g.Dependencies)]
		for i1, _ := range g.Dependencies {
			g.Dependencies[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pDependencies = nil
	}
	c.correlatedViewMaskCount = C.uint32_t(len(g.CorrelatedViewMasks))
	if len(g.CorrelatedViewMasks) != 0 {
		c.pCorrelatedViewMasks = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.CorrelatedViewMasks))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pCorrelatedViewMasks))[:len(g.CorrelatedViewMasks):len(g.CorrelatedViewMasks)]
		for i1, _ := range g.CorrelatedViewMasks {
			slice1[i1] = C.uint32_t(g.CorrelatedViewMasks[i1])
		}
	} else {
		c.pCorrelatedViewMasks = nil
	}
}
func (g *RenderPassCreateInfo2KHR) fromC(c *C.VkRenderPassCreateInfo2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkRenderPassCreateFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkRenderPassCreateFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = RenderPassCreateFlags(temp_in_VkRenderPassCreateFlags)
	}
	g.Attachments = make([]AttachmentDescription2KHR, int(c.attachmentCount))
	if len(g.Attachments) != 0 {
		slice1 := (*[1 << 31]C.VkAttachmentDescription2KHR)(unsafe.Pointer(c.pAttachments))[:len(g.Attachments):len(g.Attachments)]
		for i1, _ := range g.Attachments {
			g.Attachments[i1].fromC(&slice1[i1])
		}
	}
	g.Subpasses = make([]SubpassDescription2KHR, int(c.subpassCount))
	if len(g.Subpasses) != 0 {
		slice1 := (*[1 << 31]C.VkSubpassDescription2KHR)(unsafe.Pointer(c.pSubpasses))[:len(g.Subpasses):len(g.Subpasses)]
		for i1, _ := range g.Subpasses {
			g.Subpasses[i1].fromC(&slice1[i1])
		}
	}
	g.Dependencies = make([]SubpassDependency2KHR, int(c.dependencyCount))
	if len(g.Dependencies) != 0 {
		slice1 := (*[1 << 31]C.VkSubpassDependency2KHR)(unsafe.Pointer(c.pDependencies))[:len(g.Dependencies):len(g.Dependencies)]
		for i1, _ := range g.Dependencies {
			g.Dependencies[i1].fromC(&slice1[i1])
		}
	}
	g.CorrelatedViewMasks = make([]uint32, int(c.correlatedViewMaskCount))
	if len(g.CorrelatedViewMasks) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pCorrelatedViewMasks))[:len(g.CorrelatedViewMasks):len(g.CorrelatedViewMasks)]
		for i1, _ := range g.CorrelatedViewMasks {
			g.CorrelatedViewMasks[i1] = uint32(slice1[i1])
		}
	}
}
func (s *RenderPassCreateInfo2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
}
func (s *RenderPassCreateInfo2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkRenderPassCreateInfo2KHR)(m.alloc(C.sizeof_VkRenderPassCreateInfo2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *RenderPassCreateInfo2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkRenderPassCreateInfo2KHR)(p)
	s.fromC(c)
}
func (s *RenderPassCreateInfo2KHR) GetNext() Structure {
	return s.Next
}
func (s *RenderPassCreateInfo2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateRenderPass2KHR func(device Device, createInfo *RenderPassCreateInfo2KHR, allocator *AllocationCallbacks, renderPass *RenderPass) (_ret Result)

func ToCreateRenderPass2KHR(p PFNVoidFunction) (fn FuncCreateRenderPass2KHR) {
	return func(device Device, createInfo *RenderPassCreateInfo2KHR, allocator *AllocationCallbacks, renderPass *RenderPass) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkRenderPassCreateInfo2KHR
			pAllocator  *C.VkAllocationCallbacks
			pRenderPass *C.VkRenderPass
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkRenderPassCreateInfo2KHR)(m.alloc(C.sizeof_VkRenderPassCreateInfo2KHR))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if renderPass != nil {
			c.pRenderPass = (*C.VkRenderPass)(m.alloc(C.sizeof_VkRenderPass))
			*c.pRenderPass = C.VkRenderPass(*renderPass)
		} else {
			c.pRenderPass = nil
		}
		c._ret = C.callPFN_vkCreateRenderPass2KHR(C.PFN_vkCreateRenderPass2KHR(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pRenderPass)
		_ret = Result(c._ret)
		if renderPass != nil {
			*renderPass = RenderPass(*c.pRenderPass)
		}
		return
	}
}

type PFNCmdBeginRenderPass2KHR C.PFN_vkCmdBeginRenderPass2KHR
type SubpassBeginInfoKHR struct {
	Next     Structure
	Contents SubpassContents
}

func (g *SubpassBeginInfoKHR) toC(c *C.VkSubpassBeginInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.contents = C.VkSubpassContents(g.Contents)
}
func (g *SubpassBeginInfoKHR) fromC(c *C.VkSubpassBeginInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Contents = SubpassContents(c.contents)
}
func (s *SubpassBeginInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
}
func (s *SubpassBeginInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSubpassBeginInfoKHR)(m.alloc(C.sizeof_VkSubpassBeginInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SubpassBeginInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSubpassBeginInfoKHR)(p)
	s.fromC(c)
}
func (s *SubpassBeginInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *SubpassBeginInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdBeginRenderPass2KHR func(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, subpassBeginInfo *SubpassBeginInfoKHR)

func ToCmdBeginRenderPass2KHR(p PFNVoidFunction) (fn FuncCmdBeginRenderPass2KHR) {
	return func(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, subpassBeginInfo *SubpassBeginInfoKHR) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			pRenderPassBegin  *C.VkRenderPassBeginInfo
			pSubpassBeginInfo *C.VkSubpassBeginInfoKHR
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if renderPassBegin != nil {
			c.pRenderPassBegin = (*C.VkRenderPassBeginInfo)(m.alloc(C.sizeof_VkRenderPassBeginInfo))
			renderPassBegin.toC(c.pRenderPassBegin, m)
		} else {
			c.pRenderPassBegin = nil
		}
		if subpassBeginInfo != nil {
			c.pSubpassBeginInfo = (*C.VkSubpassBeginInfoKHR)(m.alloc(C.sizeof_VkSubpassBeginInfoKHR))
			subpassBeginInfo.toC(c.pSubpassBeginInfo, m)
		} else {
			c.pSubpassBeginInfo = nil
		}
		C.callPFN_vkCmdBeginRenderPass2KHR(C.PFN_vkCmdBeginRenderPass2KHR(unsafe.Pointer(p)), c.commandBuffer, c.pRenderPassBegin, c.pSubpassBeginInfo)
	}
}

type PFNCmdNextSubpass2KHR C.PFN_vkCmdNextSubpass2KHR
type SubpassEndInfoKHR struct{ Next Structure }

func (g *SubpassEndInfoKHR) toC(c *C.VkSubpassEndInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
}
func (g *SubpassEndInfoKHR) fromC(c *C.VkSubpassEndInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
}
func (s *SubpassEndInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
}
func (s *SubpassEndInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSubpassEndInfoKHR)(m.alloc(C.sizeof_VkSubpassEndInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SubpassEndInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSubpassEndInfoKHR)(p)
	s.fromC(c)
}
func (s *SubpassEndInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *SubpassEndInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdNextSubpass2KHR func(commandBuffer CommandBuffer, subpassBeginInfo *SubpassBeginInfoKHR, subpassEndInfo *SubpassEndInfoKHR)

func ToCmdNextSubpass2KHR(p PFNVoidFunction) (fn FuncCmdNextSubpass2KHR) {
	return func(commandBuffer CommandBuffer, subpassBeginInfo *SubpassBeginInfoKHR, subpassEndInfo *SubpassEndInfoKHR) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			pSubpassBeginInfo *C.VkSubpassBeginInfoKHR
			pSubpassEndInfo   *C.VkSubpassEndInfoKHR
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if subpassBeginInfo != nil {
			c.pSubpassBeginInfo = (*C.VkSubpassBeginInfoKHR)(m.alloc(C.sizeof_VkSubpassBeginInfoKHR))
			subpassBeginInfo.toC(c.pSubpassBeginInfo, m)
		} else {
			c.pSubpassBeginInfo = nil
		}
		if subpassEndInfo != nil {
			c.pSubpassEndInfo = (*C.VkSubpassEndInfoKHR)(m.alloc(C.sizeof_VkSubpassEndInfoKHR))
			subpassEndInfo.toC(c.pSubpassEndInfo, m)
		} else {
			c.pSubpassEndInfo = nil
		}
		C.callPFN_vkCmdNextSubpass2KHR(C.PFN_vkCmdNextSubpass2KHR(unsafe.Pointer(p)), c.commandBuffer, c.pSubpassBeginInfo, c.pSubpassEndInfo)
	}
}

type PFNCmdEndRenderPass2KHR C.PFN_vkCmdEndRenderPass2KHR
type FuncCmdEndRenderPass2KHR func(commandBuffer CommandBuffer, subpassEndInfo *SubpassEndInfoKHR)

func ToCmdEndRenderPass2KHR(p PFNVoidFunction) (fn FuncCmdEndRenderPass2KHR) {
	return func(commandBuffer CommandBuffer, subpassEndInfo *SubpassEndInfoKHR) {
		var c struct {
			commandBuffer   C.VkCommandBuffer
			pSubpassEndInfo *C.VkSubpassEndInfoKHR
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if subpassEndInfo != nil {
			c.pSubpassEndInfo = (*C.VkSubpassEndInfoKHR)(m.alloc(C.sizeof_VkSubpassEndInfoKHR))
			subpassEndInfo.toC(c.pSubpassEndInfo, m)
		} else {
			c.pSubpassEndInfo = nil
		}
		C.callPFN_vkCmdEndRenderPass2KHR(C.PFN_vkCmdEndRenderPass2KHR(unsafe.Pointer(p)), c.commandBuffer, c.pSubpassEndInfo)
	}
}

type PFNGetSwapchainStatusKHR C.PFN_vkGetSwapchainStatusKHR
type FuncGetSwapchainStatusKHR func(device Device, swapchain SwapchainKHR) (_ret Result)

func ToGetSwapchainStatusKHR(p PFNVoidFunction) (fn FuncGetSwapchainStatusKHR) {
	return func(device Device, swapchain SwapchainKHR) (_ret Result) {
		var c struct {
			device    C.VkDevice
			swapchain C.VkSwapchainKHR
			_ret      C.VkResult
		}
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		c._ret = C.callPFN_vkGetSwapchainStatusKHR(C.PFN_vkGetSwapchainStatusKHR(unsafe.Pointer(p)), c.device, c.swapchain)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetPhysicalDeviceExternalFencePropertiesKHR C.PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR
type FuncGetPhysicalDeviceExternalFencePropertiesKHR func(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo, externalFenceProperties *ExternalFenceProperties)

func ToGetPhysicalDeviceExternalFencePropertiesKHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalFencePropertiesKHR) {
	return func(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo, externalFenceProperties *ExternalFenceProperties) {
		var c struct {
			physicalDevice           C.VkPhysicalDevice
			pExternalFenceInfo       *C.VkPhysicalDeviceExternalFenceInfo
			pExternalFenceProperties *C.VkExternalFenceProperties
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if externalFenceInfo != nil {
			c.pExternalFenceInfo = (*C.VkPhysicalDeviceExternalFenceInfo)(m.alloc(C.sizeof_VkPhysicalDeviceExternalFenceInfo))
			externalFenceInfo.toC(c.pExternalFenceInfo, m)
		} else {
			c.pExternalFenceInfo = nil
		}
		if externalFenceProperties != nil {
			c.pExternalFenceProperties = (*C.VkExternalFenceProperties)(m.alloc(C.sizeof_VkExternalFenceProperties))
			externalFenceProperties.toC(c.pExternalFenceProperties, m)
		} else {
			c.pExternalFenceProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceExternalFencePropertiesKHR(C.PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR(unsafe.Pointer(p)), c.physicalDevice, c.pExternalFenceInfo, c.pExternalFenceProperties)
		if externalFenceProperties != nil {
			externalFenceProperties.fromC(c.pExternalFenceProperties)
		}
	}
}

type PFNImportFenceFdKHR C.PFN_vkImportFenceFdKHR
type FenceImportFlags Flags
type ImportFenceFdInfoKHR struct {
	Next       Structure
	Fence      Fence
	Flags      FenceImportFlags
	HandleType ExternalFenceHandleTypeFlagBits
	Fd         int32
}

func (g *ImportFenceFdInfoKHR) toC(c *C.VkImportFenceFdInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.fence = C.VkFence(g.Fence)
	{
		var temp_in_VkFenceImportFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkFenceImportFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkFenceImportFlags(temp_in_VkFenceImportFlags)
	}
	c.handleType = C.VkExternalFenceHandleTypeFlagBits(g.HandleType)
	c.fd = C.int(g.Fd)
}
func (g *ImportFenceFdInfoKHR) fromC(c *C.VkImportFenceFdInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Fence = Fence(c.fence)
	{
		var temp_in_VkFenceImportFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkFenceImportFlags = Flags(temp_in_VkFlags)
		}
		g.Flags = FenceImportFlags(temp_in_VkFenceImportFlags)
	}
	g.HandleType = ExternalFenceHandleTypeFlagBits(c.handleType)
	g.Fd = int32(c.fd)
}
func (s *ImportFenceFdInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
}
func (s *ImportFenceFdInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkImportFenceFdInfoKHR)(m.alloc(C.sizeof_VkImportFenceFdInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ImportFenceFdInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkImportFenceFdInfoKHR)(p)
	s.fromC(c)
}
func (s *ImportFenceFdInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *ImportFenceFdInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncImportFenceFdKHR func(device Device, importFenceFdInfo *ImportFenceFdInfoKHR) (_ret Result)

func ToImportFenceFdKHR(p PFNVoidFunction) (fn FuncImportFenceFdKHR) {
	return func(device Device, importFenceFdInfo *ImportFenceFdInfoKHR) (_ret Result) {
		var c struct {
			device             C.VkDevice
			pImportFenceFdInfo *C.VkImportFenceFdInfoKHR
			_ret               C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if importFenceFdInfo != nil {
			c.pImportFenceFdInfo = (*C.VkImportFenceFdInfoKHR)(m.alloc(C.sizeof_VkImportFenceFdInfoKHR))
			importFenceFdInfo.toC(c.pImportFenceFdInfo, m)
		} else {
			c.pImportFenceFdInfo = nil
		}
		c._ret = C.callPFN_vkImportFenceFdKHR(C.PFN_vkImportFenceFdKHR(unsafe.Pointer(p)), c.device, c.pImportFenceFdInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetFenceFdKHR C.PFN_vkGetFenceFdKHR
type FenceGetFdInfoKHR struct {
	Next       Structure
	Fence      Fence
	HandleType ExternalFenceHandleTypeFlagBits
}

func (g *FenceGetFdInfoKHR) toC(c *C.VkFenceGetFdInfoKHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.fence = C.VkFence(g.Fence)
	c.handleType = C.VkExternalFenceHandleTypeFlagBits(g.HandleType)
}
func (g *FenceGetFdInfoKHR) fromC(c *C.VkFenceGetFdInfoKHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Fence = Fence(c.fence)
	g.HandleType = ExternalFenceHandleTypeFlagBits(c.handleType)
}
func (s *FenceGetFdInfoKHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
}
func (s *FenceGetFdInfoKHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkFenceGetFdInfoKHR)(m.alloc(C.sizeof_VkFenceGetFdInfoKHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *FenceGetFdInfoKHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkFenceGetFdInfoKHR)(p)
	s.fromC(c)
}
func (s *FenceGetFdInfoKHR) GetNext() Structure {
	return s.Next
}
func (s *FenceGetFdInfoKHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetFenceFdKHR func(device Device, getFdInfo *FenceGetFdInfoKHR, fd *int32) (_ret Result)

func ToGetFenceFdKHR(p PFNVoidFunction) (fn FuncGetFenceFdKHR) {
	return func(device Device, getFdInfo *FenceGetFdInfoKHR, fd *int32) (_ret Result) {
		var c struct {
			device     C.VkDevice
			pGetFdInfo *C.VkFenceGetFdInfoKHR
			pFd        *C.int
			_ret       C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if getFdInfo != nil {
			c.pGetFdInfo = (*C.VkFenceGetFdInfoKHR)(m.alloc(C.sizeof_VkFenceGetFdInfoKHR))
			getFdInfo.toC(c.pGetFdInfo, m)
		} else {
			c.pGetFdInfo = nil
		}
		if fd != nil {
			c.pFd = (*C.int)(m.alloc(C.sizeof_int))
			*c.pFd = C.int(*fd)
		} else {
			c.pFd = nil
		}
		c._ret = C.callPFN_vkGetFenceFdKHR(C.PFN_vkGetFenceFdKHR(unsafe.Pointer(p)), c.device, c.pGetFdInfo, c.pFd)
		_ret = Result(c._ret)
		if fd != nil {
			*fd = int32(*c.pFd)
		}
		return
	}
}

type PFNGetPhysicalDeviceSurfaceCapabilities2KHR C.PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR
type PhysicalDeviceSurfaceInfo2KHR struct {
	Next    Structure
	Surface SurfaceKHR
}

func (g *PhysicalDeviceSurfaceInfo2KHR) toC(c *C.VkPhysicalDeviceSurfaceInfo2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.surface = C.VkSurfaceKHR(g.Surface)
}
func (g *PhysicalDeviceSurfaceInfo2KHR) fromC(c *C.VkPhysicalDeviceSurfaceInfo2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Surface = SurfaceKHR(c.surface)
}
func (s *PhysicalDeviceSurfaceInfo2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
}
func (s *PhysicalDeviceSurfaceInfo2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(m.alloc(C.sizeof_VkPhysicalDeviceSurfaceInfo2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *PhysicalDeviceSurfaceInfo2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(p)
	s.fromC(c)
}
func (s *PhysicalDeviceSurfaceInfo2KHR) GetNext() Structure {
	return s.Next
}
func (s *PhysicalDeviceSurfaceInfo2KHR) SetNext(n Structure) {
	s.Next = n
}

type SurfaceCapabilities2KHR struct {
	Next                Structure
	SurfaceCapabilities SurfaceCapabilitiesKHR
}

func (g *SurfaceCapabilities2KHR) toC(c *C.VkSurfaceCapabilities2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.SurfaceCapabilities.toC(&c.surfaceCapabilities)
}
func (g *SurfaceCapabilities2KHR) fromC(c *C.VkSurfaceCapabilities2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.SurfaceCapabilities.fromC(&c.surfaceCapabilities)
}
func (s *SurfaceCapabilities2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
}
func (s *SurfaceCapabilities2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSurfaceCapabilities2KHR)(m.alloc(C.sizeof_VkSurfaceCapabilities2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SurfaceCapabilities2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSurfaceCapabilities2KHR)(p)
	s.fromC(c)
}
func (s *SurfaceCapabilities2KHR) GetNext() Structure {
	return s.Next
}
func (s *SurfaceCapabilities2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceSurfaceCapabilities2KHR func(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR, surfaceCapabilities *SurfaceCapabilities2KHR) (_ret Result)

func ToGetPhysicalDeviceSurfaceCapabilities2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceCapabilities2KHR) {
	return func(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR, surfaceCapabilities *SurfaceCapabilities2KHR) (_ret Result) {
		var c struct {
			physicalDevice       C.VkPhysicalDevice
			pSurfaceInfo         *C.VkPhysicalDeviceSurfaceInfo2KHR
			pSurfaceCapabilities *C.VkSurfaceCapabilities2KHR
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if surfaceInfo != nil {
			c.pSurfaceInfo = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(m.alloc(C.sizeof_VkPhysicalDeviceSurfaceInfo2KHR))
			surfaceInfo.toC(c.pSurfaceInfo, m)
		} else {
			c.pSurfaceInfo = nil
		}
		if surfaceCapabilities != nil {
			c.pSurfaceCapabilities = (*C.VkSurfaceCapabilities2KHR)(m.alloc(C.sizeof_VkSurfaceCapabilities2KHR))
			surfaceCapabilities.toC(c.pSurfaceCapabilities, m)
		} else {
			c.pSurfaceCapabilities = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR(C.PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pSurfaceInfo, c.pSurfaceCapabilities)
		_ret = Result(c._ret)
		if surfaceCapabilities != nil {
			surfaceCapabilities.fromC(c.pSurfaceCapabilities)
		}
		return
	}
}

type PFNGetPhysicalDeviceSurfaceFormats2KHR C.PFN_vkGetPhysicalDeviceSurfaceFormats2KHR
type SurfaceFormat2KHR struct {
	Next          Structure
	SurfaceFormat SurfaceFormatKHR
}

func (g *SurfaceFormat2KHR) toC(c *C.VkSurfaceFormat2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.SurfaceFormat.toC(&c.surfaceFormat)
}
func (g *SurfaceFormat2KHR) fromC(c *C.VkSurfaceFormat2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.SurfaceFormat.fromC(&c.surfaceFormat)
}
func (s *SurfaceFormat2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
}
func (s *SurfaceFormat2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSurfaceFormat2KHR)(m.alloc(C.sizeof_VkSurfaceFormat2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SurfaceFormat2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSurfaceFormat2KHR)(p)
	s.fromC(c)
}
func (s *SurfaceFormat2KHR) GetNext() Structure {
	return s.Next
}
func (s *SurfaceFormat2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceSurfaceFormats2KHR func(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR, surfaceFormatCount *uint32, surfaceFormats []SurfaceFormat2KHR) (_ret Result)

func ToGetPhysicalDeviceSurfaceFormats2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceFormats2KHR) {
	return func(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR, surfaceFormatCount *uint32, surfaceFormats []SurfaceFormat2KHR) (_ret Result) {
		var c struct {
			physicalDevice      C.VkPhysicalDevice
			pSurfaceInfo        *C.VkPhysicalDeviceSurfaceInfo2KHR
			pSurfaceFormatCount *C.uint32_t
			pSurfaceFormats     *C.VkSurfaceFormat2KHR
			_ret                C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if surfaceInfo != nil {
			c.pSurfaceInfo = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(m.alloc(C.sizeof_VkPhysicalDeviceSurfaceInfo2KHR))
			surfaceInfo.toC(c.pSurfaceInfo, m)
		} else {
			c.pSurfaceInfo = nil
		}
		if surfaceFormatCount != nil {
			c.pSurfaceFormatCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSurfaceFormatCount = C.uint32_t(*surfaceFormatCount)
		} else {
			c.pSurfaceFormatCount = nil
		}
		if len(surfaceFormats) != 0 {
			c.pSurfaceFormats = (*C.VkSurfaceFormat2KHR)(m.alloc(C.sizeof_VkSurfaceFormat2KHR * uint(len(surfaceFormats))))
			slice1 := (*[1 << 31]C.VkSurfaceFormat2KHR)(unsafe.Pointer(c.pSurfaceFormats))[:len(surfaceFormats):len(surfaceFormats)]
			for i1, _ := range surfaceFormats {
				surfaceFormats[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pSurfaceFormats = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceFormats2KHR(C.PFN_vkGetPhysicalDeviceSurfaceFormats2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pSurfaceInfo, c.pSurfaceFormatCount, c.pSurfaceFormats)
		_ret = Result(c._ret)
		if surfaceFormatCount != nil {
			*surfaceFormatCount = uint32(*c.pSurfaceFormatCount)
		}
		if len(surfaceFormats) != 0 {
			slice1 := (*[1 << 31]C.VkSurfaceFormat2KHR)(unsafe.Pointer(c.pSurfaceFormats))[:len(surfaceFormats):len(surfaceFormats)]
			for i1, _ := range surfaceFormats {
				surfaceFormats[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceDisplayProperties2KHR C.PFN_vkGetPhysicalDeviceDisplayProperties2KHR
type DisplayProperties2KHR struct {
	Next              Structure
	DisplayProperties DisplayPropertiesKHR
}

func (g *DisplayProperties2KHR) toC(c *C.VkDisplayProperties2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.DisplayProperties.toC(&c.displayProperties, m)
}
func (g *DisplayProperties2KHR) fromC(c *C.VkDisplayProperties2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DisplayProperties.fromC(&c.displayProperties)
}
func (s *DisplayProperties2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
}
func (s *DisplayProperties2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayProperties2KHR)(m.alloc(C.sizeof_VkDisplayProperties2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayProperties2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayProperties2KHR)(p)
	s.fromC(c)
}
func (s *DisplayProperties2KHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayProperties2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceDisplayProperties2KHR func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayProperties2KHR) (_ret Result)

func ToGetPhysicalDeviceDisplayProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceDisplayProperties2KHR) {
	return func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayProperties2KHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayProperties2KHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayProperties2KHR)(m.alloc(C.sizeof_VkDisplayProperties2KHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceDisplayProperties2KHR(C.PFN_vkGetPhysicalDeviceDisplayProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetPhysicalDeviceDisplayPlaneProperties2KHR C.PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR
type DisplayPlaneProperties2KHR struct {
	Next                   Structure
	DisplayPlaneProperties DisplayPlanePropertiesKHR
}

func (g *DisplayPlaneProperties2KHR) toC(c *C.VkDisplayPlaneProperties2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.DisplayPlaneProperties.toC(&c.displayPlaneProperties)
}
func (g *DisplayPlaneProperties2KHR) fromC(c *C.VkDisplayPlaneProperties2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DisplayPlaneProperties.fromC(&c.displayPlaneProperties)
}
func (s *DisplayPlaneProperties2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
}
func (s *DisplayPlaneProperties2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayPlaneProperties2KHR)(m.alloc(C.sizeof_VkDisplayPlaneProperties2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayPlaneProperties2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayPlaneProperties2KHR)(p)
	s.fromC(c)
}
func (s *DisplayPlaneProperties2KHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayPlaneProperties2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceDisplayPlaneProperties2KHR func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPlaneProperties2KHR) (_ret Result)

func ToGetPhysicalDeviceDisplayPlaneProperties2KHR(p PFNVoidFunction) (fn FuncGetPhysicalDeviceDisplayPlaneProperties2KHR) {
	return func(physicalDevice PhysicalDevice, propertyCount *uint32, properties []DisplayPlaneProperties2KHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayPlaneProperties2KHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayPlaneProperties2KHR)(m.alloc(C.sizeof_VkDisplayPlaneProperties2KHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(C.PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetDisplayModeProperties2KHR C.PFN_vkGetDisplayModeProperties2KHR
type DisplayModeProperties2KHR struct {
	Next                  Structure
	DisplayModeProperties DisplayModePropertiesKHR
}

func (g *DisplayModeProperties2KHR) toC(c *C.VkDisplayModeProperties2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.DisplayModeProperties.toC(&c.displayModeProperties)
}
func (g *DisplayModeProperties2KHR) fromC(c *C.VkDisplayModeProperties2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DisplayModeProperties.fromC(&c.displayModeProperties)
}
func (s *DisplayModeProperties2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
}
func (s *DisplayModeProperties2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayModeProperties2KHR)(m.alloc(C.sizeof_VkDisplayModeProperties2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayModeProperties2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayModeProperties2KHR)(p)
	s.fromC(c)
}
func (s *DisplayModeProperties2KHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayModeProperties2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetDisplayModeProperties2KHR func(physicalDevice PhysicalDevice, display DisplayKHR, propertyCount *uint32, properties []DisplayModeProperties2KHR) (_ret Result)

func ToGetDisplayModeProperties2KHR(p PFNVoidFunction) (fn FuncGetDisplayModeProperties2KHR) {
	return func(physicalDevice PhysicalDevice, display DisplayKHR, propertyCount *uint32, properties []DisplayModeProperties2KHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			display        C.VkDisplayKHR
			pPropertyCount *C.uint32_t
			pProperties    *C.VkDisplayModeProperties2KHR
			_ret           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.display = C.VkDisplayKHR(display)
		if propertyCount != nil {
			c.pPropertyCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPropertyCount = C.uint32_t(*propertyCount)
		} else {
			c.pPropertyCount = nil
		}
		if len(properties) != 0 {
			c.pProperties = (*C.VkDisplayModeProperties2KHR)(m.alloc(C.sizeof_VkDisplayModeProperties2KHR * uint(len(properties))))
			slice1 := (*[1 << 31]C.VkDisplayModeProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pProperties = nil
		}
		c._ret = C.callPFN_vkGetDisplayModeProperties2KHR(C.PFN_vkGetDisplayModeProperties2KHR(unsafe.Pointer(p)), c.physicalDevice, c.display, c.pPropertyCount, c.pProperties)
		_ret = Result(c._ret)
		if propertyCount != nil {
			*propertyCount = uint32(*c.pPropertyCount)
		}
		if len(properties) != 0 {
			slice1 := (*[1 << 31]C.VkDisplayModeProperties2KHR)(unsafe.Pointer(c.pProperties))[:len(properties):len(properties)]
			for i1, _ := range properties {
				properties[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type PFNGetDisplayPlaneCapabilities2KHR C.PFN_vkGetDisplayPlaneCapabilities2KHR
type DisplayPlaneInfo2KHR struct {
	Next       Structure
	Mode       DisplayModeKHR
	PlaneIndex uint32
}

func (g *DisplayPlaneInfo2KHR) toC(c *C.VkDisplayPlaneInfo2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.mode = C.VkDisplayModeKHR(g.Mode)
	c.planeIndex = C.uint32_t(g.PlaneIndex)
}
func (g *DisplayPlaneInfo2KHR) fromC(c *C.VkDisplayPlaneInfo2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Mode = DisplayModeKHR(c.mode)
	g.PlaneIndex = uint32(c.planeIndex)
}
func (s *DisplayPlaneInfo2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
}
func (s *DisplayPlaneInfo2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayPlaneInfo2KHR)(m.alloc(C.sizeof_VkDisplayPlaneInfo2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayPlaneInfo2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayPlaneInfo2KHR)(p)
	s.fromC(c)
}
func (s *DisplayPlaneInfo2KHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayPlaneInfo2KHR) SetNext(n Structure) {
	s.Next = n
}

type DisplayPlaneCapabilities2KHR struct {
	Next         Structure
	Capabilities DisplayPlaneCapabilitiesKHR
}

func (g *DisplayPlaneCapabilities2KHR) toC(c *C.VkDisplayPlaneCapabilities2KHR, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.Capabilities.toC(&c.capabilities)
}
func (g *DisplayPlaneCapabilities2KHR) fromC(c *C.VkDisplayPlaneCapabilities2KHR) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Capabilities.fromC(&c.capabilities)
}
func (s *DisplayPlaneCapabilities2KHR) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
}
func (s *DisplayPlaneCapabilities2KHR) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayPlaneCapabilities2KHR)(m.alloc(C.sizeof_VkDisplayPlaneCapabilities2KHR))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayPlaneCapabilities2KHR) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayPlaneCapabilities2KHR)(p)
	s.fromC(c)
}
func (s *DisplayPlaneCapabilities2KHR) GetNext() Structure {
	return s.Next
}
func (s *DisplayPlaneCapabilities2KHR) SetNext(n Structure) {
	s.Next = n
}

type FuncGetDisplayPlaneCapabilities2KHR func(physicalDevice PhysicalDevice, displayPlaneInfo *DisplayPlaneInfo2KHR, capabilities *DisplayPlaneCapabilities2KHR) (_ret Result)

func ToGetDisplayPlaneCapabilities2KHR(p PFNVoidFunction) (fn FuncGetDisplayPlaneCapabilities2KHR) {
	return func(physicalDevice PhysicalDevice, displayPlaneInfo *DisplayPlaneInfo2KHR, capabilities *DisplayPlaneCapabilities2KHR) (_ret Result) {
		var c struct {
			physicalDevice    C.VkPhysicalDevice
			pDisplayPlaneInfo *C.VkDisplayPlaneInfo2KHR
			pCapabilities     *C.VkDisplayPlaneCapabilities2KHR
			_ret              C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if displayPlaneInfo != nil {
			c.pDisplayPlaneInfo = (*C.VkDisplayPlaneInfo2KHR)(m.alloc(C.sizeof_VkDisplayPlaneInfo2KHR))
			displayPlaneInfo.toC(c.pDisplayPlaneInfo, m)
		} else {
			c.pDisplayPlaneInfo = nil
		}
		if capabilities != nil {
			c.pCapabilities = (*C.VkDisplayPlaneCapabilities2KHR)(m.alloc(C.sizeof_VkDisplayPlaneCapabilities2KHR))
			capabilities.toC(c.pCapabilities, m)
		} else {
			c.pCapabilities = nil
		}
		c._ret = C.callPFN_vkGetDisplayPlaneCapabilities2KHR(C.PFN_vkGetDisplayPlaneCapabilities2KHR(unsafe.Pointer(p)), c.physicalDevice, c.pDisplayPlaneInfo, c.pCapabilities)
		_ret = Result(c._ret)
		if capabilities != nil {
			capabilities.fromC(c.pCapabilities)
		}
		return
	}
}

type PFNGetImageMemoryRequirements2KHR C.PFN_vkGetImageMemoryRequirements2KHR
type FuncGetImageMemoryRequirements2KHR func(device Device, info *ImageMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2)

func ToGetImageMemoryRequirements2KHR(p PFNVoidFunction) (fn FuncGetImageMemoryRequirements2KHR) {
	return func(device Device, info *ImageMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
		var c struct {
			device              C.VkDevice
			pInfo               *C.VkImageMemoryRequirementsInfo2
			pMemoryRequirements *C.VkMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkImageMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
			memoryRequirements.toC(c.pMemoryRequirements, m)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetImageMemoryRequirements2KHR(C.PFN_vkGetImageMemoryRequirements2KHR(unsafe.Pointer(p)), c.device, c.pInfo, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetBufferMemoryRequirements2KHR C.PFN_vkGetBufferMemoryRequirements2KHR
type FuncGetBufferMemoryRequirements2KHR func(device Device, info *BufferMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2)

func ToGetBufferMemoryRequirements2KHR(p PFNVoidFunction) (fn FuncGetBufferMemoryRequirements2KHR) {
	return func(device Device, info *BufferMemoryRequirementsInfo2, memoryRequirements *MemoryRequirements2) {
		var c struct {
			device              C.VkDevice
			pInfo               *C.VkBufferMemoryRequirementsInfo2
			pMemoryRequirements *C.VkMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkBufferMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkBufferMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if memoryRequirements != nil {
			c.pMemoryRequirements = (*C.VkMemoryRequirements2)(m.alloc(C.sizeof_VkMemoryRequirements2))
			memoryRequirements.toC(c.pMemoryRequirements, m)
		} else {
			c.pMemoryRequirements = nil
		}
		C.callPFN_vkGetBufferMemoryRequirements2KHR(C.PFN_vkGetBufferMemoryRequirements2KHR(unsafe.Pointer(p)), c.device, c.pInfo, c.pMemoryRequirements)
		if memoryRequirements != nil {
			memoryRequirements.fromC(c.pMemoryRequirements)
		}
	}
}

type PFNGetImageSparseMemoryRequirements2KHR C.PFN_vkGetImageSparseMemoryRequirements2KHR
type FuncGetImageSparseMemoryRequirements2KHR func(device Device, info *ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements2)

func ToGetImageSparseMemoryRequirements2KHR(p PFNVoidFunction) (fn FuncGetImageSparseMemoryRequirements2KHR) {
	return func(device Device, info *ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirementCount *uint32, sparseMemoryRequirements []SparseImageMemoryRequirements2) {
		var c struct {
			device                        C.VkDevice
			pInfo                         *C.VkImageSparseMemoryRequirementsInfo2
			pSparseMemoryRequirementCount *C.uint32_t
			pSparseMemoryRequirements     *C.VkSparseImageMemoryRequirements2
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if info != nil {
			c.pInfo = (*C.VkImageSparseMemoryRequirementsInfo2)(m.alloc(C.sizeof_VkImageSparseMemoryRequirementsInfo2))
			info.toC(c.pInfo, m)
		} else {
			c.pInfo = nil
		}
		if sparseMemoryRequirementCount != nil {
			c.pSparseMemoryRequirementCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pSparseMemoryRequirementCount = C.uint32_t(*sparseMemoryRequirementCount)
		} else {
			c.pSparseMemoryRequirementCount = nil
		}
		if len(sparseMemoryRequirements) != 0 {
			c.pSparseMemoryRequirements = (*C.VkSparseImageMemoryRequirements2)(m.alloc(C.sizeof_VkSparseImageMemoryRequirements2 * uint(len(sparseMemoryRequirements))))
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pSparseMemoryRequirements = nil
		}
		C.callPFN_vkGetImageSparseMemoryRequirements2KHR(C.PFN_vkGetImageSparseMemoryRequirements2KHR(unsafe.Pointer(p)), c.device, c.pInfo, c.pSparseMemoryRequirementCount, c.pSparseMemoryRequirements)
		if sparseMemoryRequirementCount != nil {
			*sparseMemoryRequirementCount = uint32(*c.pSparseMemoryRequirementCount)
		}
		if len(sparseMemoryRequirements) != 0 {
			slice1 := (*[1 << 31]C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(c.pSparseMemoryRequirements))[:len(sparseMemoryRequirements):len(sparseMemoryRequirements)]
			for i1, _ := range sparseMemoryRequirements {
				sparseMemoryRequirements[i1].fromC(&slice1[i1])
			}
		}
	}
}

type PFNCreateSamplerYcbcrConversionKHR C.PFN_vkCreateSamplerYcbcrConversionKHR
type FuncCreateSamplerYcbcrConversionKHR func(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks, ycbcrConversion *SamplerYcbcrConversion) (_ret Result)

func ToCreateSamplerYcbcrConversionKHR(p PFNVoidFunction) (fn FuncCreateSamplerYcbcrConversionKHR) {
	return func(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks, ycbcrConversion *SamplerYcbcrConversion) (_ret Result) {
		var c struct {
			device           C.VkDevice
			pCreateInfo      *C.VkSamplerYcbcrConversionCreateInfo
			pAllocator       *C.VkAllocationCallbacks
			pYcbcrConversion *C.VkSamplerYcbcrConversion
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkSamplerYcbcrConversionCreateInfo)(m.alloc(C.sizeof_VkSamplerYcbcrConversionCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if ycbcrConversion != nil {
			c.pYcbcrConversion = (*C.VkSamplerYcbcrConversion)(m.alloc(C.sizeof_VkSamplerYcbcrConversion))
			*c.pYcbcrConversion = C.VkSamplerYcbcrConversion(*ycbcrConversion)
		} else {
			c.pYcbcrConversion = nil
		}
		c._ret = C.callPFN_vkCreateSamplerYcbcrConversionKHR(C.PFN_vkCreateSamplerYcbcrConversionKHR(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pYcbcrConversion)
		_ret = Result(c._ret)
		if ycbcrConversion != nil {
			*ycbcrConversion = SamplerYcbcrConversion(*c.pYcbcrConversion)
		}
		return
	}
}

type PFNDestroySamplerYcbcrConversionKHR C.PFN_vkDestroySamplerYcbcrConversionKHR
type FuncDestroySamplerYcbcrConversionKHR func(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks)

func ToDestroySamplerYcbcrConversionKHR(p PFNVoidFunction) (fn FuncDestroySamplerYcbcrConversionKHR) {
	return func(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
		var c struct {
			device          C.VkDevice
			ycbcrConversion C.VkSamplerYcbcrConversion
			pAllocator      *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.ycbcrConversion = C.VkSamplerYcbcrConversion(ycbcrConversion)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroySamplerYcbcrConversionKHR(C.PFN_vkDestroySamplerYcbcrConversionKHR(unsafe.Pointer(p)), c.device, c.ycbcrConversion, c.pAllocator)
	}
}

type PFNBindBufferMemory2KHR C.PFN_vkBindBufferMemory2KHR
type FuncBindBufferMemory2KHR func(device Device, bindInfos []BindBufferMemoryInfo) (_ret Result)

func ToBindBufferMemory2KHR(p PFNVoidFunction) (fn FuncBindBufferMemory2KHR) {
	return func(device Device, bindInfos []BindBufferMemoryInfo) (_ret Result) {
		var c struct {
			device        C.VkDevice
			bindInfoCount C.uint32_t
			pBindInfos    *C.VkBindBufferMemoryInfo
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.bindInfoCount = C.uint32_t(len(bindInfos))
		if len(bindInfos) != 0 {
			c.pBindInfos = (*C.VkBindBufferMemoryInfo)(m.alloc(C.sizeof_VkBindBufferMemoryInfo * uint(len(bindInfos))))
			slice1 := (*[1 << 31]C.VkBindBufferMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
			for i1, _ := range bindInfos {
				bindInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBindInfos = nil
		}
		c._ret = C.callPFN_vkBindBufferMemory2KHR(C.PFN_vkBindBufferMemory2KHR(unsafe.Pointer(p)), c.device, c.bindInfoCount, c.pBindInfos)
		_ret = Result(c._ret)
		return
	}
}

type PFNBindImageMemory2KHR C.PFN_vkBindImageMemory2KHR
type FuncBindImageMemory2KHR func(device Device, bindInfos []BindImageMemoryInfo) (_ret Result)

func ToBindImageMemory2KHR(p PFNVoidFunction) (fn FuncBindImageMemory2KHR) {
	return func(device Device, bindInfos []BindImageMemoryInfo) (_ret Result) {
		var c struct {
			device        C.VkDevice
			bindInfoCount C.uint32_t
			pBindInfos    *C.VkBindImageMemoryInfo
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.bindInfoCount = C.uint32_t(len(bindInfos))
		if len(bindInfos) != 0 {
			c.pBindInfos = (*C.VkBindImageMemoryInfo)(m.alloc(C.sizeof_VkBindImageMemoryInfo * uint(len(bindInfos))))
			slice1 := (*[1 << 31]C.VkBindImageMemoryInfo)(unsafe.Pointer(c.pBindInfos))[:len(bindInfos):len(bindInfos)]
			for i1, _ := range bindInfos {
				bindInfos[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pBindInfos = nil
		}
		c._ret = C.callPFN_vkBindImageMemory2KHR(C.PFN_vkBindImageMemory2KHR(unsafe.Pointer(p)), c.device, c.bindInfoCount, c.pBindInfos)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetDescriptorSetLayoutSupportKHR C.PFN_vkGetDescriptorSetLayoutSupportKHR
type FuncGetDescriptorSetLayoutSupportKHR func(device Device, createInfo *DescriptorSetLayoutCreateInfo, support *DescriptorSetLayoutSupport)

func ToGetDescriptorSetLayoutSupportKHR(p PFNVoidFunction) (fn FuncGetDescriptorSetLayoutSupportKHR) {
	return func(device Device, createInfo *DescriptorSetLayoutCreateInfo, support *DescriptorSetLayoutSupport) {
		var c struct {
			device      C.VkDevice
			pCreateInfo *C.VkDescriptorSetLayoutCreateInfo
			pSupport    *C.VkDescriptorSetLayoutSupport
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDescriptorSetLayoutCreateInfo)(m.alloc(C.sizeof_VkDescriptorSetLayoutCreateInfo))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if support != nil {
			c.pSupport = (*C.VkDescriptorSetLayoutSupport)(m.alloc(C.sizeof_VkDescriptorSetLayoutSupport))
			support.toC(c.pSupport, m)
		} else {
			c.pSupport = nil
		}
		C.callPFN_vkGetDescriptorSetLayoutSupportKHR(C.PFN_vkGetDescriptorSetLayoutSupportKHR(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pSupport)
		if support != nil {
			support.fromC(c.pSupport)
		}
	}
}

type PFNCmdDrawIndirectCountKHR C.PFN_vkCmdDrawIndirectCountKHR
type FuncCmdDrawIndirectCountKHR func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32)

func ToCmdDrawIndirectCountKHR(p PFNVoidFunction) (fn FuncCmdDrawIndirectCountKHR) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			buffer            C.VkBuffer
			offset            C.VkDeviceSize
			countBuffer       C.VkBuffer
			countBufferOffset C.VkDeviceSize
			maxDrawCount      C.uint32_t
			stride            C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.countBuffer = C.VkBuffer(countBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(countBufferOffset))
			c.countBufferOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.maxDrawCount = C.uint32_t(maxDrawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndirectCountKHR(C.PFN_vkCmdDrawIndirectCountKHR(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.countBuffer, c.countBufferOffset, c.maxDrawCount, c.stride)
	}
}

type PFNCmdDrawIndexedIndirectCountKHR C.PFN_vkCmdDrawIndexedIndirectCountKHR
type FuncCmdDrawIndexedIndirectCountKHR func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32)

func ToCmdDrawIndexedIndirectCountKHR(p PFNVoidFunction) (fn FuncCmdDrawIndexedIndirectCountKHR) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			buffer            C.VkBuffer
			offset            C.VkDeviceSize
			countBuffer       C.VkBuffer
			countBufferOffset C.VkDeviceSize
			maxDrawCount      C.uint32_t
			stride            C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.countBuffer = C.VkBuffer(countBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(countBufferOffset))
			c.countBufferOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.maxDrawCount = C.uint32_t(maxDrawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndexedIndirectCountKHR(C.PFN_vkCmdDrawIndexedIndirectCountKHR(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.countBuffer, c.countBufferOffset, c.maxDrawCount, c.stride)
	}
}

type DebugReportObjectTypeEXT int

const (
	DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT                        DebugReportObjectTypeEXT = 0
	DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT                       DebugReportObjectTypeEXT = 1
	DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT                DebugReportObjectTypeEXT = 2
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                         DebugReportObjectTypeEXT = 3
	DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                          DebugReportObjectTypeEXT = 4
	DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT                      DebugReportObjectTypeEXT = 5
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT                 DebugReportObjectTypeEXT = 6
	DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                          DebugReportObjectTypeEXT = 7
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT                  DebugReportObjectTypeEXT = 8
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                         DebugReportObjectTypeEXT = 9
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                          DebugReportObjectTypeEXT = 10
	DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                          DebugReportObjectTypeEXT = 11
	DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT                     DebugReportObjectTypeEXT = 12
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT                    DebugReportObjectTypeEXT = 13
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT                     DebugReportObjectTypeEXT = 14
	DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT                  DebugReportObjectTypeEXT = 15
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT                 DebugReportObjectTypeEXT = 16
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT                DebugReportObjectTypeEXT = 17
	DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT                    DebugReportObjectTypeEXT = 18
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT                       DebugReportObjectTypeEXT = 19
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT          DebugReportObjectTypeEXT = 20
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT                        DebugReportObjectTypeEXT = 21
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT                DebugReportObjectTypeEXT = 22
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT                 DebugReportObjectTypeEXT = 23
	DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT                    DebugReportObjectTypeEXT = 24
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT                   DebugReportObjectTypeEXT = 25
	DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT                    DebugReportObjectTypeEXT = 26
	DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT                  DebugReportObjectTypeEXT = 27
	DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT      DebugReportObjectTypeEXT = 28
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT                    DebugReportObjectTypeEXT = 29
	DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT               DebugReportObjectTypeEXT = 30
	DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT               DebugReportObjectTypeEXT = 31
	DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT   DebugReportObjectTypeEXT = 32
	DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT           DebugReportObjectTypeEXT = 33
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT       DebugReportObjectTypeEXT = 1000156000
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT     DebugReportObjectTypeEXT = 1000085000
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT DebugReportObjectTypeEXT = DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT   DebugReportObjectTypeEXT = DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
	DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT                    DebugReportObjectTypeEXT = DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
	DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT                      DebugReportObjectTypeEXT = DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT
	DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT                     DebugReportObjectTypeEXT = (DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT - DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1)
	DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT                       DebugReportObjectTypeEXT = 2147483647
)

type DebugReportFlagBitsEXT int

const (
	DEBUG_REPORT_INFORMATION_BIT_EXT         DebugReportFlagBitsEXT = 1
	DEBUG_REPORT_WARNING_BIT_EXT             DebugReportFlagBitsEXT = 2
	DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT DebugReportFlagBitsEXT = 4
	DEBUG_REPORT_ERROR_BIT_EXT               DebugReportFlagBitsEXT = 8
	DEBUG_REPORT_DEBUG_BIT_EXT               DebugReportFlagBitsEXT = 16
	DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT      DebugReportFlagBitsEXT = 2147483647
)

type PFNDebugReportCallbackEXT C.PFN_vkDebugReportCallbackEXT
type DebugReportFlagsEXT Flags
type FuncDebugReportCallbackEXT func(arg0 DebugReportFlagsEXT, arg1 DebugReportObjectTypeEXT, arg2 uint64, arg3 uint, arg4 int32, arg5 string, arg6 string, arg7 unsafe.Pointer) (_ret bool)

func ToDebugReportCallbackEXT(p PFNVoidFunction) (fn FuncDebugReportCallbackEXT) {
	return func(arg0 DebugReportFlagsEXT, arg1 DebugReportObjectTypeEXT, arg2 uint64, arg3 uint, arg4 int32, arg5 string, arg6 string, arg7 unsafe.Pointer) (_ret bool) {
		var c struct {
			arg0 C.VkDebugReportFlagsEXT
			arg1 C.VkDebugReportObjectTypeEXT
			arg2 C.uint64_t
			arg3 C.size_t
			arg4 C.int32_t
			arg5 *C.char
			arg6 *C.char
			arg7 unsafe.Pointer
			_ret C.VkBool32
		}
		m := pool.take()
		defer pool.give(m)
		{
			var temp_in_VkDebugReportFlagsEXT C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(arg0)))
				temp_in_VkDebugReportFlagsEXT = C.VkFlags(temp_in_VkFlags)
			}
			c.arg0 = C.VkDebugReportFlagsEXT(temp_in_VkDebugReportFlagsEXT)
		}
		c.arg1 = C.VkDebugReportObjectTypeEXT(arg1)
		c.arg2 = C.uint64_t(arg2)
		c.arg3 = C.size_t(arg3)
		c.arg4 = C.int32_t(arg4)
		c.arg5 = toCString(arg5, m)
		c.arg6 = toCString(arg6, m)
		c.arg7 = arg7
		c._ret = C.callPFN_vkDebugReportCallbackEXT(C.PFN_vkDebugReportCallbackEXT(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3, c.arg4, c.arg5, c.arg6, c.arg7)
		_ret = c._ret != 0
		return
	}
}

type PFNCreateDebugReportCallbackEXT C.PFN_vkCreateDebugReportCallbackEXT
type DebugReportCallbackCreateInfoEXT struct {
	Next     Structure
	Flags    DebugReportFlagsEXT
	Callback PFNDebugReportCallbackEXT
	UserData unsafe.Pointer
}

func (g *DebugReportCallbackCreateInfoEXT) toC(c *C.VkDebugReportCallbackCreateInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDebugReportFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDebugReportFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDebugReportFlagsEXT(temp_in_VkDebugReportFlagsEXT)
	}
	c.pfnCallback = C.PFN_vkDebugReportCallbackEXT(g.Callback)
	c.pUserData = g.UserData
}
func (g *DebugReportCallbackCreateInfoEXT) fromC(c *C.VkDebugReportCallbackCreateInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDebugReportFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDebugReportFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.Flags = DebugReportFlagsEXT(temp_in_VkDebugReportFlagsEXT)
	}
	g.Callback = PFNDebugReportCallbackEXT(c.pfnCallback)
	g.UserData = c.pUserData
}
func (s *DebugReportCallbackCreateInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
}
func (s *DebugReportCallbackCreateInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugReportCallbackCreateInfoEXT)(m.alloc(C.sizeof_VkDebugReportCallbackCreateInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugReportCallbackCreateInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugReportCallbackCreateInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugReportCallbackCreateInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugReportCallbackCreateInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type DebugReportCallbackEXT C.VkDebugReportCallbackEXT
type FuncCreateDebugReportCallbackEXT func(instance Instance, createInfo *DebugReportCallbackCreateInfoEXT, allocator *AllocationCallbacks, callback *DebugReportCallbackEXT) (_ret Result)

func ToCreateDebugReportCallbackEXT(p PFNVoidFunction) (fn FuncCreateDebugReportCallbackEXT) {
	return func(instance Instance, createInfo *DebugReportCallbackCreateInfoEXT, allocator *AllocationCallbacks, callback *DebugReportCallbackEXT) (_ret Result) {
		var c struct {
			instance    C.VkInstance
			pCreateInfo *C.VkDebugReportCallbackCreateInfoEXT
			pAllocator  *C.VkAllocationCallbacks
			pCallback   *C.VkDebugReportCallbackEXT
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDebugReportCallbackCreateInfoEXT)(m.alloc(C.sizeof_VkDebugReportCallbackCreateInfoEXT))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if callback != nil {
			c.pCallback = (*C.VkDebugReportCallbackEXT)(m.alloc(C.sizeof_VkDebugReportCallbackEXT))
			*c.pCallback = C.VkDebugReportCallbackEXT(*callback)
		} else {
			c.pCallback = nil
		}
		c._ret = C.callPFN_vkCreateDebugReportCallbackEXT(C.PFN_vkCreateDebugReportCallbackEXT(unsafe.Pointer(p)), c.instance, c.pCreateInfo, c.pAllocator, c.pCallback)
		_ret = Result(c._ret)
		if callback != nil {
			*callback = DebugReportCallbackEXT(*c.pCallback)
		}
		return
	}
}

type PFNDestroyDebugReportCallbackEXT C.PFN_vkDestroyDebugReportCallbackEXT
type FuncDestroyDebugReportCallbackEXT func(instance Instance, callback DebugReportCallbackEXT, allocator *AllocationCallbacks)

func ToDestroyDebugReportCallbackEXT(p PFNVoidFunction) (fn FuncDestroyDebugReportCallbackEXT) {
	return func(instance Instance, callback DebugReportCallbackEXT, allocator *AllocationCallbacks) {
		var c struct {
			instance   C.VkInstance
			callback   C.VkDebugReportCallbackEXT
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		c.callback = C.VkDebugReportCallbackEXT(callback)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDebugReportCallbackEXT(C.PFN_vkDestroyDebugReportCallbackEXT(unsafe.Pointer(p)), c.instance, c.callback, c.pAllocator)
	}
}

type PFNDebugReportMessageEXT C.PFN_vkDebugReportMessageEXT
type FuncDebugReportMessageEXT func(instance Instance, flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uint, messageCode int32, layerPrefix string, message string)

func ToDebugReportMessageEXT(p PFNVoidFunction) (fn FuncDebugReportMessageEXT) {
	return func(instance Instance, flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uint, messageCode int32, layerPrefix string, message string) {
		var c struct {
			instance     C.VkInstance
			flags        C.VkDebugReportFlagsEXT
			objectType   C.VkDebugReportObjectTypeEXT
			object       C.uint64_t
			location     C.size_t
			messageCode  C.int32_t
			pLayerPrefix *C.char
			pMessage     *C.char
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		{
			var temp_in_VkDebugReportFlagsEXT C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkDebugReportFlagsEXT = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkDebugReportFlagsEXT(temp_in_VkDebugReportFlagsEXT)
		}
		c.objectType = C.VkDebugReportObjectTypeEXT(objectType)
		c.object = C.uint64_t(object)
		c.location = C.size_t(location)
		c.messageCode = C.int32_t(messageCode)
		c.pLayerPrefix = toCString(layerPrefix, m)
		c.pMessage = toCString(message, m)
		C.callPFN_vkDebugReportMessageEXT(C.PFN_vkDebugReportMessageEXT(unsafe.Pointer(p)), c.instance, c.flags, c.objectType, c.object, c.location, c.messageCode, c.pLayerPrefix, c.pMessage)
	}
}

type RasterizationOrderAMD int

const (
	RASTERIZATION_ORDER_STRICT_AMD      RasterizationOrderAMD = 0
	RASTERIZATION_ORDER_RELAXED_AMD     RasterizationOrderAMD = 1
	RASTERIZATION_ORDER_BEGIN_RANGE_AMD RasterizationOrderAMD = RASTERIZATION_ORDER_STRICT_AMD
	RASTERIZATION_ORDER_END_RANGE_AMD   RasterizationOrderAMD = RASTERIZATION_ORDER_RELAXED_AMD
	RASTERIZATION_ORDER_RANGE_SIZE_AMD  RasterizationOrderAMD = (RASTERIZATION_ORDER_RELAXED_AMD - RASTERIZATION_ORDER_STRICT_AMD + 1)
	RASTERIZATION_ORDER_MAX_ENUM_AMD    RasterizationOrderAMD = 2147483647
)

type PFNDebugMarkerSetObjectTagEXT C.PFN_vkDebugMarkerSetObjectTagEXT
type DebugMarkerObjectTagInfoEXT struct {
	Next       Structure
	ObjectType DebugReportObjectTypeEXT
	Object     uint64
	TagName    uint64
	TagSize    uint
	Tag        unsafe.Pointer
}

func (g *DebugMarkerObjectTagInfoEXT) toC(c *C.VkDebugMarkerObjectTagInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectType = C.VkDebugReportObjectTypeEXT(g.ObjectType)
	c.object = C.uint64_t(g.Object)
	c.tagName = C.uint64_t(g.TagName)
	c.tagSize = C.size_t(g.TagSize)
	c.pTag = g.Tag
}
func (g *DebugMarkerObjectTagInfoEXT) fromC(c *C.VkDebugMarkerObjectTagInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectType = DebugReportObjectTypeEXT(c.objectType)
	g.Object = uint64(c.object)
	g.TagName = uint64(c.tagName)
	g.TagSize = uint(c.tagSize)
	g.Tag = c.pTag
}
func (s *DebugMarkerObjectTagInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
}
func (s *DebugMarkerObjectTagInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugMarkerObjectTagInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerObjectTagInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugMarkerObjectTagInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugMarkerObjectTagInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugMarkerObjectTagInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugMarkerObjectTagInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncDebugMarkerSetObjectTagEXT func(device Device, tagInfo *DebugMarkerObjectTagInfoEXT) (_ret Result)

func ToDebugMarkerSetObjectTagEXT(p PFNVoidFunction) (fn FuncDebugMarkerSetObjectTagEXT) {
	return func(device Device, tagInfo *DebugMarkerObjectTagInfoEXT) (_ret Result) {
		var c struct {
			device   C.VkDevice
			pTagInfo *C.VkDebugMarkerObjectTagInfoEXT
			_ret     C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if tagInfo != nil {
			c.pTagInfo = (*C.VkDebugMarkerObjectTagInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerObjectTagInfoEXT))
			tagInfo.toC(c.pTagInfo, m)
		} else {
			c.pTagInfo = nil
		}
		c._ret = C.callPFN_vkDebugMarkerSetObjectTagEXT(C.PFN_vkDebugMarkerSetObjectTagEXT(unsafe.Pointer(p)), c.device, c.pTagInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNDebugMarkerSetObjectNameEXT C.PFN_vkDebugMarkerSetObjectNameEXT
type DebugMarkerObjectNameInfoEXT struct {
	Next       Structure
	ObjectType DebugReportObjectTypeEXT
	Object     uint64
	ObjectName string
}

func (g *DebugMarkerObjectNameInfoEXT) toC(c *C.VkDebugMarkerObjectNameInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectType = C.VkDebugReportObjectTypeEXT(g.ObjectType)
	c.object = C.uint64_t(g.Object)
	c.pObjectName = toCString(g.ObjectName, m)
}
func (g *DebugMarkerObjectNameInfoEXT) fromC(c *C.VkDebugMarkerObjectNameInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectType = DebugReportObjectTypeEXT(c.objectType)
	g.Object = uint64(c.object)
	g.ObjectName = toGoString(c.pObjectName)
}
func (s *DebugMarkerObjectNameInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
}
func (s *DebugMarkerObjectNameInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugMarkerObjectNameInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerObjectNameInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugMarkerObjectNameInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugMarkerObjectNameInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugMarkerObjectNameInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugMarkerObjectNameInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncDebugMarkerSetObjectNameEXT func(device Device, nameInfo *DebugMarkerObjectNameInfoEXT) (_ret Result)

func ToDebugMarkerSetObjectNameEXT(p PFNVoidFunction) (fn FuncDebugMarkerSetObjectNameEXT) {
	return func(device Device, nameInfo *DebugMarkerObjectNameInfoEXT) (_ret Result) {
		var c struct {
			device    C.VkDevice
			pNameInfo *C.VkDebugMarkerObjectNameInfoEXT
			_ret      C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if nameInfo != nil {
			c.pNameInfo = (*C.VkDebugMarkerObjectNameInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerObjectNameInfoEXT))
			nameInfo.toC(c.pNameInfo, m)
		} else {
			c.pNameInfo = nil
		}
		c._ret = C.callPFN_vkDebugMarkerSetObjectNameEXT(C.PFN_vkDebugMarkerSetObjectNameEXT(unsafe.Pointer(p)), c.device, c.pNameInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNCmdDebugMarkerBeginEXT C.PFN_vkCmdDebugMarkerBeginEXT
type DebugMarkerMarkerInfoEXT struct {
	Next       Structure
	MarkerName string
	Color      [4]float32
}

func (g *DebugMarkerMarkerInfoEXT) toC(c *C.VkDebugMarkerMarkerInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.pMarkerName = toCString(g.MarkerName, m)
	for i, _ := range g.Color {
		c.color[i] = C.float(g.Color[i])
	}
}
func (g *DebugMarkerMarkerInfoEXT) fromC(c *C.VkDebugMarkerMarkerInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MarkerName = toGoString(c.pMarkerName)
	for i, _ := range g.Color {
		g.Color[i] = float32(c.color[i])
	}
}
func (s *DebugMarkerMarkerInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
}
func (s *DebugMarkerMarkerInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugMarkerMarkerInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerMarkerInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugMarkerMarkerInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugMarkerMarkerInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugMarkerMarkerInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugMarkerMarkerInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdDebugMarkerBeginEXT func(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT)

func ToCmdDebugMarkerBeginEXT(p PFNVoidFunction) (fn FuncCmdDebugMarkerBeginEXT) {
	return func(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pMarkerInfo   *C.VkDebugMarkerMarkerInfoEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if markerInfo != nil {
			c.pMarkerInfo = (*C.VkDebugMarkerMarkerInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerMarkerInfoEXT))
			markerInfo.toC(c.pMarkerInfo, m)
		} else {
			c.pMarkerInfo = nil
		}
		C.callPFN_vkCmdDebugMarkerBeginEXT(C.PFN_vkCmdDebugMarkerBeginEXT(unsafe.Pointer(p)), c.commandBuffer, c.pMarkerInfo)
	}
}

type PFNCmdDebugMarkerEndEXT C.PFN_vkCmdDebugMarkerEndEXT
type FuncCmdDebugMarkerEndEXT func(commandBuffer CommandBuffer)

func ToCmdDebugMarkerEndEXT(p PFNVoidFunction) (fn FuncCmdDebugMarkerEndEXT) {
	return func(commandBuffer CommandBuffer) {
		var c struct{ commandBuffer C.VkCommandBuffer }
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		C.callPFN_vkCmdDebugMarkerEndEXT(C.PFN_vkCmdDebugMarkerEndEXT(unsafe.Pointer(p)), c.commandBuffer)
	}
}

type PFNCmdDebugMarkerInsertEXT C.PFN_vkCmdDebugMarkerInsertEXT
type FuncCmdDebugMarkerInsertEXT func(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT)

func ToCmdDebugMarkerInsertEXT(p PFNVoidFunction) (fn FuncCmdDebugMarkerInsertEXT) {
	return func(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pMarkerInfo   *C.VkDebugMarkerMarkerInfoEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if markerInfo != nil {
			c.pMarkerInfo = (*C.VkDebugMarkerMarkerInfoEXT)(m.alloc(C.sizeof_VkDebugMarkerMarkerInfoEXT))
			markerInfo.toC(c.pMarkerInfo, m)
		} else {
			c.pMarkerInfo = nil
		}
		C.callPFN_vkCmdDebugMarkerInsertEXT(C.PFN_vkCmdDebugMarkerInsertEXT(unsafe.Pointer(p)), c.commandBuffer, c.pMarkerInfo)
	}
}

type PFNCmdDrawIndirectCountAMD C.PFN_vkCmdDrawIndirectCountAMD
type FuncCmdDrawIndirectCountAMD func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32)

func ToCmdDrawIndirectCountAMD(p PFNVoidFunction) (fn FuncCmdDrawIndirectCountAMD) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			buffer            C.VkBuffer
			offset            C.VkDeviceSize
			countBuffer       C.VkBuffer
			countBufferOffset C.VkDeviceSize
			maxDrawCount      C.uint32_t
			stride            C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.countBuffer = C.VkBuffer(countBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(countBufferOffset))
			c.countBufferOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.maxDrawCount = C.uint32_t(maxDrawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndirectCountAMD(C.PFN_vkCmdDrawIndirectCountAMD(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.countBuffer, c.countBufferOffset, c.maxDrawCount, c.stride)
	}
}

type PFNCmdDrawIndexedIndirectCountAMD C.PFN_vkCmdDrawIndexedIndirectCountAMD
type FuncCmdDrawIndexedIndirectCountAMD func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32)

func ToCmdDrawIndexedIndirectCountAMD(p PFNVoidFunction) (fn FuncCmdDrawIndexedIndirectCountAMD) {
	return func(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			buffer            C.VkBuffer
			offset            C.VkDeviceSize
			countBuffer       C.VkBuffer
			countBufferOffset C.VkDeviceSize
			maxDrawCount      C.uint32_t
			stride            C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.buffer = C.VkBuffer(buffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(offset))
			c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.countBuffer = C.VkBuffer(countBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(countBufferOffset))
			c.countBufferOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.maxDrawCount = C.uint32_t(maxDrawCount)
		c.stride = C.uint32_t(stride)
		C.callPFN_vkCmdDrawIndexedIndirectCountAMD(C.PFN_vkCmdDrawIndexedIndirectCountAMD(unsafe.Pointer(p)), c.commandBuffer, c.buffer, c.offset, c.countBuffer, c.countBufferOffset, c.maxDrawCount, c.stride)
	}
}

type ShaderInfoTypeAMD int

const (
	SHADER_INFO_TYPE_STATISTICS_AMD  ShaderInfoTypeAMD = 0
	SHADER_INFO_TYPE_BINARY_AMD      ShaderInfoTypeAMD = 1
	SHADER_INFO_TYPE_DISASSEMBLY_AMD ShaderInfoTypeAMD = 2
	SHADER_INFO_TYPE_BEGIN_RANGE_AMD ShaderInfoTypeAMD = SHADER_INFO_TYPE_STATISTICS_AMD
	SHADER_INFO_TYPE_END_RANGE_AMD   ShaderInfoTypeAMD = SHADER_INFO_TYPE_DISASSEMBLY_AMD
	SHADER_INFO_TYPE_RANGE_SIZE_AMD  ShaderInfoTypeAMD = (SHADER_INFO_TYPE_DISASSEMBLY_AMD - SHADER_INFO_TYPE_STATISTICS_AMD + 1)
	SHADER_INFO_TYPE_MAX_ENUM_AMD    ShaderInfoTypeAMD = 2147483647
)

type PFNGetShaderInfoAMD C.PFN_vkGetShaderInfoAMD
type FuncGetShaderInfoAMD func(device Device, pipeline Pipeline, shaderStage ShaderStageFlagBits, infoType ShaderInfoTypeAMD, infoSize *uint, info unsafe.Pointer) (_ret Result)

func ToGetShaderInfoAMD(p PFNVoidFunction) (fn FuncGetShaderInfoAMD) {
	return func(device Device, pipeline Pipeline, shaderStage ShaderStageFlagBits, infoType ShaderInfoTypeAMD, infoSize *uint, info unsafe.Pointer) (_ret Result) {
		var c struct {
			device      C.VkDevice
			pipeline    C.VkPipeline
			shaderStage C.VkShaderStageFlagBits
			infoType    C.VkShaderInfoTypeAMD
			pInfoSize   *C.size_t
			pInfo       unsafe.Pointer
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.pipeline = C.VkPipeline(pipeline)
		c.shaderStage = C.VkShaderStageFlagBits(shaderStage)
		c.infoType = C.VkShaderInfoTypeAMD(infoType)
		if infoSize != nil {
			c.pInfoSize = (*C.size_t)(m.alloc(C.sizeof_size_t))
			*c.pInfoSize = C.size_t(*infoSize)
		} else {
			c.pInfoSize = nil
		}
		c.pInfo = info
		c._ret = C.callPFN_vkGetShaderInfoAMD(C.PFN_vkGetShaderInfoAMD(unsafe.Pointer(p)), c.device, c.pipeline, c.shaderStage, c.infoType, c.pInfoSize, c.pInfo)
		_ret = Result(c._ret)
		if infoSize != nil {
			*infoSize = uint(*c.pInfoSize)
		}
		return
	}
}

type ExternalMemoryHandleTypeFlagBitsNV int

const (
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV     ExternalMemoryHandleTypeFlagBitsNV = 1
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV ExternalMemoryHandleTypeFlagBitsNV = 2
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV      ExternalMemoryHandleTypeFlagBitsNV = 4
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV  ExternalMemoryHandleTypeFlagBitsNV = 8
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV   ExternalMemoryHandleTypeFlagBitsNV = 2147483647
)

type ExternalMemoryFeatureFlagBitsNV int

const (
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV ExternalMemoryFeatureFlagBitsNV = 1
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV     ExternalMemoryFeatureFlagBitsNV = 2
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV     ExternalMemoryFeatureFlagBitsNV = 4
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV ExternalMemoryFeatureFlagBitsNV = 2147483647
)

type PFNGetPhysicalDeviceExternalImageFormatPropertiesNV C.PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV
type ExternalMemoryHandleTypeFlagsNV Flags
type ExternalMemoryFeatureFlagsNV Flags
type ExternalImageFormatPropertiesNV struct {
	ImageFormatProperties         ImageFormatProperties
	ExternalMemoryFeatures        ExternalMemoryFeatureFlagsNV
	ExportFromImportedHandleTypes ExternalMemoryHandleTypeFlagsNV
	CompatibleHandleTypes         ExternalMemoryHandleTypeFlagsNV
}

func (g *ExternalImageFormatPropertiesNV) toC(c *C.VkExternalImageFormatPropertiesNV) {
	g.ImageFormatProperties.toC(&c.imageFormatProperties)
	{
		var temp_in_VkExternalMemoryFeatureFlagsNV C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExternalMemoryFeatures)))
			temp_in_VkExternalMemoryFeatureFlagsNV = C.VkFlags(temp_in_VkFlags)
		}
		c.externalMemoryFeatures = C.VkExternalMemoryFeatureFlagsNV(temp_in_VkExternalMemoryFeatureFlagsNV)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlagsNV C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ExportFromImportedHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlagsNV = C.VkFlags(temp_in_VkFlags)
		}
		c.exportFromImportedHandleTypes = C.VkExternalMemoryHandleTypeFlagsNV(temp_in_VkExternalMemoryHandleTypeFlagsNV)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlagsNV C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.CompatibleHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlagsNV = C.VkFlags(temp_in_VkFlags)
		}
		c.compatibleHandleTypes = C.VkExternalMemoryHandleTypeFlagsNV(temp_in_VkExternalMemoryHandleTypeFlagsNV)
	}
}
func (g *ExternalImageFormatPropertiesNV) fromC(c *C.VkExternalImageFormatPropertiesNV) {
	g.ImageFormatProperties.fromC(&c.imageFormatProperties)
	{
		var temp_in_VkExternalMemoryFeatureFlagsNV Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.externalMemoryFeatures)))
			temp_in_VkExternalMemoryFeatureFlagsNV = Flags(temp_in_VkFlags)
		}
		g.ExternalMemoryFeatures = ExternalMemoryFeatureFlagsNV(temp_in_VkExternalMemoryFeatureFlagsNV)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlagsNV Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.exportFromImportedHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlagsNV = Flags(temp_in_VkFlags)
		}
		g.ExportFromImportedHandleTypes = ExternalMemoryHandleTypeFlagsNV(temp_in_VkExternalMemoryHandleTypeFlagsNV)
	}
	{
		var temp_in_VkExternalMemoryHandleTypeFlagsNV Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.compatibleHandleTypes)))
			temp_in_VkExternalMemoryHandleTypeFlagsNV = Flags(temp_in_VkFlags)
		}
		g.CompatibleHandleTypes = ExternalMemoryHandleTypeFlagsNV(temp_in_VkExternalMemoryHandleTypeFlagsNV)
	}
}

type FuncGetPhysicalDeviceExternalImageFormatPropertiesNV func(physicalDevice PhysicalDevice, format Format, _type ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, externalHandleType ExternalMemoryHandleTypeFlagsNV, externalImageFormatProperties *ExternalImageFormatPropertiesNV) (_ret Result)

func ToGetPhysicalDeviceExternalImageFormatPropertiesNV(p PFNVoidFunction) (fn FuncGetPhysicalDeviceExternalImageFormatPropertiesNV) {
	return func(physicalDevice PhysicalDevice, format Format, _type ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, externalHandleType ExternalMemoryHandleTypeFlagsNV, externalImageFormatProperties *ExternalImageFormatPropertiesNV) (_ret Result) {
		var c struct {
			physicalDevice                 C.VkPhysicalDevice
			format                         C.VkFormat
			_type                          C.VkImageType
			tiling                         C.VkImageTiling
			usage                          C.VkImageUsageFlags
			flags                          C.VkImageCreateFlags
			externalHandleType             C.VkExternalMemoryHandleTypeFlagsNV
			pExternalImageFormatProperties *C.VkExternalImageFormatPropertiesNV
			_ret                           C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.format = C.VkFormat(format)
		c._type = C.VkImageType(_type)
		c.tiling = C.VkImageTiling(tiling)
		{
			var temp_in_VkImageUsageFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(usage)))
				temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.usage = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
		}
		{
			var temp_in_VkImageCreateFlags C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(flags)))
				temp_in_VkImageCreateFlags = C.VkFlags(temp_in_VkFlags)
			}
			c.flags = C.VkImageCreateFlags(temp_in_VkImageCreateFlags)
		}
		{
			var temp_in_VkExternalMemoryHandleTypeFlagsNV C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(externalHandleType)))
				temp_in_VkExternalMemoryHandleTypeFlagsNV = C.VkFlags(temp_in_VkFlags)
			}
			c.externalHandleType = C.VkExternalMemoryHandleTypeFlagsNV(temp_in_VkExternalMemoryHandleTypeFlagsNV)
		}
		if externalImageFormatProperties != nil {
			c.pExternalImageFormatProperties = (*C.VkExternalImageFormatPropertiesNV)(m.alloc(C.sizeof_VkExternalImageFormatPropertiesNV))
			externalImageFormatProperties.toC(c.pExternalImageFormatProperties)
		} else {
			c.pExternalImageFormatProperties = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(C.PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(unsafe.Pointer(p)), c.physicalDevice, c.format, c._type, c.tiling, c.usage, c.flags, c.externalHandleType, c.pExternalImageFormatProperties)
		_ret = Result(c._ret)
		if externalImageFormatProperties != nil {
			externalImageFormatProperties.fromC(c.pExternalImageFormatProperties)
		}
		return
	}
}

type ValidationCheckEXT int

const (
	VALIDATION_CHECK_ALL_EXT         ValidationCheckEXT = 0
	VALIDATION_CHECK_SHADERS_EXT     ValidationCheckEXT = 1
	VALIDATION_CHECK_BEGIN_RANGE_EXT ValidationCheckEXT = VALIDATION_CHECK_ALL_EXT
	VALIDATION_CHECK_END_RANGE_EXT   ValidationCheckEXT = VALIDATION_CHECK_SHADERS_EXT
	VALIDATION_CHECK_RANGE_SIZE_EXT  ValidationCheckEXT = (VALIDATION_CHECK_SHADERS_EXT - VALIDATION_CHECK_ALL_EXT + 1)
	VALIDATION_CHECK_MAX_ENUM_EXT    ValidationCheckEXT = 2147483647
)

type ConditionalRenderingFlagBitsEXT int

const (
	CONDITIONAL_RENDERING_INVERTED_BIT_EXT       ConditionalRenderingFlagBitsEXT = 1
	CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT ConditionalRenderingFlagBitsEXT = 2147483647
)

type PFNCmdBeginConditionalRenderingEXT C.PFN_vkCmdBeginConditionalRenderingEXT
type ConditionalRenderingFlagsEXT Flags
type ConditionalRenderingBeginInfoEXT struct {
	Next   Structure
	Buffer Buffer
	Offset DeviceSize
	Flags  ConditionalRenderingFlagsEXT
}

func (g *ConditionalRenderingBeginInfoEXT) toC(c *C.VkConditionalRenderingBeginInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.buffer = C.VkBuffer(g.Buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkConditionalRenderingFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkConditionalRenderingFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkConditionalRenderingFlagsEXT(temp_in_VkConditionalRenderingFlagsEXT)
	}
}
func (g *ConditionalRenderingBeginInfoEXT) fromC(c *C.VkConditionalRenderingBeginInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Buffer = Buffer(c.buffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
	{
		var temp_in_VkConditionalRenderingFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkConditionalRenderingFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.Flags = ConditionalRenderingFlagsEXT(temp_in_VkConditionalRenderingFlagsEXT)
	}
}
func (s *ConditionalRenderingBeginInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
}
func (s *ConditionalRenderingBeginInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkConditionalRenderingBeginInfoEXT)(m.alloc(C.sizeof_VkConditionalRenderingBeginInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ConditionalRenderingBeginInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkConditionalRenderingBeginInfoEXT)(p)
	s.fromC(c)
}
func (s *ConditionalRenderingBeginInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *ConditionalRenderingBeginInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdBeginConditionalRenderingEXT func(commandBuffer CommandBuffer, conditionalRenderingBegin *ConditionalRenderingBeginInfoEXT)

func ToCmdBeginConditionalRenderingEXT(p PFNVoidFunction) (fn FuncCmdBeginConditionalRenderingEXT) {
	return func(commandBuffer CommandBuffer, conditionalRenderingBegin *ConditionalRenderingBeginInfoEXT) {
		var c struct {
			commandBuffer              C.VkCommandBuffer
			pConditionalRenderingBegin *C.VkConditionalRenderingBeginInfoEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if conditionalRenderingBegin != nil {
			c.pConditionalRenderingBegin = (*C.VkConditionalRenderingBeginInfoEXT)(m.alloc(C.sizeof_VkConditionalRenderingBeginInfoEXT))
			conditionalRenderingBegin.toC(c.pConditionalRenderingBegin, m)
		} else {
			c.pConditionalRenderingBegin = nil
		}
		C.callPFN_vkCmdBeginConditionalRenderingEXT(C.PFN_vkCmdBeginConditionalRenderingEXT(unsafe.Pointer(p)), c.commandBuffer, c.pConditionalRenderingBegin)
	}
}

type PFNCmdEndConditionalRenderingEXT C.PFN_vkCmdEndConditionalRenderingEXT
type FuncCmdEndConditionalRenderingEXT func(commandBuffer CommandBuffer)

func ToCmdEndConditionalRenderingEXT(p PFNVoidFunction) (fn FuncCmdEndConditionalRenderingEXT) {
	return func(commandBuffer CommandBuffer) {
		var c struct{ commandBuffer C.VkCommandBuffer }
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		C.callPFN_vkCmdEndConditionalRenderingEXT(C.PFN_vkCmdEndConditionalRenderingEXT(unsafe.Pointer(p)), c.commandBuffer)
	}
}

type IndirectCommandsTokenTypeNVX int

const (
	INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX       IndirectCommandsTokenTypeNVX = 0
	INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX IndirectCommandsTokenTypeNVX = 1
	INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX   IndirectCommandsTokenTypeNVX = 2
	INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX  IndirectCommandsTokenTypeNVX = 3
	INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX  IndirectCommandsTokenTypeNVX = 4
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX   IndirectCommandsTokenTypeNVX = 5
	INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX           IndirectCommandsTokenTypeNVX = 6
	INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX       IndirectCommandsTokenTypeNVX = 7
	INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX    IndirectCommandsTokenTypeNVX = INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX
	INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX      IndirectCommandsTokenTypeNVX = INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX
	INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX     IndirectCommandsTokenTypeNVX = (INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX - INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX + 1)
	INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX       IndirectCommandsTokenTypeNVX = 2147483647
)

type ObjectEntryTypeNVX int

const (
	OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX ObjectEntryTypeNVX = 0
	OBJECT_ENTRY_TYPE_PIPELINE_NVX       ObjectEntryTypeNVX = 1
	OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX   ObjectEntryTypeNVX = 2
	OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX  ObjectEntryTypeNVX = 3
	OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX  ObjectEntryTypeNVX = 4
	OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX    ObjectEntryTypeNVX = OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX
	OBJECT_ENTRY_TYPE_END_RANGE_NVX      ObjectEntryTypeNVX = OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX
	OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX     ObjectEntryTypeNVX = (OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX - OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX + 1)
	OBJECT_ENTRY_TYPE_MAX_ENUM_NVX       ObjectEntryTypeNVX = 2147483647
)

type IndirectCommandsLayoutUsageFlagBitsNVX int

const (
	INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX IndirectCommandsLayoutUsageFlagBitsNVX = 1
	INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX    IndirectCommandsLayoutUsageFlagBitsNVX = 2
	INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX    IndirectCommandsLayoutUsageFlagBitsNVX = 4
	INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX   IndirectCommandsLayoutUsageFlagBitsNVX = 8
	INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX      IndirectCommandsLayoutUsageFlagBitsNVX = 2147483647
)

type ObjectEntryUsageFlagBitsNVX int

const (
	OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX       ObjectEntryUsageFlagBitsNVX = 1
	OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX        ObjectEntryUsageFlagBitsNVX = 2
	OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX ObjectEntryUsageFlagBitsNVX = 2147483647
)

type PFNCmdProcessCommandsNVX C.PFN_vkCmdProcessCommandsNVX
type ObjectTableNVX C.VkObjectTableNVX
type IndirectCommandsLayoutNVX C.VkIndirectCommandsLayoutNVX
type IndirectCommandsTokenNVX struct {
	TokenType IndirectCommandsTokenTypeNVX
	Buffer    Buffer
	Offset    DeviceSize
}

func (g *IndirectCommandsTokenNVX) toC(c *C.VkIndirectCommandsTokenNVX) {
	c.tokenType = C.VkIndirectCommandsTokenTypeNVX(g.TokenType)
	c.buffer = C.VkBuffer(g.Buffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.Offset))
		c.offset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *IndirectCommandsTokenNVX) fromC(c *C.VkIndirectCommandsTokenNVX) {
	g.TokenType = IndirectCommandsTokenTypeNVX(c.tokenType)
	g.Buffer = Buffer(c.buffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.offset))
		g.Offset = DeviceSize(temp_in_VkDeviceSize)
	}
}

type CmdProcessCommandsInfoNVX struct {
	Next                   Structure
	ObjectTable            ObjectTableNVX
	IndirectCommandsLayout IndirectCommandsLayoutNVX
	IndirectCommandsTokens []IndirectCommandsTokenNVX
	MaxSequencesCount      uint32
	TargetCommandBuffer    CommandBuffer
	SequencesCountBuffer   Buffer
	SequencesCountOffset   DeviceSize
	SequencesIndexBuffer   Buffer
	SequencesIndexOffset   DeviceSize
}

func (g *CmdProcessCommandsInfoNVX) toC(c *C.VkCmdProcessCommandsInfoNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectTable = C.VkObjectTableNVX(g.ObjectTable)
	c.indirectCommandsLayout = C.VkIndirectCommandsLayoutNVX(g.IndirectCommandsLayout)
	c.indirectCommandsTokenCount = C.uint32_t(len(g.IndirectCommandsTokens))
	if len(g.IndirectCommandsTokens) != 0 {
		c.pIndirectCommandsTokens = (*C.VkIndirectCommandsTokenNVX)(m.alloc(C.sizeof_VkIndirectCommandsTokenNVX * uint(len(g.IndirectCommandsTokens))))
		slice1 := (*[1 << 31]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(c.pIndirectCommandsTokens))[:len(g.IndirectCommandsTokens):len(g.IndirectCommandsTokens)]
		for i1, _ := range g.IndirectCommandsTokens {
			g.IndirectCommandsTokens[i1].toC(&slice1[i1])
		}
	} else {
		c.pIndirectCommandsTokens = nil
	}
	c.maxSequencesCount = C.uint32_t(g.MaxSequencesCount)
	c.targetCommandBuffer = C.VkCommandBuffer(g.TargetCommandBuffer)
	c.sequencesCountBuffer = C.VkBuffer(g.SequencesCountBuffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.SequencesCountOffset))
		c.sequencesCountOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
	c.sequencesIndexBuffer = C.VkBuffer(g.SequencesIndexBuffer)
	{
		var temp_in_VkDeviceSize C.uint64_t
		temp_in_VkDeviceSize = C.uint64_t((uint64)(g.SequencesIndexOffset))
		c.sequencesIndexOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
	}
}
func (g *CmdProcessCommandsInfoNVX) fromC(c *C.VkCmdProcessCommandsInfoNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectTable = ObjectTableNVX(c.objectTable)
	g.IndirectCommandsLayout = IndirectCommandsLayoutNVX(c.indirectCommandsLayout)
	g.IndirectCommandsTokens = make([]IndirectCommandsTokenNVX, int(c.indirectCommandsTokenCount))
	if len(g.IndirectCommandsTokens) != 0 {
		slice1 := (*[1 << 31]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(c.pIndirectCommandsTokens))[:len(g.IndirectCommandsTokens):len(g.IndirectCommandsTokens)]
		for i1, _ := range g.IndirectCommandsTokens {
			g.IndirectCommandsTokens[i1].fromC(&slice1[i1])
		}
	}
	g.MaxSequencesCount = uint32(c.maxSequencesCount)
	g.TargetCommandBuffer = CommandBuffer(c.targetCommandBuffer)
	g.SequencesCountBuffer = Buffer(c.sequencesCountBuffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.sequencesCountOffset))
		g.SequencesCountOffset = DeviceSize(temp_in_VkDeviceSize)
	}
	g.SequencesIndexBuffer = Buffer(c.sequencesIndexBuffer)
	{
		var temp_in_VkDeviceSize uint64
		temp_in_VkDeviceSize = uint64((C.uint64_t)(c.sequencesIndexOffset))
		g.SequencesIndexOffset = DeviceSize(temp_in_VkDeviceSize)
	}
}
func (s *CmdProcessCommandsInfoNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX
}
func (s *CmdProcessCommandsInfoNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCmdProcessCommandsInfoNVX)(m.alloc(C.sizeof_VkCmdProcessCommandsInfoNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CmdProcessCommandsInfoNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCmdProcessCommandsInfoNVX)(p)
	s.fromC(c)
}
func (s *CmdProcessCommandsInfoNVX) GetNext() Structure {
	return s.Next
}
func (s *CmdProcessCommandsInfoNVX) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdProcessCommandsNVX func(commandBuffer CommandBuffer, processCommandsInfo *CmdProcessCommandsInfoNVX)

func ToCmdProcessCommandsNVX(p PFNVoidFunction) (fn FuncCmdProcessCommandsNVX) {
	return func(commandBuffer CommandBuffer, processCommandsInfo *CmdProcessCommandsInfoNVX) {
		var c struct {
			commandBuffer        C.VkCommandBuffer
			pProcessCommandsInfo *C.VkCmdProcessCommandsInfoNVX
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if processCommandsInfo != nil {
			c.pProcessCommandsInfo = (*C.VkCmdProcessCommandsInfoNVX)(m.alloc(C.sizeof_VkCmdProcessCommandsInfoNVX))
			processCommandsInfo.toC(c.pProcessCommandsInfo, m)
		} else {
			c.pProcessCommandsInfo = nil
		}
		C.callPFN_vkCmdProcessCommandsNVX(C.PFN_vkCmdProcessCommandsNVX(unsafe.Pointer(p)), c.commandBuffer, c.pProcessCommandsInfo)
	}
}

type PFNCmdReserveSpaceForCommandsNVX C.PFN_vkCmdReserveSpaceForCommandsNVX
type CmdReserveSpaceForCommandsInfoNVX struct {
	Next                   Structure
	ObjectTable            ObjectTableNVX
	IndirectCommandsLayout IndirectCommandsLayoutNVX
	MaxSequencesCount      uint32
}

func (g *CmdReserveSpaceForCommandsInfoNVX) toC(c *C.VkCmdReserveSpaceForCommandsInfoNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectTable = C.VkObjectTableNVX(g.ObjectTable)
	c.indirectCommandsLayout = C.VkIndirectCommandsLayoutNVX(g.IndirectCommandsLayout)
	c.maxSequencesCount = C.uint32_t(g.MaxSequencesCount)
}
func (g *CmdReserveSpaceForCommandsInfoNVX) fromC(c *C.VkCmdReserveSpaceForCommandsInfoNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectTable = ObjectTableNVX(c.objectTable)
	g.IndirectCommandsLayout = IndirectCommandsLayoutNVX(c.indirectCommandsLayout)
	g.MaxSequencesCount = uint32(c.maxSequencesCount)
}
func (s *CmdReserveSpaceForCommandsInfoNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX
}
func (s *CmdReserveSpaceForCommandsInfoNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCmdReserveSpaceForCommandsInfoNVX)(m.alloc(C.sizeof_VkCmdReserveSpaceForCommandsInfoNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CmdReserveSpaceForCommandsInfoNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCmdReserveSpaceForCommandsInfoNVX)(p)
	s.fromC(c)
}
func (s *CmdReserveSpaceForCommandsInfoNVX) GetNext() Structure {
	return s.Next
}
func (s *CmdReserveSpaceForCommandsInfoNVX) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdReserveSpaceForCommandsNVX func(commandBuffer CommandBuffer, reserveSpaceInfo *CmdReserveSpaceForCommandsInfoNVX)

func ToCmdReserveSpaceForCommandsNVX(p PFNVoidFunction) (fn FuncCmdReserveSpaceForCommandsNVX) {
	return func(commandBuffer CommandBuffer, reserveSpaceInfo *CmdReserveSpaceForCommandsInfoNVX) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			pReserveSpaceInfo *C.VkCmdReserveSpaceForCommandsInfoNVX
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if reserveSpaceInfo != nil {
			c.pReserveSpaceInfo = (*C.VkCmdReserveSpaceForCommandsInfoNVX)(m.alloc(C.sizeof_VkCmdReserveSpaceForCommandsInfoNVX))
			reserveSpaceInfo.toC(c.pReserveSpaceInfo, m)
		} else {
			c.pReserveSpaceInfo = nil
		}
		C.callPFN_vkCmdReserveSpaceForCommandsNVX(C.PFN_vkCmdReserveSpaceForCommandsNVX(unsafe.Pointer(p)), c.commandBuffer, c.pReserveSpaceInfo)
	}
}

type PFNCreateIndirectCommandsLayoutNVX C.PFN_vkCreateIndirectCommandsLayoutNVX
type IndirectCommandsLayoutUsageFlagsNVX Flags
type IndirectCommandsLayoutTokenNVX struct {
	TokenType    IndirectCommandsTokenTypeNVX
	BindingUnit  uint32
	DynamicCount uint32
	Divisor      uint32
}

func (g *IndirectCommandsLayoutTokenNVX) toC(c *C.VkIndirectCommandsLayoutTokenNVX) {
	c.tokenType = C.VkIndirectCommandsTokenTypeNVX(g.TokenType)
	c.bindingUnit = C.uint32_t(g.BindingUnit)
	c.dynamicCount = C.uint32_t(g.DynamicCount)
	c.divisor = C.uint32_t(g.Divisor)
}
func (g *IndirectCommandsLayoutTokenNVX) fromC(c *C.VkIndirectCommandsLayoutTokenNVX) {
	g.TokenType = IndirectCommandsTokenTypeNVX(c.tokenType)
	g.BindingUnit = uint32(c.bindingUnit)
	g.DynamicCount = uint32(c.dynamicCount)
	g.Divisor = uint32(c.divisor)
}

type IndirectCommandsLayoutCreateInfoNVX struct {
	Next              Structure
	PipelineBindPoint PipelineBindPoint
	Flags             IndirectCommandsLayoutUsageFlagsNVX
	Tokens            []IndirectCommandsLayoutTokenNVX
}

func (g *IndirectCommandsLayoutCreateInfoNVX) toC(c *C.VkIndirectCommandsLayoutCreateInfoNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.pipelineBindPoint = C.VkPipelineBindPoint(g.PipelineBindPoint)
	{
		var temp_in_VkIndirectCommandsLayoutUsageFlagsNVX C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkIndirectCommandsLayoutUsageFlagsNVX = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkIndirectCommandsLayoutUsageFlagsNVX(temp_in_VkIndirectCommandsLayoutUsageFlagsNVX)
	}
	c.tokenCount = C.uint32_t(len(g.Tokens))
	if len(g.Tokens) != 0 {
		c.pTokens = (*C.VkIndirectCommandsLayoutTokenNVX)(m.alloc(C.sizeof_VkIndirectCommandsLayoutTokenNVX * uint(len(g.Tokens))))
		slice1 := (*[1 << 31]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(c.pTokens))[:len(g.Tokens):len(g.Tokens)]
		for i1, _ := range g.Tokens {
			g.Tokens[i1].toC(&slice1[i1])
		}
	} else {
		c.pTokens = nil
	}
}
func (g *IndirectCommandsLayoutCreateInfoNVX) fromC(c *C.VkIndirectCommandsLayoutCreateInfoNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.PipelineBindPoint = PipelineBindPoint(c.pipelineBindPoint)
	{
		var temp_in_VkIndirectCommandsLayoutUsageFlagsNVX Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkIndirectCommandsLayoutUsageFlagsNVX = Flags(temp_in_VkFlags)
		}
		g.Flags = IndirectCommandsLayoutUsageFlagsNVX(temp_in_VkIndirectCommandsLayoutUsageFlagsNVX)
	}
	g.Tokens = make([]IndirectCommandsLayoutTokenNVX, int(c.tokenCount))
	if len(g.Tokens) != 0 {
		slice1 := (*[1 << 31]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(c.pTokens))[:len(g.Tokens):len(g.Tokens)]
		for i1, _ := range g.Tokens {
			g.Tokens[i1].fromC(&slice1[i1])
		}
	}
}
func (s *IndirectCommandsLayoutCreateInfoNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX
}
func (s *IndirectCommandsLayoutCreateInfoNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkIndirectCommandsLayoutCreateInfoNVX)(m.alloc(C.sizeof_VkIndirectCommandsLayoutCreateInfoNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *IndirectCommandsLayoutCreateInfoNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkIndirectCommandsLayoutCreateInfoNVX)(p)
	s.fromC(c)
}
func (s *IndirectCommandsLayoutCreateInfoNVX) GetNext() Structure {
	return s.Next
}
func (s *IndirectCommandsLayoutCreateInfoNVX) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateIndirectCommandsLayoutNVX func(device Device, createInfo *IndirectCommandsLayoutCreateInfoNVX, allocator *AllocationCallbacks, indirectCommandsLayout *IndirectCommandsLayoutNVX) (_ret Result)

func ToCreateIndirectCommandsLayoutNVX(p PFNVoidFunction) (fn FuncCreateIndirectCommandsLayoutNVX) {
	return func(device Device, createInfo *IndirectCommandsLayoutCreateInfoNVX, allocator *AllocationCallbacks, indirectCommandsLayout *IndirectCommandsLayoutNVX) (_ret Result) {
		var c struct {
			device                  C.VkDevice
			pCreateInfo             *C.VkIndirectCommandsLayoutCreateInfoNVX
			pAllocator              *C.VkAllocationCallbacks
			pIndirectCommandsLayout *C.VkIndirectCommandsLayoutNVX
			_ret                    C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkIndirectCommandsLayoutCreateInfoNVX)(m.alloc(C.sizeof_VkIndirectCommandsLayoutCreateInfoNVX))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if indirectCommandsLayout != nil {
			c.pIndirectCommandsLayout = (*C.VkIndirectCommandsLayoutNVX)(m.alloc(C.sizeof_VkIndirectCommandsLayoutNVX))
			*c.pIndirectCommandsLayout = C.VkIndirectCommandsLayoutNVX(*indirectCommandsLayout)
		} else {
			c.pIndirectCommandsLayout = nil
		}
		c._ret = C.callPFN_vkCreateIndirectCommandsLayoutNVX(C.PFN_vkCreateIndirectCommandsLayoutNVX(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pIndirectCommandsLayout)
		_ret = Result(c._ret)
		if indirectCommandsLayout != nil {
			*indirectCommandsLayout = IndirectCommandsLayoutNVX(*c.pIndirectCommandsLayout)
		}
		return
	}
}

type PFNDestroyIndirectCommandsLayoutNVX C.PFN_vkDestroyIndirectCommandsLayoutNVX
type FuncDestroyIndirectCommandsLayoutNVX func(device Device, indirectCommandsLayout IndirectCommandsLayoutNVX, allocator *AllocationCallbacks)

func ToDestroyIndirectCommandsLayoutNVX(p PFNVoidFunction) (fn FuncDestroyIndirectCommandsLayoutNVX) {
	return func(device Device, indirectCommandsLayout IndirectCommandsLayoutNVX, allocator *AllocationCallbacks) {
		var c struct {
			device                 C.VkDevice
			indirectCommandsLayout C.VkIndirectCommandsLayoutNVX
			pAllocator             *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.indirectCommandsLayout = C.VkIndirectCommandsLayoutNVX(indirectCommandsLayout)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyIndirectCommandsLayoutNVX(C.PFN_vkDestroyIndirectCommandsLayoutNVX(unsafe.Pointer(p)), c.device, c.indirectCommandsLayout, c.pAllocator)
	}
}

type PFNCreateObjectTableNVX C.PFN_vkCreateObjectTableNVX
type ObjectEntryUsageFlagsNVX Flags
type ObjectTableCreateInfoNVX struct {
	Next                           Structure
	ObjectEntryTypes               []ObjectEntryTypeNVX
	ObjectEntryCounts              []uint32
	ObjectEntryUsageFlags          []ObjectEntryUsageFlagsNVX
	MaxUniformBuffersPerDescriptor uint32
	MaxStorageBuffersPerDescriptor uint32
	MaxStorageImagesPerDescriptor  uint32
	MaxSampledImagesPerDescriptor  uint32
	MaxPipelineLayouts             uint32
}

func (g *ObjectTableCreateInfoNVX) toC(c *C.VkObjectTableCreateInfoNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectCount = C.uint32_t(len(g.ObjectEntryTypes))
	if len(g.ObjectEntryTypes) != 0 {
		c.pObjectEntryTypes = (*C.VkObjectEntryTypeNVX)(m.alloc(C.sizeof_VkObjectEntryTypeNVX * uint(len(g.ObjectEntryTypes))))
		slice1 := (*[1 << 31]C.VkObjectEntryTypeNVX)(unsafe.Pointer(c.pObjectEntryTypes))[:len(g.ObjectEntryTypes):len(g.ObjectEntryTypes)]
		for i1, _ := range g.ObjectEntryTypes {
			slice1[i1] = C.VkObjectEntryTypeNVX(g.ObjectEntryTypes[i1])
		}
	} else {
		c.pObjectEntryTypes = nil
	}
	if len(g.ObjectEntryCounts) != 0 {
		c.pObjectEntryCounts = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(g.ObjectEntryCounts))))
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pObjectEntryCounts))[:len(g.ObjectEntryCounts):len(g.ObjectEntryCounts)]
		for i1, _ := range g.ObjectEntryCounts {
			slice1[i1] = C.uint32_t(g.ObjectEntryCounts[i1])
		}
	} else {
		c.pObjectEntryCounts = nil
	}
	if len(g.ObjectEntryUsageFlags) != 0 {
		c.pObjectEntryUsageFlags = (*C.VkObjectEntryUsageFlagsNVX)(m.alloc(C.sizeof_VkObjectEntryUsageFlagsNVX * uint(len(g.ObjectEntryUsageFlags))))
		slice1 := (*[1 << 31]C.VkObjectEntryUsageFlagsNVX)(unsafe.Pointer(c.pObjectEntryUsageFlags))[:len(g.ObjectEntryUsageFlags):len(g.ObjectEntryUsageFlags)]
		for i1, _ := range g.ObjectEntryUsageFlags {
			{
				var temp_in_VkObjectEntryUsageFlagsNVX C.VkFlags
				{
					var temp_in_VkFlags C.uint32_t
					temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.ObjectEntryUsageFlags[i1])))
					temp_in_VkObjectEntryUsageFlagsNVX = C.VkFlags(temp_in_VkFlags)
				}
				slice1[i1] = C.VkObjectEntryUsageFlagsNVX(temp_in_VkObjectEntryUsageFlagsNVX)
			}
		}
	} else {
		c.pObjectEntryUsageFlags = nil
	}
	c.maxUniformBuffersPerDescriptor = C.uint32_t(g.MaxUniformBuffersPerDescriptor)
	c.maxStorageBuffersPerDescriptor = C.uint32_t(g.MaxStorageBuffersPerDescriptor)
	c.maxStorageImagesPerDescriptor = C.uint32_t(g.MaxStorageImagesPerDescriptor)
	c.maxSampledImagesPerDescriptor = C.uint32_t(g.MaxSampledImagesPerDescriptor)
	c.maxPipelineLayouts = C.uint32_t(g.MaxPipelineLayouts)
}
func (g *ObjectTableCreateInfoNVX) fromC(c *C.VkObjectTableCreateInfoNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectEntryTypes = make([]ObjectEntryTypeNVX, int(c.objectCount))
	if len(g.ObjectEntryTypes) != 0 {
		slice1 := (*[1 << 31]C.VkObjectEntryTypeNVX)(unsafe.Pointer(c.pObjectEntryTypes))[:len(g.ObjectEntryTypes):len(g.ObjectEntryTypes)]
		for i1, _ := range g.ObjectEntryTypes {
			g.ObjectEntryTypes[i1] = ObjectEntryTypeNVX(slice1[i1])
		}
	}
	if len(g.ObjectEntryCounts) != 0 {
		slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pObjectEntryCounts))[:len(g.ObjectEntryCounts):len(g.ObjectEntryCounts)]
		for i1, _ := range g.ObjectEntryCounts {
			g.ObjectEntryCounts[i1] = uint32(slice1[i1])
		}
	}
	if len(g.ObjectEntryUsageFlags) != 0 {
		slice1 := (*[1 << 31]C.VkObjectEntryUsageFlagsNVX)(unsafe.Pointer(c.pObjectEntryUsageFlags))[:len(g.ObjectEntryUsageFlags):len(g.ObjectEntryUsageFlags)]
		for i1, _ := range g.ObjectEntryUsageFlags {
			{
				var temp_in_VkObjectEntryUsageFlagsNVX Flags
				{
					var temp_in_VkFlags uint32
					temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(slice1[i1])))
					temp_in_VkObjectEntryUsageFlagsNVX = Flags(temp_in_VkFlags)
				}
				g.ObjectEntryUsageFlags[i1] = ObjectEntryUsageFlagsNVX(temp_in_VkObjectEntryUsageFlagsNVX)
			}
		}
	}
	g.MaxUniformBuffersPerDescriptor = uint32(c.maxUniformBuffersPerDescriptor)
	g.MaxStorageBuffersPerDescriptor = uint32(c.maxStorageBuffersPerDescriptor)
	g.MaxStorageImagesPerDescriptor = uint32(c.maxStorageImagesPerDescriptor)
	g.MaxSampledImagesPerDescriptor = uint32(c.maxSampledImagesPerDescriptor)
	g.MaxPipelineLayouts = uint32(c.maxPipelineLayouts)
}
func (s *ObjectTableCreateInfoNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX
}
func (s *ObjectTableCreateInfoNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkObjectTableCreateInfoNVX)(m.alloc(C.sizeof_VkObjectTableCreateInfoNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ObjectTableCreateInfoNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkObjectTableCreateInfoNVX)(p)
	s.fromC(c)
}
func (s *ObjectTableCreateInfoNVX) GetNext() Structure {
	return s.Next
}
func (s *ObjectTableCreateInfoNVX) SetNext(n Structure) {
	s.Next = n
}

type FuncCreateObjectTableNVX func(device Device, createInfo *ObjectTableCreateInfoNVX, allocator *AllocationCallbacks, objectTable *ObjectTableNVX) (_ret Result)

func ToCreateObjectTableNVX(p PFNVoidFunction) (fn FuncCreateObjectTableNVX) {
	return func(device Device, createInfo *ObjectTableCreateInfoNVX, allocator *AllocationCallbacks, objectTable *ObjectTableNVX) (_ret Result) {
		var c struct {
			device       C.VkDevice
			pCreateInfo  *C.VkObjectTableCreateInfoNVX
			pAllocator   *C.VkAllocationCallbacks
			pObjectTable *C.VkObjectTableNVX
			_ret         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkObjectTableCreateInfoNVX)(m.alloc(C.sizeof_VkObjectTableCreateInfoNVX))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if objectTable != nil {
			c.pObjectTable = (*C.VkObjectTableNVX)(m.alloc(C.sizeof_VkObjectTableNVX))
			*c.pObjectTable = C.VkObjectTableNVX(*objectTable)
		} else {
			c.pObjectTable = nil
		}
		c._ret = C.callPFN_vkCreateObjectTableNVX(C.PFN_vkCreateObjectTableNVX(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pObjectTable)
		_ret = Result(c._ret)
		if objectTable != nil {
			*objectTable = ObjectTableNVX(*c.pObjectTable)
		}
		return
	}
}

type PFNDestroyObjectTableNVX C.PFN_vkDestroyObjectTableNVX
type FuncDestroyObjectTableNVX func(device Device, objectTable ObjectTableNVX, allocator *AllocationCallbacks)

func ToDestroyObjectTableNVX(p PFNVoidFunction) (fn FuncDestroyObjectTableNVX) {
	return func(device Device, objectTable ObjectTableNVX, allocator *AllocationCallbacks) {
		var c struct {
			device      C.VkDevice
			objectTable C.VkObjectTableNVX
			pAllocator  *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.objectTable = C.VkObjectTableNVX(objectTable)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyObjectTableNVX(C.PFN_vkDestroyObjectTableNVX(unsafe.Pointer(p)), c.device, c.objectTable, c.pAllocator)
	}
}

type PFNRegisterObjectsNVX C.PFN_vkRegisterObjectsNVX
type ObjectTableEntryNVX struct {
	Type  ObjectEntryTypeNVX
	Flags ObjectEntryUsageFlagsNVX
}

func (g *ObjectTableEntryNVX) toC(c *C.VkObjectTableEntryNVX) {
	c._type = C.VkObjectEntryTypeNVX(g.Type)
	{
		var temp_in_VkObjectEntryUsageFlagsNVX C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkObjectEntryUsageFlagsNVX = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkObjectEntryUsageFlagsNVX(temp_in_VkObjectEntryUsageFlagsNVX)
	}
}
func (g *ObjectTableEntryNVX) fromC(c *C.VkObjectTableEntryNVX) {
	g.Type = ObjectEntryTypeNVX(c._type)
	{
		var temp_in_VkObjectEntryUsageFlagsNVX Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkObjectEntryUsageFlagsNVX = Flags(temp_in_VkFlags)
		}
		g.Flags = ObjectEntryUsageFlagsNVX(temp_in_VkObjectEntryUsageFlagsNVX)
	}
}

type FuncRegisterObjectsNVX func(device Device, objectTable ObjectTableNVX, objectTableEntries []*ObjectTableEntryNVX, objectIndices []uint32) (_ret Result)

func ToRegisterObjectsNVX(p PFNVoidFunction) (fn FuncRegisterObjectsNVX) {
	return func(device Device, objectTable ObjectTableNVX, objectTableEntries []*ObjectTableEntryNVX, objectIndices []uint32) (_ret Result) {
		var c struct {
			device               C.VkDevice
			objectTable          C.VkObjectTableNVX
			objectCount          C.uint32_t
			ppObjectTableEntries **C.VkObjectTableEntryNVX
			pObjectIndices       *C.uint32_t
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.objectTable = C.VkObjectTableNVX(objectTable)
		c.objectCount = C.uint32_t(len(objectTableEntries))
		if len(objectTableEntries) != 0 {
			c.ppObjectTableEntries = (**C.VkObjectTableEntryNVX)(m.alloc(C.sizeof_void_pointer * uint(len(objectTableEntries))))
			slice1 := (*[1 << 31]*C.VkObjectTableEntryNVX)(unsafe.Pointer(c.ppObjectTableEntries))[:len(objectTableEntries):len(objectTableEntries)]
			for i1, _ := range objectTableEntries {
				if objectTableEntries[i1] != nil {
					slice1[i1] = (*C.VkObjectTableEntryNVX)(m.alloc(C.sizeof_VkObjectTableEntryNVX))
					objectTableEntries[i1].toC(slice1[i1])
				} else {
					slice1[i1] = nil
				}
			}
		} else {
			c.ppObjectTableEntries = nil
		}
		if len(objectIndices) != 0 {
			c.pObjectIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(objectIndices))))
			slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pObjectIndices))[:len(objectIndices):len(objectIndices)]
			for i1, _ := range objectIndices {
				slice1[i1] = C.uint32_t(objectIndices[i1])
			}
		} else {
			c.pObjectIndices = nil
		}
		c._ret = C.callPFN_vkRegisterObjectsNVX(C.PFN_vkRegisterObjectsNVX(unsafe.Pointer(p)), c.device, c.objectTable, c.objectCount, c.ppObjectTableEntries, c.pObjectIndices)
		_ret = Result(c._ret)
		return
	}
}

type PFNUnregisterObjectsNVX C.PFN_vkUnregisterObjectsNVX
type FuncUnregisterObjectsNVX func(device Device, objectTable ObjectTableNVX, objectEntryTypes []ObjectEntryTypeNVX, objectIndices []uint32) (_ret Result)

func ToUnregisterObjectsNVX(p PFNVoidFunction) (fn FuncUnregisterObjectsNVX) {
	return func(device Device, objectTable ObjectTableNVX, objectEntryTypes []ObjectEntryTypeNVX, objectIndices []uint32) (_ret Result) {
		var c struct {
			device            C.VkDevice
			objectTable       C.VkObjectTableNVX
			objectCount       C.uint32_t
			pObjectEntryTypes *C.VkObjectEntryTypeNVX
			pObjectIndices    *C.uint32_t
			_ret              C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.objectTable = C.VkObjectTableNVX(objectTable)
		c.objectCount = C.uint32_t(len(objectEntryTypes))
		if len(objectEntryTypes) != 0 {
			c.pObjectEntryTypes = (*C.VkObjectEntryTypeNVX)(m.alloc(C.sizeof_VkObjectEntryTypeNVX * uint(len(objectEntryTypes))))
			slice1 := (*[1 << 31]C.VkObjectEntryTypeNVX)(unsafe.Pointer(c.pObjectEntryTypes))[:len(objectEntryTypes):len(objectEntryTypes)]
			for i1, _ := range objectEntryTypes {
				slice1[i1] = C.VkObjectEntryTypeNVX(objectEntryTypes[i1])
			}
		} else {
			c.pObjectEntryTypes = nil
		}
		if len(objectIndices) != 0 {
			c.pObjectIndices = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t * uint(len(objectIndices))))
			slice1 := (*[1 << 31]C.uint32_t)(unsafe.Pointer(c.pObjectIndices))[:len(objectIndices):len(objectIndices)]
			for i1, _ := range objectIndices {
				slice1[i1] = C.uint32_t(objectIndices[i1])
			}
		} else {
			c.pObjectIndices = nil
		}
		c._ret = C.callPFN_vkUnregisterObjectsNVX(C.PFN_vkUnregisterObjectsNVX(unsafe.Pointer(p)), c.device, c.objectTable, c.objectCount, c.pObjectEntryTypes, c.pObjectIndices)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetPhysicalDeviceGeneratedCommandsPropertiesNVX C.PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX
type DeviceGeneratedCommandsFeaturesNVX struct {
	Next                       Structure
	ComputeBindingPointSupport bool
}

func (g *DeviceGeneratedCommandsFeaturesNVX) toC(c *C.VkDeviceGeneratedCommandsFeaturesNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	if g.ComputeBindingPointSupport {
		c.computeBindingPointSupport = 1
	} else {
		c.computeBindingPointSupport = 0
	}
}
func (g *DeviceGeneratedCommandsFeaturesNVX) fromC(c *C.VkDeviceGeneratedCommandsFeaturesNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ComputeBindingPointSupport = c.computeBindingPointSupport != 0
}
func (s *DeviceGeneratedCommandsFeaturesNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX
}
func (s *DeviceGeneratedCommandsFeaturesNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceGeneratedCommandsFeaturesNVX)(m.alloc(C.sizeof_VkDeviceGeneratedCommandsFeaturesNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceGeneratedCommandsFeaturesNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceGeneratedCommandsFeaturesNVX)(p)
	s.fromC(c)
}
func (s *DeviceGeneratedCommandsFeaturesNVX) GetNext() Structure {
	return s.Next
}
func (s *DeviceGeneratedCommandsFeaturesNVX) SetNext(n Structure) {
	s.Next = n
}

type DeviceGeneratedCommandsLimitsNVX struct {
	Next                                  Structure
	MaxIndirectCommandsLayoutTokenCount   uint32
	MaxObjectEntryCounts                  uint32
	MinSequenceCountBufferOffsetAlignment uint32
	MinSequenceIndexBufferOffsetAlignment uint32
	MinCommandsTokenBufferOffsetAlignment uint32
}

func (g *DeviceGeneratedCommandsLimitsNVX) toC(c *C.VkDeviceGeneratedCommandsLimitsNVX, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.maxIndirectCommandsLayoutTokenCount = C.uint32_t(g.MaxIndirectCommandsLayoutTokenCount)
	c.maxObjectEntryCounts = C.uint32_t(g.MaxObjectEntryCounts)
	c.minSequenceCountBufferOffsetAlignment = C.uint32_t(g.MinSequenceCountBufferOffsetAlignment)
	c.minSequenceIndexBufferOffsetAlignment = C.uint32_t(g.MinSequenceIndexBufferOffsetAlignment)
	c.minCommandsTokenBufferOffsetAlignment = C.uint32_t(g.MinCommandsTokenBufferOffsetAlignment)
}
func (g *DeviceGeneratedCommandsLimitsNVX) fromC(c *C.VkDeviceGeneratedCommandsLimitsNVX) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MaxIndirectCommandsLayoutTokenCount = uint32(c.maxIndirectCommandsLayoutTokenCount)
	g.MaxObjectEntryCounts = uint32(c.maxObjectEntryCounts)
	g.MinSequenceCountBufferOffsetAlignment = uint32(c.minSequenceCountBufferOffsetAlignment)
	g.MinSequenceIndexBufferOffsetAlignment = uint32(c.minSequenceIndexBufferOffsetAlignment)
	g.MinCommandsTokenBufferOffsetAlignment = uint32(c.minCommandsTokenBufferOffsetAlignment)
}
func (s *DeviceGeneratedCommandsLimitsNVX) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX
}
func (s *DeviceGeneratedCommandsLimitsNVX) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceGeneratedCommandsLimitsNVX)(m.alloc(C.sizeof_VkDeviceGeneratedCommandsLimitsNVX))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceGeneratedCommandsLimitsNVX) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceGeneratedCommandsLimitsNVX)(p)
	s.fromC(c)
}
func (s *DeviceGeneratedCommandsLimitsNVX) GetNext() Structure {
	return s.Next
}
func (s *DeviceGeneratedCommandsLimitsNVX) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceGeneratedCommandsPropertiesNVX func(physicalDevice PhysicalDevice, features *DeviceGeneratedCommandsFeaturesNVX, limits *DeviceGeneratedCommandsLimitsNVX)

func ToGetPhysicalDeviceGeneratedCommandsPropertiesNVX(p PFNVoidFunction) (fn FuncGetPhysicalDeviceGeneratedCommandsPropertiesNVX) {
	return func(physicalDevice PhysicalDevice, features *DeviceGeneratedCommandsFeaturesNVX, limits *DeviceGeneratedCommandsLimitsNVX) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			pFeatures      *C.VkDeviceGeneratedCommandsFeaturesNVX
			pLimits        *C.VkDeviceGeneratedCommandsLimitsNVX
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		if features != nil {
			c.pFeatures = (*C.VkDeviceGeneratedCommandsFeaturesNVX)(m.alloc(C.sizeof_VkDeviceGeneratedCommandsFeaturesNVX))
			features.toC(c.pFeatures, m)
		} else {
			c.pFeatures = nil
		}
		if limits != nil {
			c.pLimits = (*C.VkDeviceGeneratedCommandsLimitsNVX)(m.alloc(C.sizeof_VkDeviceGeneratedCommandsLimitsNVX))
			limits.toC(c.pLimits, m)
		} else {
			c.pLimits = nil
		}
		C.callPFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(C.PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(unsafe.Pointer(p)), c.physicalDevice, c.pFeatures, c.pLimits)
		if features != nil {
			features.fromC(c.pFeatures)
		}
		if limits != nil {
			limits.fromC(c.pLimits)
		}
	}
}

type PFNCmdSetViewportWScalingNV C.PFN_vkCmdSetViewportWScalingNV
type ViewportWScalingNV struct {
	Xcoeff float32
	Ycoeff float32
}

func (g *ViewportWScalingNV) toC(c *C.VkViewportWScalingNV) {
	c.xcoeff = C.float(g.Xcoeff)
	c.ycoeff = C.float(g.Ycoeff)
}
func (g *ViewportWScalingNV) fromC(c *C.VkViewportWScalingNV) {
	g.Xcoeff = float32(c.xcoeff)
	g.Ycoeff = float32(c.ycoeff)
}

type FuncCmdSetViewportWScalingNV func(commandBuffer CommandBuffer, firstViewport uint32, viewportWScalings []ViewportWScalingNV)

func ToCmdSetViewportWScalingNV(p PFNVoidFunction) (fn FuncCmdSetViewportWScalingNV) {
	return func(commandBuffer CommandBuffer, firstViewport uint32, viewportWScalings []ViewportWScalingNV) {
		var c struct {
			commandBuffer      C.VkCommandBuffer
			firstViewport      C.uint32_t
			viewportCount      C.uint32_t
			pViewportWScalings *C.VkViewportWScalingNV
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.firstViewport = C.uint32_t(firstViewport)
		c.viewportCount = C.uint32_t(len(viewportWScalings))
		if len(viewportWScalings) != 0 {
			c.pViewportWScalings = (*C.VkViewportWScalingNV)(m.alloc(C.sizeof_VkViewportWScalingNV * uint(len(viewportWScalings))))
			slice1 := (*[1 << 31]C.VkViewportWScalingNV)(unsafe.Pointer(c.pViewportWScalings))[:len(viewportWScalings):len(viewportWScalings)]
			for i1, _ := range viewportWScalings {
				viewportWScalings[i1].toC(&slice1[i1])
			}
		} else {
			c.pViewportWScalings = nil
		}
		C.callPFN_vkCmdSetViewportWScalingNV(C.PFN_vkCmdSetViewportWScalingNV(unsafe.Pointer(p)), c.commandBuffer, c.firstViewport, c.viewportCount, c.pViewportWScalings)
	}
}

type PFNReleaseDisplayEXT C.PFN_vkReleaseDisplayEXT
type FuncReleaseDisplayEXT func(physicalDevice PhysicalDevice, display DisplayKHR) (_ret Result)

func ToReleaseDisplayEXT(p PFNVoidFunction) (fn FuncReleaseDisplayEXT) {
	return func(physicalDevice PhysicalDevice, display DisplayKHR) (_ret Result) {
		var c struct {
			physicalDevice C.VkPhysicalDevice
			display        C.VkDisplayKHR
			_ret           C.VkResult
		}
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.display = C.VkDisplayKHR(display)
		c._ret = C.callPFN_vkReleaseDisplayEXT(C.PFN_vkReleaseDisplayEXT(unsafe.Pointer(p)), c.physicalDevice, c.display)
		_ret = Result(c._ret)
		return
	}
}

type SurfaceCounterFlagBitsEXT int

const (
	SURFACE_COUNTER_VBLANK_EXT             SurfaceCounterFlagBitsEXT = 1
	SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT SurfaceCounterFlagBitsEXT = 2147483647
)

type PFNGetPhysicalDeviceSurfaceCapabilities2EXT C.PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT
type SurfaceCounterFlagsEXT Flags
type SurfaceCapabilities2EXT struct {
	Next                     Structure
	MinImageCount            uint32
	MaxImageCount            uint32
	CurrentExtent            Extent2D
	MinImageExtent           Extent2D
	MaxImageExtent           Extent2D
	MaxImageArrayLayers      uint32
	SupportedTransforms      SurfaceTransformFlagsKHR
	CurrentTransform         SurfaceTransformFlagBitsKHR
	SupportedCompositeAlpha  CompositeAlphaFlagsKHR
	SupportedUsageFlags      ImageUsageFlags
	SupportedSurfaceCounters SurfaceCounterFlagsEXT
}

func (g *SurfaceCapabilities2EXT) toC(c *C.VkSurfaceCapabilities2EXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.minImageCount = C.uint32_t(g.MinImageCount)
	c.maxImageCount = C.uint32_t(g.MaxImageCount)
	g.CurrentExtent.toC(&c.currentExtent)
	g.MinImageExtent.toC(&c.minImageExtent)
	g.MaxImageExtent.toC(&c.maxImageExtent)
	c.maxImageArrayLayers = C.uint32_t(g.MaxImageArrayLayers)
	{
		var temp_in_VkSurfaceTransformFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedTransforms = C.VkSurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	c.currentTransform = C.VkSurfaceTransformFlagBitsKHR(g.CurrentTransform)
	{
		var temp_in_VkCompositeAlphaFlagsKHR C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedCompositeAlpha)))
			temp_in_VkCompositeAlphaFlagsKHR = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedCompositeAlpha = C.VkCompositeAlphaFlagsKHR(temp_in_VkCompositeAlphaFlagsKHR)
	}
	{
		var temp_in_VkImageUsageFlags C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedUsageFlags)))
			temp_in_VkImageUsageFlags = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedUsageFlags = C.VkImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	{
		var temp_in_VkSurfaceCounterFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.SupportedSurfaceCounters)))
			temp_in_VkSurfaceCounterFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.supportedSurfaceCounters = C.VkSurfaceCounterFlagsEXT(temp_in_VkSurfaceCounterFlagsEXT)
	}
}
func (g *SurfaceCapabilities2EXT) fromC(c *C.VkSurfaceCapabilities2EXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MinImageCount = uint32(c.minImageCount)
	g.MaxImageCount = uint32(c.maxImageCount)
	g.CurrentExtent.fromC(&c.currentExtent)
	g.MinImageExtent.fromC(&c.minImageExtent)
	g.MaxImageExtent.fromC(&c.maxImageExtent)
	g.MaxImageArrayLayers = uint32(c.maxImageArrayLayers)
	{
		var temp_in_VkSurfaceTransformFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedTransforms)))
			temp_in_VkSurfaceTransformFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedTransforms = SurfaceTransformFlagsKHR(temp_in_VkSurfaceTransformFlagsKHR)
	}
	g.CurrentTransform = SurfaceTransformFlagBitsKHR(c.currentTransform)
	{
		var temp_in_VkCompositeAlphaFlagsKHR Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedCompositeAlpha)))
			temp_in_VkCompositeAlphaFlagsKHR = Flags(temp_in_VkFlags)
		}
		g.SupportedCompositeAlpha = CompositeAlphaFlagsKHR(temp_in_VkCompositeAlphaFlagsKHR)
	}
	{
		var temp_in_VkImageUsageFlags Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedUsageFlags)))
			temp_in_VkImageUsageFlags = Flags(temp_in_VkFlags)
		}
		g.SupportedUsageFlags = ImageUsageFlags(temp_in_VkImageUsageFlags)
	}
	{
		var temp_in_VkSurfaceCounterFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.supportedSurfaceCounters)))
			temp_in_VkSurfaceCounterFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.SupportedSurfaceCounters = SurfaceCounterFlagsEXT(temp_in_VkSurfaceCounterFlagsEXT)
	}
}
func (s *SurfaceCapabilities2EXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
}
func (s *SurfaceCapabilities2EXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSurfaceCapabilities2EXT)(m.alloc(C.sizeof_VkSurfaceCapabilities2EXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SurfaceCapabilities2EXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSurfaceCapabilities2EXT)(p)
	s.fromC(c)
}
func (s *SurfaceCapabilities2EXT) GetNext() Structure {
	return s.Next
}
func (s *SurfaceCapabilities2EXT) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceSurfaceCapabilities2EXT func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceCapabilities *SurfaceCapabilities2EXT) (_ret Result)

func ToGetPhysicalDeviceSurfaceCapabilities2EXT(p PFNVoidFunction) (fn FuncGetPhysicalDeviceSurfaceCapabilities2EXT) {
	return func(physicalDevice PhysicalDevice, surface SurfaceKHR, surfaceCapabilities *SurfaceCapabilities2EXT) (_ret Result) {
		var c struct {
			physicalDevice       C.VkPhysicalDevice
			surface              C.VkSurfaceKHR
			pSurfaceCapabilities *C.VkSurfaceCapabilities2EXT
			_ret                 C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.surface = C.VkSurfaceKHR(surface)
		if surfaceCapabilities != nil {
			c.pSurfaceCapabilities = (*C.VkSurfaceCapabilities2EXT)(m.alloc(C.sizeof_VkSurfaceCapabilities2EXT))
			surfaceCapabilities.toC(c.pSurfaceCapabilities, m)
		} else {
			c.pSurfaceCapabilities = nil
		}
		c._ret = C.callPFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT(C.PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT(unsafe.Pointer(p)), c.physicalDevice, c.surface, c.pSurfaceCapabilities)
		_ret = Result(c._ret)
		if surfaceCapabilities != nil {
			surfaceCapabilities.fromC(c.pSurfaceCapabilities)
		}
		return
	}
}

type DisplayPowerStateEXT int

const (
	DISPLAY_POWER_STATE_OFF_EXT         DisplayPowerStateEXT = 0
	DISPLAY_POWER_STATE_SUSPEND_EXT     DisplayPowerStateEXT = 1
	DISPLAY_POWER_STATE_ON_EXT          DisplayPowerStateEXT = 2
	DISPLAY_POWER_STATE_BEGIN_RANGE_EXT DisplayPowerStateEXT = DISPLAY_POWER_STATE_OFF_EXT
	DISPLAY_POWER_STATE_END_RANGE_EXT   DisplayPowerStateEXT = DISPLAY_POWER_STATE_ON_EXT
	DISPLAY_POWER_STATE_RANGE_SIZE_EXT  DisplayPowerStateEXT = (DISPLAY_POWER_STATE_ON_EXT - DISPLAY_POWER_STATE_OFF_EXT + 1)
	DISPLAY_POWER_STATE_MAX_ENUM_EXT    DisplayPowerStateEXT = 2147483647
)

type DeviceEventTypeEXT int

const (
	DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT DeviceEventTypeEXT = 0
	DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT     DeviceEventTypeEXT = DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT
	DEVICE_EVENT_TYPE_END_RANGE_EXT       DeviceEventTypeEXT = DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT
	DEVICE_EVENT_TYPE_RANGE_SIZE_EXT      DeviceEventTypeEXT = (DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT - DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT + 1)
	DEVICE_EVENT_TYPE_MAX_ENUM_EXT        DeviceEventTypeEXT = 2147483647
)

type DisplayEventTypeEXT int

const (
	DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT DisplayEventTypeEXT = 0
	DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT     DisplayEventTypeEXT = DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT
	DISPLAY_EVENT_TYPE_END_RANGE_EXT       DisplayEventTypeEXT = DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT
	DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT      DisplayEventTypeEXT = (DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT - DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT + 1)
	DISPLAY_EVENT_TYPE_MAX_ENUM_EXT        DisplayEventTypeEXT = 2147483647
)

type PFNDisplayPowerControlEXT C.PFN_vkDisplayPowerControlEXT
type DisplayPowerInfoEXT struct {
	Next       Structure
	PowerState DisplayPowerStateEXT
}

func (g *DisplayPowerInfoEXT) toC(c *C.VkDisplayPowerInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.powerState = C.VkDisplayPowerStateEXT(g.PowerState)
}
func (g *DisplayPowerInfoEXT) fromC(c *C.VkDisplayPowerInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.PowerState = DisplayPowerStateEXT(c.powerState)
}
func (s *DisplayPowerInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
}
func (s *DisplayPowerInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayPowerInfoEXT)(m.alloc(C.sizeof_VkDisplayPowerInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayPowerInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayPowerInfoEXT)(p)
	s.fromC(c)
}
func (s *DisplayPowerInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DisplayPowerInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncDisplayPowerControlEXT func(device Device, display DisplayKHR, displayPowerInfo *DisplayPowerInfoEXT) (_ret Result)

func ToDisplayPowerControlEXT(p PFNVoidFunction) (fn FuncDisplayPowerControlEXT) {
	return func(device Device, display DisplayKHR, displayPowerInfo *DisplayPowerInfoEXT) (_ret Result) {
		var c struct {
			device            C.VkDevice
			display           C.VkDisplayKHR
			pDisplayPowerInfo *C.VkDisplayPowerInfoEXT
			_ret              C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.display = C.VkDisplayKHR(display)
		if displayPowerInfo != nil {
			c.pDisplayPowerInfo = (*C.VkDisplayPowerInfoEXT)(m.alloc(C.sizeof_VkDisplayPowerInfoEXT))
			displayPowerInfo.toC(c.pDisplayPowerInfo, m)
		} else {
			c.pDisplayPowerInfo = nil
		}
		c._ret = C.callPFN_vkDisplayPowerControlEXT(C.PFN_vkDisplayPowerControlEXT(unsafe.Pointer(p)), c.device, c.display, c.pDisplayPowerInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNRegisterDeviceEventEXT C.PFN_vkRegisterDeviceEventEXT
type DeviceEventInfoEXT struct {
	Next        Structure
	DeviceEvent DeviceEventTypeEXT
}

func (g *DeviceEventInfoEXT) toC(c *C.VkDeviceEventInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.deviceEvent = C.VkDeviceEventTypeEXT(g.DeviceEvent)
}
func (g *DeviceEventInfoEXT) fromC(c *C.VkDeviceEventInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DeviceEvent = DeviceEventTypeEXT(c.deviceEvent)
}
func (s *DeviceEventInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
}
func (s *DeviceEventInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDeviceEventInfoEXT)(m.alloc(C.sizeof_VkDeviceEventInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DeviceEventInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDeviceEventInfoEXT)(p)
	s.fromC(c)
}
func (s *DeviceEventInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DeviceEventInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncRegisterDeviceEventEXT func(device Device, deviceEventInfo *DeviceEventInfoEXT, allocator *AllocationCallbacks, fence *Fence) (_ret Result)

func ToRegisterDeviceEventEXT(p PFNVoidFunction) (fn FuncRegisterDeviceEventEXT) {
	return func(device Device, deviceEventInfo *DeviceEventInfoEXT, allocator *AllocationCallbacks, fence *Fence) (_ret Result) {
		var c struct {
			device           C.VkDevice
			pDeviceEventInfo *C.VkDeviceEventInfoEXT
			pAllocator       *C.VkAllocationCallbacks
			pFence           *C.VkFence
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if deviceEventInfo != nil {
			c.pDeviceEventInfo = (*C.VkDeviceEventInfoEXT)(m.alloc(C.sizeof_VkDeviceEventInfoEXT))
			deviceEventInfo.toC(c.pDeviceEventInfo, m)
		} else {
			c.pDeviceEventInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if fence != nil {
			c.pFence = (*C.VkFence)(m.alloc(C.sizeof_VkFence))
			*c.pFence = C.VkFence(*fence)
		} else {
			c.pFence = nil
		}
		c._ret = C.callPFN_vkRegisterDeviceEventEXT(C.PFN_vkRegisterDeviceEventEXT(unsafe.Pointer(p)), c.device, c.pDeviceEventInfo, c.pAllocator, c.pFence)
		_ret = Result(c._ret)
		if fence != nil {
			*fence = Fence(*c.pFence)
		}
		return
	}
}

type PFNRegisterDisplayEventEXT C.PFN_vkRegisterDisplayEventEXT
type DisplayEventInfoEXT struct {
	Next         Structure
	DisplayEvent DisplayEventTypeEXT
}

func (g *DisplayEventInfoEXT) toC(c *C.VkDisplayEventInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.displayEvent = C.VkDisplayEventTypeEXT(g.DisplayEvent)
}
func (g *DisplayEventInfoEXT) fromC(c *C.VkDisplayEventInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DisplayEvent = DisplayEventTypeEXT(c.displayEvent)
}
func (s *DisplayEventInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
}
func (s *DisplayEventInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDisplayEventInfoEXT)(m.alloc(C.sizeof_VkDisplayEventInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DisplayEventInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDisplayEventInfoEXT)(p)
	s.fromC(c)
}
func (s *DisplayEventInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DisplayEventInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncRegisterDisplayEventEXT func(device Device, display DisplayKHR, displayEventInfo *DisplayEventInfoEXT, allocator *AllocationCallbacks, fence *Fence) (_ret Result)

func ToRegisterDisplayEventEXT(p PFNVoidFunction) (fn FuncRegisterDisplayEventEXT) {
	return func(device Device, display DisplayKHR, displayEventInfo *DisplayEventInfoEXT, allocator *AllocationCallbacks, fence *Fence) (_ret Result) {
		var c struct {
			device            C.VkDevice
			display           C.VkDisplayKHR
			pDisplayEventInfo *C.VkDisplayEventInfoEXT
			pAllocator        *C.VkAllocationCallbacks
			pFence            *C.VkFence
			_ret              C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.display = C.VkDisplayKHR(display)
		if displayEventInfo != nil {
			c.pDisplayEventInfo = (*C.VkDisplayEventInfoEXT)(m.alloc(C.sizeof_VkDisplayEventInfoEXT))
			displayEventInfo.toC(c.pDisplayEventInfo, m)
		} else {
			c.pDisplayEventInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if fence != nil {
			c.pFence = (*C.VkFence)(m.alloc(C.sizeof_VkFence))
			*c.pFence = C.VkFence(*fence)
		} else {
			c.pFence = nil
		}
		c._ret = C.callPFN_vkRegisterDisplayEventEXT(C.PFN_vkRegisterDisplayEventEXT(unsafe.Pointer(p)), c.device, c.display, c.pDisplayEventInfo, c.pAllocator, c.pFence)
		_ret = Result(c._ret)
		if fence != nil {
			*fence = Fence(*c.pFence)
		}
		return
	}
}

type PFNGetSwapchainCounterEXT C.PFN_vkGetSwapchainCounterEXT
type FuncGetSwapchainCounterEXT func(device Device, swapchain SwapchainKHR, counter SurfaceCounterFlagBitsEXT, counterValue *uint64) (_ret Result)

func ToGetSwapchainCounterEXT(p PFNVoidFunction) (fn FuncGetSwapchainCounterEXT) {
	return func(device Device, swapchain SwapchainKHR, counter SurfaceCounterFlagBitsEXT, counterValue *uint64) (_ret Result) {
		var c struct {
			device        C.VkDevice
			swapchain     C.VkSwapchainKHR
			counter       C.VkSurfaceCounterFlagBitsEXT
			pCounterValue *C.uint64_t
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		c.counter = C.VkSurfaceCounterFlagBitsEXT(counter)
		if counterValue != nil {
			c.pCounterValue = (*C.uint64_t)(m.alloc(C.sizeof_uint64_t))
			*c.pCounterValue = C.uint64_t(*counterValue)
		} else {
			c.pCounterValue = nil
		}
		c._ret = C.callPFN_vkGetSwapchainCounterEXT(C.PFN_vkGetSwapchainCounterEXT(unsafe.Pointer(p)), c.device, c.swapchain, c.counter, c.pCounterValue)
		_ret = Result(c._ret)
		if counterValue != nil {
			*counterValue = uint64(*c.pCounterValue)
		}
		return
	}
}

type PFNGetRefreshCycleDurationGOOGLE C.PFN_vkGetRefreshCycleDurationGOOGLE
type RefreshCycleDurationGOOGLE struct{ RefreshDuration uint64 }

func (g *RefreshCycleDurationGOOGLE) toC(c *C.VkRefreshCycleDurationGOOGLE) {
	c.refreshDuration = C.uint64_t(g.RefreshDuration)
}
func (g *RefreshCycleDurationGOOGLE) fromC(c *C.VkRefreshCycleDurationGOOGLE) {
	g.RefreshDuration = uint64(c.refreshDuration)
}

type FuncGetRefreshCycleDurationGOOGLE func(device Device, swapchain SwapchainKHR, displayTimingProperties *RefreshCycleDurationGOOGLE) (_ret Result)

func ToGetRefreshCycleDurationGOOGLE(p PFNVoidFunction) (fn FuncGetRefreshCycleDurationGOOGLE) {
	return func(device Device, swapchain SwapchainKHR, displayTimingProperties *RefreshCycleDurationGOOGLE) (_ret Result) {
		var c struct {
			device                   C.VkDevice
			swapchain                C.VkSwapchainKHR
			pDisplayTimingProperties *C.VkRefreshCycleDurationGOOGLE
			_ret                     C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		if displayTimingProperties != nil {
			c.pDisplayTimingProperties = (*C.VkRefreshCycleDurationGOOGLE)(m.alloc(C.sizeof_VkRefreshCycleDurationGOOGLE))
			displayTimingProperties.toC(c.pDisplayTimingProperties)
		} else {
			c.pDisplayTimingProperties = nil
		}
		c._ret = C.callPFN_vkGetRefreshCycleDurationGOOGLE(C.PFN_vkGetRefreshCycleDurationGOOGLE(unsafe.Pointer(p)), c.device, c.swapchain, c.pDisplayTimingProperties)
		_ret = Result(c._ret)
		if displayTimingProperties != nil {
			displayTimingProperties.fromC(c.pDisplayTimingProperties)
		}
		return
	}
}

type PFNGetPastPresentationTimingGOOGLE C.PFN_vkGetPastPresentationTimingGOOGLE
type PastPresentationTimingGOOGLE struct {
	PresentID           uint32
	DesiredPresentTime  uint64
	ActualPresentTime   uint64
	EarliestPresentTime uint64
	PresentMargin       uint64
}

func (g *PastPresentationTimingGOOGLE) toC(c *C.VkPastPresentationTimingGOOGLE) {
	c.presentID = C.uint32_t(g.PresentID)
	c.desiredPresentTime = C.uint64_t(g.DesiredPresentTime)
	c.actualPresentTime = C.uint64_t(g.ActualPresentTime)
	c.earliestPresentTime = C.uint64_t(g.EarliestPresentTime)
	c.presentMargin = C.uint64_t(g.PresentMargin)
}
func (g *PastPresentationTimingGOOGLE) fromC(c *C.VkPastPresentationTimingGOOGLE) {
	g.PresentID = uint32(c.presentID)
	g.DesiredPresentTime = uint64(c.desiredPresentTime)
	g.ActualPresentTime = uint64(c.actualPresentTime)
	g.EarliestPresentTime = uint64(c.earliestPresentTime)
	g.PresentMargin = uint64(c.presentMargin)
}

type FuncGetPastPresentationTimingGOOGLE func(device Device, swapchain SwapchainKHR, presentationTimingCount *uint32, presentationTimings []PastPresentationTimingGOOGLE) (_ret Result)

func ToGetPastPresentationTimingGOOGLE(p PFNVoidFunction) (fn FuncGetPastPresentationTimingGOOGLE) {
	return func(device Device, swapchain SwapchainKHR, presentationTimingCount *uint32, presentationTimings []PastPresentationTimingGOOGLE) (_ret Result) {
		var c struct {
			device                   C.VkDevice
			swapchain                C.VkSwapchainKHR
			pPresentationTimingCount *C.uint32_t
			pPresentationTimings     *C.VkPastPresentationTimingGOOGLE
			_ret                     C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchain = C.VkSwapchainKHR(swapchain)
		if presentationTimingCount != nil {
			c.pPresentationTimingCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pPresentationTimingCount = C.uint32_t(*presentationTimingCount)
		} else {
			c.pPresentationTimingCount = nil
		}
		if len(presentationTimings) != 0 {
			c.pPresentationTimings = (*C.VkPastPresentationTimingGOOGLE)(m.alloc(C.sizeof_VkPastPresentationTimingGOOGLE * uint(len(presentationTimings))))
			slice1 := (*[1 << 31]C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(c.pPresentationTimings))[:len(presentationTimings):len(presentationTimings)]
			for i1, _ := range presentationTimings {
				presentationTimings[i1].toC(&slice1[i1])
			}
		} else {
			c.pPresentationTimings = nil
		}
		c._ret = C.callPFN_vkGetPastPresentationTimingGOOGLE(C.PFN_vkGetPastPresentationTimingGOOGLE(unsafe.Pointer(p)), c.device, c.swapchain, c.pPresentationTimingCount, c.pPresentationTimings)
		_ret = Result(c._ret)
		if presentationTimingCount != nil {
			*presentationTimingCount = uint32(*c.pPresentationTimingCount)
		}
		if len(presentationTimings) != 0 {
			slice1 := (*[1 << 31]C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(c.pPresentationTimings))[:len(presentationTimings):len(presentationTimings)]
			for i1, _ := range presentationTimings {
				presentationTimings[i1].fromC(&slice1[i1])
			}
		}
		return
	}
}

type ViewportCoordinateSwizzleNV int

const (
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV  ViewportCoordinateSwizzleNV = 0
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV  ViewportCoordinateSwizzleNV = 1
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV  ViewportCoordinateSwizzleNV = 2
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV  ViewportCoordinateSwizzleNV = 3
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV  ViewportCoordinateSwizzleNV = 4
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV  ViewportCoordinateSwizzleNV = 5
	VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV  ViewportCoordinateSwizzleNV = 6
	VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV  ViewportCoordinateSwizzleNV = 7
	VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV ViewportCoordinateSwizzleNV = VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV
	VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV   ViewportCoordinateSwizzleNV = VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV
	VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV  ViewportCoordinateSwizzleNV = (VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV - VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV + 1)
	VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV    ViewportCoordinateSwizzleNV = 2147483647
)

type DiscardRectangleModeEXT int

const (
	DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT   DiscardRectangleModeEXT = 0
	DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT   DiscardRectangleModeEXT = 1
	DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT DiscardRectangleModeEXT = DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT
	DISCARD_RECTANGLE_MODE_END_RANGE_EXT   DiscardRectangleModeEXT = DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT
	DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT  DiscardRectangleModeEXT = (DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT - DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT + 1)
	DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT    DiscardRectangleModeEXT = 2147483647
)

type PFNCmdSetDiscardRectangleEXT C.PFN_vkCmdSetDiscardRectangleEXT
type FuncCmdSetDiscardRectangleEXT func(commandBuffer CommandBuffer, firstDiscardRectangle uint32, discardRectangles []Rect2D)

func ToCmdSetDiscardRectangleEXT(p PFNVoidFunction) (fn FuncCmdSetDiscardRectangleEXT) {
	return func(commandBuffer CommandBuffer, firstDiscardRectangle uint32, discardRectangles []Rect2D) {
		var c struct {
			commandBuffer         C.VkCommandBuffer
			firstDiscardRectangle C.uint32_t
			discardRectangleCount C.uint32_t
			pDiscardRectangles    *C.VkRect2D
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.firstDiscardRectangle = C.uint32_t(firstDiscardRectangle)
		c.discardRectangleCount = C.uint32_t(len(discardRectangles))
		if len(discardRectangles) != 0 {
			c.pDiscardRectangles = (*C.VkRect2D)(m.alloc(C.sizeof_VkRect2D * uint(len(discardRectangles))))
			slice1 := (*[1 << 31]C.VkRect2D)(unsafe.Pointer(c.pDiscardRectangles))[:len(discardRectangles):len(discardRectangles)]
			for i1, _ := range discardRectangles {
				discardRectangles[i1].toC(&slice1[i1])
			}
		} else {
			c.pDiscardRectangles = nil
		}
		C.callPFN_vkCmdSetDiscardRectangleEXT(C.PFN_vkCmdSetDiscardRectangleEXT(unsafe.Pointer(p)), c.commandBuffer, c.firstDiscardRectangle, c.discardRectangleCount, c.pDiscardRectangles)
	}
}

type ConservativeRasterizationModeEXT int

const (
	CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT      ConservativeRasterizationModeEXT = 0
	CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT  ConservativeRasterizationModeEXT = 1
	CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT ConservativeRasterizationModeEXT = 2
	CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT   ConservativeRasterizationModeEXT = CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
	CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT     ConservativeRasterizationModeEXT = CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT
	CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT    ConservativeRasterizationModeEXT = (CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT - CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT + 1)
	CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT      ConservativeRasterizationModeEXT = 2147483647
)

type PFNSetHdrMetadataEXT C.PFN_vkSetHdrMetadataEXT
type XYColorEXT struct {
	X float32
	Y float32
}

func (g *XYColorEXT) toC(c *C.VkXYColorEXT) {
	c.x = C.float(g.X)
	c.y = C.float(g.Y)
}
func (g *XYColorEXT) fromC(c *C.VkXYColorEXT) {
	g.X = float32(c.x)
	g.Y = float32(c.y)
}

type HdrMetadataEXT struct {
	Next                      Structure
	DisplayPrimaryRed         XYColorEXT
	DisplayPrimaryGreen       XYColorEXT
	DisplayPrimaryBlue        XYColorEXT
	WhitePoint                XYColorEXT
	MaxLuminance              float32
	MinLuminance              float32
	MaxContentLightLevel      float32
	MaxFrameAverageLightLevel float32
}

func (g *HdrMetadataEXT) toC(c *C.VkHdrMetadataEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.DisplayPrimaryRed.toC(&c.displayPrimaryRed)
	g.DisplayPrimaryGreen.toC(&c.displayPrimaryGreen)
	g.DisplayPrimaryBlue.toC(&c.displayPrimaryBlue)
	g.WhitePoint.toC(&c.whitePoint)
	c.maxLuminance = C.float(g.MaxLuminance)
	c.minLuminance = C.float(g.MinLuminance)
	c.maxContentLightLevel = C.float(g.MaxContentLightLevel)
	c.maxFrameAverageLightLevel = C.float(g.MaxFrameAverageLightLevel)
}
func (g *HdrMetadataEXT) fromC(c *C.VkHdrMetadataEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.DisplayPrimaryRed.fromC(&c.displayPrimaryRed)
	g.DisplayPrimaryGreen.fromC(&c.displayPrimaryGreen)
	g.DisplayPrimaryBlue.fromC(&c.displayPrimaryBlue)
	g.WhitePoint.fromC(&c.whitePoint)
	g.MaxLuminance = float32(c.maxLuminance)
	g.MinLuminance = float32(c.minLuminance)
	g.MaxContentLightLevel = float32(c.maxContentLightLevel)
	g.MaxFrameAverageLightLevel = float32(c.maxFrameAverageLightLevel)
}
func (s *HdrMetadataEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_HDR_METADATA_EXT
}
func (s *HdrMetadataEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkHdrMetadataEXT)(m.alloc(C.sizeof_VkHdrMetadataEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *HdrMetadataEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkHdrMetadataEXT)(p)
	s.fromC(c)
}
func (s *HdrMetadataEXT) GetNext() Structure {
	return s.Next
}
func (s *HdrMetadataEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncSetHdrMetadataEXT func(device Device, swapchains []SwapchainKHR, metadata []HdrMetadataEXT)

func ToSetHdrMetadataEXT(p PFNVoidFunction) (fn FuncSetHdrMetadataEXT) {
	return func(device Device, swapchains []SwapchainKHR, metadata []HdrMetadataEXT) {
		var c struct {
			device         C.VkDevice
			swapchainCount C.uint32_t
			pSwapchains    *C.VkSwapchainKHR
			pMetadata      *C.VkHdrMetadataEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.swapchainCount = C.uint32_t(len(swapchains))
		if len(swapchains) != 0 {
			c.pSwapchains = (*C.VkSwapchainKHR)(m.alloc(C.sizeof_VkSwapchainKHR * uint(len(swapchains))))
			slice1 := (*[1 << 31]C.VkSwapchainKHR)(unsafe.Pointer(c.pSwapchains))[:len(swapchains):len(swapchains)]
			for i1, _ := range swapchains {
				slice1[i1] = C.VkSwapchainKHR(swapchains[i1])
			}
		} else {
			c.pSwapchains = nil
		}
		if len(metadata) != 0 {
			c.pMetadata = (*C.VkHdrMetadataEXT)(m.alloc(C.sizeof_VkHdrMetadataEXT * uint(len(metadata))))
			slice1 := (*[1 << 31]C.VkHdrMetadataEXT)(unsafe.Pointer(c.pMetadata))[:len(metadata):len(metadata)]
			for i1, _ := range metadata {
				metadata[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pMetadata = nil
		}
		C.callPFN_vkSetHdrMetadataEXT(C.PFN_vkSetHdrMetadataEXT(unsafe.Pointer(p)), c.device, c.swapchainCount, c.pSwapchains, c.pMetadata)
	}
}

type DebugUtilsMessageSeverityFlagBitsEXT int

const (
	DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT        DebugUtilsMessageSeverityFlagBitsEXT = 1
	DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT           DebugUtilsMessageSeverityFlagBitsEXT = 16
	DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT        DebugUtilsMessageSeverityFlagBitsEXT = 256
	DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT          DebugUtilsMessageSeverityFlagBitsEXT = 4096
	DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT DebugUtilsMessageSeverityFlagBitsEXT = 2147483647
)

type DebugUtilsMessageTypeFlagBitsEXT int

const (
	DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT        DebugUtilsMessageTypeFlagBitsEXT = 1
	DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT     DebugUtilsMessageTypeFlagBitsEXT = 2
	DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT    DebugUtilsMessageTypeFlagBitsEXT = 4
	DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT DebugUtilsMessageTypeFlagBitsEXT = 2147483647
)

type PFNDebugUtilsMessengerCallbackEXT C.PFN_vkDebugUtilsMessengerCallbackEXT
type DebugUtilsMessageTypeFlagsEXT Flags
type DebugUtilsMessengerCallbackDataFlagsEXT Flags
type DebugUtilsLabelEXT struct {
	Next      Structure
	LabelName string
	Color     [4]float32
}

func (g *DebugUtilsLabelEXT) toC(c *C.VkDebugUtilsLabelEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.pLabelName = toCString(g.LabelName, m)
	for i, _ := range g.Color {
		c.color[i] = C.float(g.Color[i])
	}
}
func (g *DebugUtilsLabelEXT) fromC(c *C.VkDebugUtilsLabelEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.LabelName = toGoString(c.pLabelName)
	for i, _ := range g.Color {
		g.Color[i] = float32(c.color[i])
	}
}
func (s *DebugUtilsLabelEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
}
func (s *DebugUtilsLabelEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugUtilsLabelEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugUtilsLabelEXT)(p)
	s.fromC(c)
}
func (s *DebugUtilsLabelEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugUtilsLabelEXT) SetNext(n Structure) {
	s.Next = n
}

type DebugUtilsObjectNameInfoEXT struct {
	Next         Structure
	ObjectType   ObjectType
	ObjectHandle uint64
	ObjectName   string
}

func (g *DebugUtilsObjectNameInfoEXT) toC(c *C.VkDebugUtilsObjectNameInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectType = C.VkObjectType(g.ObjectType)
	c.objectHandle = C.uint64_t(g.ObjectHandle)
	c.pObjectName = toCString(g.ObjectName, m)
}
func (g *DebugUtilsObjectNameInfoEXT) fromC(c *C.VkDebugUtilsObjectNameInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectType = ObjectType(c.objectType)
	g.ObjectHandle = uint64(c.objectHandle)
	g.ObjectName = toGoString(c.pObjectName)
}
func (s *DebugUtilsObjectNameInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
}
func (s *DebugUtilsObjectNameInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugUtilsObjectNameInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsObjectNameInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugUtilsObjectNameInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugUtilsObjectNameInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugUtilsObjectNameInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugUtilsObjectNameInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type DebugUtilsMessengerCallbackDataEXT struct {
	Next            Structure
	Flags           DebugUtilsMessengerCallbackDataFlagsEXT
	MessageIdName   string
	MessageIdNumber int32
	Message         string
	QueueLabels     []DebugUtilsLabelEXT
	CmdBufLabels    []DebugUtilsLabelEXT
	Objects         []DebugUtilsObjectNameInfoEXT
}

func (g *DebugUtilsMessengerCallbackDataEXT) toC(c *C.VkDebugUtilsMessengerCallbackDataEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDebugUtilsMessengerCallbackDataFlagsEXT(temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT)
	}
	c.pMessageIdName = toCString(g.MessageIdName, m)
	c.messageIdNumber = C.int32_t(g.MessageIdNumber)
	c.pMessage = toCString(g.Message, m)
	c.queueLabelCount = C.uint32_t(len(g.QueueLabels))
	if len(g.QueueLabels) != 0 {
		c.pQueueLabels = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT * uint(len(g.QueueLabels))))
		slice1 := (*[1 << 31]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(c.pQueueLabels))[:len(g.QueueLabels):len(g.QueueLabels)]
		for i1, _ := range g.QueueLabels {
			g.QueueLabels[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pQueueLabels = nil
	}
	c.cmdBufLabelCount = C.uint32_t(len(g.CmdBufLabels))
	if len(g.CmdBufLabels) != 0 {
		c.pCmdBufLabels = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT * uint(len(g.CmdBufLabels))))
		slice1 := (*[1 << 31]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(c.pCmdBufLabels))[:len(g.CmdBufLabels):len(g.CmdBufLabels)]
		for i1, _ := range g.CmdBufLabels {
			g.CmdBufLabels[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pCmdBufLabels = nil
	}
	c.objectCount = C.uint32_t(len(g.Objects))
	if len(g.Objects) != 0 {
		c.pObjects = (*C.VkDebugUtilsObjectNameInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsObjectNameInfoEXT * uint(len(g.Objects))))
		slice1 := (*[1 << 31]C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(c.pObjects))[:len(g.Objects):len(g.Objects)]
		for i1, _ := range g.Objects {
			g.Objects[i1].toC(&slice1[i1], m)
		}
	} else {
		c.pObjects = nil
	}
}
func (g *DebugUtilsMessengerCallbackDataEXT) fromC(c *C.VkDebugUtilsMessengerCallbackDataEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.Flags = DebugUtilsMessengerCallbackDataFlagsEXT(temp_in_VkDebugUtilsMessengerCallbackDataFlagsEXT)
	}
	g.MessageIdName = toGoString(c.pMessageIdName)
	g.MessageIdNumber = int32(c.messageIdNumber)
	g.Message = toGoString(c.pMessage)
	g.QueueLabels = make([]DebugUtilsLabelEXT, int(c.queueLabelCount))
	if len(g.QueueLabels) != 0 {
		slice1 := (*[1 << 31]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(c.pQueueLabels))[:len(g.QueueLabels):len(g.QueueLabels)]
		for i1, _ := range g.QueueLabels {
			g.QueueLabels[i1].fromC(&slice1[i1])
		}
	}
	g.CmdBufLabels = make([]DebugUtilsLabelEXT, int(c.cmdBufLabelCount))
	if len(g.CmdBufLabels) != 0 {
		slice1 := (*[1 << 31]C.VkDebugUtilsLabelEXT)(unsafe.Pointer(c.pCmdBufLabels))[:len(g.CmdBufLabels):len(g.CmdBufLabels)]
		for i1, _ := range g.CmdBufLabels {
			g.CmdBufLabels[i1].fromC(&slice1[i1])
		}
	}
	g.Objects = make([]DebugUtilsObjectNameInfoEXT, int(c.objectCount))
	if len(g.Objects) != 0 {
		slice1 := (*[1 << 31]C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(c.pObjects))[:len(g.Objects):len(g.Objects)]
		for i1, _ := range g.Objects {
			g.Objects[i1].fromC(&slice1[i1])
		}
	}
}
func (s *DebugUtilsMessengerCallbackDataEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
}
func (s *DebugUtilsMessengerCallbackDataEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugUtilsMessengerCallbackDataEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerCallbackDataEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugUtilsMessengerCallbackDataEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugUtilsMessengerCallbackDataEXT)(p)
	s.fromC(c)
}
func (s *DebugUtilsMessengerCallbackDataEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugUtilsMessengerCallbackDataEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncDebugUtilsMessengerCallbackEXT func(arg0 DebugUtilsMessageSeverityFlagBitsEXT, arg1 DebugUtilsMessageTypeFlagsEXT, arg2 *DebugUtilsMessengerCallbackDataEXT, arg3 unsafe.Pointer) (_ret bool)

func ToDebugUtilsMessengerCallbackEXT(p PFNVoidFunction) (fn FuncDebugUtilsMessengerCallbackEXT) {
	return func(arg0 DebugUtilsMessageSeverityFlagBitsEXT, arg1 DebugUtilsMessageTypeFlagsEXT, arg2 *DebugUtilsMessengerCallbackDataEXT, arg3 unsafe.Pointer) (_ret bool) {
		var c struct {
			arg0 C.VkDebugUtilsMessageSeverityFlagBitsEXT
			arg1 C.VkDebugUtilsMessageTypeFlagsEXT
			arg2 *C.VkDebugUtilsMessengerCallbackDataEXT
			arg3 unsafe.Pointer
			_ret C.VkBool32
		}
		m := pool.take()
		defer pool.give(m)
		c.arg0 = C.VkDebugUtilsMessageSeverityFlagBitsEXT(arg0)
		{
			var temp_in_VkDebugUtilsMessageTypeFlagsEXT C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(arg1)))
				temp_in_VkDebugUtilsMessageTypeFlagsEXT = C.VkFlags(temp_in_VkFlags)
			}
			c.arg1 = C.VkDebugUtilsMessageTypeFlagsEXT(temp_in_VkDebugUtilsMessageTypeFlagsEXT)
		}
		if arg2 != nil {
			c.arg2 = (*C.VkDebugUtilsMessengerCallbackDataEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerCallbackDataEXT))
			arg2.toC(c.arg2, m)
		} else {
			c.arg2 = nil
		}
		c.arg3 = arg3
		c._ret = C.callPFN_vkDebugUtilsMessengerCallbackEXT(C.PFN_vkDebugUtilsMessengerCallbackEXT(unsafe.Pointer(p)), c.arg0, c.arg1, c.arg2, c.arg3)
		_ret = c._ret != 0
		return
	}
}

type PFNSetDebugUtilsObjectNameEXT C.PFN_vkSetDebugUtilsObjectNameEXT
type FuncSetDebugUtilsObjectNameEXT func(device Device, nameInfo *DebugUtilsObjectNameInfoEXT) (_ret Result)

func ToSetDebugUtilsObjectNameEXT(p PFNVoidFunction) (fn FuncSetDebugUtilsObjectNameEXT) {
	return func(device Device, nameInfo *DebugUtilsObjectNameInfoEXT) (_ret Result) {
		var c struct {
			device    C.VkDevice
			pNameInfo *C.VkDebugUtilsObjectNameInfoEXT
			_ret      C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if nameInfo != nil {
			c.pNameInfo = (*C.VkDebugUtilsObjectNameInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsObjectNameInfoEXT))
			nameInfo.toC(c.pNameInfo, m)
		} else {
			c.pNameInfo = nil
		}
		c._ret = C.callPFN_vkSetDebugUtilsObjectNameEXT(C.PFN_vkSetDebugUtilsObjectNameEXT(unsafe.Pointer(p)), c.device, c.pNameInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNSetDebugUtilsObjectTagEXT C.PFN_vkSetDebugUtilsObjectTagEXT
type DebugUtilsObjectTagInfoEXT struct {
	Next         Structure
	ObjectType   ObjectType
	ObjectHandle uint64
	TagName      uint64
	TagSize      uint
	Tag          unsafe.Pointer
}

func (g *DebugUtilsObjectTagInfoEXT) toC(c *C.VkDebugUtilsObjectTagInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.objectType = C.VkObjectType(g.ObjectType)
	c.objectHandle = C.uint64_t(g.ObjectHandle)
	c.tagName = C.uint64_t(g.TagName)
	c.tagSize = C.size_t(g.TagSize)
	c.pTag = g.Tag
}
func (g *DebugUtilsObjectTagInfoEXT) fromC(c *C.VkDebugUtilsObjectTagInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.ObjectType = ObjectType(c.objectType)
	g.ObjectHandle = uint64(c.objectHandle)
	g.TagName = uint64(c.tagName)
	g.TagSize = uint(c.tagSize)
	g.Tag = c.pTag
}
func (s *DebugUtilsObjectTagInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
}
func (s *DebugUtilsObjectTagInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugUtilsObjectTagInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsObjectTagInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugUtilsObjectTagInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugUtilsObjectTagInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugUtilsObjectTagInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugUtilsObjectTagInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncSetDebugUtilsObjectTagEXT func(device Device, tagInfo *DebugUtilsObjectTagInfoEXT) (_ret Result)

func ToSetDebugUtilsObjectTagEXT(p PFNVoidFunction) (fn FuncSetDebugUtilsObjectTagEXT) {
	return func(device Device, tagInfo *DebugUtilsObjectTagInfoEXT) (_ret Result) {
		var c struct {
			device   C.VkDevice
			pTagInfo *C.VkDebugUtilsObjectTagInfoEXT
			_ret     C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if tagInfo != nil {
			c.pTagInfo = (*C.VkDebugUtilsObjectTagInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsObjectTagInfoEXT))
			tagInfo.toC(c.pTagInfo, m)
		} else {
			c.pTagInfo = nil
		}
		c._ret = C.callPFN_vkSetDebugUtilsObjectTagEXT(C.PFN_vkSetDebugUtilsObjectTagEXT(unsafe.Pointer(p)), c.device, c.pTagInfo)
		_ret = Result(c._ret)
		return
	}
}

type PFNQueueBeginDebugUtilsLabelEXT C.PFN_vkQueueBeginDebugUtilsLabelEXT
type FuncQueueBeginDebugUtilsLabelEXT func(queue Queue, labelInfo *DebugUtilsLabelEXT)

func ToQueueBeginDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncQueueBeginDebugUtilsLabelEXT) {
	return func(queue Queue, labelInfo *DebugUtilsLabelEXT) {
		var c struct {
			queue      C.VkQueue
			pLabelInfo *C.VkDebugUtilsLabelEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		if labelInfo != nil {
			c.pLabelInfo = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT))
			labelInfo.toC(c.pLabelInfo, m)
		} else {
			c.pLabelInfo = nil
		}
		C.callPFN_vkQueueBeginDebugUtilsLabelEXT(C.PFN_vkQueueBeginDebugUtilsLabelEXT(unsafe.Pointer(p)), c.queue, c.pLabelInfo)
	}
}

type PFNQueueEndDebugUtilsLabelEXT C.PFN_vkQueueEndDebugUtilsLabelEXT
type FuncQueueEndDebugUtilsLabelEXT func(queue Queue)

func ToQueueEndDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncQueueEndDebugUtilsLabelEXT) {
	return func(queue Queue) {
		var c struct{ queue C.VkQueue }
		c.queue = C.VkQueue(queue)
		C.callPFN_vkQueueEndDebugUtilsLabelEXT(C.PFN_vkQueueEndDebugUtilsLabelEXT(unsafe.Pointer(p)), c.queue)
	}
}

type PFNQueueInsertDebugUtilsLabelEXT C.PFN_vkQueueInsertDebugUtilsLabelEXT
type FuncQueueInsertDebugUtilsLabelEXT func(queue Queue, labelInfo *DebugUtilsLabelEXT)

func ToQueueInsertDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncQueueInsertDebugUtilsLabelEXT) {
	return func(queue Queue, labelInfo *DebugUtilsLabelEXT) {
		var c struct {
			queue      C.VkQueue
			pLabelInfo *C.VkDebugUtilsLabelEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		if labelInfo != nil {
			c.pLabelInfo = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT))
			labelInfo.toC(c.pLabelInfo, m)
		} else {
			c.pLabelInfo = nil
		}
		C.callPFN_vkQueueInsertDebugUtilsLabelEXT(C.PFN_vkQueueInsertDebugUtilsLabelEXT(unsafe.Pointer(p)), c.queue, c.pLabelInfo)
	}
}

type PFNCmdBeginDebugUtilsLabelEXT C.PFN_vkCmdBeginDebugUtilsLabelEXT
type FuncCmdBeginDebugUtilsLabelEXT func(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT)

func ToCmdBeginDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncCmdBeginDebugUtilsLabelEXT) {
	return func(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pLabelInfo    *C.VkDebugUtilsLabelEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if labelInfo != nil {
			c.pLabelInfo = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT))
			labelInfo.toC(c.pLabelInfo, m)
		} else {
			c.pLabelInfo = nil
		}
		C.callPFN_vkCmdBeginDebugUtilsLabelEXT(C.PFN_vkCmdBeginDebugUtilsLabelEXT(unsafe.Pointer(p)), c.commandBuffer, c.pLabelInfo)
	}
}

type PFNCmdEndDebugUtilsLabelEXT C.PFN_vkCmdEndDebugUtilsLabelEXT
type FuncCmdEndDebugUtilsLabelEXT func(commandBuffer CommandBuffer)

func ToCmdEndDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncCmdEndDebugUtilsLabelEXT) {
	return func(commandBuffer CommandBuffer) {
		var c struct{ commandBuffer C.VkCommandBuffer }
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		C.callPFN_vkCmdEndDebugUtilsLabelEXT(C.PFN_vkCmdEndDebugUtilsLabelEXT(unsafe.Pointer(p)), c.commandBuffer)
	}
}

type PFNCmdInsertDebugUtilsLabelEXT C.PFN_vkCmdInsertDebugUtilsLabelEXT
type FuncCmdInsertDebugUtilsLabelEXT func(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT)

func ToCmdInsertDebugUtilsLabelEXT(p PFNVoidFunction) (fn FuncCmdInsertDebugUtilsLabelEXT) {
	return func(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pLabelInfo    *C.VkDebugUtilsLabelEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if labelInfo != nil {
			c.pLabelInfo = (*C.VkDebugUtilsLabelEXT)(m.alloc(C.sizeof_VkDebugUtilsLabelEXT))
			labelInfo.toC(c.pLabelInfo, m)
		} else {
			c.pLabelInfo = nil
		}
		C.callPFN_vkCmdInsertDebugUtilsLabelEXT(C.PFN_vkCmdInsertDebugUtilsLabelEXT(unsafe.Pointer(p)), c.commandBuffer, c.pLabelInfo)
	}
}

type PFNCreateDebugUtilsMessengerEXT C.PFN_vkCreateDebugUtilsMessengerEXT
type DebugUtilsMessengerCreateFlagsEXT Flags
type DebugUtilsMessageSeverityFlagsEXT Flags
type DebugUtilsMessengerCreateInfoEXT struct {
	Next            Structure
	Flags           DebugUtilsMessengerCreateFlagsEXT
	MessageSeverity DebugUtilsMessageSeverityFlagsEXT
	MessageType     DebugUtilsMessageTypeFlagsEXT
	UserCallback    PFNDebugUtilsMessengerCallbackEXT
	UserData        unsafe.Pointer
}

func (g *DebugUtilsMessengerCreateInfoEXT) toC(c *C.VkDebugUtilsMessengerCreateInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkDebugUtilsMessengerCreateFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkDebugUtilsMessengerCreateFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkDebugUtilsMessengerCreateFlagsEXT(temp_in_VkDebugUtilsMessengerCreateFlagsEXT)
	}
	{
		var temp_in_VkDebugUtilsMessageSeverityFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.MessageSeverity)))
			temp_in_VkDebugUtilsMessageSeverityFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.messageSeverity = C.VkDebugUtilsMessageSeverityFlagsEXT(temp_in_VkDebugUtilsMessageSeverityFlagsEXT)
	}
	{
		var temp_in_VkDebugUtilsMessageTypeFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.MessageType)))
			temp_in_VkDebugUtilsMessageTypeFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.messageType = C.VkDebugUtilsMessageTypeFlagsEXT(temp_in_VkDebugUtilsMessageTypeFlagsEXT)
	}
	c.pfnUserCallback = C.PFN_vkDebugUtilsMessengerCallbackEXT(g.UserCallback)
	c.pUserData = g.UserData
}
func (g *DebugUtilsMessengerCreateInfoEXT) fromC(c *C.VkDebugUtilsMessengerCreateInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkDebugUtilsMessengerCreateFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkDebugUtilsMessengerCreateFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.Flags = DebugUtilsMessengerCreateFlagsEXT(temp_in_VkDebugUtilsMessengerCreateFlagsEXT)
	}
	{
		var temp_in_VkDebugUtilsMessageSeverityFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.messageSeverity)))
			temp_in_VkDebugUtilsMessageSeverityFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.MessageSeverity = DebugUtilsMessageSeverityFlagsEXT(temp_in_VkDebugUtilsMessageSeverityFlagsEXT)
	}
	{
		var temp_in_VkDebugUtilsMessageTypeFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.messageType)))
			temp_in_VkDebugUtilsMessageTypeFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.MessageType = DebugUtilsMessageTypeFlagsEXT(temp_in_VkDebugUtilsMessageTypeFlagsEXT)
	}
	g.UserCallback = PFNDebugUtilsMessengerCallbackEXT(c.pfnUserCallback)
	g.UserData = c.pUserData
}
func (s *DebugUtilsMessengerCreateInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
}
func (s *DebugUtilsMessengerCreateInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkDebugUtilsMessengerCreateInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerCreateInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *DebugUtilsMessengerCreateInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkDebugUtilsMessengerCreateInfoEXT)(p)
	s.fromC(c)
}
func (s *DebugUtilsMessengerCreateInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *DebugUtilsMessengerCreateInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type DebugUtilsMessengerEXT C.VkDebugUtilsMessengerEXT
type FuncCreateDebugUtilsMessengerEXT func(instance Instance, createInfo *DebugUtilsMessengerCreateInfoEXT, allocator *AllocationCallbacks, messenger *DebugUtilsMessengerEXT) (_ret Result)

func ToCreateDebugUtilsMessengerEXT(p PFNVoidFunction) (fn FuncCreateDebugUtilsMessengerEXT) {
	return func(instance Instance, createInfo *DebugUtilsMessengerCreateInfoEXT, allocator *AllocationCallbacks, messenger *DebugUtilsMessengerEXT) (_ret Result) {
		var c struct {
			instance    C.VkInstance
			pCreateInfo *C.VkDebugUtilsMessengerCreateInfoEXT
			pAllocator  *C.VkAllocationCallbacks
			pMessenger  *C.VkDebugUtilsMessengerEXT
			_ret        C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkDebugUtilsMessengerCreateInfoEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerCreateInfoEXT))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if messenger != nil {
			c.pMessenger = (*C.VkDebugUtilsMessengerEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerEXT))
			*c.pMessenger = C.VkDebugUtilsMessengerEXT(*messenger)
		} else {
			c.pMessenger = nil
		}
		c._ret = C.callPFN_vkCreateDebugUtilsMessengerEXT(C.PFN_vkCreateDebugUtilsMessengerEXT(unsafe.Pointer(p)), c.instance, c.pCreateInfo, c.pAllocator, c.pMessenger)
		_ret = Result(c._ret)
		if messenger != nil {
			*messenger = DebugUtilsMessengerEXT(*c.pMessenger)
		}
		return
	}
}

type PFNDestroyDebugUtilsMessengerEXT C.PFN_vkDestroyDebugUtilsMessengerEXT
type FuncDestroyDebugUtilsMessengerEXT func(instance Instance, messenger DebugUtilsMessengerEXT, allocator *AllocationCallbacks)

func ToDestroyDebugUtilsMessengerEXT(p PFNVoidFunction) (fn FuncDestroyDebugUtilsMessengerEXT) {
	return func(instance Instance, messenger DebugUtilsMessengerEXT, allocator *AllocationCallbacks) {
		var c struct {
			instance   C.VkInstance
			messenger  C.VkDebugUtilsMessengerEXT
			pAllocator *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		c.messenger = C.VkDebugUtilsMessengerEXT(messenger)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyDebugUtilsMessengerEXT(C.PFN_vkDestroyDebugUtilsMessengerEXT(unsafe.Pointer(p)), c.instance, c.messenger, c.pAllocator)
	}
}

type PFNSubmitDebugUtilsMessageEXT C.PFN_vkSubmitDebugUtilsMessageEXT
type FuncSubmitDebugUtilsMessageEXT func(instance Instance, messageSeverity DebugUtilsMessageSeverityFlagBitsEXT, messageTypes DebugUtilsMessageTypeFlagsEXT, callbackData *DebugUtilsMessengerCallbackDataEXT)

func ToSubmitDebugUtilsMessageEXT(p PFNVoidFunction) (fn FuncSubmitDebugUtilsMessageEXT) {
	return func(instance Instance, messageSeverity DebugUtilsMessageSeverityFlagBitsEXT, messageTypes DebugUtilsMessageTypeFlagsEXT, callbackData *DebugUtilsMessengerCallbackDataEXT) {
		var c struct {
			instance        C.VkInstance
			messageSeverity C.VkDebugUtilsMessageSeverityFlagBitsEXT
			messageTypes    C.VkDebugUtilsMessageTypeFlagsEXT
			pCallbackData   *C.VkDebugUtilsMessengerCallbackDataEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.instance = C.VkInstance(instance)
		c.messageSeverity = C.VkDebugUtilsMessageSeverityFlagBitsEXT(messageSeverity)
		{
			var temp_in_VkDebugUtilsMessageTypeFlagsEXT C.VkFlags
			{
				var temp_in_VkFlags C.uint32_t
				temp_in_VkFlags = C.uint32_t((uint32)((Flags)(messageTypes)))
				temp_in_VkDebugUtilsMessageTypeFlagsEXT = C.VkFlags(temp_in_VkFlags)
			}
			c.messageTypes = C.VkDebugUtilsMessageTypeFlagsEXT(temp_in_VkDebugUtilsMessageTypeFlagsEXT)
		}
		if callbackData != nil {
			c.pCallbackData = (*C.VkDebugUtilsMessengerCallbackDataEXT)(m.alloc(C.sizeof_VkDebugUtilsMessengerCallbackDataEXT))
			callbackData.toC(c.pCallbackData, m)
		} else {
			c.pCallbackData = nil
		}
		C.callPFN_vkSubmitDebugUtilsMessageEXT(C.PFN_vkSubmitDebugUtilsMessageEXT(unsafe.Pointer(p)), c.instance, c.messageSeverity, c.messageTypes, c.pCallbackData)
	}
}

type SamplerReductionModeEXT int

const (
	SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT SamplerReductionModeEXT = 0
	SAMPLER_REDUCTION_MODE_MIN_EXT              SamplerReductionModeEXT = 1
	SAMPLER_REDUCTION_MODE_MAX_EXT              SamplerReductionModeEXT = 2
	SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT      SamplerReductionModeEXT = SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
	SAMPLER_REDUCTION_MODE_END_RANGE_EXT        SamplerReductionModeEXT = SAMPLER_REDUCTION_MODE_MAX_EXT
	SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT       SamplerReductionModeEXT = (SAMPLER_REDUCTION_MODE_MAX_EXT - SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT + 1)
	SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT         SamplerReductionModeEXT = 2147483647
)

type PFNCmdSetSampleLocationsEXT C.PFN_vkCmdSetSampleLocationsEXT
type SampleLocationEXT struct {
	X float32
	Y float32
}

func (g *SampleLocationEXT) toC(c *C.VkSampleLocationEXT) {
	c.x = C.float(g.X)
	c.y = C.float(g.Y)
}
func (g *SampleLocationEXT) fromC(c *C.VkSampleLocationEXT) {
	g.X = float32(c.x)
	g.Y = float32(c.y)
}

type SampleLocationsInfoEXT struct {
	Next                    Structure
	SampleLocationsPerPixel SampleCountFlagBits
	SampleLocationGridSize  Extent2D
	SampleLocations         []SampleLocationEXT
}

func (g *SampleLocationsInfoEXT) toC(c *C.VkSampleLocationsInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.sampleLocationsPerPixel = C.VkSampleCountFlagBits(g.SampleLocationsPerPixel)
	g.SampleLocationGridSize.toC(&c.sampleLocationGridSize)
	c.sampleLocationsCount = C.uint32_t(len(g.SampleLocations))
	if len(g.SampleLocations) != 0 {
		c.pSampleLocations = (*C.VkSampleLocationEXT)(m.alloc(C.sizeof_VkSampleLocationEXT * uint(len(g.SampleLocations))))
		slice1 := (*[1 << 31]C.VkSampleLocationEXT)(unsafe.Pointer(c.pSampleLocations))[:len(g.SampleLocations):len(g.SampleLocations)]
		for i1, _ := range g.SampleLocations {
			g.SampleLocations[i1].toC(&slice1[i1])
		}
	} else {
		c.pSampleLocations = nil
	}
}
func (g *SampleLocationsInfoEXT) fromC(c *C.VkSampleLocationsInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.SampleLocationsPerPixel = SampleCountFlagBits(c.sampleLocationsPerPixel)
	g.SampleLocationGridSize.fromC(&c.sampleLocationGridSize)
	g.SampleLocations = make([]SampleLocationEXT, int(c.sampleLocationsCount))
	if len(g.SampleLocations) != 0 {
		slice1 := (*[1 << 31]C.VkSampleLocationEXT)(unsafe.Pointer(c.pSampleLocations))[:len(g.SampleLocations):len(g.SampleLocations)]
		for i1, _ := range g.SampleLocations {
			g.SampleLocations[i1].fromC(&slice1[i1])
		}
	}
}
func (s *SampleLocationsInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
}
func (s *SampleLocationsInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkSampleLocationsInfoEXT)(m.alloc(C.sizeof_VkSampleLocationsInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *SampleLocationsInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkSampleLocationsInfoEXT)(p)
	s.fromC(c)
}
func (s *SampleLocationsInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *SampleLocationsInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncCmdSetSampleLocationsEXT func(commandBuffer CommandBuffer, sampleLocationsInfo *SampleLocationsInfoEXT)

func ToCmdSetSampleLocationsEXT(p PFNVoidFunction) (fn FuncCmdSetSampleLocationsEXT) {
	return func(commandBuffer CommandBuffer, sampleLocationsInfo *SampleLocationsInfoEXT) {
		var c struct {
			commandBuffer        C.VkCommandBuffer
			pSampleLocationsInfo *C.VkSampleLocationsInfoEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		if sampleLocationsInfo != nil {
			c.pSampleLocationsInfo = (*C.VkSampleLocationsInfoEXT)(m.alloc(C.sizeof_VkSampleLocationsInfoEXT))
			sampleLocationsInfo.toC(c.pSampleLocationsInfo, m)
		} else {
			c.pSampleLocationsInfo = nil
		}
		C.callPFN_vkCmdSetSampleLocationsEXT(C.PFN_vkCmdSetSampleLocationsEXT(unsafe.Pointer(p)), c.commandBuffer, c.pSampleLocationsInfo)
	}
}

type PFNGetPhysicalDeviceMultisamplePropertiesEXT C.PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT
type MultisamplePropertiesEXT struct {
	Next                      Structure
	MaxSampleLocationGridSize Extent2D
}

func (g *MultisamplePropertiesEXT) toC(c *C.VkMultisamplePropertiesEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	g.MaxSampleLocationGridSize.toC(&c.maxSampleLocationGridSize)
}
func (g *MultisamplePropertiesEXT) fromC(c *C.VkMultisamplePropertiesEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MaxSampleLocationGridSize.fromC(&c.maxSampleLocationGridSize)
}
func (s *MultisamplePropertiesEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
}
func (s *MultisamplePropertiesEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMultisamplePropertiesEXT)(m.alloc(C.sizeof_VkMultisamplePropertiesEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MultisamplePropertiesEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMultisamplePropertiesEXT)(p)
	s.fromC(c)
}
func (s *MultisamplePropertiesEXT) GetNext() Structure {
	return s.Next
}
func (s *MultisamplePropertiesEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncGetPhysicalDeviceMultisamplePropertiesEXT func(physicalDevice PhysicalDevice, samples SampleCountFlagBits, multisampleProperties *MultisamplePropertiesEXT)

func ToGetPhysicalDeviceMultisamplePropertiesEXT(p PFNVoidFunction) (fn FuncGetPhysicalDeviceMultisamplePropertiesEXT) {
	return func(physicalDevice PhysicalDevice, samples SampleCountFlagBits, multisampleProperties *MultisamplePropertiesEXT) {
		var c struct {
			physicalDevice         C.VkPhysicalDevice
			samples                C.VkSampleCountFlagBits
			pMultisampleProperties *C.VkMultisamplePropertiesEXT
		}
		m := pool.take()
		defer pool.give(m)
		c.physicalDevice = C.VkPhysicalDevice(physicalDevice)
		c.samples = C.VkSampleCountFlagBits(samples)
		if multisampleProperties != nil {
			c.pMultisampleProperties = (*C.VkMultisamplePropertiesEXT)(m.alloc(C.sizeof_VkMultisamplePropertiesEXT))
			multisampleProperties.toC(c.pMultisampleProperties, m)
		} else {
			c.pMultisampleProperties = nil
		}
		C.callPFN_vkGetPhysicalDeviceMultisamplePropertiesEXT(C.PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT(unsafe.Pointer(p)), c.physicalDevice, c.samples, c.pMultisampleProperties)
		if multisampleProperties != nil {
			multisampleProperties.fromC(c.pMultisampleProperties)
		}
	}
}

type BlendOverlapEXT int

const (
	BLEND_OVERLAP_UNCORRELATED_EXT BlendOverlapEXT = 0
	BLEND_OVERLAP_DISJOINT_EXT     BlendOverlapEXT = 1
	BLEND_OVERLAP_CONJOINT_EXT     BlendOverlapEXT = 2
	BLEND_OVERLAP_BEGIN_RANGE_EXT  BlendOverlapEXT = BLEND_OVERLAP_UNCORRELATED_EXT
	BLEND_OVERLAP_END_RANGE_EXT    BlendOverlapEXT = BLEND_OVERLAP_CONJOINT_EXT
	BLEND_OVERLAP_RANGE_SIZE_EXT   BlendOverlapEXT = (BLEND_OVERLAP_CONJOINT_EXT - BLEND_OVERLAP_UNCORRELATED_EXT + 1)
	BLEND_OVERLAP_MAX_ENUM_EXT     BlendOverlapEXT = 2147483647
)

type CoverageModulationModeNV int

const (
	COVERAGE_MODULATION_MODE_NONE_NV        CoverageModulationModeNV = 0
	COVERAGE_MODULATION_MODE_RGB_NV         CoverageModulationModeNV = 1
	COVERAGE_MODULATION_MODE_ALPHA_NV       CoverageModulationModeNV = 2
	COVERAGE_MODULATION_MODE_RGBA_NV        CoverageModulationModeNV = 3
	COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV CoverageModulationModeNV = COVERAGE_MODULATION_MODE_NONE_NV
	COVERAGE_MODULATION_MODE_END_RANGE_NV   CoverageModulationModeNV = COVERAGE_MODULATION_MODE_RGBA_NV
	COVERAGE_MODULATION_MODE_RANGE_SIZE_NV  CoverageModulationModeNV = (COVERAGE_MODULATION_MODE_RGBA_NV - COVERAGE_MODULATION_MODE_NONE_NV + 1)
	COVERAGE_MODULATION_MODE_MAX_ENUM_NV    CoverageModulationModeNV = 2147483647
)

type ValidationCacheHeaderVersionEXT int

const (
	VALIDATION_CACHE_HEADER_VERSION_ONE_EXT         ValidationCacheHeaderVersionEXT = 1
	VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT ValidationCacheHeaderVersionEXT = VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
	VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT   ValidationCacheHeaderVersionEXT = VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
	VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT  ValidationCacheHeaderVersionEXT = (VALIDATION_CACHE_HEADER_VERSION_ONE_EXT - VALIDATION_CACHE_HEADER_VERSION_ONE_EXT + 1)
	VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT    ValidationCacheHeaderVersionEXT = 2147483647
)

type PFNCreateValidationCacheEXT C.PFN_vkCreateValidationCacheEXT
type ValidationCacheCreateFlagsEXT Flags
type ValidationCacheCreateInfoEXT struct {
	Next        Structure
	Flags       ValidationCacheCreateFlagsEXT
	InitialData []byte
}

func (g *ValidationCacheCreateInfoEXT) toC(c *C.VkValidationCacheCreateInfoEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	{
		var temp_in_VkValidationCacheCreateFlagsEXT C.VkFlags
		{
			var temp_in_VkFlags C.uint32_t
			temp_in_VkFlags = C.uint32_t((uint32)((Flags)(g.Flags)))
			temp_in_VkValidationCacheCreateFlagsEXT = C.VkFlags(temp_in_VkFlags)
		}
		c.flags = C.VkValidationCacheCreateFlagsEXT(temp_in_VkValidationCacheCreateFlagsEXT)
	}
	c.initialDataSize = C.size_t(len(g.InitialData))
	if len(g.InitialData) != 0 {
		c.pInitialData = m.alloc(C.sizeof_char * uint(len(g.InitialData)))
		slice1 := (*[1 << 31]byte)(c.pInitialData)[:len(g.InitialData):len(g.InitialData)]
		for i1, _ := range g.InitialData {
			slice1[i1] = g.InitialData[i1]
		}
	} else {
		c.pInitialData = nil
	}
}
func (g *ValidationCacheCreateInfoEXT) fromC(c *C.VkValidationCacheCreateInfoEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	{
		var temp_in_VkValidationCacheCreateFlagsEXT Flags
		{
			var temp_in_VkFlags uint32
			temp_in_VkFlags = uint32((C.uint32_t)((C.VkFlags)(c.flags)))
			temp_in_VkValidationCacheCreateFlagsEXT = Flags(temp_in_VkFlags)
		}
		g.Flags = ValidationCacheCreateFlagsEXT(temp_in_VkValidationCacheCreateFlagsEXT)
	}
	g.InitialData = make([]byte, int(c.initialDataSize))
	if len(g.InitialData) != 0 {
		slice1 := (*[1 << 31]byte)(c.pInitialData)[:len(g.InitialData):len(g.InitialData)]
		for i1, _ := range g.InitialData {
			g.InitialData[i1] = slice1[i1]
		}
	}
}
func (s *ValidationCacheCreateInfoEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
}
func (s *ValidationCacheCreateInfoEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkValidationCacheCreateInfoEXT)(m.alloc(C.sizeof_VkValidationCacheCreateInfoEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *ValidationCacheCreateInfoEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkValidationCacheCreateInfoEXT)(p)
	s.fromC(c)
}
func (s *ValidationCacheCreateInfoEXT) GetNext() Structure {
	return s.Next
}
func (s *ValidationCacheCreateInfoEXT) SetNext(n Structure) {
	s.Next = n
}

type ValidationCacheEXT C.VkValidationCacheEXT
type FuncCreateValidationCacheEXT func(device Device, createInfo *ValidationCacheCreateInfoEXT, allocator *AllocationCallbacks, validationCache *ValidationCacheEXT) (_ret Result)

func ToCreateValidationCacheEXT(p PFNVoidFunction) (fn FuncCreateValidationCacheEXT) {
	return func(device Device, createInfo *ValidationCacheCreateInfoEXT, allocator *AllocationCallbacks, validationCache *ValidationCacheEXT) (_ret Result) {
		var c struct {
			device           C.VkDevice
			pCreateInfo      *C.VkValidationCacheCreateInfoEXT
			pAllocator       *C.VkAllocationCallbacks
			pValidationCache *C.VkValidationCacheEXT
			_ret             C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		if createInfo != nil {
			c.pCreateInfo = (*C.VkValidationCacheCreateInfoEXT)(m.alloc(C.sizeof_VkValidationCacheCreateInfoEXT))
			createInfo.toC(c.pCreateInfo, m)
		} else {
			c.pCreateInfo = nil
		}
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		if validationCache != nil {
			c.pValidationCache = (*C.VkValidationCacheEXT)(m.alloc(C.sizeof_VkValidationCacheEXT))
			*c.pValidationCache = C.VkValidationCacheEXT(*validationCache)
		} else {
			c.pValidationCache = nil
		}
		c._ret = C.callPFN_vkCreateValidationCacheEXT(C.PFN_vkCreateValidationCacheEXT(unsafe.Pointer(p)), c.device, c.pCreateInfo, c.pAllocator, c.pValidationCache)
		_ret = Result(c._ret)
		if validationCache != nil {
			*validationCache = ValidationCacheEXT(*c.pValidationCache)
		}
		return
	}
}

type PFNDestroyValidationCacheEXT C.PFN_vkDestroyValidationCacheEXT
type FuncDestroyValidationCacheEXT func(device Device, validationCache ValidationCacheEXT, allocator *AllocationCallbacks)

func ToDestroyValidationCacheEXT(p PFNVoidFunction) (fn FuncDestroyValidationCacheEXT) {
	return func(device Device, validationCache ValidationCacheEXT, allocator *AllocationCallbacks) {
		var c struct {
			device          C.VkDevice
			validationCache C.VkValidationCacheEXT
			pAllocator      *C.VkAllocationCallbacks
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.validationCache = C.VkValidationCacheEXT(validationCache)
		if allocator != nil {
			c.pAllocator = (*C.VkAllocationCallbacks)(m.alloc(C.sizeof_VkAllocationCallbacks))
			allocator.toC(c.pAllocator)
		} else {
			c.pAllocator = nil
		}
		C.callPFN_vkDestroyValidationCacheEXT(C.PFN_vkDestroyValidationCacheEXT(unsafe.Pointer(p)), c.device, c.validationCache, c.pAllocator)
	}
}

type PFNMergeValidationCachesEXT C.PFN_vkMergeValidationCachesEXT
type FuncMergeValidationCachesEXT func(device Device, dstCache ValidationCacheEXT, srcCaches []ValidationCacheEXT) (_ret Result)

func ToMergeValidationCachesEXT(p PFNVoidFunction) (fn FuncMergeValidationCachesEXT) {
	return func(device Device, dstCache ValidationCacheEXT, srcCaches []ValidationCacheEXT) (_ret Result) {
		var c struct {
			device        C.VkDevice
			dstCache      C.VkValidationCacheEXT
			srcCacheCount C.uint32_t
			pSrcCaches    *C.VkValidationCacheEXT
			_ret          C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.dstCache = C.VkValidationCacheEXT(dstCache)
		c.srcCacheCount = C.uint32_t(len(srcCaches))
		if len(srcCaches) != 0 {
			c.pSrcCaches = (*C.VkValidationCacheEXT)(m.alloc(C.sizeof_VkValidationCacheEXT * uint(len(srcCaches))))
			slice1 := (*[1 << 31]C.VkValidationCacheEXT)(unsafe.Pointer(c.pSrcCaches))[:len(srcCaches):len(srcCaches)]
			for i1, _ := range srcCaches {
				slice1[i1] = C.VkValidationCacheEXT(srcCaches[i1])
			}
		} else {
			c.pSrcCaches = nil
		}
		c._ret = C.callPFN_vkMergeValidationCachesEXT(C.PFN_vkMergeValidationCachesEXT(unsafe.Pointer(p)), c.device, c.dstCache, c.srcCacheCount, c.pSrcCaches)
		_ret = Result(c._ret)
		return
	}
}

type PFNGetValidationCacheDataEXT C.PFN_vkGetValidationCacheDataEXT
type FuncGetValidationCacheDataEXT func(device Device, validationCache ValidationCacheEXT, dataSize *uint, data []byte) (_ret Result)

func ToGetValidationCacheDataEXT(p PFNVoidFunction) (fn FuncGetValidationCacheDataEXT) {
	return func(device Device, validationCache ValidationCacheEXT, dataSize *uint, data []byte) (_ret Result) {
		var c struct {
			device          C.VkDevice
			validationCache C.VkValidationCacheEXT
			pDataSize       *C.size_t
			pData           unsafe.Pointer
			_ret            C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.validationCache = C.VkValidationCacheEXT(validationCache)
		if dataSize != nil {
			c.pDataSize = (*C.size_t)(m.alloc(C.sizeof_size_t))
			*c.pDataSize = C.size_t(*dataSize)
		} else {
			c.pDataSize = nil
		}
		if len(data) != 0 {
			c.pData = m.alloc(C.sizeof_char * uint(len(data)))
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				slice1[i1] = data[i1]
			}
		} else {
			c.pData = nil
		}
		c._ret = C.callPFN_vkGetValidationCacheDataEXT(C.PFN_vkGetValidationCacheDataEXT(unsafe.Pointer(p)), c.device, c.validationCache, c.pDataSize, c.pData)
		_ret = Result(c._ret)
		if dataSize != nil {
			*dataSize = uint(*c.pDataSize)
		}
		if len(data) != 0 {
			slice1 := (*[1 << 31]byte)(c.pData)[:len(data):len(data)]
			for i1, _ := range data {
				data[i1] = slice1[i1]
			}
		}
		return
	}
}

type DescriptorBindingFlagBitsEXT int

const (
	DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT           DescriptorBindingFlagBitsEXT = 1
	DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT DescriptorBindingFlagBitsEXT = 2
	DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT             DescriptorBindingFlagBitsEXT = 4
	DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT   DescriptorBindingFlagBitsEXT = 8
	DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT              DescriptorBindingFlagBitsEXT = 2147483647
)

type QueueGlobalPriorityEXT int

const (
	QUEUE_GLOBAL_PRIORITY_LOW_EXT         QueueGlobalPriorityEXT = 128
	QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT      QueueGlobalPriorityEXT = 256
	QUEUE_GLOBAL_PRIORITY_HIGH_EXT        QueueGlobalPriorityEXT = 512
	QUEUE_GLOBAL_PRIORITY_REALTIME_EXT    QueueGlobalPriorityEXT = 1024
	QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT QueueGlobalPriorityEXT = QUEUE_GLOBAL_PRIORITY_LOW_EXT
	QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT   QueueGlobalPriorityEXT = QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
	QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT  QueueGlobalPriorityEXT = (QUEUE_GLOBAL_PRIORITY_REALTIME_EXT - QUEUE_GLOBAL_PRIORITY_LOW_EXT + 1)
	QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT    QueueGlobalPriorityEXT = 2147483647
)

type PFNGetMemoryHostPointerPropertiesEXT C.PFN_vkGetMemoryHostPointerPropertiesEXT
type MemoryHostPointerPropertiesEXT struct {
	Next           Structure
	MemoryTypeBits uint32
}

func (g *MemoryHostPointerPropertiesEXT) toC(c *C.VkMemoryHostPointerPropertiesEXT, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.memoryTypeBits = C.uint32_t(g.MemoryTypeBits)
}
func (g *MemoryHostPointerPropertiesEXT) fromC(c *C.VkMemoryHostPointerPropertiesEXT) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.MemoryTypeBits = uint32(c.memoryTypeBits)
}
func (s *MemoryHostPointerPropertiesEXT) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
}
func (s *MemoryHostPointerPropertiesEXT) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkMemoryHostPointerPropertiesEXT)(m.alloc(C.sizeof_VkMemoryHostPointerPropertiesEXT))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *MemoryHostPointerPropertiesEXT) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkMemoryHostPointerPropertiesEXT)(p)
	s.fromC(c)
}
func (s *MemoryHostPointerPropertiesEXT) GetNext() Structure {
	return s.Next
}
func (s *MemoryHostPointerPropertiesEXT) SetNext(n Structure) {
	s.Next = n
}

type FuncGetMemoryHostPointerPropertiesEXT func(device Device, handleType ExternalMemoryHandleTypeFlagBits, hostPointer unsafe.Pointer, memoryHostPointerProperties *MemoryHostPointerPropertiesEXT) (_ret Result)

func ToGetMemoryHostPointerPropertiesEXT(p PFNVoidFunction) (fn FuncGetMemoryHostPointerPropertiesEXT) {
	return func(device Device, handleType ExternalMemoryHandleTypeFlagBits, hostPointer unsafe.Pointer, memoryHostPointerProperties *MemoryHostPointerPropertiesEXT) (_ret Result) {
		var c struct {
			device                       C.VkDevice
			handleType                   C.VkExternalMemoryHandleTypeFlagBits
			pHostPointer                 unsafe.Pointer
			pMemoryHostPointerProperties *C.VkMemoryHostPointerPropertiesEXT
			_ret                         C.VkResult
		}
		m := pool.take()
		defer pool.give(m)
		c.device = C.VkDevice(device)
		c.handleType = C.VkExternalMemoryHandleTypeFlagBits(handleType)
		c.pHostPointer = hostPointer
		if memoryHostPointerProperties != nil {
			c.pMemoryHostPointerProperties = (*C.VkMemoryHostPointerPropertiesEXT)(m.alloc(C.sizeof_VkMemoryHostPointerPropertiesEXT))
			memoryHostPointerProperties.toC(c.pMemoryHostPointerProperties, m)
		} else {
			c.pMemoryHostPointerProperties = nil
		}
		c._ret = C.callPFN_vkGetMemoryHostPointerPropertiesEXT(C.PFN_vkGetMemoryHostPointerPropertiesEXT(unsafe.Pointer(p)), c.device, c.handleType, c.pHostPointer, c.pMemoryHostPointerProperties)
		_ret = Result(c._ret)
		if memoryHostPointerProperties != nil {
			memoryHostPointerProperties.fromC(c.pMemoryHostPointerProperties)
		}
		return
	}
}

type PFNCmdWriteBufferMarkerAMD C.PFN_vkCmdWriteBufferMarkerAMD
type FuncCmdWriteBufferMarkerAMD func(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, dstBuffer Buffer, dstOffset DeviceSize, marker uint32)

func ToCmdWriteBufferMarkerAMD(p PFNVoidFunction) (fn FuncCmdWriteBufferMarkerAMD) {
	return func(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {
		var c struct {
			commandBuffer C.VkCommandBuffer
			pipelineStage C.VkPipelineStageFlagBits
			dstBuffer     C.VkBuffer
			dstOffset     C.VkDeviceSize
			marker        C.uint32_t
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pipelineStage = C.VkPipelineStageFlagBits(pipelineStage)
		c.dstBuffer = C.VkBuffer(dstBuffer)
		{
			var temp_in_VkDeviceSize C.uint64_t
			temp_in_VkDeviceSize = C.uint64_t((uint64)(dstOffset))
			c.dstOffset = C.VkDeviceSize(temp_in_VkDeviceSize)
		}
		c.marker = C.uint32_t(marker)
		C.callPFN_vkCmdWriteBufferMarkerAMD(C.PFN_vkCmdWriteBufferMarkerAMD(unsafe.Pointer(p)), c.commandBuffer, c.pipelineStage, c.dstBuffer, c.dstOffset, c.marker)
	}
}

type PFNCmdSetCheckpointNV C.PFN_vkCmdSetCheckpointNV
type FuncCmdSetCheckpointNV func(commandBuffer CommandBuffer, checkpointMarker unsafe.Pointer)

func ToCmdSetCheckpointNV(p PFNVoidFunction) (fn FuncCmdSetCheckpointNV) {
	return func(commandBuffer CommandBuffer, checkpointMarker unsafe.Pointer) {
		var c struct {
			commandBuffer     C.VkCommandBuffer
			pCheckpointMarker unsafe.Pointer
		}
		c.commandBuffer = C.VkCommandBuffer(commandBuffer)
		c.pCheckpointMarker = checkpointMarker
		C.callPFN_vkCmdSetCheckpointNV(C.PFN_vkCmdSetCheckpointNV(unsafe.Pointer(p)), c.commandBuffer, c.pCheckpointMarker)
	}
}

type PFNGetQueueCheckpointDataNV C.PFN_vkGetQueueCheckpointDataNV
type CheckpointDataNV struct {
	Next             Structure
	Stage            PipelineStageFlagBits
	CheckpointMarker unsafe.Pointer
}

func (g *CheckpointDataNV) toC(c *C.VkCheckpointDataNV, m *cmemory) {
	c.sType = g.sType()
	if g.Next != nil {
		c.pNext = g.Next.toCStructure(m)
	}
	c.stage = C.VkPipelineStageFlagBits(g.Stage)
	c.pCheckpointMarker = g.CheckpointMarker
}
func (g *CheckpointDataNV) fromC(c *C.VkCheckpointDataNV) {
	if g.Next != nil {
		g.Next.fromCStructure(c.pNext)
	}
	g.Stage = PipelineStageFlagBits(c.stage)
	g.CheckpointMarker = c.pCheckpointMarker
}
func (s *CheckpointDataNV) sType() C.VkStructureType {
	return C.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
}
func (s *CheckpointDataNV) toCStructure(m *cmemory) unsafe.Pointer {
	c := (*C.VkCheckpointDataNV)(m.alloc(C.sizeof_VkCheckpointDataNV))
	s.toC(c, m)
	return unsafe.Pointer(c)
}
func (s *CheckpointDataNV) fromCStructure(p unsafe.Pointer) {
	c := (*C.VkCheckpointDataNV)(p)
	s.fromC(c)
}
func (s *CheckpointDataNV) GetNext() Structure {
	return s.Next
}
func (s *CheckpointDataNV) SetNext(n Structure) {
	s.Next = n
}

type FuncGetQueueCheckpointDataNV func(queue Queue, checkpointDataCount *uint32, checkpointData []CheckpointDataNV)

func ToGetQueueCheckpointDataNV(p PFNVoidFunction) (fn FuncGetQueueCheckpointDataNV) {
	return func(queue Queue, checkpointDataCount *uint32, checkpointData []CheckpointDataNV) {
		var c struct {
			queue                C.VkQueue
			pCheckpointDataCount *C.uint32_t
			pCheckpointData      *C.VkCheckpointDataNV
		}
		m := pool.take()
		defer pool.give(m)
		c.queue = C.VkQueue(queue)
		if checkpointDataCount != nil {
			c.pCheckpointDataCount = (*C.uint32_t)(m.alloc(C.sizeof_uint32_t))
			*c.pCheckpointDataCount = C.uint32_t(*checkpointDataCount)
		} else {
			c.pCheckpointDataCount = nil
		}
		if len(checkpointData) != 0 {
			c.pCheckpointData = (*C.VkCheckpointDataNV)(m.alloc(C.sizeof_VkCheckpointDataNV * uint(len(checkpointData))))
			slice1 := (*[1 << 31]C.VkCheckpointDataNV)(unsafe.Pointer(c.pCheckpointData))[:len(checkpointData):len(checkpointData)]
			for i1, _ := range checkpointData {
				checkpointData[i1].toC(&slice1[i1], m)
			}
		} else {
			c.pCheckpointData = nil
		}
		C.callPFN_vkGetQueueCheckpointDataNV(C.PFN_vkGetQueueCheckpointDataNV(unsafe.Pointer(p)), c.queue, c.pCheckpointDataCount, c.pCheckpointData)
		if checkpointDataCount != nil {
			*checkpointDataCount = uint32(*c.pCheckpointDataCount)
		}
		if len(checkpointData) != 0 {
			slice1 := (*[1 << 31]C.VkCheckpointDataNV)(unsafe.Pointer(c.pCheckpointData))[:len(checkpointData):len(checkpointData)]
			for i1, _ := range checkpointData {
				checkpointData[i1].fromC(&slice1[i1])
			}
		}
	}
}
